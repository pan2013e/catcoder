{
  "benchmark": "javaeval_if",
  "lastest_eval": {
    "compile@1": 0.5974874371859296,
    "pass@1": 0.3527638190954773,
    "compile@3": 0.7273450586264657,
    "pass@3": 0.43768844221105513,
    "compile@5": 0.76790699529393,
    "pass@5": 0.4757717157214646
  },
  "n": 10,
  "k": [
    1,
    3,
    5
  ],
  "fn_codes": [
    [
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }"
    ],
    [
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        result = new Double(task.getPercentComplete());\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        result = new Double(task.getPercentComplete());\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        result = new Double(task.getPercentComplete());\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        result = new Double(task.getPercentComplete());\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        result = new Double(task.getPercentComplete());\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        result = new Double(task.getPercentComplete());\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        result = new Double(task.getPercentComplete());\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        result = new Double(task.getPercentComplete());\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        result = new Double(task.getPercentComplete());\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        result = new Double(task.getPercentComplete());\n    }\n    return result;\n}"
    ],
    [
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}"
    ],
    [
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new Iterable<E>() {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new Iterable<E>() {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new Iterable<E>() \n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new Iterable<E>() {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new Iterable<E>() \n    {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new Iterable<E>() \n    {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new Iterable<E>() {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n}"
    ],
    [
      "private static RealMatrix diag(final RealMatrix m)  {\n    if(m.getColumnDimension() == 1)\n    {\n        double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n        for(int r = 0; r < m.getRowDimension(); r++)\n        {\n            for(int c = 0; c < m.getRowDimension(); c++)\n            {\n                if(r == c)\n                {\n                    d[r][c] = m.getEntry(r, 0);\n                }\n                else\n                {\n                    d[r][c] = 0;\n                }\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n    else\n    {\n        double[][] d = new double[1][m.getColumnDimension()];\n        for(int c = 0; c < m.getColumnDimension(); c++)\n        {\n            d[0][c] = m.getEntry(c, c);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        final double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            d[r][r] = m.getEntry(r, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        final double[][] d = new double[1][m.getColumnDimension()];\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            d[0][c] = m.getEntry(c, c);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if(m.getRowDimension() == 1)\n    {\n        final double[][] d = new double[m.getColumnDimension()][m.getColumnDimension()];\n        for(int i = 0; i < m.getColumnDimension(); i++)\n        {\n            d[i][i] = m.getEntry(0, i);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n    else\n    {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for(int i = 0; i < m.getRowDimension(); i++)\n        {\n            d[i][i] = m.getEntry(i, i);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            d[r][c] = r == c ? m.getEntry(r, c) : 0;\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if(m.getRowDimension() == 1)\n    {\n        final double[][] d = new double[m.getColumnDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getColumnDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = r == c ? m.getEntry(0, r) : 0;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n    else\n    {\n        final double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getRowDimension(); c++) {\n                d[r][c] = r == c ? m.getEntry(r, c) : 0;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            d[r][c] = r == c ? m.getEntry(r, c) : 0;\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            d[r][c] = r == c ? m.getEntry(r, c) : 0;\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            d[r][c] = r == c ? m.getEntry(r, c) : 0;\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            d[r][c] = r == c ? m.getEntry(r, c) : 0;\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) \n    {\n        for (int c = 0; c < m.getColumnDimension(); c++) \n        {\n            d[r][c] = r == c ? m.getEntry(r, c) : 0;\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}"
    ],
    [
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    // safety checks\n    if (rows < 1 || columns < 1) {\n        throw new IllegalArgumentException(\"rows and columns must be positive\");\n    }\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final double[][] blocks = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            if (blocks[index].length != iHeight * blockWidth(jBlock)) {\n                throw new DimensionMismatchException(blocks[index].length,\n                                                     iHeight * blockWidth(jBlock));\n            }\n            blocks[index] = new double[iHeight * blockWidth(jBlock)];\n        }\n    }\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    // safety checks\n    if (rows < 1 || columns < 1) {\n        throw new IllegalArgumentException(\"rows and columns must be positive\");\n    }\n\n    // compute block dimensions\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate blocks\n    final double[][] blocks = new double[blockRows * blockColumns][];\n\n    // fill blocks\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // fill block\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int q = qStart; q < qEnd; ++q) {\n                    block[index++] = 0;\n                }\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n        final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n                ++blockIndex;\n            }\n        }\n        return blocks;\n    }",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n            ++blockIndex;\n        }\n    }\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    // safety checks\n    if (rows < 1 || columns < 1) {\n        throw new IllegalArgumentException(\"rows and columns must be positive\");\n    }\n\n    // compute number of blocks\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate array\n    final double[][] blocks = new double[blockRows * blockColumns][];\n\n    // fill array\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    // safety checks\n    if (rows < 1 || columns < 1) {\n        throw new IllegalArgumentException(\"Invalid matrix size\");\n    }\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final double[][] blocks = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            blocks[index] = new double[iHeight * blockWidth(jBlock)];\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n            ++blockIndex;\n        }\n    }\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    // safety checks\n    if (rows < 1 || columns < 1) {\n        throw new IllegalArgumentException(\"rows and columns must be positive\");\n    }\n\n    // convert array\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // convert array\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    // calculate the number of blocks\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    double[][] blocks = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            if (blocks[index].length != iHeight * blockWidth(jBlock)) {\n                throw new DimensionMismatchException(blocks[index].length,\n                                                     iHeight * blockWidth(jBlock));\n            }\n            blocks[index] = new double[iHeight * blockWidth(jBlock)];\n        }\n    }\n\n    return blocks;\n}"
    ],
    [
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    if (Modifier.isStatic(field.getModifiers())) {\n        return field.get(null);\n    } else {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    if (Modifier.isStatic(field.getModifiers())) {\n        return field.get(null);\n    } else {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    if (Modifier.isStatic(field.getModifiers())) {\n        return field.get(null);\n    } else {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    if (Modifier.isStatic(field.getModifiers())) {\n        return field.get(null);\n    } else {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n}"
    ],
    [
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) \n        {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) \n        {\n            return UTC;\n        }\n        if (cZoneIdConversion.containsKey(id)) \n        {\n            id = cZoneIdConversion.get(id);\n        }\n        if (cAvailableIDs.contains(id)) \n        {\n            return new DateTimeZone(id, null);\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) \n        {\n            return forOffset(id);\n        }\n        throw new IllegalArgumentException(\"Invalid ID for DateTimeZone, invalid format: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            return forOffset(id);\n        }\n        return forZoneId(id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        if (id.equals(\"GMT\")) {\n            return GMT;\n        }\n        if (id.equals(\"GMT0\")) {\n            return GMT0;\n        }\n        if (id.equals(\"GMT+0\")) {\n            return GMT0;\n        }\n        if (id.equals(\"GMT-0\")) {\n            return GMT0;\n        }\n        if (id.equals(\"GMT+00\") || id.equals(\"GMT00\")) {\n            return GMT0;\n        }\n        if (id.equals(\"GMT-00\")) {\n            return GMT0;\n        }\n        if (id.equals(\"GMT+0000\") || id.equals(\"GMT0000\")) {\n            return GMT0;\n        }\n        if (id.equals(\"GMT-0000\")) {\n            return GMT0;\n        }\n        if (id.equals(\"GMT+00:00\") || id.equals(\"GMT00:00\")) {\n            return GMT0;\n        }\n        if (id.equals(\"GMT-00:00\")) {\n            return GMT0;\n        }\n        if (id.equals(\"GMT+01\") || id.equals(\"GMT01\")) {\n            return GMT1;\n        }\n        if (id.equals(\"GMT-01\")) {\n            return GMT_1;\n        }\n        if (id.equals(\"GMT+0100\") || id.equals(\"GMT0100\")) {\n            return GMT1;\n        }\n        if (id.equals(\"GMT-0100\")) {\n            return GMT_1;\n        }\n        if (id.equals(\"GMT+01:00\") || id.equals(\"GMT01:00\")) {\n            return GMT1;\n        }\n}",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        if (id.equals(\"GMT\")) {\n            return GMT;\n        }\n        if (id.equals(\"GMT0\")) {\n            return GMT0;\n        }\n        if (id.equals(\"GMT+0\")) {\n            return GMT0;\n        }\n        if (id.equals(\"GMT-0\")) {\n            return GMT0;\n        }\n        if (id.equals(\"GMT+00:00\")) {\n            return GMT0;\n        }\n        if (id.equals(\"GMT-00:00\")) {\n            return GMT0;\n        }\n        if (id.equals(\"GMT+00\")) {\n            return GMT0;\n        }\n        if (id.equals(\"GMT-00\")) {\n            return GMT0;\n        }\n        if (id.equals(\"GMT+0000\")) {\n            return GMT0;\n        }\n        if (id.equals(\"GMT-0000\")) {\n            return GMT0;\n        }\n        if (id.equals(\"GMT+00:00\")) {\n            return GMT0;\n        }\n        if (id.equals(\"GMT-00:00\")) {\n            return GMT0;\n        }\n        if (id.equals(\"GMT+01:00\")) {\n            return GMT1;\n        }\n        if (id.equals(\"GMT-01:00\")) {\n            return GMT1;\n        }\n        if (id.equals(\"GMT+01:00\")) {\n            return GMT1;\n        }\n        if (id.equals(\"GMT-01:00\")) {\n            return GMT1;\n        }\n        if (id.equals(\"GMT+01\")) {\n            return GMT1;\n        }\n        if (id.equals(\"GMT-01\")) {\n            return GMT1;\n        }\n}",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        int offset = id.indexOf(':');\n        if (offset >= 0) {\n            int hours = Integer.parseInt(id.substring(0, offset));\n            int minutes = Integer.parseInt(id.substring(offset + 1));\n            return forOffsetMillis(hours * 60 * 60 * 1000 + minutes * 60 * 1000);\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int hours = Integer.parseInt(id.substring(1, 3));\n            int minutes = Integer.parseInt(id.substring(4, 6));\n            return forOffsetMillis(hours * 60 * 60 * 1000 + minutes * 60 * 1000);\n        }\n        synchronized(DateTimeZone.class) {\n            SoftReference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n            DateTimeZone zone = (ref == null ? null : ref.get());\n            if (zone == null) {\n                zone = new FixedDateTimeZone(id, id);\n                iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n            }\n            return zone;\n        }\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) \n        {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) \n        {\n            return UTC;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) \n        {\n            return forOffset(id);\n        }\n        if (cZoneIdConversion.containsKey(id)) \n        {\n            id = cZoneIdConversion.get(id);\n        }\n        DateTimeZone zone = null;\n        SoftReference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n        if (ref != null) \n        {\n            zone = ref.get();\n        }\n        if (zone == null) \n        {\n            zone = new DateTimeZone(id);\n            iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n        }\n        return zone;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            return forOffset(id);\n        }\n        if (id.length() <= 1) {\n            throw new IllegalArgumentException(\"The datetime zone id must not be empty\");\n        }\n        if (id.length() <= 2) {\n            throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is too short\");\n        }\n        if (id.charAt(1) == ':') {\n            throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is invalid\");\n        }\n        if (id.charAt(2) == ':') {\n            throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is invalid\");\n        }\n        if (id.length() >= 5 && id.charAt(3) == ':' && id.charAt(4) == ':') {\n            throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is invalid\");\n        }\n        if (id.length() >= 6 && id.charAt(5) == ':') {\n            throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is invalid\");\n        }\n        if (id.length() >= 7 && id.charAt(6) == ':') {\n            throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is invalid\");\n        }\n        if (id.length() >= 9 && id.charAt(7) == ':' && id.charAt(8) == ':') {\n            throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is invalid\");\n        }\n        if (id.length() >= 10 && id.charAt(9) == ':') {\n            throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is invalid\");\n        }\n}",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        if (cAvailableIDs.contains(id)) {\n            return new DateTimeZone(id, null);\n        }\n        if (id.length() > 6) {\n            if (id.charAt(3) == ':' && id.charAt(6) == ':') {\n                try {\n                    int hours = Integer.parseInt(id.substring(0, 3));\n                    int minutes = Integer.parseInt(id.substring(4, 6));\n                    return forOffsetMillis(hours * 3600000 + minutes * 60000);\n                } catch (NumberFormatException ex) {\n                    // ignore\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id is not recognised: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) \n        {\n            return getDefault();\n        }\n        else if (id.equals(\"UTC\")) \n        {\n            return UTC;\n        }\n        else if (id.equals(\"GMT\")) \n        {\n            return GMT;\n        }\n        else if (id.equals(\"GMT0\")) \n        {\n            return GMT0;\n        }\n        else if (id.equals(\"GMT+0\")) \n        {\n            return GMT0;\n        }\n        else if (id.equals(\"GMT-0\")) \n        {\n            return GMT0;\n        }\n        else if (id.equals(\"GMT+00\")) \n        {\n            return GMT0;\n        }\n        else if (id.equals(\"GMT-00\")) \n        {\n            return GMT0;\n        }\n        else if (id.equals(\"GMT+0000\")) \n        {\n            return GMT0;\n        }\n        else if (id.equals(\"GMT-0000\")) \n        {\n            return GMT0;\n        }\n        else if (id.equals(\"GMT+00:00\")) \n        {\n            return GMT0;\n        }\n        else if (id.equals(\"GMT-00:00\")) \n        {\n            return GMT0;\n        }\n        else if (id.equals(\"GMT+00:0000\")) \n        {\n            return GMT0;\n        }\n        else if (id.equals(\"GMT-00:0000\")) \n        {\n            return GMT0;\n        }\n        else if (id.equals(\"GMT+000000\")) \n        {\n            return GMT0;\n        }\n        else if (id.equals(\"GMT-000000\")) \n        {\n            return GMT0;\n        }\n        else if (id.equals(\"GMT+00:00:00\")) \n        {\n            return GMT0;\n        }\n}",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        if (id.equals(\"GMT\")) {\n            return GMT;\n        }\n        if (id.equals(\"GMT0\")) {\n            return GMT0;\n        }\n        if (id.equals(\"GMT+0\")) {\n            return GMT0;\n        }\n        if (id.equals(\"GMT-0\")) {\n            return GMT0;\n        }\n        if (id.equals(\"GMT+00:00\")) {\n            return GMT0;\n        }\n        if (id.equals(\"GMT-00:00\")) {\n            return GMT0;\n        }\n        if (id.equals(\"GMT+00\")) {\n            return GMT0;\n        }\n        if (id.equals(\"GMT-00\")) {\n            return GMT0;\n        }\n        if (id.equals(\"GMT+0000\")) {\n            return GMT0;\n        }\n        if (id.equals(\"GMT-0000\")) {\n            return GMT0;\n        }\n        if (id.equals(\"GMT+00:00\")) {\n            return GMT0;\n        }\n        if (id.equals(\"GMT-00:00\")) {\n            return GMT0;\n        }\n        if (id.equals(\"GMT+01:00\")) {\n            return GMT1;\n        }\n        if (id.equals(\"GMT-01:00\")) {\n            return GMT1;\n        }\n        if (id.equals(\"GMT+02:00\")) {\n            return GMT2;\n        }\n        if (id.equals(\"GMT-02:00\")) {\n            return GMT2;\n        }\n        if (id.equals(\"GMT+03:00\")) {\n            return GMT3;\n        }\n        if (id.equals(\"GMT-03:00\")) {\n            return GMT3;\n}\n}"
    ],
    [
      "private Dfp multiplyFast(final int x)  {\n        if (x == 0) {\n            return getZero();\n        }\n\n        if (x == 1) {\n            return this;\n        }\n\n        if (x == -1) {\n            return negate();\n        }\n\n        Dfp result = newInstance(this);\n\n        if (x == RADIX) {\n            result.exp++;\n            return result;\n        }\n\n        if (x == -RADIX) {\n            result.exp++;\n            return result.negate();\n        }\n\n        int rh = 0;  // acts as a carry\n        for (int i=0; i<mant.length; i++) {\n            int r = mant[i] * x;    // multiply the 2 digits\n            r = r + rh;  // add to the product digit with carry in\n\n            rh = r / RADIX;\n            result.mant[mant.length - i - 1] = r - rh * RADIX;\n        }\n\n        // Fixup the exponent.\n        result.exp++;\n\n        final int excp;\n        if (rh != 0) {\n            excp = result.round(rh);\n        } else {\n            excp = result.round(0); // has no effect except to check status\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, newInstance(x), result);\n        }\n\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n\n    // Multiply by zero\n    if (x == 0) {\n        return getZero();\n    }\n\n    // Multiply by one\n    if (x == 1) {\n        return this;\n    }\n\n    // Multiply by -1\n    if (x == -1) {\n        return negate();\n    }\n\n    // Multiply by a power of two\n    if (x < RADIX / 2) {\n        return shiftLeft(log2(x));\n    }\n\n    // Multiply by a power of two\n    if (x > RADIX / 2) {\n        return shiftRight(log2(x));\n    }\n\n    // Multiply by a power of two\n    if (x == RADIX / 2) {\n        return shiftLeft(1);\n    }\n\n    // Multiply by a power of two\n    if (x == -RADIX / 2) {\n        return shiftRight(1);\n    }\n\n    // Multiply by a power of two\n    if (x == RADIX) {\n        return shiftLeft(1);\n    }\n\n    // Multiply by a power of two\n    if (x == -RADIX) {\n        return shiftRight(1);\n    }\n\n    // Multiply by a power of two\n    if (x == RADIX * RADIX) {\n        return shiftLeft(2);\n    }\n\n    // Multiply by a power of two\n    if (x == -RADIX * RADIX) {\n        return shiftRight(2);\n    }\n\n    // Multiply by a power of two\n    if (x == RADIX * RADIX * RADIX) {\n        return shiftLeft(3);\n    }\n\n    // Multiply by a power of two\n    if (x == -RADIX * RADIX * RADIX) {\n        return shiftRight(3);\n    }\n\n    // Multiply by a power of two\n    if (x == RADIX * RADIX * RADIX * RADIX) {\n}\n}",
      "private Dfp multiplyFast(final int x)  {\n        Dfp result = newInstance(this);\n        result.sign = (byte) (sign * x);\n        result.mant[mant.length-1] = 0;\n        for (int i = 0; i < mant.length; i++) {\n            result.mant[i] = mant[i] * x;\n        }\n        result.exp = exp + 1;\n        result.nans = FINITE;\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n        Dfp result = newInstance(this);\n        result.sign = (byte) (sign * x);\n        if (x == 0) {\n            result.exp = 0;\n            result.nans = FINITE;\n            result.mant[mant.length-1] = 0;\n            return result;\n        }\n\n        if (x == 1) {\n            return result;\n        }\n\n        if (x == -1) {\n            result.sign = (byte) -result.sign;\n            return result;\n        }\n\n        if (x == RADIX) {\n            result.exp++;\n            return result;\n        }\n\n        if (x == -RADIX) {\n            result.exp++;\n            result.sign = (byte) -result.sign;\n            return result;\n        }\n\n        if (nans == INFINITE) {\n            result.nans = INFINITE;\n            return result;\n        }\n\n        if (nans == QNAN) {\n            result.nans = QNAN;\n            return result;\n        }\n\n        if (nans == SNAN) {\n            result.nans = SNAN;\n            return result;\n        }\n\n        int[] product = new int[mant.length];  // Big enough to hold even the largest result\n\n        for (int i = 0; i < mant.length; i++) {\n            int rh = 0;  // acts as a carry\n            for (int j=0; j<mant.length; j++) {\n                int r = mant[i] * x;    // multiply the 2 digits\n                r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n                rh = r / RADIX;\n                product[i+j] = r - rh * RADIX;\n            }\n            product[i+mant.length] = rh;\n        }\n\n        // Find the most sig digit\n        int md = mant.length - 1;  // default, in case result is zero\n}",
      "private Dfp multiplyFast(final int x)  {\n\n        if (x == 0) {\n            return getZero();\n        }\n\n        if (x == 1) {\n            return this;\n        }\n\n        if (x == -1) {\n            return negate();\n        }\n\n        if (x == RADIX) {\n            return shiftLeft(1);\n        }\n\n        if (x == -RADIX) {\n            return shiftLeft(1).negate();\n        }\n\n        if (x == 2) {\n            return shiftLeft(1);\n        }\n\n        if (x == -2) {\n            return shiftLeft(1).negate();\n        }\n\n        if (x == 4) {\n            return shiftLeft(2);\n        }\n\n        if (x == -4) {\n            return shiftLeft(2).negate();\n        }\n\n        if (x == 8) {\n            return shiftLeft(3);\n        }\n\n        if (x == -8) {\n            return shiftLeft(3).negate();\n        }\n\n        if (x == 16) {\n            return shiftLeft(4);\n        }\n\n        if (x == -16) {\n            return shiftLeft(4).negate();\n        }\n\n        if (x == 32) {\n            return shiftLeft(5);\n        }\n\n        if (x == -32) {\n            return shiftLeft(5).negate();\n        }\n\n        if (x == 64) {\n            return shiftLeft(6);\n        }\n\n        if (x == -64) {\n            return shiftLeft(6).negate();\n        }\n\n        if (x == 128) {\n            return shiftLeft(7);\n        }\n\n        if (x == -128) {\n            return shiftLeft(7).negate();\n        }\n\n        if (x == 256) {\n            return shiftLeft(8);\n        }\n\n        if (x == -256) {\n            return shiftLeft(8).negate();\n        }\n\n}",
      "private Dfp multiplyFast(final int x)  {\n\n    if (x == 0) {\n        return getZero();\n    }\n\n    if (x == 1) {\n        return this;\n    }\n\n    if (x == -1) {\n        return negate();\n    }\n\n    if (x == RADIX) {\n        return shift(1);\n    }\n\n    if (x == -RADIX) {\n        return shift(-1);\n    }\n\n    if (x == 2) {\n        return shift(1).add(this);\n    }\n\n    if (x == -2) {\n        return shift(-1).add(this);\n    }\n\n    if (x == 3) {\n        return shift(1).add(this).add(this);\n    }\n\n    if (x == -3) {\n        return shift(-1).add(this).add(this);\n    }\n\n    if (x == 4) {\n        return shift(2).add(this);\n    }\n\n    if (x == -4) {\n        return shift(-2).add(this);\n    }\n\n    if (x == 5) {\n        return shift(2).add(this).add(this);\n    }\n\n    if (x == -5) {\n        return shift(-2).add(this).add(this);\n    }\n\n    if (x == 6) {\n        return shift(2).add(this).add(this).add(this);\n    }\n\n    if (x == -6) {\n        return shift(-2).add(this).add(this).add(this);\n    }\n\n    if (x == 7) {\n        return shift(2).add(this).add(this).add(this).add(this);\n    }\n\n    if (x == -7) {\n        return shift(-2).add(this).add(this).add(this).add(this);\n    }\n\n    if (x == 8) {\n        return shift(3).add(this);\n    }\n\n    if (x == -8) {\n        return shift(-3).add(this);\n    }\n}",
      "private Dfp multiplyFast(final int x)  {\n\n        if (nans != FINITE) {\n            return this;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rh = 0;  // acts as a carry\n        for (int i=0; i<mant.length; i++) {\n            int r = mant[i] * x;    // multiply the 2 digits\n            r = r + rh;  // add to the product digit with carry in\n\n            rh = r / RADIX;\n            result.mant[mant.length - i - 1] = r - rh * RADIX;\n        }\n\n        // Fixup the exponent.\n        result.exp = exp + 1;\n\n        final int excp;\n        if (rh != 0) {\n            excp = result.round(rh);\n        } else {\n            excp = result.round(0); // has no effect except to check status\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, x, result);\n        }\n\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n        if (x == 0) {\n            return getZero();\n        }\n\n        Dfp result = newInstance(this);\n\n        int rh = 0;  // acts as a carry\n        for (int i=0; i<mant.length; i++) {\n            int r = mant[i] * x;    // multiply the 2 digits\n            r = r + rh;  // add to the product digit with carry in\n\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n\n        // Fixup the exponent.\n        result.exp = exp + 1;\n\n        final int excp;\n        if (rh != 0) {\n            excp = result.round(rh);\n        } else {\n            excp = result.round(0); // has no effect except to check status\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, x, result);\n        }\n\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n\n    Dfp result = newInstance(this);\n\n    // Multiply the mantissa\n    for (int i = 0; i < mant.length; i++) {\n        int r = mant[i] * x;\n        r = r + result.mant[i];\n        result.mant[i] = r;\n    }\n\n    // Fixup the exponent.\n    result.exp = exp + 1;\n\n    final int excp;\n    if (result.mant[mant.length-1] == 0) {\n        // if result is zero, set exp to zero\n        result.exp = 0;\n    }\n\n    excp = result.round(0); // has no effect except to check status\n\n    if (excp != 0) {\n        result = dotrap(excp, MULTIPLY_TRAP, x, result);\n    }\n\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n        Dfp result = newInstance(this);\n        int rh = 0;  // acts as a carry\n        for (int i=0; i<mant.length; i++) {\n            int r = mant[i] * x;    // multiply the 2 digits\n            r = r + rh;  // add to the product digit with carry in\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = exp;\n        result.sign = (byte)((sign == x)?1:-1);\n\n        if (rh != 0) {\n            // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp;\n        if (rh != 0) {\n            excp = result.round(rh);\n        } else {\n            excp = result.round(0); // has no effect except to check status\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, x, result);\n        }\n\n        return result;\n    }"
    ],
    [
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map == null) \n        {\n            return null;\n        }\n        final Map<K, V> result = new HashMap<K, V>();\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> transformed = new HashMap<K, V>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            transformed.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return transformed;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> transformed = new HashMap<K, V>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            transformed.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return transformed;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (keyTransformer == null && valueTransformer == null) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new HashMap<K, V>(map.size());\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        final Map<K, V> result = new HashMap<K, V>();\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            final K key = transformKey(entry.getKey());\n            final V value = transformValue(entry.getValue());\n            result.put(key, value);\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map == null) {\n            return null;\n        }\n        final Map<K, V> result = new HashMap<K, V>();\n        for (final Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            final K key = transformKey(entry.getKey());\n            final V value = transformValue(entry.getValue());\n            result.put(key, value);\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (keyTransformer == null && valueTransformer == null) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new HashMap<K, V>();\n        for (final Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        final Map<K, V> result = new HashMap<K, V>();\n        for (final Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey((K) entry.getKey()), transformValue((V) entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        final Map<K, V> result = new HashMap<K, V>();\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            final K key = transformKey((K) entry.getKey());\n            final V value = transformValue((V) entry.getValue());\n            result.put(key, value);\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        final Map<K, V> result = new HashMap<K, V>();\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            final K key = transformKey((K) entry.getKey());\n            final V value = transformValue((V) entry.getValue());\n            result.put(key, value);\n        }\n        return result;\n    }"
    ],
    [
      "private Node createExternFunction(Node exportedFunction)  {\n  Node function = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n  function.setJSDocInfo(exportedFunction.getJSDocInfo());\n  return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Preconditions.checkState(exportedFunction.isFunction());\n    Node externFunction = IR.function(\n        exportedFunction.getFirstChild().cloneNode(),\n        exportedFunction.getLastChild().cloneNode());\n    externFunction.setJSDocInfo(exportedFunction.getJSDocInfo());\n    return externFunction;\n  }",
      "private Node createExternFunction(Node exportedFunction)  {\n  Preconditions.checkArgument(exportedFunction.isFunction());\n\n  Node function = IR.function(\n      exportedFunction.getFirstChild().cloneNode(),\n      exportedFunction.getLastChild().cloneNode());\n\n  // TODO(nicksantos): Add parameter and return types.\n  compiler.report(JSError.make(exportedFunction,\n      \"Function to export is missing parameter or return types.\"));\n\n  return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Preconditions.checkState(exportedFunction.isFunction());\n    Node functionNode = exportedFunction.cloneNode();\n    functionNode.removeChildren();\n    functionNode.addChildrenToFront(exportedFunction.getFirstChild().cloneNode());\n    functionNode.addChildrenToBack(exportedFunction.getLastChild().cloneNode());\n    return functionNode;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node functionNode = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n\n  // Copy the function name.\n  functionNode.addChildToFront(exportedFunction.getFirstChild().cloneNode());\n\n  // Copy the function parameters.\n  for (Node param : exportedFunction.getSecondChild().children()) {\n    functionNode.getSecondChild().addChildToBack(param.cloneNode());\n  }\n\n  // Copy the function return type.\n  if (exportedFunction.getChildCount() > 2) {\n    functionNode.addChildToBack(exportedFunction.getChildAtIndex(2).cloneNode());\n  }\n\n  return functionNode;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node externFunction = IR.function(\n      exportedFunction.getFirstChild().cloneNode(),\n      exportedFunction.getLastChild().cloneNode());\n\n  externFunction.setJSDocInfo(exportedFunction.getJSDocInfo());\n\n  if (exportedFunction.getJSDocInfo() == null) {\n    compiler.report(JSError.make(exportedFunction,\n        \"Exported function missing JSDoc\"));\n  } else if (exportedFunction.getJSDocInfo().getType() == null) {\n    compiler.report(JSError.make(exportedFunction,\n        \"Exported function missing type annotation\"));\n  } else if (exportedFunction.getJSDocInfo().getReturnType() == null) {\n    compiler.report(JSError.make(exportedFunction,\n        \"Exported function missing return type annotation\"));\n  }\n\n  return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node function = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n    function.setJSDocInfo(exportedFunction.getJSDocInfo());\n    return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node externFunction = IR.function(\n      exportedFunction.getFirstChild().cloneNode(),\n      exportedFunction.getLastChild().cloneNode());\n\n  externFunction.setJSDocInfo(exportedFunction.getJSDocInfo());\n\n  if (exportedFunction.getJSDocInfo() == null) {\n    compiler.report(\n        JSError.make(exportedFunction,\n            \"Function exported without type information\"));\n  }\n\n  return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Preconditions.checkArgument(exportedFunction.isFunction());\n    Node function = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n    function.setJSDocInfo(exportedFunction.getJSDocInfo());\n    return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Preconditions.checkState(exportedFunction.isFunction());\n  Node functionNode = exportedFunction.cloneNode();\n  functionNode.removeChildren();\n  functionNode.setIsFromExterns(true);\n  functionNode.setJSDocInfo(exportedFunction.getJSDocInfo());\n  return functionNode;\n}"
    ],
    [
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        // Compute the covariance matrix.\n        final double[][] covariance = computeCovariances(params,\n                                                         covarianceSingularityThreshold);\n\n        // Extract the diagonal elements.\n        final double[] sigma = new double[params.length];\n        for (int i = 0; i < params.length; ++i) {\n            sigma[i] = FastMath.sqrt(covariance[i][i]);\n        }\n\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        // Compute the covariance matrix.\n        final double[][] covariance = computeCovariances(params,\n                                                         covarianceSingularityThreshold);\n\n        // Extract the diagonal coefficients.\n        final double[] sigma = new double[covariance.length];\n        for (int i = 0; i < covariance.length; ++i) {\n            sigma[i] = FastMath.sqrt(covariance[i][i]);\n        }\n\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        // Compute the covariance matrix.\n        double[][] covariance = computeCovariances(params,\n                                                   covarianceSingularityThreshold);\n\n        // Extract the diagonal coefficients.\n        double[] sigma = new double[params.length];\n        for (int i = 0; i < params.length; ++i) {\n            sigma[i] = FastMath.sqrt(covariance[i][i]);\n        }\n\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        // Compute the covariance matrix.\n        final double[][] cov = computeCovariances(params,\n                                                  covarianceSingularityThreshold);\n\n        // Extract the diagonal elements.\n        final double[] sigma = new double[cov.length];\n        for (int i = 0; i < cov.length; ++i) {\n            sigma[i] = FastMath.sqrt(cov[i][i]);\n        }\n\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        final double[][] covariance = computeCovariances(params,\n                                                         covarianceSingularityThreshold);\n        final double[] sigma = new double[params.length];\n        for (int i = 0; i < params.length; ++i) {\n            sigma[i] = FastMath.sqrt(covariance[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        final double[][] cov = computeCovariances(params,\n                                                  covarianceSingularityThreshold);\n        final double[] sigma = new double[params.length];\n        for (int i = 0; i < params.length; ++i) {\n            sigma[i] = FastMath.sqrt(cov[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        // Compute the covariance matrix.\n        final double[][] covariance = computeCovariances(params,\n                                                         covarianceSingularityThreshold);\n\n        // Extract the diagonal coefficients.\n        final int n = covariance.length;\n        final double[] sigma = new double[n];\n        for (int i = 0; i < n; ++i) {\n            sigma[i] = FastMath.sqrt(covariance[i][i]);\n        }\n\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        // Compute the covariance matrix.\n        double[][] covariance = computeCovariances(params,\n                                                   covarianceSingularityThreshold);\n\n        // Extract the diagonal elements.\n        double[] sigma = new double[params.length];\n        for (int i = 0; i < params.length; ++i) {\n            sigma[i] = FastMath.sqrt(covariance[i][i]);\n        }\n\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        // Compute the covariance matrix.\n        final double[][] covariance = computeCovariances(params,\n                                                         covarianceSingularityThreshold);\n\n        // Extract the diagonal coefficients.\n        final double[] sigma = new double[covariance.length];\n        for (int i = 0; i < sigma.length; ++i) {\n            sigma[i] = FastMath.sqrt(covariance[i][i]);\n        }\n\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        // Compute the covariance matrix.\n        final double[][] cov = computeCovariances(params,\n                                                  covarianceSingularityThreshold);\n\n        // Extract the diagonal coefficients.\n        final int n = cov.length;\n        final double[] sigma = new double[n];\n        for (int i = 0; i < n; ++i) {\n            sigma[i] = FastMath.sqrt(cov[i][i]);\n        }\n\n        return sigma;\n    }"
    ],
    [
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalStateException(\"Variable: \" + varName + \" has already been used in the cycle. Substitution is not possible.\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalStateException(\"The variable \" + varName + \" is already in the stack of variables. Cyclic substitution is not allowed.\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n        if (priorVariables.contains(varName)) {\n            throw new IllegalStateException(\"Variable: \" + varName\n                    + \" has already been substituted. Cyclic substitution is not allowed.\");\n        }\n    }",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalStateException(\"The variable \" + varName + \" is already defined in the stack of variables.\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalStateException(\"The variable \" + varName + \" is already defined in the stack of variables.\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalStateException(\"The variable \" + varName\n                + \" is already in the stack of variables. Cyclic substitution is not allowed.\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalStateException(\"Variable: \" + varName + \" has already been used, cyclic substitution is not allowed.\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalStateException(\"The variable \" + varName + \" is already defined in the stack of variables.\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalStateException(\"Variable \" + varName + \" is already being resolved\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalStateException(\"Variable \" + varName\n                + \" is already in the stack of variables being resolved.\");\n    }\n}"
    ],
    [
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> result = Lists.newArrayList();\n    Set<INPUT> seen = Sets.newHashSet();\n    Deque<INPUT> worklist = new ArrayDeque<INPUT>(roots);\n    while (!worklist.isEmpty()) {\n      INPUT current = worklist.pop();\n      if (seen.add(current)) {\n        result.add(current);\n        for (INPUT dep : current.getRequires()) {\n          worklist.add(dep);\n        }\n      }\n    }\n    if (sorted) {\n      Collections.sort(result, new Comparator<INPUT>() {\n}\n}\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    // Implement this method.\n    return null;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> result = Lists.newArrayList();\n    Multimap<INPUT, INPUT> deps = HashMultimap.create();\n    for (INPUT input : roots) {\n      for (String symbol : input.getRequires()) {\n        INPUT candidate = provideMap.get(symbol);\n        if (candidate != null) {\n          deps.put(candidate, input);\n        }\n      }\n    }\n    Set<INPUT> covered = Sets.newHashSet();\n    for (INPUT root : roots) {\n      if (covered.add(root)) {\n        addDependencies(root, deps, covered, result);\n      }\n    }\n    if (sorted) {\n      result = getSortedList(result, deps);\n    }\n    return result;\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    // TODO: Implement this method\n    return null;\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  Multimap<INPUT, INPUT> deps = HashMultimap.create();\n  for (INPUT input : provideMap.values()) {\n    for (String symbol : input.getRequires()) {\n      INPUT candidate = provideMap.get(symbol);\n      if (candidate != null) {\n        deps.put(candidate, input);\n      }\n    }\n  }\n\n  List<INPUT> result = Lists.newArrayList();\n  for (INPUT root : roots) {\n    result.addAll(getDependenciesOf(root, deps, Sets.<INPUT>newHashSet()));\n  }\n\n  if (sorted) {\n    return getSortedList(result, deps);\n  } else {\n    return result;\n  }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    // TODO: Implement this function\n    return null;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    // Create a multimap of all the dependencies.\n    Multimap<INPUT, INPUT> deps = HashMultimap.create();\n    for (INPUT input : roots) {\n      for (String symbol : input.getRequires()) {\n        deps.put(input, provideMap.get(symbol));\n      }\n    }\n\n    // Find all the inputs that are not in the roots.\n    Set<INPUT> subGraph = Sets.newHashSet(roots);\n    for (INPUT input : roots) {\n      subGraph.addAll(deps.get(input));\n    }\n\n    // If we're sorting, find the first circular dependency and throw an\n    // exception.\n    if (sorted) {\n      List<INPUT> cycle = findCycle(Lists.newArrayList(roots), deps);\n      throw new IllegalStateException(\n          \"Circular dependency: \" + cycleToString(cycle));\n    }\n\n    // If we're not sorting, return the list of inputs in the order they were\n    // passed to the compiler.\n    return Lists.newArrayList(subGraph);\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> result = Lists.newArrayList();\n    Multimap<INPUT, INPUT> deps = ArrayListMultimap.create();\n    for (INPUT input : provideMap.values()) {\n      for (String symbol : input.getRequires()) {\n        INPUT provider = provideMap.get(symbol);\n        if (provider != null) {\n          deps.put(provider, input);\n        }\n      }\n    }\n    Set<INPUT> covered = Sets.newHashSet();\n    for (INPUT root : roots) {\n      getDependenciesOf(root, deps, covered, result);\n    }\n    if (sorted) {\n      Collections.sort(result, new Comparator<INPUT>() {\n}\n}\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    // TODO: Implement this method.\n    return null;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    Multimap<INPUT, INPUT> deps = ArrayListMultimap.create();\n    for (INPUT input : provideMap.values()) {\n      for (String symbol : input.getRequires()) {\n        INPUT candidate = provideMap.get(symbol);\n        if (candidate != null) {\n          deps.put(candidate, input);\n        }\n      }\n    }\n\n    List<INPUT> sortedList = Lists.newArrayList();\n    Set<INPUT> covered = Sets.newHashSet();\n    for (INPUT root : roots) {\n      sortedList.addAll(getDependenciesOf(root, deps, covered));\n    }\n\n    if (sorted) {\n      Collections.sort(sortedList, new Comparator<INPUT>() {\n}\n}\n}"
    ],
    [
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (Character.isWhitespace(ch)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext || (delimLen > 0 && Character.isWhitespace(delimiters[0]))) {\n            buffer[i] = Character.toLowerCase(ch);\n            if (delimLen == 1) {\n                uncapitalizeNext = false;\n            }\n        } else {\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final char[] buffer = new char[strLen];\n    final int[] delimiterBuffer = new int[strLen];\n    int count = 0;\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < strLen; i++) {\n        char c = str.charAt(i);\n        if (isDelimiter(c, delimiters)) {\n            uncapitalizeNext = true;\n            delimiterBuffer[count++] = i;\n        } else if (uncapitalizeNext || (i == 0 && !Character.isTitleCase(c))) {\n            // TextUtils.decapitalize is broken.\n            buffer[i] = Character.toLowerCase(c);\n            uncapitalizeNext = false;\n        } else {\n            buffer[i] = c;\n        }\n    }\n    return new String(buffer, 0, count);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (Character.isWhitespace(ch)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext || (delimLen > 0 && Character.isWhitespace(delimiters[0]))) {\n            buffer[i] = Character.toLowerCase(ch);\n            if (delimLen == 1) {\n                uncapitalizeNext = false;\n            }\n        } else {\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (Character.isWhitespace(ch)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext || (delimLen > 0 && Character.isWhitespace(delimiters[0]) && Character.isWhitespace(ch))) {\n            buffer[i] = Character.toLowerCase(ch);\n            if (delimLen == 1) {\n                uncapitalizeNext = true;\n            } else {\n                uncapitalizeNext = false;\n                for (int j = 1; j < delimLen; j++) {\n                    if (delimiters[j] == ch) {\n                        uncapitalizeNext = true;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (Character.isWhitespace(ch)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext || (delimLen > 0 && Character.isWhitespace(delimiters[0]))) {\n            buffer[i] = Character.toLowerCase(ch);\n            if (delimLen == 1) {\n                uncapitalizeNext = false;\n            }\n        } else {\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (Character.isWhitespace(ch)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext || (delimLen > 0 && Character.isWhitespace(delimiters[0]))) {\n            buffer[i] = Character.toLowerCase(ch);\n            if (delimLen == 1) {\n                uncapitalizeNext = false;\n            }\n        } else {\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final char[] buffer = new char[strLen];\n    final int[] delimiterBuffer = new int[strLen];\n    int count = 0;\n    boolean whitespace = true;\n    char ch = 0;\n    char delimiter = 0;\n    for (int i = 0; i < strLen; i++) {\n        ch = str.charAt(i);\n        if (isWhitespace(ch)) {\n            ch = Character.toLowerCase(ch);\n            whitespace = true;\n        } else {\n            if (whitespace) {\n                if (delimLen == -1) {\n                    ch = Character.toLowerCase(ch);\n                } else {\n                    for (int j = 0; j < delimLen; j++) {\n                        delimiter = delimiters[j];\n                        if (ch == delimiter) {\n                            ch = Character.toLowerCase(ch);\n                            break;\n                        }\n                    }\n                }\n            } else {\n                ch = Character.toLowerCase(ch);\n            }\n            whitespace = false;\n        }\n        buffer[count++] = ch;\n    }\n    return new String(buffer, 0, count);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    int strLen = str.length();\n    StringBuilder buffer = new StringBuilder(strLen);\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < strLen; i++) {\n        char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            buffer.append(ch);\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer.append(Character.toLowerCase(ch));\n            uncapitalizeNext = false;\n        } else {\n            buffer.append(ch);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int[] newCodePoints = new int[strLen];\n    int outOffset = 0;\n    boolean capitalizeNext = true;\n    int cp;\n    for (int inOffset = 0; inOffset < strLen;) {\n        cp = str.codePointAt(inOffset);\n        if (isDelimiter(cp, delimiters)) {\n            newCodePoints[outOffset++] = cp;\n            capitalizeNext = true;\n        } else if (capitalizeNext || outOffset != 0 && capitalizeNext == false) {\n            newCodePoints[outOffset++] = Character.toLowerCase(cp);\n            capitalizeNext = false;\n        } else {\n            newCodePoints[outOffset++] = cp;\n        }\n        inOffset += Character.charCount(cp);\n    }\n    if (outOffset != 0) {\n        return new String(newCodePoints, 0, outOffset);\n    }\n    return str;\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (Character.isWhitespace(ch)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext || (delimLen > 0 && Character.isWhitespace(delimiters[0]) && Character.isWhitespace(ch))) {\n            buffer[i] = Character.toLowerCase(ch);\n            if (delimLen == 1) {\n                uncapitalizeNext = true;\n            } else {\n                for (int j = 1; j < delimLen; j++) {\n                    if (delimiters[j] == ch) {\n                        uncapitalizeNext = true;\n                        break;\n                    }\n                }\n            }\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}"
    ],
    [
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    char[] buf;\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    buf = new char[a.toString().length()];\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.getField().newDfp(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    DfpField field = a.getField();\n    int n = a.getField().getRadixDigits();\n    int m = a.getField().getRadix();\n    int n2 = n / 2;\n    int n1 = n - n2;\n    int m2 = (int) Math.pow(m, n2);\n    int m1 = (int) Math.pow(m, n1);\n    int a2 = a.getUnsignedNormalized();\n    int a1 = a2 % m2;\n    a2 = a2 / m2;\n    a1 = a1 * m1;\n    a2 = a2 * m1;\n    result[0] = field.newDfp(a2);\n    result[1] = field.newDfp(a1);\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    DfpField field = a.getField();\n    int radixDigits = field.getRadixDigits();\n    int[] mantissa = a.getUnsignedMantissa();\n    int exponent = a.getExponent();\n    int[] mantissa1 = new int[radixDigits];\n    int[] mantissa2 = new int[radixDigits];\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int carry = 0;\n    int shift = 0;\n    int shift1 = 0;\n    int shift2 = 0;\n    int shift3 = 0;\n    int shift4 = 0;\n    int shift5 = 0;\n    int shift6 = 0;\n    int shift7 = 0;\n    int shift8 = 0;\n    int shift9 = 0;\n    int shift10 = 0;\n    int shift11 = 0;\n    int shift12 = 0;\n    int shift13 = 0;\n    int shift14 = 0;\n    int shift15 = 0;\n    int shift16 = 0;\n    int shift17 = 0;\n    int shift18 = 0;\n    int shift19 = 0;\n    int shift20 = 0;\n    int shift21 = 0;\n    int shift22 = 0;\n    int shift23 = 0;\n    int shift24 = 0;\n    int shift25 = 0;\n    int shift26 = 0;\n    int shift27 = 0;\n    int shift28 = 0;\n    int shift29 = 0;\n    int shift30 = 0;\n    int shift31 = 0;\n    int shift32 = 0;\n    int shift33 = 0;\n    int shift34 = 0;\n    int shift35 = 0;\n    int shift36 = 0;\n    int shift37 = 0;\n    int shift38 = 0;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    char[] buf;\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    buf = new char[a.toString().length()];\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = new Dfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = new Dfp(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    char[] buf;\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    buf = new char[a.toString().length()];\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.getField().newDfp(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    DfpField field = a.getField();\n    int radixDigits = field.getRadixDigits();\n    int radix = field.getRadix();\n    int[] digits = a.getUnsignedDigits();\n    int[] firstDigits = new int[radixDigits / 2];\n    int[] secondDigits = new int[radixDigits - radixDigits / 2];\n    int firstDigitsLength = 0;\n    int secondDigitsLength = 0;\n    int firstDigitsSum = 0;\n    int secondDigitsSum = 0;\n    int firstDigitsSumOfSquares = 0;\n    int secondDigitsSumOfSquares = 0;\n    int firstDigitsSumOfCubes = 0;\n    int secondDigitsSumOfCubes = 0;\n    int firstDigitsSumOfFourthPowers = 0;\n    int secondDigitsSumOfFourthPowers = 0;\n    int firstDigitsSumOfFifthPowers = 0;\n    int secondDigitsSumOfFifthPowers = 0;\n    int firstDigitsSumOfSixthPowers = 0;\n    int secondDigitsSumOfSixthPowers = 0;\n    int firstDigitsSumOfSeventhPowers = 0;\n    int secondDigitsSumOfSeventhPowers = 0;\n    int firstDigitsSumOfEighthPowers = 0;\n    int secondDigitsSumOfEighthPowers = 0;\n    int firstDigitsSumOfNinthPowers = 0;\n    int secondDigitsSumOfNinthPowers = 0;\n    int firstDigitsSumOfTenthPowers = 0;\n    int secondDigitsSumOfTenthPowers = 0;\n    int firstDigitsSumOfEleventhPowers = 0;\n    int secondDigitsSumOfEleventhPowers = 0;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n        Dfp result[] = new Dfp[2];\n        char[] buf;\n        boolean leading = true;\n        int sp = 0;\n        int sig = 0;\n\n        buf = new char[a.toString().length()];\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = a.toString().charAt(i);\n\n            if (buf[i] >= '1' && buf[i] <= '9') {\n                leading = false;\n            }\n\n            if (buf[i] == '.') {\n                sig += (400 - sig) % 4;\n                leading = false;\n            }\n\n            if (sig == (a.getRadixDigits() / 2) * 4) {\n                sp = i;\n                break;\n            }\n\n            if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n                sig ++;\n            }\n        }\n\n        result[0] = a.newInstance(new String(buf, 0, sp));\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = a.toString().charAt(i);\n            if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n                buf[i] = '0';\n            }\n        }\n\n        result[1] = a.newInstance(new String(buf));\n\n        return result;\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n        Dfp result[] = new Dfp[2];\n        DfpField field = a.getField();\n        DfpField field2 = new DfpField(field.getRadix(), field.getRadixDigits() * 2);\n        Dfp a2 = field2.newDfp(a.toString());\n        result[0] = a2.subtract(a2.subtract(a2));\n        result[1] = a2.subtract(result[0]);\n        return result;\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    char[] buf;\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    buf = new char[a.toString().length()];\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.getField().newDfp(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    char[] buf;\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    buf = new char[a.toString().length()];\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.getField().newDfp(new String(buf));\n\n    return result;\n}"
    ],
    [
      "public String cssSelector()  {\n    if (id().length() > 0)\n        return \"#\" + id();\n    else if (parent() == null)\n        return tagName();\n    else {\n        String selector = \"\";\n        Elements els = parent().children();\n        int i = 0;\n        for (Element el : els) {\n            if (el == this)\n                break;\n            else if (el.tagName().equals(tagName()))\n                i++;\n        }\n        if (i > 0)\n            selector = tagName() + \":nth-child(\" + (i + 1) + \")\";\n        else\n            selector = tagName();\n        return parent().cssSelector() + \">\" + selector;\n    }\n}",
      "public String cssSelector()  {\n    if (id() != null && !id().isEmpty()) {\n        return \"#\" + id();\n    }\n    Elements parents = parents();\n    if (parents.size() == 0) {\n        return tagName();\n    }\n    Element parent = parents.get(0);\n    String parentCss = parent.cssSelector();\n    String myIndex = String.valueOf(parent.children().indexOf(this) + 1);\n    return parentCss + \">\" + tagName() + \":\" + myIndex;\n}",
      "public String cssSelector()  {\n    if (id().length() > 0) {\n        return \"#\" + id();\n    } else {\n        Elements parents = parents();\n        if (parents.size() == 0) {\n            return tagName();\n        } else {\n            Element parent = parents.get(0);\n            Elements siblings = parent.children();\n            String uniqueSelector = tagName();\n            if (siblings.size() > 1) {\n                uniqueSelector += \":nth-child(\" + (siblings.indexOf(this) + 1) + \")\";\n            }\n            if (parent.id().length() > 0) {\n                return parent.cssSelector() + \">\" + uniqueSelector;\n            } else {\n                return parent.cssSelector() + \" \" + uniqueSelector;\n            }\n        }\n    }\n}",
      "public String cssSelector()  {\n    if (id() != null)\n        return \"#\" + id();\n    else if (parent() != null)\n        return parent().cssSelector() + \" > \" + uniqueSelector();\n    else\n        return uniqueSelector();\n}",
      "public String cssSelector()  {\n    if (id() != null && !id().isEmpty()) {\n        return \"#\" + id();\n    }\n    Elements parents = parents();\n    if (parents.size() == 0) {\n        return tagName();\n    }\n    Element parent = parents.get(0);\n    Elements siblings = parent.children();\n    String combinator = siblings.size() > 1 && siblings.first() != this ? \" > \" : \" \";\n    String className = attr(\"class\");\n    String nthChild = \"\";\n    if (siblings.size() > 1) {\n        int index = siblings.indexOf(this);\n        nthChild = \":nth-child(\" + (index + 1) + \")\";\n    }\n    String tagName = tagName();\n    if (className != null && !className.isEmpty()) {\n        return parent.cssSelector() + combinator + tagName + \".\" + className.replace(\" \", \".\") + nthChild;\n    }\n    return parent.cssSelector() + combinator + tagName + nthChild;\n}",
      "public String cssSelector()  {\n    if (id().length() > 0) \n    {\n        return \"#\" + id();\n    } \n    else \n    {\n        Elements parents = parents();\n        if (parents.size() == 0) \n        {\n            return tagName();\n        } \n        else \n        {\n            return parents.get(0).cssSelector() + \" > \" + uniqueSelector();\n        }\n    }\n}",
      "public String cssSelector()  {\n    if (id() != null && !id().isEmpty()) {\n        return \"#\" + id();\n    }\n    else if (parent() != null) {\n        return parent().cssSelector() + \" > \" + uniqueSelector();\n    }\n    else {\n        return uniqueSelector();\n    }\n}",
      "public String cssSelector()  {\n        if (id().length() > 0) {\n            return \"#\" + id();\n        }\n        else {\n            Elements parents = parents();\n            if (parents.size() == 0) {\n                return tagName();\n            }\n            else {\n                Element parent = parents.get(0);\n                Elements siblings = parent.children();\n                String uniqueSelector = tagName();\n                if (siblings.size() > 1) {\n                    uniqueSelector += \":nth-child(\" + (siblings.indexOf(this) + 1) + \")\";\n                }\n                return parent.cssSelector() + \">\" + uniqueSelector;\n            }\n        }\n    }",
      "public String cssSelector()  {\n    String selector = \"\";\n    if (id() != null && !id().isEmpty()) {\n        selector = \"#\" + id();\n    } else {\n        Elements parents = parents();\n        if (parents.size() > 0) {\n            selector = parents.get(0).cssSelector() + \" > \";\n        }\n        selector += tagName();\n        if (classNames().size() > 0) {\n            selector += \".\" + classNames().get(0);\n        }\n        if (siblingIndex() > 0) {\n            selector += \":nth-child(\" + (siblingIndex() + 1) + \")\";\n        }\n    }\n    return selector;\n}",
      "public String cssSelector()  {\n    Validate.notNull(tagName());\n    if (id().length() > 0)\n        return \"#\" + id();\n    else if (parent() == null)\n        return tagName();\n    else {\n        StringBuffer selector = new StringBuffer();\n        Elements siblings = parent().children();\n        int index = siblings.indexOf(this);\n        if (siblings.size() > 1 && index > 0) {\n            selector.append(tagName());\n            if (!classNames().isEmpty()) {\n                selector.append(\".\" + StringUtils.join(classNames(), \".\"));\n            }\n            selector.append(\":nth-child(\" + (index + 1) + \")\");\n        }\n        else {\n            selector.append(parent().cssSelector());\n            selector.append(\" > \");\n            selector.append(tagName());\n            if (!classNames().isEmpty()) {\n                selector.append(\".\" + StringUtils.join(classNames(), \".\"));\n            }\n        }\n        return selector.toString();\n    }\n}"
    ],
    [
      "private static int estimateCostOneLevel(Node n)  {\n  int result = 0;\n  switch (n.getType()) {\n    case Token.NOT:\n      result = 1;\n      break;\n    case Token.HOOK:\n    case Token.COMMA:\n      result = 2;\n      break;\n    default:\n      break;\n  }\n  return result;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  int cost = 0;\n  if (n.getType() == Token.NOT) {\n    cost = 1;\n  } else if (n.getType() == Token.HOOK) {\n    cost = 2;\n  } else if (n.getType() == Token.COMMA) {\n    cost = 2;\n  }\n  return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType()) {\n      case Token.NOT:\n        cost += 1;\n        break;\n      case Token.LP:\n        cost += 2;\n        break;\n      case Token.HOOK:\n        cost += 3;\n        break;\n      case Token.COMMA:\n        cost += 4;\n        break;\n      default:\n        cost += 0;\n    }\n    return cost;\n  }",
      "private static int estimateCostOneLevel(Node n)  {\n    int result = 0;\n    switch (n.getType()) {\n      case Token.NOT:\n        result = 1;\n        break;\n      case Token.HOOK:\n        result = 1;\n        break;\n      case Token.COMMA:\n        result = 1;\n        break;\n      default:\n        break;\n    }\n    return result;\n  }",
      "private static int estimateCostOneLevel(Node n)  {\n  switch (n.getType()) {\n    case Token.NOT:\n      return 1;\n    case Token.HOOK:\n    case Token.COMMA:\n      return 2;\n    default:\n      return 0;\n  }\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  switch (n.getType()) {\n    case Token.NOT:\n      return 1;\n    case Token.HOOK:\n    case Token.COMMA:\n      return 2;\n    default:\n      return 0;\n  }\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType()) {\n      case Token.NOT:\n        cost = 1;\n        break;\n      case Token.HOOK:\n      case Token.COMMA:\n        cost = 2;\n        break;\n      default:\n        break;\n    }\n    return cost;\n  }",
      "private static int estimateCostOneLevel(Node n)  {\n    switch (n.getType()) {\n      case Token.NOT:\n        return 1;\n      case Token.HOOK:\n      case Token.COMMA:\n        return 2;\n      default:\n        return 0;\n    }\n  }",
      "private static int estimateCostOneLevel(Node n)  {\n    switch (n.getType()) {\n      case Token.NOT:\n        return 4;\n      case Token.HOOK:\n      case Token.COMMA:\n        return 2;\n      default:\n        return 0;\n    }\n  }",
      "private static int estimateCostOneLevel(Node n)  {\n  int result = 0;\n  switch (n.getType()) {\n    case Token.NOT:\n      result = 1;\n      break;\n    case Token.HOOK:\n    case Token.COMMA:\n      result = 2;\n      break;\n    default:\n      break;\n  }\n  return result;\n}"
    ],
    [
      "public StrBuilder reverse()  {\n    int i = 0;\n    int j = size - 1;\n    char[] buf = buffer;\n    while (j > i) {\n        char swap = buf[i];\n        buf[i] = buf[j];\n        buf[j] = swap;\n        j--;\n        i++;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int i = 0;\n    int j = size - 1;\n    char[] buf = buffer;\n    while (j > i) {\n        char swap = buf[i];\n        buf[i] = buf[j];\n        buf[j] = swap;\n        j--;\n        i++;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int i = 0;\n    int j = size - 1;\n    char[] buf = buffer;\n    while (j > i) {\n        char swap = buf[i];\n        buf[i] = buf[j];\n        buf[j] = swap;\n        j--;\n        i++;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int left = 0;\n    int right = size - 1;\n    char[] buf = buffer;\n    while (left < right) {\n        char temp = buf[left];\n        buf[left] = buf[right];\n        buf[right] = temp;\n        left++;\n        right--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int low = 0;\n    int high = size - 1;\n    char[] buf = buffer;\n    while (low < high) \n    {\n        char swap = buf[low];\n        buf[low] = buf[high];\n        buf[high] = swap;\n        low++;\n        high--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size > 1) {\n        int mid = size >> 1;\n        for (int i = 0, j = size - 1; i < mid; i++, j--) {\n            char ch = buffer[i];\n            buffer[i] = buffer[j];\n            buffer[j] = ch;\n        }\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int left = 0;\n    int right = size - 1;\n    char[] buf = buffer;\n    while (left < right) \n    {\n        char temp = buf[left];\n        buf[left++] = buf[right];\n        buf[right--] = temp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int i = 0;\n    int j = size - 1;\n    char[] buf = buffer;\n    while (j > i) \n    {\n        char swap = buf[i];\n        buf[i] = buf[j];\n        buf[j] = swap;\n        j--;\n        i++;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size <= 1) {\n        return this;\n    }\n    int left = 0;\n    int right = size - 1;\n    while (left < right) {\n        char temp = buffer[left];\n        buffer[left] = buffer[right];\n        buffer[right] = temp;\n        left++;\n        right--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int low = 0;\n    int high = size - 1;\n    char[] buf = buffer;\n    while (low < high) \n    {\n        char swap = buf[low];\n        buf[low] = buf[high];\n        buf[high] = swap;\n        low++;\n        high--;\n    }\n    return this;\n}"
    ],
    [
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n    Validate.isTrue(offset < value.length(), \"Split offset must not be greater than current text length\");\n\n    String head = value.substring(0, offset);\n    String tail = value.substring(offset);\n\n    TextNode tailNode = new TextNode(tail);\n    replaceWith(tailNode);\n\n    return tailNode;\n}",
      "public TextNode splitText(int offset)  {\n        Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n        Validate.isTrue(offset < value.length(), \"Split offset must not be greater than current text length\");\n\n        String head = value.substring(0, offset);\n        String tail = value.substring(offset);\n        value = head;\n\n        TextNode tailNode = new TextNode(tail);\n        if (parent != null) {\n            parent.addChildren(siblingIndex + 1, tailNode);\n        }\n        return tailNode;\n    }",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n    Validate.isTrue(offset < coreValue().length(), \"Split offset must not be greater than current text length\");\n\n    String head = coreValue().substring(0, offset);\n    String tail = coreValue().substring(offset);\n\n    coreValue(head);\n\n    TextNode tailNode = new TextNode(tail);\n    if (parentNode != null)\n    {\n        parentNode.addChildren(siblingIndex + 1, tailNode);\n    }\n\n    return tailNode;\n}",
      "public TextNode splitText(int offset)  {\n        Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n        Validate.isTrue(offset < value.length(), \"Split offset must not be greater than current text length\");\n\n        String head = value.substring(0, offset);\n        String tail = value.substring(offset);\n\n        TextNode tailNode = new TextNode(tail);\n        replaceWith(tailNode);\n\n        return tailNode;\n    }",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n    Validate.isTrue(offset < value.length(), \"Split offset must not be greater than current text length\");\n\n    String head = value.substring(0, offset);\n    String tail = value.substring(offset);\n\n    TextNode tailNode = new TextNode(tail);\n    this.value = head;\n    this.parentNode.addChildren(tailNode);\n\n    return tailNode;\n}",
      "public TextNode splitText(int offset)  {\n        Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n        Validate.isTrue(offset < coreValue().length(), \"Split offset must not be greater than current text length\");\n\n        String head = coreValue().substring(0, offset);\n        String tail = coreValue().substring(offset);\n\n        coreValue(head);\n\n        TextNode tailNode = new TextNode(tail);\n        if (parentNode != null) {\n            parentNode.addChildren(siblingIndex + 1, tailNode);\n        }\n\n        return tailNode;\n    }",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n    Validate.isTrue(offset < value.length(), \"Split offset must not be greater than current text length\");\n    String head = value.substring(0, offset);\n    String tail = value.substring(offset);\n    value = head;\n    TextNode tailNode = new TextNode(tail);\n    if (parent != null)\n        parent.addChildren(this, tailNode);\n    return tailNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n    Validate.isTrue(offset < value.length(), \"Split offset must not be greater than current text length\");\n\n    String head = value.substring(0, offset);\n    String tail = value.substring(offset);\n\n    TextNode tailNode = new TextNode(tail);\n    replaceWith(tailNode);\n    return tailNode;\n}",
      "public TextNode splitText(int offset)  {\n        Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n        Validate.isTrue(offset < value.length(), \"Split offset must not be greater than current text length\");\n\n        String head = value.substring(0, offset);\n        String tail = value.substring(offset);\n\n        TextNode tailNode = new TextNode(tail);\n        this.text(head);\n\n        return tailNode;\n    }",
      "public TextNode splitText(int offset)  {\n        Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n        Validate.isTrue(offset < coreValue().length(), \"Split offset must not be greater than current text length\");\n\n        String head = coreValue().substring(0, offset);\n        String tail = coreValue().substring(offset);\n\n        coreValue(head);\n\n        TextNode tailNode = new TextNode(tail);\n        if (parentNode != null) {\n            parentNode.addChildren(siblingIndex + 1, tailNode);\n        }\n\n        return tailNode;\n    }"
    ],
    [
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return subtract(union(a, b), intersection(a, b));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return subtract(union(a, b), intersection(a, b));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return subtract(union(a, b), intersection(a, b));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return subtract(union(a, b), intersection(a, b));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, Math.abs(helper.max(obj) - helper.min(obj)));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return subtract(union(a, b), intersection(a, b));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return subtract(union(a, b), intersection(a, b));\n}"
    ],
    [
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    long longValue = value.longValue();\n    for (int i = 0; i < 8; i++) \n    {\n        bytes[i] = (byte) (longValue & 0xFF);\n        longValue = longValue >> 8;\n    }\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n        byte[] result = new byte[8];\n        for (int i = 0; i < 8; i++) {\n            result[i] = (byte) (value.shiftRight(i * 8).and(0xFF).intValue());\n        }\n        return result;\n    }",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] result = new byte[8];\n    byte[] val = value.toByteArray();\n    int offset = (val.length > 8) ? val.length - 8 : 0;\n    for (int i = 0; i < 8; i++) {\n        result[i] = (i < val.length - offset) ? val[i + offset] : 0;\n    }\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n        byte[] result = new byte[8];\n        for (int i = 0; i < 8; i++) {\n            result[i] = (byte) (value.shiftRight(BYTE_7_SHIFT - i * 8).longValue() & BYTE_7_MASK);\n        }\n        return result;\n    }",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    byte[] val = value.toByteArray();\n    int start = (val.length == 8) ? 0 : 1;\n    int index = 7;\n    for (int i = start; i < val.length; i++) {\n        bytes[index--] = val[i];\n    }\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] result = new byte[8];\n    byte[] bytes = value.toByteArray();\n    int offset = bytes.length > 8 ? bytes.length - 8 : 0;\n    for (int i = 0; i < 8; i++) {\n        result[i] = bytes[i + offset];\n    }\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n        byte[] bytes = new byte[8];\n        for (int i = 0; i < 8; i++) {\n            bytes[i] = value.shiftRight(BYTE_7_SHIFT - i * 8).and(BYTE_7_MASK).byteValue();\n        }\n        return bytes;\n    }",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] result = new byte[8];\n    byte[] bytes = value.toByteArray();\n    int length = bytes.length;\n    int offset = 8 - length;\n    for (int i = 0; i < length; i++) \n    {\n        result[i + offset] = bytes[i];\n    }\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n        byte[] bytes = new byte[8];\n        for (int i = 0; i < 8; i++) {\n            bytes[i] = (byte) (value.shiftRight(i * 8).longValue() & 0xFF);\n        }\n        return bytes;\n    }",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] result = new byte[8];\n    byte[] bytes = value.toByteArray();\n    int offset = bytes.length - 8;\n    for (int i = 0; i < 8; i++) {\n        result[i] = bytes[offset + i];\n    }\n    return result;\n}"
    ],
    [
      "public static String keep(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return \"\";\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        final StringBuilder buffer = new StringBuilder();\n        for (final char c : str.toCharArray()) {\n            if (chars.contains(c)) {\n                buffer.append(c);\n            }\n        }\n        return buffer.toString();\n    }",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return StringUtils.EMPTY;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return StringUtils.EMPTY;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return \"\";\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder();\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return str;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        final StringBuilder buffer = new StringBuilder();\n        for (final char c : str.toCharArray()) {\n            if (chars.contains(c)) {\n                buffer.append(c);\n            }\n        }\n        return buffer.toString();\n    }",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return StringUtils.EMPTY;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder();\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return StringUtils.EMPTY;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return \"\";\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder();\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return str;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        final StringBuilder buffer = new StringBuilder();\n        for (final char c : str.toCharArray()) {\n            if (chars.contains(c)) {\n                buffer.append(c);\n            }\n        }\n        return buffer.toString();\n    }\n\n    // Remove"
    ],
    [
      "public RealMatrix getSquareRoot()  {\n    // Check if the matrix is symmetric and positive definite.\n    if (!isSymmetric() || !isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(\n                LocalizedFormats.NOT_SYMMETRIC_POSITIVE_DEFINITE);\n    }\n\n    // Compute the eigenvalues and eigenvectors of the matrix.\n    EigenDecomposition eigen = new EigenDecomposition(this);\n    double[] realEigenvalues = eigen.getRealEigenvalues();\n    RealVector[] eigenvectors = eigen.getEigenvectors();\n\n    // Compute the square-root of the eigenvalues.\n    double[] sqrtEigenvalues = new double[realEigenvalues.length];\n    for (int i = 0; i < realEigenvalues.length; i++) {\n        sqrtEigenvalues[i] = Math.sqrt(realEigenvalues[i]);\n    }\n\n    // Compute the square-root of the matrix.\n    RealMatrix sqrtMatrix = MatrixUtils.createRealMatrix(getRowDimension(), getColumnDimension());\n    for (int i = 0; i < realEigenvalues.length; i++) {\n        sqrtMatrix = sqrtMatrix.add(eigenvectors[i].mapMultiplyToSelf(sqrtEigenvalues[i]));\n    }\n\n    return sqrtMatrix;\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SYMMETRIC);\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_POSITIVE_DEFINITE);\n    }\n    final int n = getRowDimension();\n    final RealMatrix eigenvectors = getV();\n    final double[] eigenvalues = getRealEigenvalues();\n    final RealMatrix squareRoot = MatrixUtils.createRealMatrix(n, n);\n    for (int i = 0; i < n; i++) {\n        final RealVector eigenvector = eigenvectors.getColumnVector(i);\n        final double eigenvalue = eigenvalues[i];\n        final double sqrtEigenvalue = Math.sqrt(eigenvalue);\n        final RealVector sqrtEigenvector = eigenvector.mapMultiply(1 / sqrtEigenvalue);\n        squareRoot.setColumnVector(i, sqrtEigenvector);\n    }\n    return squareRoot;\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric() || !isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SYMMETRIC_POSITIVE_DEFINITE);\n    }\n\n    // Get the eigen decomposition of the matrix\n    EigenDecomposition eigen = new EigenDecomposition(this);\n\n    // Compute the square-root of the eigenvalues\n    double[] realEigenvalues = eigen.getRealEigenvalues();\n    double[] imagEigenvalues = eigen.getImagEigenvalues();\n    for (int i = 0; i < realEigenvalues.length; i++) {\n        if (imagEigenvalues[i] == 0) {\n            realEigenvalues[i] = Math.sqrt(realEigenvalues[i]);\n        } else {\n            throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SYMMETRIC_POSITIVE_DEFINITE);\n        }\n    }\n\n    // Build the square-root matrix\n    int n = getRowDimension();\n    RealMatrix sqrt = createMatrix(n, n);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            sqrt.setEntry(i, j, eigen.getEigenvector(i).getEntry(j) * realEigenvalues[j]);\n        }\n    }\n\n    return sqrt;\n}",
      "public RealMatrix getSquareRoot()  {\n    // Check if the matrix is symmetric and positive definite.\n    if (!isSymmetricAndPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(\n                LocalizedFormats.NOT_SYMMETRIC_POSITIVE_DEFINITE);\n    }\n\n    // Compute the square-root of the eigenvalues.\n    final int n = getRowDimension();\n    final double[] realEigenvalues = getRealEigenvalues();\n    final double[] imagEigenvalues = getImagEigenvalues();\n    final double[] sqrtRealEigenvalues = new double[n];\n    for (int i = 0; i < n; i++) {\n        sqrtRealEigenvalues[i] = FastMath.sqrt(realEigenvalues[i]);\n    }\n\n    // Compute the square-root of the eigenvectors.\n    final RealMatrix eigenvectors = getEigenvectors();\n    final RealMatrix sqrtEigenvectors = eigenvectors.copy();\n    for (int i = 0; i < n; i++) {\n        final RealVector sqrtEigenvector = sqrtEigenvectors.getColumnVector(i);\n        sqrtEigenvector.mapMultiplyToSelf(1.0 / sqrtRealEigenvalues[i]);\n    }\n\n    // Compute the square-root of the matrix.\n    return sqrtEigenvectors.multiply(new DiagonalMatrix(sqrtRealEigenvalues)).multiply(sqrtEigenvectors.transpose());\n}",
      "public RealMatrix getSquareRoot()  {\n\n    // check if the matrix is symmetric\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SYMMETRIC);\n    }\n\n    // check if the matrix is positive definite\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_POSITIVE_DEFINITE);\n    }\n\n    // compute the square-root of the matrix\n    RealMatrix sqrt = new Array2DRowRealMatrix(getRowDimension(), getColumnDimension());\n    for (int i = 0; i < getRowDimension(); i++) {\n        for (int j = 0; j < getColumnDimension(); j++) {\n            sqrt.setEntry(i, j, FastMath.sqrt(getEntry(i, j)));\n        }\n    }\n    return sqrt;\n}",
      "public RealMatrix getSquareRoot()  {\n\n        // check if the matrix is symmetric and positive definite\n        if (!isSymmetric() || !isPositiveDefinite()) {\n            throw new MathUnsupportedOperationException(\n                    LocalizedFormats.NOT_SYMMETRIC_POSITIVE_DEFINITE);\n        }\n\n        // compute the square-root of the eigenvalues\n        double[] sqrtEigenvalues = new double[realEigenvalues.length];\n        for (int i = 0; i < realEigenvalues.length; i++) {\n            sqrtEigenvalues[i] = FastMath.sqrt(realEigenvalues[i]);\n        }\n\n        // compute the square-root of the eigenvectors\n        RealMatrix[] eigenvectors = new RealMatrix[realEigenvalues.length];\n        for (int i = 0; i < realEigenvalues.length; i++) {\n            eigenvectors[i] = getEigenvector(i).mapMultiply(1.0 / sqrtEigenvalues[i]);\n        }\n\n        // compute the square-root of the matrix\n        RealMatrix squareRoot = new Array2DRowRealMatrix(getRowDimension(), getColumnDimension());\n        for (int i = 0; i < realEigenvalues.length; i++) {\n            squareRoot = squareRoot.add(eigenvectors[i].multiply(eigenvectors[i].transpose()).scalarMultiply(sqrtEigenvalues[i]));\n        }\n\n        return squareRoot;\n    }",
      "public RealMatrix getSquareRoot()  {\n    // Check if the matrix is symmetric and positive definite.\n    if (!isSymmetric() || !isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SYMMETRIC_POSITIVE_DEFINITE);\n    }\n\n    // Initialize the square-root matrix.\n    RealMatrix squareRoot = new Array2DRowRealMatrix(getRowDimension(), getColumnDimension());\n\n    // Compute the square-root of each eigenvalue.\n    for (int i = 0; i < realEigenvalues.length; i++) {\n        squareRoot.setEntry(i, i, Math.sqrt(realEigenvalues[i]));\n    }\n\n    // Compute the square-root of each eigenvector.\n    for (int i = 0; i < eigenvectors.length; i++) {\n        squareRoot.setColumnVector(i, eigenvectors[i].mapMultiply(Math.sqrt(realEigenvalues[i])));\n    }\n\n    return squareRoot;\n}",
      "public RealMatrix getSquareRoot()  {\n\n    // Check if the matrix is symmetric and positive definite\n    if (!isSymmetricAndPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(\n                LocalizedFormats.NOT_SYMMETRIC_POSITIVE_DEFINITE_MATRIX);\n    }\n\n    // Compute the square-root of the eigenvalues\n    final double[] sqrtEigenvalues = new double[realEigenvalues.length];\n    for (int i = 0; i < realEigenvalues.length; i++) {\n        sqrtEigenvalues[i] = FastMath.sqrt(realEigenvalues[i]);\n    }\n\n    // Compute the square-root of the eigenvectors\n    final RealMatrix sqrtEigenvectors = new Array2DRowRealMatrix(eigenvectors.length, eigenvectors[0].getDimension());\n    for (int i = 0; i < eigenvectors.length; i++) {\n        sqrtEigenvectors.setColumn(i, eigenvectors[i].mapMultiply(sqrtEigenvalues[i]));\n    }\n\n    // Return the square-root of the matrix\n    return sqrtEigenvectors.multiply(sqrtEigenvectors.transpose());\n}",
      "public RealMatrix getSquareRoot()  {\n    // Compute the eigenvalues and eigenvectors of the matrix.\n    EigenDecomposition decomposition = new EigenDecomposition(this);\n    double[] realEigenvalues = decomposition.getRealEigenvalues();\n    RealVector[] eigenvectors = decomposition.getEigenvectors();\n\n    // Check that the matrix is symmetric and positive definite.\n    for (int i = 0; i < realEigenvalues.length; ++i) {\n        if (realEigenvalues[i] <= 0) {\n            throw new MathUnsupportedOperationException(\n                    LocalizedFormats.NOT_SPD_MATRIX);\n        }\n    }\n\n    // Compute the square-root of the eigenvalues.\n    double[] sqrtEigenvalues = new double[realEigenvalues.length];\n    for (int i = 0; i < realEigenvalues.length; ++i) {\n        sqrtEigenvalues[i] = Math.sqrt(realEigenvalues[i]);\n    }\n\n    // Compute the square-root of the matrix.\n    RealMatrix squareRoot = MatrixUtils.createRealIdentityMatrix(realEigenvalues.length);\n    for (int i = 0; i < realEigenvalues.length; ++i) {\n        squareRoot = squareRoot.multiply(eigenvectors[i].mapMultiply(sqrtEigenvalues[i]));\n    }\n\n    return squareRoot;\n}",
      "public RealMatrix getSquareRoot()  {\n    // Check if the matrix is symmetric and positive definite.\n    if (!isSymmetric() || !isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(\n            LocalizedFormats.NOT_SYMMETRIC_POSITIVE_DEFINITE);\n    }\n\n    // Compute the eigenvalues and eigenvectors of the matrix.\n    final double[] realEigenvalues = getRealEigenvalues();\n    final double[] imagEigenvalues = getImagEigenvalues();\n    final RealVector[] eigenvectors = getEigenvectors();\n\n    // Compute the square-root of the eigenvalues.\n    final double[] sqrtRealEigenvalues = new double[realEigenvalues.length];\n    for (int i = 0; i < realEigenvalues.length; ++i) {\n        sqrtRealEigenvalues[i] = Math.sqrt(realEigenvalues[i]);\n    }\n\n    // Compute the square-root of the matrix.\n    final RealMatrix sqrtMatrix =\n        new Array2DRowRealMatrix(getRowDimension(), getColumnDimension());\n    for (int i = 0; i < realEigenvalues.length; ++i) {\n        // Compute the square-root of the eigenvalue.\n        final double sqrtRealEigenvalue = sqrtRealEigenvalues[i];\n\n        // Compute the eigenvector.\n        final RealVector eigenvector = eigenvectors[i];\n\n        // Compute the square-root of the eigenvector.\n        final RealVector sqrtEigenvector =\n            new ArrayRealVector(getColumnDimension());\n        for (int j = 0; j < getColumnDimension(); ++j) {\n            sqrtEigenvector.setEntry(j, Math.sqrt(eigenvector.getEntry(j)));\n        }\n\n        // Compute the square-root of the matrix.\n        sqrtMatrix.setColumnVector(i, sqrtEigenvector);\n    }\n\n    return sqrtMatrix;\n}"
    ],
    [
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.VALUE_STRING) {\n            return deserializeFromString(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return deserializeFromNumber(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return deserializeFromDouble(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            return deserializeFromEmbedded(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_TRUE) {\n            return deserializeFromBoolean(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_FALSE) {\n            return deserializeFromBoolean(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NULL) {\n            return deserializeFromNull(p, ctxt);\n        }\n        if (t == JsonToken.START_ARRAY) {\n            return deserializeFromArray(p, ctxt);\n        }\n        if (t == JsonToken.START_OBJECT) {\n            return deserializeFromObject(p, ctxt);\n        }\n        return ctxt.handleUnexpectedToken(handledType(), p);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t) {\n        case START_OBJECT:\n            return deserializeFromObject(p, ctxt);\n        case END_ARRAY:\n            return deserializeFromArray(p, ctxt);\n        case VALUE_STRING:\n            return deserializeFromString(p, ctxt);\n        case VALUE_NUMBER_INT:\n            return deserializeFromNumber(p, ctxt);\n        case VALUE_NUMBER_FLOAT:\n            return deserializeFromDouble(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT:\n            return deserializeFromEmbedded(p, ctxt);\n        case VALUE_TRUE:\n        case VALUE_FALSE:\n            return deserializeFromBoolean(p, ctxt);\n        case VALUE_NULL:\n            return deserializeFromNull(p, ctxt);\n        default:\n        }\n        return ctxt.handleUnexpectedToken(handledType(), p);\n    }\n\n    @Deprecated // since 2.8; remove unless getting used\n    protected Object _missingToken(JsonParser p, DeserializationContext ctxt) throws IOException {\n        throw ctxt.endOfInputException(handledType());\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n         switch (t) {\n         case START_OBJECT:\n             return deserializeFromObject(p, ctxt);\n         case START_ARRAY:\n             return deserializeFromArray(p, ctxt);\n         case VALUE_STRING:\n             return deserializeFromString(p, ctxt);\n         case VALUE_NUMBER_INT:\n             return deserializeFromNumber(p, ctxt);\n         case VALUE_NUMBER_FLOAT:\n             return deserializeFromDouble(p, ctxt);\n         case VALUE_EMBEDDED_OBJECT:\n             return deserializeFromEmbedded(p, ctxt);\n         case VALUE_TRUE:\n         case VALUE_FALSE:\n             return deserializeFromBoolean(p, ctxt);\n         case VALUE_NULL:\n             return deserializeFromNull(p, ctxt);\n         default:\n             return ctxt.handleUnexpectedToken(handledType(), p);\n         }\n     }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n         switch (t.id()) {\n         case ID_STRING:\n             return deserializeFromString(p, ctxt);\n         case ID_NUMBER_INT:\n             return deserializeFromNumber(p, ctxt);\n         case ID_NUMBER_FLOAT:\n             return deserializeFromDouble(p, ctxt);\n         case ID_EMBEDDED_OBJECT:\n             return deserializeFromEmbedded(p, ctxt);\n         case ID_TRUE:\n         case ID_FALSE:\n             return deserializeFromBoolean(p, ctxt);\n         case ID_NULL:\n             return deserializeFromNull(p, ctxt);\n         case ID_START_ARRAY:\n             // these only work if there's a (delegating) creator...\n             return deserializeFromArray(p, ctxt);\n         case ID_FIELD_NAME:\n         case ID_END_OBJECT: // added to resolve [JACKSON-319], possible related issues\n             if (_vanillaProcessing) {\n                 return vanillaDeserialize(p, ctxt, t);\n             }\n             if (_objectIdReader != null) {\n                 return deserializeWithObjectId(p, ctxt);\n             }\n             return deserializeFromObject(p, ctxt);\n         default:\n         }\n         return ctxt.handleUnexpectedToken(handledType(), p);\n     }\n\n    @Deprecated // since 2.8; remove unless getting used\n    protected Object _missingToken(JsonParser p, DeserializationContext ctxt) throws IOException {\n        throw ctxt.endOfInputException(handledType());\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return deserializeFromNumber(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_STRING) {\n            return deserializeFromString(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return deserializeFromDouble(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            return deserializeFromEmbedded(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_TRUE) {\n            return deserializeFromBoolean(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_FALSE) {\n            return deserializeFromBoolean(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NULL) {\n            return deserializeFromNull(p, ctxt);\n        }\n        if (t == JsonToken.START_ARRAY) {\n            return deserializeFromArray(p, ctxt);\n        }\n        if (t == JsonToken.START_OBJECT) {\n            return deserializeFromObject(p, ctxt);\n        }\n        throw ctxt.endOfInputException(handledType());\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t) {\n        case START_OBJECT:\n            return deserializeFromObject(p, ctxt);\n        case START_ARRAY:\n            return deserializeFromArray(p, ctxt);\n        case VALUE_STRING:\n            return deserializeFromString(p, ctxt);\n        case VALUE_NUMBER_INT:\n            return deserializeFromNumber(p, ctxt);\n        case VALUE_NUMBER_FLOAT:\n            return deserializeFromDouble(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT:\n            return deserializeFromEmbedded(p, ctxt);\n        case VALUE_TRUE:\n        case VALUE_FALSE:\n            return deserializeFromBoolean(p, ctxt);\n        case VALUE_NULL:\n            return deserializeFromNull(p, ctxt);\n        default:\n        }\n        return ctxt.handleUnexpectedToken(handledType(), p);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t) {\n        case START_OBJECT:\n            return deserializeFromObject(p, ctxt);\n        case START_ARRAY:\n            return deserializeFromArray(p, ctxt);\n        case VALUE_STRING:\n            return deserializeFromString(p, ctxt);\n        case VALUE_NUMBER_INT:\n            return deserializeFromNumber(p, ctxt);\n        case VALUE_NUMBER_FLOAT:\n            return deserializeFromDouble(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT:\n            return deserializeFromEmbedded(p, ctxt);\n        case VALUE_TRUE:\n        case VALUE_FALSE:\n            return deserializeFromBoolean(p, ctxt);\n        case VALUE_NULL:\n            return deserializeFromNull(p, ctxt);\n        default:\n        }\n        return ctxt.handleUnexpectedToken(handledType(), p);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t) {\n        case START_OBJECT:\n            return deserializeFromObject(p, ctxt);\n        case START_ARRAY:\n            return deserializeFromArray(p, ctxt);\n        case VALUE_STRING:\n            return deserializeFromString(p, ctxt);\n        case VALUE_NUMBER_INT:\n            return deserializeFromNumber(p, ctxt);\n        case VALUE_NUMBER_FLOAT:\n            return deserializeFromDouble(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT:\n            return deserializeFromEmbedded(p, ctxt);\n        case VALUE_TRUE:\n        case VALUE_FALSE:\n            return deserializeFromBoolean(p, ctxt);\n        case VALUE_NULL:\n            return deserializeFromNull(p, ctxt);\n        default:\n        }\n        return ctxt.handleUnexpectedToken(handledType(), p);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        // 04-May-2019, tatu: [databind#2303] Need to be able to handle\n        //    \"native\" values a bit better, so that we can support\n        //    things like `JsonNode`s and `JsonParser`s\n        if (t.isScalarValue()) {\n            switch (t.id()) {\n            case ID_STRING:\n                return deserializeFromString(p, ctxt);\n            case ID_NUMBER_INT:\n                return deserializeFromNumber(p, ctxt);\n            case ID_NUMBER_FLOAT:\n                return deserializeFromDouble(p, ctxt);\n            case ID_EMBEDDED_OBJECT:\n                return deserializeFromEmbedded(p, ctxt);\n            case ID_TRUE:\n            case ID_FALSE:\n                return deserializeFromBoolean(p, ctxt);\n            case ID_NULL:\n                return deserializeFromNull(p, ctxt);\n            default:\n            }\n        }\n        return ctxt.handleUnexpectedToken(handledType(), p);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t) {\n        case START_OBJECT:\n            return deserializeFromObject(p, ctxt);\n        case START_ARRAY:\n            return deserializeFromArray(p, ctxt);\n        case VALUE_STRING:\n            return deserializeFromString(p, ctxt);\n        case VALUE_NUMBER_INT:\n            return deserializeFromNumber(p, ctxt);\n        case VALUE_NUMBER_FLOAT:\n            return deserializeFromDouble(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT:\n            return deserializeFromEmbedded(p, ctxt);\n        case VALUE_TRUE:\n        case VALUE_FALSE:\n            return deserializeFromBoolean(p, ctxt);\n        case VALUE_NULL:\n            return deserializeFromNull(p, ctxt);\n        default:\n        }\n        return ctxt.handleUnexpectedToken(handledType(), p);\n    }"
    ],
    [
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        double sum = 0;\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        return SUM_DIFFERENCE.evaluate(sample1, sample2);\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n\n        double sum = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        double sum = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        double sum = 0;\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        double sum = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        double sum = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n\n        double sum = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }"
    ],
    [
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         // First, let's see if we have a free buffer we can use:\n         if (_freeBuffer != null) {\n             Object[] result = _freeBuffer;\n             _freeBuffer = null;\n             return result;\n         }\n         // Otherwise let's see if we have room in current chunk:\n         int len = fullChunk.length;\n         if (len < MAX_CHUNK) {\n             // If so, let's just use it:\n             return fullChunk;\n         }\n         // Otherwise we need to create a new chunk\n         return new Object[Math.min(len, MAX_CHUNK)];\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         // First: let's append the chunk to the end of linked list\n         LinkedNode<Object[]> newNode = new LinkedNode<Object[]>(fullChunk);\n         if (_head == null) {\n             _head = newNode;\n         } else {\n             _tail.next = newNode;\n         }\n         _tail = newNode;\n         _size += fullChunk.length;\n\n         // And then see if we need to expand the chunk\n         if (fullChunk.length < MAX_CHUNK) {\n             return fullChunk;\n         }\n         // If so, let's allocate a new array, and return it\n         return new Object[Math.min(fullChunk.length << 1, MAX_CHUNK)];\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         // First, let's see if we can just reuse the array:\n         if (_freeBuffer == null) {\n             _freeBuffer = fullChunk;\n         } else {\n             // Nope, need to add it to the list:\n             _appendChunk(fullChunk);\n         }\n         // and then return new array for caller to fill:\n         return _getNextChunk();\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         // First: let's try to append to existing chunk\n         if (_tail != null) {\n             int count = fullChunk.length;\n             if (_tail.value.length < _tail.count + count) {\n                 // Let's expand existing chunk\n                 int newSize = _tail.count + count;\n                 if (newSize < SMALL_CHUNK) {\n                     newSize = SMALL_CHUNK;\n                 } else if (newSize > MAX_CHUNK) {\n                     newSize = MAX_CHUNK;\n                 }\n                 Object[] newChunk = new Object[newSize];\n                 System.arraycopy(_tail.value, 0, newChunk, 0, _tail.count);\n                 _tail.value = newChunk;\n             }\n             System.arraycopy(fullChunk, 0, _tail.value, _tail.count, count);\n             _tail.count += count;\n             _size += count;\n             return _tail.value;\n         }\n         // If no tail, let's just use the array as is\n         _tail = new LinkedNode<Object[]>(fullChunk, fullChunk.length);\n         _head = _tail;\n         _size += fullChunk.length;\n         return _tail.value;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         // First, let's append chunk to linked list:\n         LinkedNode<Object[]> node = new LinkedNode<>(fullChunk);\n         if (_tail == null) {\n             _head = node;\n         } else {\n             _tail.next = node;\n         }\n         _tail = node;\n         _size += fullChunk.length;\n         // And then, let's see if we need to expand buffer\n         if (_freeBuffer == null) {\n             _freeBuffer = new Object[12];\n         }\n         return _freeBuffer;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         // First: let's try to reuse existing buffer if it's big enough\n         if (_freeBuffer != null && _freeBuffer.length >= fullChunk.length) {\n             System.arraycopy(fullChunk, 0, _freeBuffer, 0, fullChunk.length);\n             return _freeBuffer;\n         }\n         // Otherwise need to allocate a new one\n         int len = fullChunk.length;\n         if (len < SMALL_CHUNK) {\n             len = SMALL_CHUNK;\n         } else if (len > MAX_CHUNK) {\n             len = MAX_CHUNK;\n         } else {\n             len = len + (len >> 1);\n         }\n         Object[] newBuffer = new Object[len];\n         System.arraycopy(fullChunk, 0, newBuffer, 0, fullChunk.length);\n         return newBuffer;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         // First, let's see if we have a free buffer we can use\n         if (_freeBuffer != null) {\n             Object[] oldBuffer = _freeBuffer;\n             _freeBuffer = null;\n             if (oldBuffer.length < fullChunk.length) {\n                 oldBuffer = null;\n             } else {\n                 System.arraycopy(fullChunk, 0, oldBuffer, 0, fullChunk.length);\n             }\n             fullChunk = oldBuffer;\n         }\n         // And if we still don't have a buffer, let's create one\n         if (fullChunk == null) {\n             fullChunk = new Object[Math.min(SMALL_CHUNK, _size + SMALL_CHUNK)];\n         }\n         // Ok, let's add it to the linked list\n         if (_tail == null) {\n             _head = _tail = new LinkedNode<>(fullChunk);\n         } else {\n             _tail = _tail.next = new LinkedNode<>(fullChunk);\n         }\n         _size += fullChunk.length;\n         return fullChunk;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         // First: let's see if we have a free buffer to use\n         if (_freeBuffer == null) {\n             // Nope, need to allocate one\n             int len = fullChunk.length;\n             if (len < SMALL_CHUNK) {\n                 len = SMALL_CHUNK;\n             } else if (len > MAX_CHUNK) {\n                 len = MAX_CHUNK;\n             } else {\n                 // Ok, let's round up to nearest power of 2\n                 int exp = 1;\n                 while (len > (1 << exp)) {\n                     ++exp;\n                 }\n                 len = (1 << exp);\n             }\n             _freeBuffer = new Object[len];\n         }\n         // Ok, we have a buffer; let's append it to the list\n         LinkedNode<Object[]> newNode = new LinkedNode<Object[]>(fullChunk);\n         if (_head == null) {\n             _head = newNode;\n             _tail = newNode;\n         } else {\n             _tail.setNext(newNode);\n             _tail = newNode;\n         }\n         _size += fullChunk.length;\n         return _freeBuffer;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         // First, let's see if we have a free buffer we can use\n         if (_freeBuffer == null) {\n             _freeBuffer = fullChunk;\n             return new Object[Math.min(SMALL_CHUNK, MAX_CHUNK)];\n         }\n         // If not, let's see if we can append to existing last chunk\n         if (_tail != null) {\n             Object[] last = _tail.value;\n             int len = last.length;\n             int newLen = len + fullChunk.length;\n             if (newLen <= MAX_CHUNK) {\n                 Object[] newLast = new Object[newLen];\n                 System.arraycopy(last, 0, newLast, 0, len);\n                 System.arraycopy(fullChunk, 0, newLast, len, fullChunk.length);\n                 _tail.value = newLast;\n                 _size += fullChunk.length;\n                 return new Object[Math.min(newLen, MAX_CHUNK)];\n             }\n         }\n         // If not, let's add as a new chunk\n         _size += fullChunk.length;\n         _tail = new LinkedNode<Object[]>(fullChunk, _tail);\n         if (_head == null) {\n             _head = _tail;\n         }\n         return new Object[Math.min(SMALL_CHUNK, MAX_CHUNK)];\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         // First: let's add chunk to the end of the linked list\n         if (_tail == null) {\n             _head = _tail = new LinkedNode<Object[]>(fullChunk);\n         } else {\n             _tail.next = new LinkedNode<Object[]>(fullChunk);\n             _tail = _tail.next;\n         }\n         // and then update size\n         _size += fullChunk.length;\n         // and finally, let's see if we need to expand the buffer\n         if (_size > MAX_CHUNK) {\n             _compact();\n         }\n         // and finally, let's return a new buffer to fill\n         return resetAndStart();\n     }"
    ],
    [
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    //-----------------------------------------------------------------------\n    // This code is copied from the JDK source code, with the following changes:\n    // 1. The code is made to work with the provided context.\n    // 2. The code is made to be functional.\n    // 3. The code is made to be readable.\n    // 4. The code is made to be efficient.\n    //-----------------------------------------------------------------------\n    DateTimeFormatter formatter = null;\n    int length = pattern.length();\n    int[] indexRef = new int[1];\n    indexRef[0] = 0;\n\n    while (indexRef[0] < length) {\n        String token = parseToken(pattern, indexRef);\n        int tokenLen = token.length();\n        if (tokenLen == 0) {\n            break;\n        }\n\n        if (formatter == null) {\n            formatter = new DateTimeFormatterBuilder();\n        }\n\n        if (isNumericToken(token)) {\n            formatter.appendValue(token.charAt(0));\n        } else if (token.equals(\"'\")) {\n            // treat single quote as text\n            formatter.appendLiteral('\\'');\n        } else {\n            formatter.appendPattern(token);\n        }\n    }\n\n    return formatter.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    // This is a custom pattern.\n    StringBuilder buf = new StringBuilder();\n\n    int i = 0;\n    int length = pattern.length();\n\n    while (i < length) {\n        char c = pattern.charAt(i);\n        if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n            // Scan a run of the same character, which indicates a time\n            // pattern.\n            buf.append(c);\n\n            while (i + 1 < length) {\n                char peek = pattern.charAt(i + 1);\n                if (peek == c) {\n                    buf.append(c);\n                    i++;\n                } else {\n                    break;\n                }\n            }\n        } else {\n            // This will identify token as text.\n            buf.append('\\'');\n\n            boolean inLiteral = false;\n\n            for (; i < length; i++) {\n                c = pattern.charAt(i);\n                \n                if (c == '\\'') {\n                    if (i + 1 < length && pattern.charAt(i + 1) == '\\'') {\n                        // '' is treated as escaped '\n                        i++;\n                        buf.append(c);\n                    } else {\n                        inLiteral = !inLiteral;\n                    }\n                } else if (!inLiteral &&\n                           (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {\n                    i--;\n                    break;\n                } else {\n                    buf.append(c);\n                }\n            }\n        }\n    }\n\n    return DateTimeFormat.forPattern(buf.toString());\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    //-----------------------------------------------------------------------\n    // handle standard patterns\n    //-----------------------------------------------------------------------\n    if (pattern.equals(\"yyyy-MM-dd\")) \n    {\n        return DateTimeFormat.forPattern(\"yyyy-MM-dd\");\n    }\n    else if (pattern.equals(\"yyyy-MM-dd HH:mm:ss\")) \n    {\n        return DateTimeFormat.forPattern(\"yyyy-MM-dd HH:mm:ss\");\n    }\n    else if (pattern.equals(\"yyyy-MM-dd HH:mm:ss.SSS\")) \n    {\n        return DateTimeFormat.forPattern(\"yyyy-MM-dd HH:mm:ss.SSS\");\n    }\n    else if (pattern.equals(\"yyyy-MM-dd HH:mm:ss.SSSSSS\")) \n    {\n        return DateTimeFormat.forPattern(\"yyyy-MM-dd HH:mm:ss.SSSSSS\");\n    }\n    else if (pattern.equals(\"yyyy-MM-dd HH:mm:ss.SSSSSSSSS\")) \n    {\n        return DateTimeFormat.forPattern(\"yyyy-MM-dd HH:mm:ss.SSSSSSSSS\");\n    }\n    else if (pattern.equals(\"yyyy-MM-dd HH:mm:ss.SSSSSSSSSSS\")) \n    {\n        return DateTimeFormat.forPattern(\"yyyy-MM-dd HH:mm:ss.SSSSSSSSSSS\");\n    }\n    else if (pattern.equals(\"yyyy-MM-dd HH:mm:ss.SSSSSSSSSSSSS\")) \n    {\n        return DateTimeFormat.forPattern(\"yyyy-MM-dd HH:mm:ss.SSSSSSSSSSSSS\");\n    }\n    else if (pattern.equals(\"yyyy-MM-dd HH:mm:ss.SSSSSSSSSSSSSSS\")) \n    {\n        return DateTimeFormat.forPattern(\"yyyy-MM-dd HH:mm:ss.SSSSSSSSSSSSSSS\");\n    }\n    else if (pattern.equals(\"yyyy-MM-dd HH:mm:ss.SSSSSSSSSSSSSSSSS\")) \n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    int[] indexRef = new int[1];\n    indexRef[0] = 0;\n\n    while (indexRef[0] < pattern.length()) {\n        String token = parseToken(pattern, indexRef);\n        indexRef[0]++;\n\n        if (isNumericToken(token)) {\n            builder.appendPattern(token);\n        } else {\n            builder.appendLiteral(token);\n        }\n    }\n\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    int[] indexRef = new int[1];\n    indexRef[0] = 0;\n    StringBuilder buf = new StringBuilder();\n\n    while (indexRef[0] < pattern.length()) {\n        String token = parseToken(pattern, indexRef);\n        if (token.length() == 0) {\n            break;\n        }\n\n        if (isNumericToken(token)) {\n            buf.append(token);\n        } else {\n            buf.append(token);\n        }\n    }\n\n    return DateTimeFormatter.ofPattern(buf.toString());\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n\n    int[] indexRef = new int[] { 0 };\n    while (indexRef[0] < pattern.length()) {\n        String token = parseToken(pattern, indexRef);\n        int tokenLen = token.length();\n        if (tokenLen == 0) {\n            break;\n        }\n\n        char c = token.charAt(0);\n        if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n            // Letters 'S' to 'Z' are reserved for future use\n            // (user field, week date, year, and so on).\n            throw new IllegalArgumentException(\"Invalid pattern component: \" + token);\n        }\n\n        if (isNumericToken(token)) {\n            // Numeric fields\n            if (tokenLen >= 4) {\n                // Long form of numeric field\n                builder.appendValue(DateTimeFieldType.valueOf(token), tokenLen);\n            } else {\n                // Short form of numeric field\n                builder.appendValue(DateTimeFieldType.valueOf(token), tokenLen, tokenLen);\n            }\n        } else if (token.equals(\"'\")) {\n            // Literal text\n            if (indexRef[0] >= pattern.length()) {\n                break;\n            }\n\n            StringBuilder buf = new StringBuilder();\n            while (indexRef[0] < pattern.length()) {\n                char peek = pattern.charAt(indexRef[0]);\n                if (peek == '\\'') {\n                    indexRef[0]++;\n                    if (indexRef[0] >= pattern.length() || pattern.charAt(indexRef[0]) != '\\'') {\n                        break;\n                    }\n                    buf.append('\\'');\n                } else {\n                    buf.append(peek);\n                    indexRef[0]++;\n                    break;\n                }\n            }\n            builder.appendLiteral(buf.toString());\n        } else {\n            // Unquoted text is an error\n            throw new IllegalArgumentException(\"Invalid pattern component: \" + token);\n        }\n    }\n\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatter formatter = new DateTimeFormatterBuilder()\n            .appendPattern(pattern)\n            .toFormatter();\n    return formatter;\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatter formatter = new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter();\n    return formatter;\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    //-----------------------------------------------------------------------\n    // Format builders\n    //-----------------------------------------------------------------------\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    DateTimeFormatterBuilder altBuilder = null;\n    int[] indexRef = new int[1];\n    String token = null;\n    boolean active = false;\n    boolean inLiteral = false;\n\n    //-----------------------------------------------------------------------\n    // Parse the pattern\n    //-----------------------------------------------------------------------\n    int i = 0;\n    int length = pattern.length();\n\n    while (i < length) {\n        char c = pattern.charAt(i);\n        if (inLiteral) {\n            if (c == '\\'') {\n                // handle escaped single quote\n                if (i + 1 < length && pattern.charAt(i + 1) == '\\'') {\n                    builder.appendLiteral('\\'');\n                    i++;\n                } else {\n                    inLiteral = false;\n                }\n            } else {\n                builder.appendLiteral(c);\n            }\n            i++;\n            continue;\n        }\n\n        if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n            // Scan a run of the same character, which indicates a time\n            // pattern.\n            token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            if (token.length() > 1) {\n                if (token.equals(\"yyyy\") || token.equals(\"yy\") || token.equals(\"yyy\") || token.equals(\"yyyy\")) {\n                    builder.appendYear(token.length(), token.length());\n                } else if (token.equals(\"MMMMM\")) {\n                    builder.appendMonthOfYearText();\n                } else if (token.equals(\"MMM\")) {\n                    builder.appendMonthOfYearShortText();\n                } else if (token.equals(\"MM\")) {\n                    builder.appendMonthOfYear(2);\n                } else if (token.equals(\"M\")) {\n                    builder.appendMonthOfYear(1);\n                } else if (token.equals(\"dddd\")) {\n}\n}\n}\n}\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    //-----------------------------------------------------------------------\n    // Parse the pattern.\n    //-----------------------------------------------------------------------\n    int[] indexRef = new int[1];\n    indexRef[0] = 0;\n    String token = parseToken(pattern, indexRef);\n    indexRef[0]++;\n\n    if (token.length() == 0) {\n        throw new IllegalArgumentException(\"Invalid format: \" + pattern);\n    }\n\n    //-----------------------------------------------------------------------\n    // Create the formatter.\n    //-----------------------------------------------------------------------\n    DateTimeFormatter formatter = null;\n    if (isNumericToken(token)) {\n        formatter = new DateTimeFormatterBuilder().appendLiteral(token).toFormatter();\n    } else {\n        formatter = DateTimeFormat.forPattern(token);\n    }\n\n    //-----------------------------------------------------------------------\n    // Recurse.\n    //-----------------------------------------------------------------------\n    while (indexRef[0] < pattern.length()) {\n        token = parseToken(pattern, indexRef);\n        if (token.length() == 0) {\n            throw new IllegalArgumentException(\"Invalid format: \" + pattern);\n        }\n\n        if (isNumericToken(token)) {\n            formatter = formatter.withZone(DateTimeZone.UTC);\n            formatter = formatter.withChronology(ISOChronology.getInstanceUTC());\n            formatter = formatter.withLocale(Locale.ROOT);\n            formatter = formatter.withPivotYear(1970);\n            formatter = formatter.withDefaultYear(2000);\n            formatter = formatter.withDefaultMonth(1);\n            formatter = formatter.withDefaultDayOfMonth(1);\n            formatter = formatter.withDefaultHourOfDay(0);\n            formatter = formatter.withDefaultMinuteOfHour(0);\n            formatter = formatter.withDefaultSecondOfMinute(0);\n            formatter = formatter.withDefaultMillisOfSecond(0);\n            formatter = formatter.withDefaultZone(DateTimeZone.UTC);\n            formatter = formatter.withDefaultZoneOffset(null);\n}\n}\n}"
    ],
    [
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    Node typeExpr = null;\n    switch (token) \n    {\n        case JsDocToken.STAR:\n            typeExpr = newNode(Token.STAR);\n            break;\n        case JsDocToken.NULL:\n            typeExpr = newNode(Token.NULL);\n            break;\n        case JsDocToken.UNDEFINED:\n            typeExpr = newNode(Token.UNDEFINED);\n            break;\n        case JsDocToken.IDENTIFIER:\n            typeExpr = parseTypeName(token);\n            break;\n        case JsDocToken.LP:\n            typeExpr = parseFunctionType(token);\n            break;\n        case JsDocToken.LB:\n            typeExpr = parseUnionType(token);\n            break;\n        case JsDocToken.LC:\n            typeExpr = parseRecordType(token);\n            break;\n        case JsDocToken.LS:\n            typeExpr = parseArrayType(token);\n            break;\n        default:\n            break;\n    }\n    return typeExpr;\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.UNDEFINED) {\n    return newNode(Token.UNDEFINED);\n  } else if (token == JsDocToken.IDENTIFIER) {\n    return newNode(Token.NAME, token.text);\n  } else if (token == JsDocToken.LP) {\n    return parseFunctionType(token);\n  } else if (token == JsDocToken.LC) {\n    return parseRecordType(token);\n  } else if (token == JsDocToken.LS) {\n    return parseArrayType(token);\n  } else {\n    return null;\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.UNDEFINED) {\n    return newNode(Token.UNDEFINED);\n  } else if (token == JsDocToken.IDENTIFIER) {\n    return parseTypeName(token);\n  } else if (token == JsDocToken.FUNCTION) {\n    return parseFunctionType(token);\n  } else if (token == JsDocToken.LB) {\n    return parseUnionType(token);\n  } else if (token == JsDocToken.LC) {\n    return parseRecordType(token);\n  } else if (token == JsDocToken.LS) {\n    return parseArrayType(token);\n  }\n  return null;\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL) {\n      return newNode(Token.NULL);\n    } else if (token == JsDocToken.UNDEFINED) {\n      return newNode(Token.UNDEFINED);\n    } else if (token == JsDocToken.IDENTIFIER) {\n      return parseTypeName(token);\n    } else if (token == JsDocToken.LP) {\n      return parseFunctionType(token);\n    } else if (token == JsDocToken.LC) {\n      return parseRecordType(token);\n    } else if (token == JsDocToken.LB) {\n      return parseArrayType(token);\n    } else {\n      return null;\n    }\n  }",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL) {\n      return newNode(Token.NULL);\n    } else if (token == JsDocToken.UNDEFINED) {\n      return newNode(Token.UNDEFINED);\n    } else if (token == JsDocToken.IDENTIFIER) {\n      return parseTypeName(token);\n    } else if (token == JsDocToken.FUNCTION) {\n      return parseFunctionType(token);\n    } else if (token == JsDocToken.LB) {\n      return parseUnionType(token);\n    } else if (token == JsDocToken.LC) {\n      return parseRecordType(token);\n    } else if (token == JsDocToken.LS) {\n      return parseArrayType(token);\n    } else {\n      return null;\n    }\n  }",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.UNDEFINED) {\n    return newNode(Token.UNDEFINED);\n  } else if (token == JsDocToken.IDENTIFIER) {\n    return newNode(Token.NAME, token.value);\n  } else if (token == JsDocToken.LP) {\n    return parseFunctionType(token);\n  } else if (token == JsDocToken.LB) {\n    return parseUnionType(token);\n  } else if (token == JsDocToken.LC) {\n    return parseRecordType(token);\n  } else if (token == JsDocToken.LS) {\n    return parseArrayType(token);\n  } else {\n    return null;\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  switch (token) \n  {\n    case JsDocToken.STAR:\n      return newNode(Token.STAR);\n    case JsDocToken.NULL:\n      return newNode(Token.NULL);\n    case JsDocToken.UNDEFINED:\n      return newNode(Token.UNDEFINED);\n    case JsDocToken.IDENTIFIER:\n      return parseTypeName(token);\n    case JsDocToken.LP:\n      return parseFunctionType(token);\n    case JsDocToken.LB:\n      return parseUnionType(token);\n    case JsDocToken.LC:\n      return parseRecordType(token);\n    case JsDocToken.LS:\n      return parseArrayType(token);\n    default:\n      return null;\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n        return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL) {\n        return newNode(Token.NULL);\n    } else if (token == JsDocToken.UNDEFINED) {\n        return newNode(Token.UNDEFINED);\n    } else if (token == JsDocToken.IDENTIFIER) {\n        return parseTypeName(token);\n    } else if (token == JsDocToken.FUNCTION) {\n        return parseFunctionType(token);\n    } else if (token == JsDocToken.LB) {\n        return parseUnionType(token);\n    } else if (token == JsDocToken.LC) {\n        return parseRecordType(token);\n    } else if (token == JsDocToken.LS) {\n        return parseArrayType(token);\n    } else {\n        return null;\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL) {\n      return newNode(Token.NULL);\n    } else if (token == JsDocToken.UNDEFINED) {\n      return newNode(Token.UNDEFINED);\n    } else if (token == JsDocToken.IDENTIFIER) {\n      return newNode(Token.NAME, token.value);\n    } else if (token == JsDocToken.FUNCTION) {\n      return parseFunctionType(token);\n    } else if (token == JsDocToken.LB) {\n      return parseUnionType(token);\n    } else if (token == JsDocToken.LC) {\n      return parseRecordType(token);\n    } else if (token == JsDocToken.LS) {\n      return parseArrayType(token);\n    } else {\n      return null;\n    }\n  }",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL) {\n      return newNode(Token.NULL);\n    } else if (token == JsDocToken.UNDEFINED) {\n      return newNode(Token.UNDEFINED);\n    } else if (token == JsDocToken.IDENTIFIER) {\n      return parseTypeName(token);\n    } else if (token == JsDocToken.LP) {\n      return parseFunctionType(token);\n    } else if (token == JsDocToken.LB) {\n      return parseUnionType(token);\n    } else if (token == JsDocToken.LC) {\n      return parseRecordType(token);\n    } else if (token == JsDocToken.LS) {\n      return parseArrayType(token);\n    } else {\n      return null;\n    }\n  }"
    ],
    [
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException();\n    }\n    beforeName();\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    beforeName();\n    string(name);\n    deferredName = null;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    beforeName();\n    string(name);\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException();\n    }\n    this.deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    beforeName();\n    string(name);\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name == null\");\n    }\n    beforeName();\n    string(name);\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    beforeName();\n    string(name);\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name == null\");\n    }\n    beforeName();\n    string(name);\n    deferredName = null;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException();\n    }\n    this.deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    beforeName();\n    string(name);\n    deferredName = name;\n    return this;\n  }"
    ],
    [
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    // check arguments\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    // initialise the minimum value\n    Number minimum = null;\n\n    // loop through each category and find the minimum value\n    for (int categoryIndex = 0; categoryIndex < dataset.getColumnCount(); categoryIndex++) {\n        double categoryMinimum = 0.0;\n        for (int seriesIndex = 0; seriesIndex < dataset.getRowCount(); seriesIndex++) {\n            Number value = dataset.getValue(seriesIndex, categoryIndex);\n            if (value != null) {\n                double doubleValue = value.doubleValue();\n                if (doubleValue < 0.0) {\n                    categoryMinimum += doubleValue;\n                }\n            }\n        }\n        if (minimum == null) {\n            minimum = categoryMinimum;\n        }\n        else {\n            minimum = Math.min(minimum.doubleValue(), categoryMinimum);\n        }\n    }\n\n    return minimum;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    boolean hasValidData = false;\n    double minimum = Double.MAX_VALUE;\n\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double[] positive = new double[dataset.getRowCount()];\n        double[] negative = new double[dataset.getRowCount()];\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    positive[series] = positive[series] + value;\n                }\n                if (value < 0.0) {\n                    negative[series] = negative[series] + value;\n                    // '+', remember value is negative\n                }\n            }\n        }\n        for (int series = 0; series < seriesCount; series++) {\n            minimum = Math.min(minimum, negative[series] + positive[series]);\n        }\n    }\n    if (hasValidData) {\n        return new Double(minimum);\n    }\n    else {\n        return null;\n    }\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double[] positive = new double[dataset.getRowCount()];\n        double[] negative = new double[dataset.getRowCount()];\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    positive[series] = positive[series] + value;\n                }\n                if (value < 0.0) {\n                    negative[series] = negative[series] + value;\n                    // '+', remember value is negative\n                }\n            }\n        }\n        for (int series = 0; series < seriesCount; series++) {\n            minimum = Math.min(minimum, negative[series]);\n            minimum = Math.min(minimum, positive[series]);\n        }\n    }\n    return minimum;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range range = findStackedRangeBounds(dataset, null);\n    if (range == null) {\n        return null;\n    }\n    return range.getLowerBound();\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    // TODO: Implement this method\n    return null;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.MAX_VALUE;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double[] positive = new double[dataset.getRowCount()];\n        double[] negative = new double[dataset.getRowCount()];\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    positive[series] = positive[series] + value;\n                }\n                if (value < 0.0) {\n                    negative[series] = negative[series] + value;\n                }\n            }\n        }\n        for (int series = 0; series < seriesCount; series++) {\n            minimum = Math.min(minimum, negative[series] + positive[series]);\n        }\n    }\n    return minimum;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    boolean hasValidData = false;\n    double minimum = Double.MAX_VALUE;\n\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double[] positive = new double[dataset.getRowCount()];\n        double[] negative = new double[dataset.getRowCount()];\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    positive[series] = positive[series] + value;\n                }\n                if (value < 0.0) {\n                    negative[series] = negative[series] + value;\n                    // '+', remember value is negative\n                }\n            }\n        }\n        for (int series = 0; series < seriesCount; series++) {\n            minimum = Math.min(minimum, negative[series]);\n            minimum = Math.min(minimum, positive[series]);\n        }\n    }\n    if (hasValidData) {\n        return new Double(minimum);\n    }\n    else {\n        return null;\n    }\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double result = Double.POSITIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double[] positive = new double[dataset.getRowCount()];\n        double[] negative = new double[dataset.getRowCount()];\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    positive[series] = positive[series] + value;\n                }\n                if (value < 0.0) {\n                    negative[series] = negative[series] + value;\n                    // '+', remember value is negative\n                }\n            }\n        }\n        for (int series = 0; series < seriesCount; series++) {\n            result = Math.min(result, negative[series]);\n        }\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    boolean hasValidData = false;\n    double minimum = Double.MAX_VALUE;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double[] positive = new double[dataset.getRowCount()];\n        double[] negative = new double[dataset.getRowCount()];\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    positive[series] = positive[series] + value;\n                }\n                if (value < 0.0) {\n                    negative[series] = negative[series] + value;\n                    // '+', remember value is negative\n                }\n            }\n        }\n        for (int series = 0; series < seriesCount; series++) {\n            minimum = Math.min(minimum, negative[series]);\n            minimum = Math.min(minimum, positive[series]);\n        }\n    }\n    if (hasValidData) {\n        return new Double(minimum);\n    }\n    else {\n        return null;\n    }\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.MAX_VALUE;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double[] positive = new double[dataset.getRowCount()];\n        double[] negative = new double[dataset.getRowCount()];\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    positive[series] = positive[series] + value;\n                }\n                if (value < 0.0) {\n                    negative[series] = negative[series] + value;\n                    // '+', remember value is negative\n                }\n            }\n        }\n        for (int series = 0; series < seriesCount; series++) {\n            minimum = Math.min(minimum, negative[series]);\n        }\n    }\n    return new Double(minimum);\n}"
    ],
    [
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}"
    ],
    [
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n\n    char[] chars = str.toCharArray();\n    StringBuilder buf = new StringBuilder(chars.length / 2);\n    boolean whitespace = true;\n    for (char c : chars) {\n        if (Character.isWhitespace(c)) {\n            whitespace = true;\n        } else if (ArrayUtils.contains(delimiters, c)) {\n            whitespace = true;\n        } else if (whitespace) {\n            buf.append(Character.toTitleCase(c));\n            whitespace = false;\n        }\n    }\n    return buf.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n    final int strLen = str.length();\n    final int[] delims = WordUtils.toCharArray(delimiters);\n    final StringBuilder result = new StringBuilder(strLen / 5);\n    int prevDelim = 0;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (WordUtils.isDelimiter(ch, delims)) {\n            if (i - prevDelim > 0) {\n                final char init = str.charAt(prevDelim);\n                result.append(Character.toUpperCase(init));\n            }\n            prevDelim = i + 1;\n        }\n    }\n    if (prevDelim == 0) {\n        result.append(str.charAt(0));\n    } else if (prevDelim < strLen) {\n        final char init = str.charAt(prevDelim);\n        result.append(Character.toUpperCase(init));\n    }\n    return result.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n\n    final int strLen = str.length();\n    final int[] delims = WordUtils.toCharArray(delimiters);\n\n    final StringBuilder sb = new StringBuilder(strLen / 5);\n    char c = 0;\n    boolean whitespace = true;\n    for (int i = 0; i < strLen; i++) {\n        c = str.charAt(i);\n        if (Character.isWhitespace(c)) {\n            whitespace = true;\n        } else if (WordUtils.contains(delims, c)) {\n            whitespace = true;\n        } else if (whitespace) {\n            sb.append(Character.toTitleCase(c));\n            whitespace = false;\n        } else {\n            break;\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n\n    final int strLen = str.length();\n    final int[] delims = WordUtils.toCharArray(delimiters);\n    final StringBuilder result = new StringBuilder(strLen / 5);\n    int prevDelim = 0;\n\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n\n        if (WordUtils.isDelimiter(ch, delims)) {\n            prevDelim = i;\n        } else {\n            if (i - prevDelim > 0) {\n                result.append(str.charAt(i));\n            }\n        }\n    }\n\n    return result.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n    int strLen = str.length();\n    char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        char ch = str.charAt(i);\n\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else {\n            if (lastWasGap) {\n                buf[count++] = ch;\n            }\n            lastWasGap = false;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n    int strLen = str.length();\n    char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        char ch = str.charAt(i);\n\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else {\n            if (lastWasGap) {\n                buf[count++] = ch;\n            }\n            lastWasGap = false;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n\n    char[] buf = new char[str.length() / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < str.length(); i++) {\n        char ch = str.charAt(i);\n\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buf[count++] = ch;\n            lastWasGap = false;\n        } else {\n            // ignore ch\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n    int strLen = str.length();\n    char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        char ch = str.charAt(i);\n\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else {\n            if (lastWasGap) {\n                buf[count++] = ch;\n            }\n            lastWasGap = false;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n\n    char[] chars = str.toCharArray();\n    boolean whitespace = true;\n    boolean match = true;\n    StringBuilder initials = new StringBuilder();\n    for (char c : chars) {\n        if (Character.isWhitespace(c)) {\n            whitespace = true;\n            match = true;\n        } else if (ArrayUtils.contains(delimiters, c)) {\n            whitespace = true;\n            match = true;\n        } else if (whitespace) {\n            initials.append(Character.toTitleCase(c));\n            whitespace = false;\n        } else if (match) {\n            initials.append(c);\n            match = false;\n        }\n    }\n    return initials.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n\n    final int strLen = str.length();\n    final int[] delims = WordUtils.toCharArray(delimiters);\n    final StringBuilder initials = new StringBuilder(strLen / 5);\n    int lastWasGap = 0;\n\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n\n        if (WordUtils.isDelimiter(ch, delims)) {\n            lastWasGap = 1;\n        } else if (lastWasGap == 0) {\n            initials.append(ch);\n            lastWasGap = 0;\n        } else {\n            initials.append(Character.toTitleCase(ch));\n            lastWasGap = 0;\n        }\n    }\n\n    return initials.toString();\n}"
    ],
    [
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0;\n    for (int i = 0; i < data.getRowCount(); i++) {\n        total += data.getDouble(i, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0.0;\n    for (int i = 0; i < data.getRowCount(); i++) {\n        total += data.getValue(i, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0;\n    for (int i = 0; i < data.getRowCount(); i++) \n    {\n        total += data.getDouble(i, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0;\n    for (int i = 0; i < data.getRowCount(); i++) \n    {\n        total += data.getDouble(i, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0;\n    for (int i = 0; i < data.getRowCount(); i++) {\n        total += data.getValue(i, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0;\n    for (int i = 0; i < data.getRowCount(); i++) \n    {\n        total += data.getValue(i, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0.0;\n    for (int i = 0; i < data.getRowCount(); i++) {\n        total += data.getDouble(i, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0;\n    for (int i = 0; i < data.getRowCount(); i++) {\n        total += data.getValue(i, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0;\n    for (int i = 0; i < data.getRowCount(); i++) {\n        total += data.getDouble(i, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0;\n    for (int i = 0; i < data.getRowCount(); i++) {\n        total += data.getDouble(i, column);\n    }\n    return total;\n}"
    ],
    [
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / this.scaleX;\n    double y = (screenPoint.y - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / this.scaleX;\n    double y = (screenPoint.y - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / this.scaleX;\n    double y = (screenPoint.y - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / this.scaleX;\n    double y = (screenPoint.y - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}"
    ],
    [
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final String[] parts = source.split(\"/\");\n        if (parts.length != 2) {\n            throw new MathParseException(source, BigFraction.class,\n                                         LocalizedFormats.FRACTION_FORMAT_ERROR,\n                                         source);\n        }\n        try {\n            return new BigFraction(new BigInteger(parts[0]), new BigInteger(parts[1]));\n        } catch (NumberFormatException nfe) {\n            throw new MathParseException(source, BigFraction.class,\n                                         LocalizedFormats.FRACTION_FORMAT_ERROR,\n                                         source);\n        }\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final String[] parts = source.split(\"/\");\n        if (parts.length != 2) {\n            throw new MathParseException(source, BigFraction.class, null, null);\n        }\n        final BigInteger numerator = getNumeratorFormat().parse(parts[0]).numberValue(BigInteger.class);\n        final BigInteger denominator = getDenominatorFormat().parse(parts[1]).numberValue(BigInteger.class);\n        return new BigFraction(numerator, denominator);\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final String[] parts = source.split(\"/\");\n        if (parts.length != 2) {\n            throw new MathParseException(source, BigFraction.class, null, \"The fraction should be in the form of 'numerator/denominator'\");\n        }\n        try {\n            final BigInteger numerator = new BigInteger(parts[0]);\n            final BigInteger denominator = new BigInteger(parts[1]);\n            return new BigFraction(numerator, denominator);\n        } catch (NumberFormatException e) {\n            throw new MathParseException(source, BigFraction.class, null, \"The fraction should be in the form of 'numerator/denominator'\");\n        }\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final String[] parts = source.split(\"/\");\n        if (parts.length != 2) {\n            throw new MathParseException(source, BigFraction.class, null, \"Invalid format\");\n        }\n        final BigInteger numerator = getNumeratorFormat().parse(parts[0]).numberValue(BigInteger.class);\n        final BigInteger denominator = getDenominatorFormat().parse(parts[1]).numberValue(BigInteger.class);\n        return new BigFraction(numerator, denominator);\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final Number numerator = getNumeratorFormat().parse(source, parsePosition);\n        if (numerator == null) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(),\n                                         LocalizedFormats.CANNOT_PARSE_NUMBER,\n                                         source.substring(0, parsePosition.getIndex()));\n        }\n\n        final int start = parsePosition.getIndex();\n        if (start >= source.length()) {\n            throw new MathParseException(source, start,\n                                         LocalizedFormats.CANNOT_PARSE_FRACTION,\n                                         source.substring(0, start));\n        }\n\n        if (source.charAt(start) != '/') {\n            throw new MathParseException(source, start,\n                                         LocalizedFormats.CANNOT_PARSE_FRACTION,\n                                         source.substring(0, start));\n        }\n\n        final int end = source.length();\n        final ParsePosition parsePositionDenominator = new ParsePosition(start + 1);\n        final Number denominator = getDenominatorFormat().parse(source, parsePositionDenominator);\n        if (denominator == null) {\n            throw new MathParseException(source, parsePositionDenominator.getErrorIndex(),\n                                         LocalizedFormats.CANNOT_PARSE_NUMBER,\n                                         source.substring(start + 1, end));\n        }\n\n        return new BigFraction(numerator.longValue(), denominator.longValue());\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final Number numerator = getNumeratorFormat().parse(source, parsePosition);\n        final Number denominator = getDenominatorFormat().parse(source, parsePosition);\n        if (numerator == null || denominator == null) {\n            throw new MathParseException(source, BigFraction.class, null,\n                                         \"Unparseable number\", parsePosition.getErrorIndex());\n        }\n        return new BigFraction(numerator.longValue(), denominator.longValue());\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final Number numerator = getNumeratorFormat().parse(source, parsePosition);\n        if (numerator == null) {\n            throw new MathParseException(source, BigFraction.class, parsePosition.getErrorIndex(),\n                                         LocalizedFormats.CANNOT_PARSE_NUMBER,\n                                         parsePosition.getIndex());\n        }\n        final int numeratorEndIndex = parsePosition.getIndex();\n        if (numeratorEndIndex == source.length()) {\n            return new BigFraction(numerator.longValue());\n        }\n        final String numeratorString = source.substring(0, numeratorEndIndex);\n        final String denominatorString = source.substring(numeratorEndIndex + 1);\n        final Number denominator = getDenominatorFormat().parse(denominatorString, parsePosition);\n        if (denominator == null) {\n            throw new MathParseException(source, BigFraction.class, parsePosition.getErrorIndex(),\n                                         LocalizedFormats.CANNOT_PARSE_NUMBER,\n                                         parsePosition.getIndex());\n        }\n        return new BigFraction(numerator.longValue(), denominator.longValue());\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final String[] parts = source.split(\"/\");\n        if (parts.length != 2) {\n            throw new MathParseException(source, BigFraction.class,\n                                         LocalizedFormats.FRACTION_FORMAT_ERROR,\n                                         source);\n        }\n        final BigInteger numerator = getNumeratorFormat().parse(parts[0].trim());\n        final BigInteger denominator = getDenominatorFormat().parse(parts[1].trim());\n        return new BigFraction(numerator, denominator);\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(),\n                                         LocalizedFormats.CANNOT_PARSE_FRACTION);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final String[] parts = source.split(\"/\");\n        if (parts.length != 2) {\n            throw new MathParseException(source, BigFraction.class, null, null, \"Expected fraction in the form 'numerator/denominator'.\");\n        }\n        try {\n            final BigInteger numerator = getNumeratorFormat().parse(parts[0]).intValue();\n            final BigInteger denominator = getDenominatorFormat().parse(parts[1]).intValue();\n            return new BigFraction(numerator, denominator);\n        } catch (ParseException e) {\n            throw new MathParseException(source, BigFraction.class, null, null, e.getMessage());\n        }\n    }"
    ],
    [
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return new ListOrderedSet<E>(new HashSet<E>(list), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    final Set<E> set = new HashSet<E>(list);\n    return new ListOrderedSet<E>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return new ListOrderedSet<E>(new HashSet<E>(list), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    // create a new HashSet to store the elements\n    Set<E> set = new HashSet<E>(list.size());\n    // add all the elements to the set\n    set.addAll(list);\n    // create a new ArrayList to store the order\n    List<E> setOrder = new ArrayList<E>(list.size());\n    // add all the elements to the list\n    setOrder.addAll(set);\n    // return the new ListOrderedSet\n    return new ListOrderedSet<E>(set, setOrder);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return new ListOrderedSet<E>(new HashSet<E>(list), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return new ListOrderedSet<E>(new HashSet<E>(list), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return new ListOrderedSet<E>(new HashSet<E>(list), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return new ListOrderedSet<E>(new HashSet<E>(list), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return new ListOrderedSet<E>(new HashSet<E>(list), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    // Create a new HashSet to use as the underlying set\n    Set<E> set = new HashSet<E>(list);\n\n    // Create a new ArrayList to use as the underlying list\n    ArrayList<E> newList = new ArrayList<E>(list);\n\n    // Remove any duplicates from the list\n    newList.removeAll(set);\n\n    // Return the new ListOrderedSet\n    return new ListOrderedSet<E>(set, newList);\n}"
    ],
    [
      "public Range getDataRange(ValueAxis axis)  {\n    Range range = null;\n    for (int i = 0; i < this.subplots.size(); i++) {\n        CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n        Range r = plot.getDataRange(axis);\n        if (r != null) {\n            if (range == null) {\n                range = r;\n            }\n            else {\n                range = range.add(r);\n            }\n        }\n    }\n    return range;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n\n    // get the range from the first subplot\n    CategoryPlot plot = (CategoryPlot) this.subplots.get(0);\n    Range range = plot.getDataRange(axis);\n\n    // loop through the rest of the subplots and expand the range\n    for (int i = 1; i < this.subplots.size(); i++)  {\n        plot = (CategoryPlot) this.subplots.get(i);\n        range = range.add(plot.getDataRange(axis));\n    }\n\n    return range;\n\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    // TODO: Implement this method\n    return null;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n\n    Range result = null;\n\n    for (int i = 0; i < this.subplots.size(); i++) {\n        CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n        result = Range.combine(result, plot.getDataRange(axis));\n    }\n\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n\n    // create a new range object\n    Range range = new Range();\n\n    // loop through each subplot and get the range\n    for (int i = 0; i < this.subplots.size(); i++) {\n        CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n        Range subplotRange = plot.getDataRange(axis);\n        range.addRange(subplotRange);\n    }\n\n    return range;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n\n    // get the range from the subplots\n    Range result = null;\n    for (int i = 0; i < this.subplots.size(); i++) {\n        CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n        result = Range.combine(result, plot.getDataRange(axis));\n    }\n\n    return result;\n\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    // initialize the range\n    double min = Double.MAX_VALUE;\n    double max = -Double.MAX_VALUE;\n\n    // iterate over all subplots\n    for (int i = 0; i < this.subplots.size(); i++) \n    {\n        // get the subplot\n        CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n\n        // get the range of the subplot\n        Range subplotRange = plot.getDataRange(axis);\n\n        // update the range\n        min = Math.min(min, subplotRange.getLowerBound());\n        max = Math.max(max, subplotRange.getUpperBound());\n    }\n\n    // return the range\n    return new Range(min, max);\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    for (int i = 0; i < this.subplots.size(); i++) \n    {\n        CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n        Range range = plot.getDataRange(axis);\n        if (range != null) \n        {\n            if (result == null) \n            {\n                result = range;\n            } \n            else \n            {\n                result = result.add(range);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    for (int i = 0; i < this.subplots.size(); i++) {\n        CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n        result = Range.combine(result, plot.getDataRange(axis));\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n\n    // get the range from the first subplot\n    CategoryPlot plot = (CategoryPlot) this.subplots.get(0);\n    Range range = plot.getDataRange(axis);\n\n    // check the other subplots\n    for (int i = 1; i < this.subplots.size(); i++)  {\n        plot = (CategoryPlot) this.subplots.get(i);\n        Range subrange = plot.getDataRange(axis);\n        if (subrange != null)  {\n            if (range == null)  {\n                range = subrange;\n            }\n            else  {\n                range.ensureValidRange(subrange);\n            }\n        }\n    }\n\n    return range;\n}"
    ],
    [
      "public double adjustedLog10(double val)  {\n    double adjustedLog10 = 0.0;\n    double adjustedVal = 0.0;\n    double scalingFactor = 0.0;\n    if (val < 0.0)\n    {\n        adjustedVal = -val;\n    }\n    else\n    {\n        adjustedVal = val;\n    }\n    if (adjustedVal < 10.0)\n    {\n        scalingFactor = (10.0 - adjustedVal) / 10.0;\n        adjustedLog10 = Math.log(adjustedVal + scalingFactor) / LOG10_VALUE;\n    }\n    else\n    {\n        adjustedLog10 = Math.log(adjustedVal) / LOG10_VALUE;\n    }\n    if (val < 0.0)\n    {\n        adjustedLog10 = -adjustedLog10;\n    }\n    return adjustedLog10;\n}",
      "public double adjustedLog10(double val)  {\n    double logVal;\n    if (val <= 0.0) {\n        logVal = Math.log(Math.abs(val)) / LOG10_VALUE;\n    } else {\n        logVal = Math.log(val) / LOG10_VALUE;\n    }\n    if (logVal < 0.0) {\n        logVal = -logVal;\n    }\n    if (logVal < 1.0) {\n        logVal = logVal / (1.0 - logVal);\n    }\n    return logVal;\n}",
      "public double adjustedLog10(double val)  {\n    double result;\n    if (val < 0.0) \n    {\n        result = Math.log(Math.abs(val)) / LOG10_VALUE;\n    } \n    else \n    {\n        result = Math.log(val) / LOG10_VALUE;\n    }\n    if (result < 0.0) \n    {\n        result = 0.0;\n    } \n    else \n    {\n        result = result + (10.0 - Math.floor(result));\n    }\n    return result;\n}",
      "public double adjustedLog10(double val)  {\n    // change negative values to positive:\n    double absVal = Math.abs(val);\n    // calculate log10:\n    double log10Val = Math.log10(absVal);\n    // adjust for values less than 10:\n    if (absVal < 10.0) {\n        // add a scaling factor to adjust for values less than 10:\n        log10Val += (10.0 - absVal) / 10.0;\n    }\n    // negate the result if the original value was negative:\n    return val < 0.0 ? -log10Val : log10Val;\n}",
      "public double adjustedLog10(double val)  {\n    // adjust for negative values\n    double adjustedVal = val;\n    if (val < 0.0) {\n        adjustedVal = -val;\n    }\n\n    // adjust for values less than 10\n    double logVal = Math.log(adjustedVal) / LOG10_VALUE;\n    if (val < 10.0) {\n        logVal += (10.0 - val) / val;\n    }\n\n    // negate if necessary\n    if (val < 0.0) {\n        logVal = -logVal;\n    }\n    return logVal;\n}",
      "public double adjustedLog10(double val)  {\n    double adjustedVal = val;\n    if (val < 0)\n    {\n        adjustedVal = -val;\n    }\n    if (adjustedVal < 10)\n    {\n        adjustedVal = Math.log(adjustedVal) / Math.log(10) + Math.log(adjustedVal) / Math.log(10);\n    }\n    else\n    {\n        adjustedVal = Math.log(adjustedVal) / Math.log(10);\n    }\n    if (val < 0)\n    {\n        adjustedVal = -adjustedVal;\n    }\n    return adjustedVal;\n}",
      "public double adjustedLog10(double val)  {\n    double adjustedLog = 0;\n    if (val < 0) {\n        val = -val;\n        adjustedLog = -Math.log10(val);\n    }\n    else {\n        adjustedLog = Math.log10(val);\n    }\n\n    if (val < 10) {\n        adjustedLog += (10 - val) / 10;\n    }\n\n    return adjustedLog;\n}",
      "public double adjustedLog10(double val)  {\n    // if negative values not allowed and the lower bound is between 0 and 10\n    // then a normal log is returned; otherwise the returned value is adjusted\n    // if the given value is less than 10:\n    if (this.smallLogFlag) {\n        return Math.log(val) / LOG10_VALUE;\n    }\n    else {\n        // if value is less than 10, then add an increasingly large (0 to 1)\n        // scaling factor such that at 0 the value is adjusted to 1, resulting\n        // in a returned result of 0:\n        double adjustedVal = val;\n        if (val < 10.0) {\n            adjustedVal = val + (10.0 - val) / 10.0;\n        }\n        return Math.log(adjustedVal) / LOG10_VALUE;\n    }\n}",
      "public double adjustedLog10(double val)  {\n    double result = 0;\n    if (val < 0) \n    {\n        val = -val;\n    }\n    if (val < 10) \n    {\n        result = Math.log(val) / LOG10_VALUE;\n        result += Math.log(val) / (LOG10_VALUE * val);\n    }\n    else \n    {\n        result = Math.log(val) / LOG10_VALUE;\n    }\n    return result;\n}",
      "public double adjustedLog10(double val)  {\n    double adjustedVal = val;\n    if (val < 0.0) {\n        adjustedVal = -val;\n    }\n    if (adjustedVal < 10.0) {\n        adjustedVal = adjustedVal + (10.0 - adjustedVal) / 10.0;\n    }\n    return Math.log10(adjustedVal) * (val < 0.0 ? -1.0 : 1.0);\n}"
    ],
    [
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  // If the implicit return node is reachable from the entry node, then all\n  // paths return.\n  return cfg.getImplicitReturn().getPredNodes().contains(cfg.getEntry());\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    Node implicitReturn = cfg.getImplicitReturn();\n    if (implicitReturn == null) {\n      return false;\n    }\n\n    // If the implicit return is a return node, then all paths return.\n    if (implicitReturn.isReturn()) {\n      return true;\n    }\n\n    // If the implicit return is an if, then all paths return if all\n    // branches return.\n    if (implicitReturn.isIf()) {\n      Node trueNode = implicitReturn.getFirstChild();\n      Node falseNode = trueNode.getNext();\n      return fastAllPathsReturnCheck(cfg.getSubGraph(trueNode))\n          && fastAllPathsReturnCheck(cfg.getSubGraph(falseNode));\n    }\n\n    // If the implicit return is a switch, then all paths return if all\n    // cases return.\n    if (implicitReturn.isSwitch()) {\n      for (Node child : implicitReturn.children()) {\n        if (!fastAllPathsReturnCheck(cfg.getSubGraph(child))) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    // Otherwise, no paths return.\n    return false;\n  }",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    // Check for a single return statement.\n    if (cfg.getReturnNodes().size() == 1) {\n      return true;\n    }\n\n    // Check for a return statement in the implicit return node.\n    if (cfg.getImplicitReturn().getFirst().isReturn()) {\n      return true;\n    }\n\n    return false;\n  }",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    return cfg.getImplicitReturn().getInEdges().size() == 1;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  Node implicitReturn = cfg.getImplicitReturn();\n  if (implicitReturn == null) {\n    return false;\n  }\n  for (DiGraphEdge<Node, ControlFlowGraph.Branch> edge : cfg.getDirectedGraph()\n      .getInEdges(implicitReturn)) {\n    if (!edge.getValue().isReturn()) {\n      return false;\n    }\n  }\n  return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    Node implicitReturn = cfg.getImplicitReturn();\n    if (implicitReturn == null) {\n      return false;\n    }\n\n    for (DiGraphEdge<Node, ControlFlowGraph.Branch> edge : cfg.getDirectedGraph()\n        .getOutEdges(implicitReturn)) {\n      if (edge.getValue() == Branch.ON_EX) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    Node implicitReturn = cfg.getImplicitReturn();\n    if (implicitReturn == null) {\n      return false;\n    }\n    if (implicitReturn.getParent().isFunction()) {\n      return true;\n    }\n    return false;\n  }",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    for (DiGraphNode<Node, ControlFlowGraph.Branch> node : cfg.getDirectedGraphNodes()) {\n      if (node.getValue().isReturn()) {\n        return true;\n      }\n    }\n    return false;\n  }",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  // TODO(user): Implement this method.\n  return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    // Check if the function has an explicit return statement.\n    if (cfg.getImplicitReturn() != null) {\n      return true;\n    }\n\n    // Check if the function has a return statement on every path.\n    for (DiGraphEdge<Node, ControlFlowGraph.Branch> edge : cfg.getDirectedGraph().getEdges()) {\n      if (edge.getValue() == Branch.ON_EX) {\n        continue;\n      }\n\n      Node src = edge.getSource().getValue();\n      Node dst = edge.getDestination().getValue();\n      if (src.isReturn() || dst.isReturn()) {\n        return true;\n      }\n    }\n\n    return false;\n  }"
    ],
    [
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] x = new Dfp[2];\n    Dfp[] spy = new Dfp[2];\n    Dfp[] spz = new Dfp[2];\n    int p2 = 0;\n    int ix;\n\n    x = a.clone();\n\n    lr = x.log10K();\n\n    x = x.divide(pow(a.newInstance(10000), lr));  /* This puts x in the range 0-10000 */\n    ix = x.floor().intValue();\n\n    while (ix > 2) {\n        ix >>= 1;\n        p2++;\n    }\n\n\n    Dfp[] spx = split(x);\n    spy[0] = pow(a.getTwo(), p2);          // use spy[0] temporarily as a divisor\n    spx[0] = spx[0].divide(spy[0]);\n    spx[1] = spx[1].divide(spy[0]);\n\n    spy[0] = a.newInstance(\"1.33333\");    // Use spy[0] for comparison\n    while (spx[0].add(spx[1]).greaterThan(spy[0])) {\n        spx[0] = spx[0].divide(2);\n        spx[1] = spx[1].divide(2);\n        p2++;\n    }\n\n    // X is now in the range of 2/3 < x < 4/3\n    spz = logInternal(spx);\n\n    spx[0] = a.newInstance(new StringBuilder().append(p2+4*lr).toString());\n    spx[1] = a.getZero();\n    spy = splitMult(a.getField().getLn2Split(), spx);\n\n    spz[0] = spz[0].add(spy[0]);\n    spz[1] = spz[1].add(spy[1]);\n\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] spx = a;\n    Dfp[] spy = new Dfp[2];\n    spy[0] = a.getField().getOne();\n    spy[1] = a.getField().getZero();\n    spx[0] = spx[0].divide(spy[0]);\n    spx[1] = spx[1].divide(spy[0]);\n    spy[0] = a.getField().getOne();\n    spy[1] = a.getField().getZero();\n    spx = splitMult(spx, spy);\n    spy[0] = a.getField().getOne();\n    spy[1] = a.getField().getZero();\n    spx = splitSubtract(spx, spy);\n    spy[0] = a.getField().getOne();\n    spy[1] = a.getField().getZero();\n    spx = splitMult(spx, spy);\n    spy[0] = a.getField().getOne();\n    spy[1] = a.getField().getZero();\n    spx = splitMult(spx, spy);\n    spy[0] = a.getField().getOne();\n    spy[1] = a.getField().getZero();\n    spx = splitMult(spx, spy);\n    spy[0] = a.getField().getOne();\n    spy[1] = a.getField().getZero();\n    spx = splitMult(spx, spy);\n    spy[0] = a.getField().getOne();\n    spy[1] = a.getField().getZero();\n    spx = splitMult(spx, spy);\n    spy[0] = a.getField().getOne();\n    spy[1] = a.getField().getZero();\n    spx = splitMult(spx, spy);\n    spy[0] = a.getField().getOne();\n    spy[1] = a.getField().getZero();\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] spx = a;\n    Dfp[] spy = new Dfp[2];\n    spy[0] = a[0].subtract(a[1]);\n    spy[1] = a[0].add(a[1]);\n    spx = splitDiv(spy, spx);\n    spy[0] = spx[0].add(spx[1]);\n    spy[1] = spx[0].subtract(spx[1]);\n    spx = splitMult(a[0].getField().getLn2Split(), spy);\n    spy[0] = spx[0].add(spx[1]);\n    spy[1] = spx[0].subtract(spx[1]);\n    spx = splitMult(a[0].getField().getLn5Split(), spy);\n    spy[0] = spx[0].add(spx[1]);\n    spy[1] = spx[0].subtract(spx[1]);\n    spx[0] = spy[0].add(spy[1]);\n    spx[1] = spy[0].subtract(spy[1]);\n    return spx;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    // This is the value of x such that a = (x+1)/(x-1)\n    final Dfp x = a[0].divide(a[1]).add(a[1]).divide(a[0]).subtract(a[1]);\n\n    // This is the value of x-1\n    final Dfp xm1 = x.subtract(a[1]);\n\n    // This is the value of x+1\n    final Dfp xp1 = x.add(a[1]);\n\n    // This is the value of 2x\n    final Dfp twox = x.multiply(2);\n\n    // This is the value of 2x+1\n    final Dfp twoxp1 = twox.add(a[1]);\n\n    // This is the value of 2x-1\n    final Dfp twoxm1 = twox.subtract(a[1]);\n\n    // This is the value of 2x+1\n    final Dfp twoxp1 = twox.add(a[1]);\n\n    // This is the value of 2x-1\n    final Dfp twoxm1 = twox.subtract(a[1]);\n\n    // This is the value of 2x+1\n    final Dfp twoxp1 = twox.add(a[1]);\n\n    // This is the value of 2x-1\n    final Dfp twoxm1 = twox.subtract(a[1]);\n\n    // This is the value of 2x+1\n    final Dfp twoxp1 = twox.add(a[1]);\n\n    // This is the value of 2x-1\n    final Dfp twoxm1 = twox.subtract(a[1]);\n\n    // This is the value of 2x+1\n    final Dfp twoxp1 = twox.add(a[1]);\n\n    // This is the value of 2x-1\n    final Dfp twoxm1 = twox.subtract(a[1]);\n\n    // This is the value of 2x+1\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] x = new Dfp[2];\n    x[0] = a[0].add(a[1]);\n    x[1] = a[0].subtract(a[1]);\n    x = divide(x, x[0]);\n    x[0] = x[0].add(Dfp.ONE);\n    x[1] = x[1].subtract(Dfp.ONE);\n    return x;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] spx = a;\n    Dfp[] spy = new Dfp[2];\n    Dfp[] spz = new Dfp[2];\n    int p2 = 0;\n    int ix = 0;\n    Dfp x = spx[0].add(spx[1]);\n    Dfp lr = x.log10K();\n\n    x = x.divide(pow(a.newInstance(10000), lr));  /* This puts x in the range 0-10000 */\n    ix = x.floor().intValue();\n\n    while (ix > 2) {\n        ix >>= 1;\n        p2++;\n    }\n\n\n    spx = split(x);\n    spy[0] = pow(a.getTwo(), p2);          // use spy[0] temporarily as a divisor\n    spx[0] = spx[0].divide(spy[0]);\n    spx[1] = spx[1].divide(spy[0]);\n\n    spy[0] = a.newInstance(\"1.33333\");    // Use spy[0] for comparison\n    while (spx[0].add(spx[1]).greaterThan(spy[0])) {\n        spx[0] = spx[0].divide(2);\n        spx[1] = spx[1].divide(2);\n        p2++;\n    }\n\n    // X is now in the range of 2/3 < x < 4/3\n    spz = logInternal(spx);\n\n    spx[0] = a.newInstance(new StringBuilder().append(p2+4*lr).toString());\n    spx[1] = a.getZero();\n    spy = splitMult(a.getField().getLn2Split(), spx);\n\n    spz[0] = spz[0].add(spy[0]);\n    spz[1] = spz[1].add(spy[1]);\n\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n\n    Dfp[] spx = new Dfp[2];\n    Dfp[] spy = new Dfp[2];\n    Dfp[] spz = new Dfp[2];\n\n    spx[0] = a[0].subtract(a[1]);\n    spx[1] = a[0].add(a[1]);\n\n    spy[0] = a[0].subtract(a[1]);\n    spy[1] = a[0].add(a[1]);\n\n    spz[0] = spx[0].divide(spy[0]);\n    spz[1] = spx[1].divide(spy[1]);\n\n    spx[0] = spz[0].subtract(spz[1]);\n    spx[1] = spz[0].add(spz[1]);\n\n    spz[0] = spx[0].divide(2);\n    spz[1] = spx[1].divide(2);\n\n    spx[0] = spz[0].add(spz[1]);\n    spx[1] = spz[0].subtract(spz[1]);\n\n    spy[0] = a[0].divide(a[1]);\n    spy[1] = a[0].divide(a[1]);\n\n    spz[0] = spx[0].divide(spy[0]);\n    spz[1] = spx[1].divide(spy[1]);\n\n    spx[0] = spz[0].subtract(spz[1]);\n    spx[1] = spz[0].add(spz[1]);\n\n    spz[0] = spx[0].divide(2);\n    spz[1] = spx[1].divide(2);\n\n    spx[0] = spz[0].add(spz[1]);\n    spx[1] = spz[0].subtract(spz[1]);\n\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        Dfp[] x = new Dfp[2];\n        x[0] = a[0].subtract(a[1]);\n        x[1] = a[0].add(a[1]);\n        x = x[0].divide(x[1]).split();\n        Dfp[] y = new Dfp[2];\n        y[0] = x[0].subtract(x[1]);\n        y[1] = x[0].add(x[1]);\n        y = y[0].divide(y[1]).split();\n        Dfp[] z = new Dfp[2];\n        z[0] = y[0].subtract(y[1]);\n        z[1] = y[0].add(y[1]);\n        z = z[0].divide(z[1]).split();\n        Dfp[] w = new Dfp[2];\n        w[0] = z[0].subtract(z[1]);\n        w[1] = z[0].add(z[1]);\n        w = w[0].divide(w[1]).split();\n        Dfp[] t = new Dfp[2];\n        t[0] = w[0].subtract(w[1]);\n        t[1] = w[0].add(w[1]);\n        t = t[0].divide(t[1]).split();\n        Dfp[] s = new Dfp[2];\n        s[0] = t[0].subtract(t[1]);\n        s[1] = t[0].add(t[1]);\n        s = s[0].divide(s[1]).split();\n        Dfp[] r = new Dfp[2];\n        r[0] = s[0].subtract(s[1]);\n        r[1] = s[0].add(s[1]);\n        r = r[0].divide(r[1]).split();\n        Dfp[] q = new Dfp[2];\n        q[0] = r[0].subtract(r[1]);\n        q[1] = r[0].add(r[1]);\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n\n    // compute x = (a-1)/(a+1)\n    Dfp[] x = new Dfp[2];\n    x[0] = a[0].subtract(a[1]);\n    x[1] = a[0].add(a[1]);\n    x[0] = x[0].divide(x[1]);\n\n    // compute the series\n    Dfp[] ln = new Dfp[2];\n    ln[0] = a[0].subtract(a[1]);\n    ln[1] = a[0].add(a[1]);\n    Dfp[] term = new Dfp[2];\n    term[0] = a[0].subtract(a[1]);\n    term[1] = a[0].add(a[1]);\n    int n = 1;\n    while (term[0].abs().greaterThan(a[0].ulp())) {\n        term[0] = term[0].multiply(x[0]);\n        term[1] = term[1].multiply(x[1]);\n        term[0] = term[0].divide(n);\n        term[1] = term[1].divide(n);\n        ln[0] = ln[0].add(term[0]);\n        ln[1] = ln[1].add(term[1]);\n        n += 2;\n    }\n\n    // return the result\n    return ln;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] spx = new Dfp[2];\n    Dfp[] spy = new Dfp[2];\n    Dfp[] spz = new Dfp[2];\n\n    spx[0] = a[0].add(a[1]);\n    spx[1] = a[0].subtract(a[1]);\n\n    spy[0] = spx[0].divide(spx[1]);\n    spy[1] = spx[0].divide(spx[1]);\n\n    spx[0] = spy[0].subtract(a[0]);\n    spx[1] = spy[1].subtract(a[1]);\n\n    spy[0] = spx[0].divide(spx[1]);\n    spy[1] = spx[0].divide(spx[1]);\n\n    spx[0] = spy[0].subtract(a[0]);\n    spx[1] = spy[1].subtract(a[1]);\n\n    spy[0] = spx[0].divide(spx[1]);\n    spy[1] = spx[0].divide(spx[1]);\n\n    spx[0] = spy[0].subtract(a[0]);\n    spx[1] = spy[1].subtract(a[1]);\n\n    spy[0] = spx[0].divide(spx[1]);\n    spy[1] = spx[0].divide(spx[1]);\n\n    spx[0] = spy[0].subtract(a[0]);\n    spx[1] = spy[1].subtract(a[1]);\n\n    spy[0] = spx[0].divide(spx[1]);\n    spy[1] = spx[0].divide(spx[1]);\n\n    spx[0] = spy[0].subtract(a[0]);\n    spx[1] = spy[1].subtract(a[1]);\n}"
    ],
    [
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null) {\n            throw new NullPointerException(\"Key is null\");\n        }\n        if (value == null) {\n            throw new NullPointerException(\"Value is null\");\n        }\n        final Collection coll = decorated().get(key);\n        if (coll == null) {\n            return false;\n        }\n        return coll.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null) {\n            throw new NullPointerException(\"The key must not be null\");\n        }\n        if (value == null) {\n            throw new NullPointerException(\"The value must not be null\");\n        }\n        final Collection coll = decorated().get(key);\n        if (coll == null) {\n            return false;\n        }\n        final boolean removed = coll.remove(value);\n        if (coll.isEmpty()) {\n            decorated().remove(key);\n        }\n        return removed;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null) {\n            throw new NullPointerException(\"The key must not be null\");\n        }\n        if (value == null) {\n            throw new NullPointerException(\"The value must not be null\");\n        }\n        final Collection<V> coll = decorated().get(key);\n        if (coll == null) {\n            return false;\n        }\n        final boolean result = coll.remove(value);\n        if (coll.isEmpty()) {\n            decorated().remove(key);\n        }\n        return result;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = decorated().get(key);\n        if (coll == null) {\n            return false;\n        }\n        final boolean removed = coll.remove(value);\n        if (coll.isEmpty()) {\n            decorated().remove(key);\n        }\n        return removed;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = decorated().get(key);\n        if (coll == null) {\n            return false;\n        }\n        final boolean result = coll.remove(value);\n        if (coll.isEmpty()) {\n            decorated().remove(key);\n        }\n        return result;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null) {\n            throw new NullPointerException(\"The key must not be null\");\n        }\n        if (value == null) {\n            throw new NullPointerException(\"The value must not be null\");\n        }\n        final Collection coll = (Collection) decorated().get(key);\n        if (coll == null) {\n            return false;\n        }\n        if (coll.remove(value)) {\n            if (coll.isEmpty()) {\n                decorated().remove(key);\n            }\n            return true;\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null) {\n            throw new NullPointerException(\"The key must not be null\");\n        }\n        if (value == null) {\n            throw new NullPointerException(\"The value must not be null\");\n        }\n        final Collection<V> coll = decorated().get(key);\n        if (coll == null) {\n            return false;\n        }\n        final boolean result = coll.remove(value);\n        if (coll.isEmpty()) {\n            decorated().remove(key);\n        }\n        return result;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection coll = decorated().get(key);\n        if (coll == null) {\n            return false;\n        }\n        final boolean removed = coll.remove(value);\n        if (coll.isEmpty()) {\n            decorated().remove(key);\n        }\n        return removed;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null) {\n            throw new NullPointerException(\"Key is null\");\n        }\n        if (value == null) {\n            throw new NullPointerException(\"Value is null\");\n        }\n        final Collection<V> coll = decorated().get(key);\n        if (coll == null) {\n            return false;\n        }\n        if (coll.remove(value)) {\n            if (coll.isEmpty()) {\n                decorated().remove(key);\n            }\n            return true;\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection coll = decorated().get(key);\n        if (coll == null) {\n            return false;\n        }\n        final boolean result = coll.remove(value);\n        if (coll.isEmpty()) {\n            decorated().remove(key);\n        }\n        return result;\n    }"
    ],
    [
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) {\n    node.setType(Token.STRING);\n  } else if (node.getType() == Token.STRING) {\n    node.setType(Token.STRING);\n    node.setQuotedString();\n  }\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) {\n    node.setType(Token.STRING);\n  } else if (node.getType() == Token.STRING) {\n    node.setType(Token.STRING);\n    node.setQuotedString();\n  }\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n      node.setType(Token.STRING);\n    } else if (node.getType() == Token.STRING) {\n      node.setType(Token.STRING);\n      node.setQuotedString();\n    }\n    return node;\n  }",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n      node.setType(Token.STRING);\n    } else if (node.getType() == Token.STRING) {\n      node.setType(Token.STRING);\n      node.setQuotedString();\n    }\n    return node;\n  }",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n    } else if (node.getType() == Token.STRING) {\n        node.setType(Token.STRING);\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) {\n    node.setType(Token.STRING);\n  } else if (node.getType() == Token.STRING) {\n    node.setType(Token.STRING);\n    node.setQuotedString();\n  }\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) {\n    node.setType(Token.STRING);\n  } else if (node.getType() == Token.STRING) {\n    node.setType(Token.STRING);\n    node.setQuotedString();\n  }\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) {\n    node.setType(Token.STRING);\n  } else if (node.getType() == Token.STRING) {\n    node.setType(Token.STRING);\n  }\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) {\n    node.setType(Token.STRING);\n  } else if (node.getType() == Token.STRING) {\n    node.setType(Token.STRING);\n  }\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n    } else if (node.getType() == Token.STRING) {\n        node.setType(Token.STRING);\n    }\n    return node;\n}"
    ],
    [
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n\n    List result = new java.util.ArrayList();\n    for (int i = 0; i < includedRows.length; i++) {\n        int row = includedRows[i];\n        double v = dataset.getValue(row, category);\n        if (this.renderAsPercentages) {\n            double total = 0.0;\n            for (int j = 0; j < dataset.getColumnCount(); j++) {\n                total += dataset.getValue(row, dataset.getColumnKey(j));\n            }\n            v = v / total;\n        }\n        result.add(new Double(base + v));\n        base += v;\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double total = 0.0;\n    for (int i = 0; i < includedRows.length; i++) {\n        int row = includedRows[i];\n        double value = dataset.getValue(row, dataset.getColumnIndex(category));\n        if (value > 0) {\n            total += value;\n        }\n    }\n    for (int i = 0; i < includedRows.length; i++) {\n        int row = includedRows[i];\n        double value = dataset.getValue(row, dataset.getColumnIndex(category));\n        if (asPercentages) {\n            value = value / total;\n        }\n        result.add(new Double(value + base));\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double total = 0.0;\n    for (int i = 0; i < includedRows.length; i++) {\n        int row = includedRows[i];\n        double v = dataset.getValue(row, category);\n        if (v >= 0.0) {\n            total += v;\n        }\n    }\n    for (int i = 0; i < includedRows.length; i++) {\n        int row = includedRows[i];\n        double v = dataset.getValue(row, category);\n        if (v >= 0.0) {\n            double p = 0.0;\n            if (total > 0.0) {\n                p = v / total;\n            }\n            if (asPercentages) {\n                result.add(new Double(p));\n            }\n            else {\n                result.add(new Double(base + v));\n            }\n        }\n        else {\n            result.add(null);\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    for (int i = 0; i < includedRows.length; i++) {\n        int row = includedRows[i];\n        double value = dataset.getValue(row, category);\n        if (this.renderAsPercentages) {\n            double total = 0.0;\n            for (int j = 0; j < dataset.getColumnCount(); j++) {\n                total += dataset.getValue(j, category);\n            }\n            if (total > 0.0) {\n                value = value / total;\n            }\n        }\n        if (value > 0.0 || !this.ignoreZeroValues) {\n            result.add(new Double(value + base));\n        }\n        base += value;\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n\n    List result = new ArrayList();\n    double total = 0.0;\n    for (int i = 0; i < includedRows.length; i++) {\n        int row = includedRows[i];\n        double value = dataset.getValue(row, category);\n        if (value >= 0.0) {\n            total = total + value;\n        }\n    }\n    if (total == 0.0) {\n        result.add(new Double(base));\n    }\n    else {\n        for (int i = 0; i < includedRows.length; i++) {\n            int row = includedRows[i];\n            double value = dataset.getValue(row, category);\n            if (value >= 0.0) {\n                double p = value / total;\n                if (asPercentages) {\n                    p = p * 100.0;\n                }\n                result.add(new Double(base + p));\n            }\n            else {\n                result.add(new Double(base));\n            }\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double total = 0.0;\n    for (int row = 0; row < dataset.getRowCount(); row++) {\n        if (includedRows[row]) {\n            double value = dataset.getValue(row, dataset.getColumnIndex(category));\n            if (value > 0.0) {\n                total += value;\n            }\n        }\n    }\n    for (int row = 0; row < dataset.getRowCount(); row++) {\n        if (includedRows[row]) {\n            double value = dataset.getValue(row, dataset.getColumnIndex(category));\n            if (value > 0.0) {\n                double percentage = (value / total) * 100.0;\n                if (asPercentages) {\n                    result.add(new Double(percentage));\n                }\n                else {\n                    result.add(new Double(value + base));\n                }\n            }\n            else {\n                result.add(new Double(base));\n            }\n        }\n        else {\n            result.add(new Double(base));\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    // check arguments\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    if (category == null) {\n        throw new IllegalArgumentException(\"Null 'category' argument.\");\n    }\n    if (includedRows == null) {\n        throw new IllegalArgumentException(\"Null 'includedRows' argument.\");\n    }\n    // create a new list to store the stacked values\n    List result = new java.util.ArrayList();\n    // loop through the rows and calculate the stacked value\n    for (int row = 0; row < includedRows.length; row++) {\n        int series = includedRows[row];\n        double total = 0.0;\n        for (int item = 0; item <= row; item++) {\n            Comparable seriesKey = dataset.getRowKey(item);\n            Comparable categoryKey = dataset.getColumnKey(series);\n            Number value = dataset.getValue(seriesKey, categoryKey);\n            if (value != null) {\n                total += value.doubleValue();\n            }\n        }\n        if (asPercentages) {\n            double totalForCategory = 0.0;\n            for (int item = 0; item < dataset.getColumnCount(); item++) {\n                Comparable seriesKey = dataset.getRowKey(row);\n                Comparable categoryKey = dataset.getColumnKey(item);\n                Number value = dataset.getValue(seriesKey, categoryKey);\n                if (value != null) {\n                    totalForCategory += value.doubleValue();\n                }\n            }\n            result.add(new Double(total / totalForCategory));\n        }\n        else {\n            result.add(new Double(total + base));\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n\n        List result = new ArrayList();\n        double total = 0.0;\n        for (int i = 0; i < includedRows.length; i++) {\n            int row = includedRows[i];\n            double value = dataset.getValue(row, category);\n            if (value > 0.0) {\n                total += value;\n            }\n        }\n        if (asPercentages) {\n            base = total;\n        }\n        for (int i = 0; i < includedRows.length; i++) {\n            int row = includedRows[i];\n            double value = dataset.getValue(row, category);\n            if (value > 0.0) {\n                double percentage = value / total;\n                if (asPercentages) {\n                    percentage = percentage * 100.0;\n                }\n                result.add(new Double(base + percentage));\n            }\n            else {\n                result.add(new Double(base));\n            }\n        }\n        return result;\n    }",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    // get the stacked values\n    List stackedValues = DatasetUtilities.collectStackedValues(dataset,\n            category, includedRows);\n\n    // add the base value\n    stackedValues.add(new Double(base));\n\n    // convert to percentages if required\n    if (asPercentages) {\n        double total = 0.0;\n        Iterator iterator = stackedValues.iterator();\n        while (iterator.hasNext()) {\n            Double d = (Double) iterator.next();\n            total = total + d.doubleValue();\n        }\n        iterator = stackedValues.iterator();\n        while (iterator.hasNext()) {\n            Double d = (Double) iterator.next();\n            d.setValue(d.doubleValue() / total);\n        }\n    }\n    return stackedValues;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    // get the values from the dataset\n    List values = new ArrayList();\n    for (int row = 0; row < includedRows.length; row++) {\n        int r = includedRows[row];\n        Number value = dataset.getValue(r, category);\n        if (value != null) {\n            values.add(value);\n        }\n    }\n\n    // add the base value\n    values.add(new Double(base));\n\n    // convert to percentages if required\n    if (asPercentages) {\n        double total = 0.0;\n        for (int i = 0; i < values.size(); i++) {\n            Number v = (Number) values.get(i);\n            total = total + v.doubleValue();\n        }\n        for (int i = 0; i < values.size(); i++) {\n            Number v = (Number) values.get(i);\n            values.set(i, new Double(v.doubleValue() / total));\n        }\n    }\n\n    return values;\n}"
    ],
    [
      "private List<Element> childElementsList()  {\n    if (childElements == null)\n    {\n        childElements = new ArrayList<Element>();\n        for (Node child : childNodes)\n        {\n            if (child instanceof Element)\n            {\n                childElements.add((Element) child);\n            }\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    if (childElements == null) \n    {\n        childElements = new ArrayList<Element>();\n        for (Node node : childNodes) \n        {\n            if (node instanceof Element) \n            {\n                childElements.add((Element) node);\n            }\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    if (childElements == null)\n    {\n        childElements = new ArrayList<Element>();\n        for (Node childNode : childNodes)\n        {\n            if (childNode instanceof Element)\n            {\n                childElements.add((Element) childNode);\n            }\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    if (childElements == null) \n    {\n        childElements = new ArrayList<Element>();\n        for (Node node : childNodes) \n        {\n            if (node instanceof Element) \n            {\n                childElements.add((Element) node);\n            }\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    if (childElements == null)\n    {\n        childElements = new ArrayList<Element>();\n        for (Node child : childNodes)\n        {\n            if (child instanceof Element)\n            {\n                childElements.add((Element) child);\n            }\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    if (childElements == null) {\n        childElements = new ArrayList<Element>();\n        for (Node node : childNodes) {\n            if (node instanceof Element) {\n                childElements.add((Element) node);\n            }\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    if (childElements == null) {\n        childElements = new ArrayList<Element>();\n        for (Node node : childNodes) {\n            if (node instanceof Element) {\n                childElements.add((Element) node);\n            }\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    if (childElements == null) \n    {\n        childElements = new ArrayList<Element>();\n        for (Node node : childNodes) \n        {\n            if (node instanceof Element) \n            {\n                childElements.add((Element) node);\n            }\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    if (childElements == null) {\n        childElements = new ArrayList<Element>();\n        for (Node child : childNodes) {\n            if (child instanceof Element) {\n                childElements.add((Element) child);\n            }\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    if (childElements == null) {\n        childElements = new ArrayList<>();\n        for (Node child : childNodes) {\n            if (child instanceof Element) {\n                childElements.add((Element) child);\n            }\n        }\n    }\n    return childElements;\n}"
    ],
    [
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    hash += ~(hash << 9);\n    hash ^= (hash >>> 14);\n    hash += (hash << 4);\n    hash ^= (hash >>> 10);\n    return Math.abs(hash);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    hash += ~(hash << 9);\n    hash ^= (hash >>> 14);\n    hash += (hash << 4);\n    hash ^= (hash >>> 10);\n    return Math.abs(hash);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    return Math.abs(hash % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    hash += ~(hash << 9);\n    hash ^=  (hash >>> 14);\n    hash +=  (hash << 4);\n    hash ^=  (hash >>> 10);\n    return Math.abs(hash);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    return Math.abs(hash) % buckets.length;\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    hash += ~(hash << 9);\n    hash ^=  (hash >>> 14);\n    hash +=  (hash << 4);\n    hash ^=  (hash >>> 10);\n    return Math.abs(hash);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    return Math.abs(hash) % buckets.length;\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    hash += ~(hash << 9);\n    hash ^= (hash >>> 14);\n    hash += (hash << 4);\n    hash ^= (hash >>> 10);\n    return Math.abs(hash);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    hash += ~(hash << 9);\n    hash ^=  (hash >>> 14);\n    hash +=  (hash << 4);\n    hash ^=  (hash >>> 10);\n    return Math.abs(hash);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    return hash & (buckets.length - 1);\n}"
    ],
    [
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r - c > k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    int rowDimension = m.getRowDimension();\n    int columnDimension = m.getColumnDimension();\n    double[][] d = new double[rowDimension][columnDimension];\n    for (int r = 0; r < rowDimension; r++) \n    {\n        for (int c = 0; c < columnDimension; c++) \n        {\n            if (r + k < c) \n            {\n                d[r][c] = 0;\n            } \n            else \n            {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) \n    {\n        for (int c = 0; c < m.getColumnDimension(); c++) \n        {\n            if (r - c < k) \n            {\n                d[r][c] = 0;\n            } \n            else \n            {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    int n = m.getRowDimension();\n    int m1 = n - k;\n    double[][] d = new double[m1][m1];\n    for (int i = 0; i < m1; i++) {\n        for (int j = 0; j < m1; j++) {\n            if (i + k < j + k) {\n                d[i][j] = m.getEntry(i + k, j + k);\n            } else if (i + k == j + k) {\n                d[i][j] = m.getEntry(i + k, j + k);\n            } else {\n                d[i][j] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    if (k < 0) \n    {\n        k = 0;\n    }\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) \n    {\n        for (int c = 0; c < m.getColumnDimension(); c++) \n        {\n            if (r - c > k) \n            {\n                d[r][c] = m.getEntry(r, c);\n            }\n            else \n            {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    int n = m.getRowDimension();\n    int m1 = m.getColumnDimension();\n    double[][] d = new double[n][m1];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m1; j++) {\n            if (i - j < k) {\n                d[i][j] = m.getEntry(i, j);\n            } else {\n                d[i][j] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r - c >= k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r < c + k) {\n                d[r][c] = 0;\n            } else {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    int row = m.getRowDimension();\n    int col = m.getColumnDimension();\n    double[][] d = new double[row][col];\n    for(int r = 0; r < row; r++)\n    {\n        for(int c = 0; c < col; c++)\n        {\n            if(r < c - k)\n            {\n                d[r][c] = m.getEntry(r, c);\n            }\n            else\n            {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    if (k < 0) {\n        k = 0;\n    }\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r - c < k) {\n                d[r][c] = 0;\n            } else {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}"
    ],
    [
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n            switch (skew) \n            {\n            case LEFT_HIGH:\n                skew = Skew.BALANCED;\n                return true;\n            case RIGHT_HIGH:\n                if (right.skew == Skew.RIGHT_HIGH) \n                {\n                    rotateCCW();\n                    skew = Skew.BALANCED;\n                    left.skew = Skew.BALANCED;\n                    return true;\n                } \n                else if (right.skew == Skew.BALANCED) \n                {\n                    rotateCCW();\n                    skew = Skew.LEFT_HIGH;\n                    left.skew = Skew.RIGHT_HIGH;\n                    return false;\n                } \n                else \n                {\n                    final Skew s = right.left.skew;\n                    right.rotateCW();\n                    rotateCCW();\n                    switch (s) \n                    {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                    }\n                    skew = Skew.BALANCED;\n                    return true;\n                }\n            default:\n                skew = Skew.RIGHT_HIGH;\n                return false;\n            }\n        }",
      "private boolean rebalanceRightShrunk()  {\n            switch (skew) \n            {\n            case LEFT_HIGH:\n                skew = Skew.BALANCED;\n                return true;\n            case RIGHT_HIGH:\n                if (right.skew == Skew.RIGHT_HIGH) \n                {\n                    rotateCCW();\n                    skew = Skew.BALANCED;\n                    left.skew = Skew.BALANCED;\n                    return true;\n                } \n                else if (right.skew == Skew.BALANCED) \n                {\n                    rotateCCW();\n                    skew = Skew.LEFT_HIGH;\n                    left.skew = Skew.RIGHT_HIGH;\n                    return false;\n                } \n                else \n                {\n                    final Skew s = right.left.skew;\n                    right.rotateCW();\n                    rotateCCW();\n                    switch (s) \n                    {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                    }\n                    skew = Skew.BALANCED;\n                    return true;\n                }\n            default:\n                skew = Skew.RIGHT_HIGH;\n                return false;\n            }\n        }",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) {\n                rotateCCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } else if (right.skew == Skew.BALANCED) {\n                rotateCCW();\n                skew      = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } else {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n            switch (skew) \n            {\n                case LEFT_HIGH:\n                    skew = Skew.BALANCED;\n                    return true;\n                case RIGHT_HIGH:\n                    if (right.skew == Skew.RIGHT_HIGH) \n                    {\n                        rotateCCW();\n                        skew = Skew.BALANCED;\n                        left.skew = Skew.BALANCED;\n                        return true;\n                    } \n                    else if (right.skew == Skew.BALANCED) \n                    {\n                        rotateCCW();\n                        skew = Skew.LEFT_HIGH;\n                        left.skew = Skew.RIGHT_HIGH;\n                        return false;\n                    } \n                    else \n                    {\n                        final Skew s = right.left.skew;\n                        right.rotateCW();\n                        rotateCCW();\n                        switch (s) \n                        {\n                            case LEFT_HIGH:\n                                left.skew = Skew.BALANCED;\n                                right.skew = Skew.RIGHT_HIGH;\n                                break;\n                            case RIGHT_HIGH:\n                                left.skew = Skew.LEFT_HIGH;\n                                right.skew = Skew.BALANCED;\n                                break;\n                            default:\n                                left.skew = Skew.BALANCED;\n                                right.skew = Skew.BALANCED;\n                        }\n                        skew = Skew.BALANCED;\n                        return true;\n                    }\n                default:\n                    skew = Skew.RIGHT_HIGH;\n                    return false;\n            }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}"
    ],
    [
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n\n    // find the first small sub-diagonal element\n    int iu = startIdx;\n    while (iu > 0) {\n        if (FastMath.abs(matrixT[iu - 1][iu - 1]) <= norm * EPS) {\n            break;\n        }\n        iu--;\n    }\n\n    return iu;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    // find the first small sub-diagonal element\n    for (int i = startIdx; i >= 0; i--) {\n        if (FastMath.abs(matrixT[i][i]) <= norm * EPS) {\n            return i;\n        }\n    }\n    return startIdx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    // Find the first small sub-diagonal element\n    int il = startIdx;\n    while (il > 0) {\n        if (FastMath.abs(matrixT[il - 1][il - 1]) <= norm * EPS) {\n            break;\n        }\n        il--;\n    }\n    return il;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    // find the first small sub-diagonal element\n    int il = startIdx;\n    while (il > 0) {\n        if (FastMath.abs(matrixT[il - 1][il - 1]) <= norm * EPS) {\n            break;\n        }\n        il--;\n    }\n    return il;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n\n    // Find the first small sub-diagonal element\n    for (int i = startIdx; i >= 0; i--) {\n        if (FastMath.abs(matrixT[i][i]) <= SMALL_SUB_DIAGONAL * norm) {\n            return i;\n        }\n    }\n    return startIdx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    // check for convergence\n    for (int i = startIdx; i >= 0; i--) {\n        if (FastMath.abs(matrixT[i][i]) <= norm * EPS) {\n            return i;\n        }\n    }\n    return startIdx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n\n        // look for the first small sub-diagonal element\n        for (int i = startIdx; i >= 0; i--) {\n            if (FastMath.abs(matrixT[i][i]) <= norm * EPS) {\n                return i;\n            }\n        }\n        return startIdx;\n    }",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int iu = startIdx;\n    while (iu > 0) {\n        if (FastMath.abs(matrixT[iu][iu - 1]) <= norm * EPS) {\n            return iu;\n        }\n        iu--;\n    }\n    return iu;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n\n        // find the first small sub-diagonal element\n        for (int i = startIdx; i >= 0; i--) {\n            if (FastMath.abs(matrixT[i][i]) <= norm * EPS) {\n                return i;\n            }\n        }\n        return startIdx;\n    }",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    // Find the first small sub-diagonal element\n    int iu = startIdx;\n    while (iu > 0) {\n        if (FastMath.abs(matrixT[iu][iu - 1]) <= norm * EPS) {\n            break;\n        }\n        iu--;\n    }\n    return iu;\n}"
    ],
    [
      "public Node getNotSmaller(final T reference)  {\n    if (reference == null) {\n        return null;\n    }\n    Node node = top;\n    while (node != null) {\n        if (node.element.compareTo(reference) >= 0) {\n            return node;\n        }\n        node = node.getNext();\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    if (reference == null) {\n        return null;\n    }\n    if (top == null) {\n        return null;\n    }\n    Node node = top.getSmallest();\n    while (node != null) {\n        if (node.element.compareTo(reference) >= 0) {\n            return node;\n        }\n        node = node.getNext();\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    if (reference == null) {\n        return null;\n    }\n    if (top == null) {\n        return null;\n    }\n    Node node = top;\n    while (node != null) {\n        if (node.element.compareTo(reference) >= 0) {\n            return node;\n        }\n        node = node.getNext();\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    if (reference == null) {\n        return getSmallest();\n    }\n    Node node = getSmallest();\n    while (node != null && node.element.compareTo(reference) < 0) {\n        node = node.getNext();\n    }\n    return node;\n}",
      "public Node getNotSmaller(final T reference)  {\n        if (reference == null) {\n            return null;\n        }\n        Node node = top;\n        while (node != null) {\n            final int comparison = node.element.compareTo(reference);\n            if (comparison == 0) {\n                return node;\n            } else if (comparison > 0) {\n                node = node.getPrevious();\n            } else {\n                node = node.getNext();\n            }\n        }\n        return null;\n    }",
      "public Node getNotSmaller(final T reference)  {\n    if (reference == null) {\n        return getSmallest();\n    }\n    Node node = getSmallest();\n    while (node != null && node.element.compareTo(reference) < 0) {\n        node = node.getNext();\n    }\n    return node;\n}",
      "public Node getNotSmaller(final T reference)  {\n    if (reference == null) {\n        return null;\n    }\n    Node node = top;\n    while (node != null) {\n        final int comparison = node.element.compareTo(reference);\n        if (comparison == 0) {\n            return node;\n        } else if (comparison < 0) {\n            node = node.getNext();\n        } else {\n            return node.getPrevious();\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n        if (reference == null) {\n            return null;\n        }\n        Node node = top;\n        while (node != null) {\n            final int comparison = node.element.compareTo(reference);\n            if (comparison == 0) {\n                return node;\n            } else if (comparison < 0) {\n                node = node.getNext();\n            } else {\n                return node.getPrevious();\n            }\n        }\n        return null;\n    }",
      "public Node getNotSmaller(final T reference)  {\n    if (reference == null) {\n        return null;\n    }\n    Node node = getSmallest();\n    while (node != null && node.element.compareTo(reference) < 0) {\n        node = node.getNext();\n    }\n    return node;\n}",
      "public Node getNotSmaller(final T reference)  {\n        if (reference == null) {\n            return getSmallest();\n        }\n        Node node = top;\n        while (node != null) {\n            final int comparison = node.element.compareTo(reference);\n            if (comparison == 0) {\n                return node;\n            } else if (comparison > 0) {\n                node = node.getPrevious();\n            } else {\n                node = node.getNext();\n            }\n        }\n        return null;\n    }"
    ],
    [
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int index = indexOf(str);\n    while (index >= 0) {\n        delete(index, index + str.length());\n        index = indexOf(str, index);\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) \n    {\n        return this;\n    }\n    int index = indexOf(str);\n    while (index >= 0) \n    {\n        delete(index, index + str.length());\n        index = indexOf(str, index);\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) \n    {\n        return this;\n    }\n    int index = indexOf(str);\n    while (index >= 0) \n    {\n        delete(index, index + str.length());\n        index = indexOf(str, index);\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int index = indexOf(str);\n    while (index >= 0) {\n        delete(index, index + str.length());\n        index = indexOf(str, index);\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int index = indexOf(str, 0);\n    while (index >= 0) {\n        delete(index, index + str.length());\n        index = indexOf(str, index);\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int index = indexOf(str);\n    while (index >= 0) {\n        delete(index, index + str.length());\n        index = indexOf(str, index);\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int index = indexOf(str);\n    while (index >= 0) {\n        delete(index, index + str.length());\n        index = indexOf(str, index);\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) \n    {\n        return this;\n    }\n    int index = indexOf(str);\n    while (index >= 0) \n    {\n        delete(index, index + str.length());\n        index = indexOf(str, index);\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int index = indexOf(str, 0);\n    while (index >= 0) {\n        delete(index, index + str.length());\n        index = indexOf(str, index);\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) \n    {\n        return this;\n    }\n    int index = indexOf(str);\n    while (index >= 0) \n    {\n        delete(index, index + str.length());\n        index = indexOf(str, index);\n    }\n    return this;\n}"
    ],
    [
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  JSDocInfo jsDocInfo = node.getJSDocInfo();\n  if (jsDocInfo != null) {\n    if (jsDocInfo.hasType()) {\n      Node irNode = justTransform(node);\n      irNode.setJSDocInfo(jsDocInfo);\n      return irNode;\n    }\n  }\n  return transform(node);\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info != null) {\n    if (info.hasType()) {\n      // Create a cast node with the type annotation\n      Node castNode = newNode(Token.CAST, transform(node));\n      castNode.setJSType(info.getType());\n      return castNode;\n    }\n  }\n  return transform(node);\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = justTransform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) {\n      irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n  }",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = justTransform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) {\n      irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n  }",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info != null) {\n    // Inline JSDocInfo is only allowed on NAMEs in parameter or variable\n    // declarations.\n    if (node.getType() != com.google.javascript.rhino.head.Token.NAME\n        || !(node.getParent() instanceof Parameter\n            || node.getParent() instanceof VariableInitializer)) {\n      errorReporter.warning(INVALID_JSDOC_ON_NAMESPACE,\n          sourceName, node.getLineno(), \"\", 0);\n      return transform(node);\n    }\n\n    // The JSDocInfo is only valid if it's attached to a NAME node.\n    info = info.clone();\n    info.setAssociatedNode(node);\n    Node irNode = justTransform(node);\n    irNode.setJSDocInfo(info);\n    return irNode;\n  }\n\n  return transform(node);\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info != null) {\n    Node irNode = justTransform(node);\n    irNode.setJSDocInfo(info);\n    return irNode;\n  }\n  return transform(node);\n}"
    ],
    [
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    final Set<E> set = new HashSet<>(list);\n    final List<E> uniqueList = new ArrayList<>(set);\n    return new SetUniqueList<>(uniqueList);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    final Set<E> set = new HashSet<>(list);\n    final List<E> uniqueList = new ArrayList<>(set);\n    return new SetUniqueList<>(uniqueList);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<>(list);\n}"
    ],
    [
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.ARRAYLIT);\n  Node expr = null;\n  do {\n    if (expr != null) {\n      skipEOLs();\n      token = next();\n      Preconditions.checkState(\n          token == JsDocToken.COMMA || token == JsDocToken.RB);\n      skipEOLs();\n      token = next();\n    }\n    if (token == JsDocToken.ELLIPSIS) {\n      expr = newNode(Token.ELLIPSIS);\n      next();\n    } else {\n      expr = parseTypeExpression(token);\n    }\n    if (expr == null) {\n      return null;\n    }\n    arrayType.addChildToBack(expr);\n  } while (match(JsDocToken.COMMA));\n\n  skipEOLs();\n  if (!match(JsDocToken.RB)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n  }\n  next();\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node array = newNode(Token.ARRAYLIT);\n  do {\n    skipEOLs();\n    token = next();\n    if (match(JsDocToken.ELLIPSIS)) {\n      next();\n      array.addChildToBack(newNode(Token.ELLIPSIS));\n    }\n    Node expr = parseTypeExpression(token);\n    if (expr == null) {\n      return null;\n    }\n    array.addChildToBack(expr);\n  } while (match(JsDocToken.COMMA));\n  skipEOLs();\n  if (!match(JsDocToken.RB)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n  }\n  next();\n  return array;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.ARRAYLIT);\n    do {\n      skipEOLs();\n      token = next();\n      if (match(JsDocToken.ELLIPSIS)) {\n        arrayType.addChildToBack(newNode(Token.ELLIPSIS));\n        next();\n      } else {\n        Node typeExpression = parseTypeExpression(token);\n        if (typeExpression == null) {\n          return null;\n        }\n        arrayType.addChildToBack(typeExpression);\n      }\n    } while (match(JsDocToken.COMMA));\n\n    skipEOLs();\n    if (!match(JsDocToken.RB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n    return arrayType;\n  }",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.ARRAYLIT);\n  do {\n    skipEOLs();\n    token = next();\n    if (match(JsDocToken.ELLIPSIS)) {\n      arrayType.addChildToBack(newNode(Token.ELLIPSIS));\n      token = next();\n    }\n    Node elementType = parseTypeExpression(token);\n    if (elementType == null) {\n      return null;\n    }\n    arrayType.addChildToBack(elementType);\n  } while (match(JsDocToken.COMMA));\n\n  skipEOLs();\n  if (!match(JsDocToken.RB)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n  }\n  next();\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    skipEOLs();\n    if (!match(JsDocToken.LB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n    }\n    next();\n\n    Node arrayType = newNode(Token.ARRAYLIT);\n    Node elementType = null;\n    do {\n      skipEOLs();\n      token = next();\n      if (match(JsDocToken.ELLIPSIS)) {\n        elementType = parseTypeExpression(next());\n        if (elementType == null) {\n          return reportTypeSyntaxWarning(\"msg.jsdoc.missing.type\");\n        }\n        arrayType.addChildToBack(elementType);\n        skipEOLs();\n        if (!match(JsDocToken.RB)) {\n          return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n        }\n        next();\n        return arrayType;\n      }\n      elementType = parseTypeExpression(token);\n      if (elementType == null) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.type\");\n      }\n      arrayType.addChildToBack(elementType);\n      skipEOLs();\n    } while (match(JsDocToken.COMMA));\n\n    if (!match(JsDocToken.RB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n    return arrayType;\n  }",
      "private Node parseArrayType(JsDocToken token)  {\n    Node array = newNode(Token.ARRAYLIT);\n    do {\n      if (match(JsDocToken.ELLIPSIS)) {\n        next();\n        array.addChildToBack(newNode(Token.ELLIPSIS));\n      } else {\n        Node expr = parseTypeExpression(next());\n        if (expr == null) {\n          return null;\n        }\n        array.addChildToBack(expr);\n      }\n    } while (match(JsDocToken.COMMA));\n\n    skipEOLs();\n    if (!match(JsDocToken.RB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n    return array;\n  }",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.ARRAYLIT);\n  do {\n    skipEOLs();\n    token = next();\n    if (token == JsDocToken.RB) {\n      break;\n    }\n    if (match(JsDocToken.ELLIPSIS)) {\n      Node rest = newNode(Token.ELLIPSIS);\n      rest.addChildToBack(parseTypeExpression(next()));\n      arrayType.addChildToBack(rest);\n      continue;\n    }\n    Node expr = parseTypeExpression(token);\n    if (expr == null) {\n      return null;\n    }\n    arrayType.addChildToBack(expr);\n  } while (match(JsDocToken.COMMA));\n  skipEOLs();\n  if (!match(JsDocToken.RB)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n  }\n  next();\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    skipEOLs();\n    if (!match(JsDocToken.LB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n    }\n    next();\n    skipEOLs();\n\n    Node array = newNode(Token.ARRAYLIT);\n    Node expr = null;\n    do {\n      if (expr != null) {\n        skipEOLs();\n        token = next();\n        Preconditions.checkState(\n            token == JsDocToken.COMMA || token == JsDocToken.RB);\n        skipEOLs();\n        token = next();\n      }\n      if (match(JsDocToken.ELLIPSIS)) {\n        next();\n        skipEOLs();\n        token = next();\n        expr = parseTypeExpression(token);\n        if (expr == null) {\n          return null;\n        }\n        expr = newNode(Token.ELLIPSIS, expr);\n      } else {\n        expr = parseTypeExpression(token);\n        if (expr == null) {\n          return null;\n        }\n      }\n      array.addChildToBack(expr);\n    } while (match(JsDocToken.COMMA));\n\n    skipEOLs();\n    if (!match(JsDocToken.RB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n    return array;\n  }",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.ARRAYLIT);\n  do {\n    skipEOLs();\n    token = next();\n    if (match(JsDocToken.RB)) {\n      break;\n    }\n    if (match(JsDocToken.ELLIPSIS)) {\n      arrayType.addChildToBack(newNode(Token.ELLIPSIS));\n      skipEOLs();\n      token = next();\n    }\n    Node elementType = parseTypeExpression(token);\n    if (elementType == null) {\n      return null;\n    }\n    arrayType.addChildToBack(elementType);\n  } while (match(JsDocToken.COMMA));\n  skipEOLs();\n  if (!match(JsDocToken.RB)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n  }\n  next();\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.ARRAYLIT);\n  skipEOLs();\n  if (!match(JsDocToken.LB)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n  }\n  next();\n  skipEOLs();\n  if (match(JsDocToken.RB)) {\n    next();\n    return arrayType;\n  }\n\n  do {\n    if (match(JsDocToken.ELLIPSIS)) {\n      next();\n      Node elipsis = newNode(Token.ELLIPSIS);\n      elipsis.addChildToBack(parseTypeExpression(next()));\n      arrayType.addChildToBack(elipsis);\n    } else {\n      Node expr = parseTypeExpression(next());\n      if (expr == null) {\n        return null;\n      }\n      arrayType.addChildToBack(expr);\n    }\n    skipEOLs();\n  } while (match(JsDocToken.COMMA));\n\n  skipEOLs();\n  if (!match(JsDocToken.RB)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n  }\n  next();\n  return arrayType;\n}"
    ],
    [
      "public Vector3D getAxis()  {\n    return new Vector3D(q1, q2, q3).normalize();\n  }",
      "public Vector3D getAxis()  {\n\n    // Compute the axis\n    double x = 2 * (q1 * q1 + q2 * q2 - q0 * q0 - q3 * q3);\n    double y = 2 * (q2 * q3 + q0 * q1 - q0 * q3 - q1 * q2);\n    double z = 2 * (q1 * q3 - q0 * q2 + q0 * q1 + q2 * q3);\n\n    // Normalize the axis\n    double norm = FastMath.sqrt(x * x + y * y + z * z);\n    if (norm < 1.0e-10) {\n        return new Vector3D(1.0, 0.0, 0.0);\n    } else {\n        return new Vector3D(x / norm, y / norm, z / norm);\n    }\n\n}",
      "public Vector3D getAxis()  {\n    // compute the axis of the rotation\n    double norm = FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    if (norm < 1.0e-10) {\n        // the axis is null, we can return any vector\n        return new Vector3D(1.0, 0.0, 0.0);\n    }\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n}",
      "public Vector3D getAxis()  {\n    double norm = FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    if (norm == 0) {\n        return new Vector3D(1, 0, 0);\n    } else {\n        return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n    }\n}",
      "public Vector3D getAxis()  {\n    double norm = FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n}",
      "public Vector3D getAxis()  {\n    // compute the axis\n    final double norm = FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    if (norm == 0.0) {\n        return new Vector3D(1.0, 0.0, 0.0);\n    }\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n}",
      "public Vector3D getAxis()  {\n    // Compute the axis by normalizing the vectorial part of the quaternion\n    return new Vector3D(q1, q2, q3).normalize();\n}",
      "public Vector3D getAxis()  {\n    // compute the axis of the rotation\n    double x = 2.0 * (q1 * q1 + q2 * q2 - q0 * q0 - q3 * q3);\n    double y = 2.0 * (q2 * q3 - q0 * q1);\n    double z = 2.0 * (q0 * q2 + q1 * q3);\n    return new Vector3D(x, y, z);\n}",
      "public Vector3D getAxis()  {\n    return new Vector3D(q1, q2, q3).normalize();\n}",
      "public Vector3D getAxis()  {\n\n    // compute the axis from the quaternion\n    double n = FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    if (n == 0) {\n        return new Vector3D(1, 0, 0);\n    }\n    return new Vector3D(q1 / n, q2 / n, q3 / n);\n\n}"
    ],
    [
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n        if (bytes == null) {\n            return null;\n        }\n        int length = 0;\n        for (int i = 0; i < bytes.length; i++) {\n            final byte b = bytes[i];\n            if (b == ESCAPE_CHAR) {\n                try {\n                    if (bytes[i + 1] == ESCAPE_CHAR) {\n                        i++;\n                    } else {\n                        final int u = Character.digit((char) bytes[i + 1], RADIX);\n                        final int l = Character.digit((char) bytes[i + 2], RADIX);\n                        if (u == -1 || l == -1) {\n                            throw new DecoderException(\"Invalid URL encoding\");\n                        }\n                        final byte unescaped = (byte) ((u << 4) + l);\n                        bytes[length++] = unescaped;\n                        i += 2;\n                    }\n                } catch (final ArrayIndexOutOfBoundsException e) {\n                    throw new DecoderException(\"Invalid URL encoding\", e);\n                }\n            } else {\n                bytes[length++] = b;\n            }\n        }\n        final byte[] newBytes = new byte[length];\n        System.arraycopy(bytes, 0, newBytes, 0, length);\n        return newBytes;\n    }",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final byte[] data = new byte[2];\n                data[0] = bytes[++i];\n                data[1] = bytes[++i];\n                buffer.write((byte) Integer.parseInt(new String(data), RADIX));\n            } catch (final NumberFormatException e) {\n                throw new DecoderException(\"Invalid URL encoding: \", e);\n            }\n        } else {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final byte b1 = bytes[++i];\n                final byte b2 = bytes[++i];\n                b = (HEX_DECODING[(b1 >> 4) & 0xF] << 4) + HEX_DECODING[b1 & 0xF];\n                b = (b << 4) + HEX_DECODING[(b2 >> 4) & 0xF];\n                b = (b << 4) + HEX_DECODING[b2 & 0xF];\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding: \", e);\n            }\n        }\n        buffer.write(b);\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n        if (bytes == null) {\n            return null;\n        }\n        int length = 0;\n        for (final byte b : bytes) {\n            if (b == ESCAPE_CHAR) {\n                length++;\n            }\n        }\n        length++;\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream(length);\n        for (final byte c : bytes) {\n            if (c == ESCAPE_CHAR) {\n                try {\n                    final byte b = (byte) parseByte(new String(bytes, c, 2, StandardCharsets.UTF_8));\n                    buffer.write(b);\n                    c += 2;\n                } catch (final NumberFormatException e) {\n                    throw new DecoderException(\"Invalid URL encoding: \", e);\n                }\n            } else {\n                buffer.write(c);\n            }\n        }\n        return buffer.toByteArray();\n    }",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    int length = 0;\n    for (final byte b : bytes) {\n        if (b == ESCAPE_CHAR) {\n            length++;\n        }\n    }\n    length++;\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream(length);\n    for (final byte b : bytes) {\n        if (b == ESCAPE_CHAR) {\n            try {\n                final byte[] data = new byte[] {\n                        bytes[++length], bytes[++length]\n                };\n                buffer.write(URLCodec.unescape(data));\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding: \", e);\n            }\n        } else {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final byte b1 = bytes[++i];\n                final byte b2 = bytes[++i];\n                b = (HEX_DECODING[(b1)] << 4) + HEX_DECODING[(b2)];\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding: \", e);\n            }\n        }\n        buffer.write(b);\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n        if (bytes == null) {\n            return null;\n        }\n\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            int b = bytes[i];\n            if (b < 0) {\n                b = 256 + b;\n            }\n            if (b == ESCAPE_CHAR) {\n                try {\n                    final int u = Character.digit((char) bytes[++i], RADIX);\n                    final int l = Character.digit((char) bytes[++i], RADIX);\n                    if (u == -1 || l == -1) {\n                        throw new DecoderException(\"Invalid URL encoding\");\n                    }\n                    buffer.write((char) ((u << 4) + l));\n                } catch (final ArrayIndexOutOfBoundsException e) {\n                    throw new DecoderException(\"Invalid URL encoding\");\n                }\n            } else {\n                buffer.write(b);\n            }\n        }\n        return buffer.toByteArray();\n    }",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n        if (bytes == null) {\n            return null;\n        }\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            int b = bytes[i];\n            if (b == ESCAPE_CHAR) {\n                try {\n                    final byte b1 = bytes[++i];\n                    final byte b2 = bytes[++i];\n                    b = (HEX_DECODING[(b1)] << 4) + HEX_DECODING[(b2)];\n                } catch (final ArrayIndexOutOfBoundsException e) {\n                    throw new DecoderException(\"Invalid URL encoding: \", e);\n                }\n            }\n            buffer.write(b);\n        }\n        return buffer.toByteArray();\n    }",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        int b = bytes[i];\n        if (b < 0) {\n            b = 256 + b;\n        }\n        if (b == ESCAPE_CHAR) {\n            try {\n                final int u = Utils.digit16(bytes[++i]);\n                final int l = Utils.digit16(bytes[++i]);\n                b = ((u << 4) + l);\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding: \", e);\n            }\n        }\n        buffer.write(b);\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    int length = 0;\n    for (final byte b : bytes) {\n        if (b == ESCAPE_CHAR) {\n            length++;\n        }\n    }\n    if (length == 0) {\n        return bytes;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final int u = Utils.digit16(bytes[++i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding: \", e);\n            }\n        } else {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}"
    ],
    [
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}"
    ],
    [
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    List<DateTimeFieldType> types = partial.getFieldTypes();\n    if (types.size() < 2) {\n        return true;\n    }\n    DateTimeFieldType lastType = types.get(types.size() - 1);\n    DateTimeFieldType firstType = types.get(0);\n    if (lastType.getRangeDurationField().getType() != firstType) {\n        return false;\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size == 0) {\n        return false;\n    }\n    int[] values = partial.getValues();\n    int[] fields = partial.getFields();\n    for (int i = 1; i < size; i++) {\n        if (fields[i - 1].getRangeDurationField().getUnitMillis() != fields[i].getUnitMillis()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size == 0) {\n        return false;\n    }\n    int[] values = new int[size];\n    partial.get(values);\n    for (int i = 0; i < size - 1; i++) {\n        if (values[i] != values[i + 1]) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    List<DurationFieldType> types = partial.getFieldTypes();\n    int size = types.size();\n    if (size == 0) {\n        return false;\n    }\n    DurationFieldType previous = types.get(0);\n    for (int i = 1; i < size; i++) {\n        DurationFieldType current = types.get(i);\n        if (previous.getRangeDurationType() != current) {\n            return false;\n        }\n        previous = current;\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    List<DateTimeFieldType> fields = partial.getFieldTypes();\n    int size = fields.size();\n    if (size < 2) {\n        return true;\n    }\n    DateTimeFieldType lastField = fields.get(size - 1);\n    DateTimeFieldType nextField = fields.get(0);\n    if (lastField.getRangeDurationField().equals(nextField)) {\n        return true;\n    }\n    return false;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size == 0) {\n        return false;\n    }\n    int[] values = new int[size];\n    partial.get(values);\n    int[] ranges = partial.getFieldTypes();\n    for (int i = 0; i < size; i++) {\n        int range = ranges[i];\n        if (range == DateTimeFieldType.DAY_OF_MONTH.getFieldType()) {\n            if (values[i] != DateTimeFieldType.MONTH_OF_YEAR.getFieldType()) {\n                return false;\n            }\n        } else if (range == DateTimeFieldType.MONTH_OF_YEAR.getFieldType()) {\n            if (values[i] != DateTimeFieldType.YEAR.getFieldType()) {\n                return false;\n            }\n        } else if (range == DateTimeFieldType.YEAR.getFieldType()) {\n            if (values[i] != DateTimeFieldType.ERA.getFieldType()) {\n                return false;\n            }\n        } else if (range == DateTimeFieldType.ERA.getFieldType()) {\n            if (values[i] != DateTimeFieldType.YEAR_OF_ERA.getFieldType()) {\n                return false;\n            }\n        } else if (range == DateTimeFieldType.YEAR_OF_ERA.getFieldType()) {\n            if (values[i] != DateTimeFieldType.CENTURY_OF_ERA.getFieldType()) {\n                return false;\n            }\n        } else if (range == DateTimeFieldType.CENTURY_OF_ERA.getFieldType()) {\n            if (values[i] != DateTimeFieldType.MILLENNIUM_OF_ERA.getFieldType()) {\n                return false;\n            }\n        } else if (range == DateTimeFieldType.MILLENNIUM_OF_ERA.getFieldType()) {\n}\n}\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    List<DurationFieldType> types = partial.getFieldTypes();\n    int size = types.size();\n    if (size < 2) {\n        return true;\n    }\n    DurationFieldType lastType = types.get(size - 1);\n    DurationFieldType thisType = types.get(size - 2);\n    DurationFieldType nextType = types.get(size - 3);\n    return lastType.getRangeDurationType().equals(thisType) &&\n            thisType.getRangeDurationType().equals(nextType);\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size == 0) {\n        return false;\n    }\n    int[] values = new int[size];\n    partial.get(values);\n    int[] types = new int[size];\n    partial.get(types);\n    for (int i = 0; i < size - 1; i++) {\n        if (types[i] != types[i + 1]) {\n            return false;\n        }\n        if (values[i] != values[i + 1]) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size == 0) {\n        return false;\n    }\n    int[] values = partial.getValues();\n    for (int i = 0; i < size - 1; i++) {\n        if (values[i] != values[i + 1]) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size < 2) {\n        return true;\n    }\n    int[] values = new int[size];\n    partial.get(values);\n    DurationFieldType lastType = partial.getFieldType(size - 1);\n    DurationFieldType thisType = partial.getFieldType(0);\n    if (thisType.getRangeDurationType() != lastType) {\n        return false;\n    }\n    for (int i = 1; i < size; i++) {\n        thisType = partial.getFieldType(i);\n        if (thisType.getRangeDurationType() != lastType) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper.elements) {\n        helper.setCardinality(obj, Math.max(helper.getCardinality(obj, a), helper.getCardinality(obj, b)));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (O obj : helper) {\n        helper.setCardinality(obj, Math.max(helper.getCardinality(obj, a), helper.getCardinality(obj, b)));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, Math.max(helper.getCardinality(obj, a), helper.getCardinality(obj, b)));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper.elements) {\n        helper.setCardinality(obj, Math.max(helper.getCardinality(obj, a), helper.getCardinality(obj, b)));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (O obj : helper) {\n        helper.setCardinality(obj, Math.max(helper.getCardinality(obj), 1));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (O obj : helper) {\n        helper.setCardinality(obj, Math.max(helper.getCardinality(obj), 1));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper.elements) {\n        helper.setCardinality(obj, Math.max(helper.getCardinality(obj, a), helper.getCardinality(obj, b)));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, Math.max(helper.getCardinality(obj, a), helper.getCardinality(obj, b)));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, Math.max(Collections.frequency(a, obj), Collections.frequency(b, obj)));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, Math.max(helper.getCardinality(obj, a), helper.getCardinality(obj, b)));\n    }\n    return helper.list();\n}"
    ],
    [
      "private static List<Node> createStringsFromParamList(Node params)  {\n  Preconditions.checkArgument(params.isParamList());\n  List<Node> strings = Lists.newArrayList();\n  for (Node param : params.children()) {\n    if (param.isName()) {\n      strings.add(IR.string(param.getString()));\n    } else if (param.isRest()) {\n      strings.add(IR.string(\"...\"));\n    } else {\n      throw new IllegalArgumentException(\n          \"Unexpected param type: \" + param.getToken());\n    }\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    Preconditions.checkArgument(params.isParamList());\n    List<Node> strings = new ArrayList<Node>();\n    for (Node param : params.children()) {\n      strings.add(IR.string(param.getString()));\n    }\n    return strings;\n  }",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    Preconditions.checkArgument(params.isParamList());\n    List<Node> strings = Lists.newArrayList();\n    for (Node param : params.children()) {\n      if (param.isName()) {\n        strings.add(IR.string(param.getString()));\n      }\n    }\n    return strings;\n  }",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    Preconditions.checkArgument(params.isParamList());\n    List<Node> strings = Lists.newArrayList();\n    for (Node param : params.children()) {\n      if (param.isName()) {\n        strings.add(IR.string(param.getString()));\n      }\n    }\n    return strings;\n  }",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    Preconditions.checkArgument(params.isParamList());\n    List<Node> dependencies = Lists.newArrayList();\n    for (Node param : params.children()) {\n      if (param.isName()) {\n        dependencies.add(IR.string(param.getString()));\n      }\n    }\n    return dependencies;\n  }",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  Preconditions.checkArgument(params.isParamList());\n  List<Node> result = new ArrayList<Node>();\n  for (Node child = params.getFirstChild();\n       child != null;\n       child = child.getNext()) {\n    result.add(IR.string(child.getString()));\n  }\n  return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  Preconditions.checkArgument(params.isParamList());\n  List<Node> dependencies = Lists.newArrayList();\n  for (Node param : params.children()) {\n    if (param.isName()) {\n      dependencies.add(IR.string(param.getString()));\n    }\n  }\n  return dependencies;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  Preconditions.checkArgument(params.isParamList());\n  List<Node> dependencies = Lists.newArrayList();\n  for (Node param : params.children()) {\n    if (param.isName()) {\n      dependencies.add(IR.string(param.getString()));\n    }\n  }\n  return dependencies;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  Preconditions.checkArgument(params.isParamList());\n  List<Node> dependencies = new ArrayList<Node>();\n  for (Node param : params.children()) {\n    if (param.isName()) {\n      dependencies.add(IR.string(param.getString()));\n    }\n  }\n  return dependencies;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    Preconditions.checkArgument(params.isParamList());\n    List<Node> strings = new ArrayList<Node>();\n    for (Node param : params.children()) {\n      if (param.isName()) {\n        strings.add(IR.string(param.getString()));\n      }\n    }\n    return strings;\n  }"
    ],
    [
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}"
    ],
    [
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null || str.isEmpty()) {\n        return str;\n    }\n    str = capitalize(str, delimiters);\n    return str.substring(0, 1).toUpperCase() + str.substring(1);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    str = capitalize(str, delimiters);\n    return capitalize(str, ' ');\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    str = capitalize(str, delimiters);\n    return capitalize(str, ' ');\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) \n    {\n        return str;\n    }\n    str = capitalize(str, delimiters);\n    return str.substring(0, 1).toUpperCase() + str.substring(1);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    str = capitalize(str, delimiters);\n    return capitalize(str, ' ');\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    str = capitalize(str, delimiters);\n    return capitalize(str, ' ');\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    str = capitalize(str, delimiters);\n    char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    str = capitalize(str, delimiters);\n    char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    str = capitalize(str, delimiters);\n    return capitalize(str, ' ');\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) \n    {\n        return str;\n    }\n    str = capitalize(str, delimiters);\n    return str.substring(0, 1).toUpperCase() + str.substring(1);\n}"
    ],
    [
      "private static synchronized String getConvertedId(String id)  {\n    //-----------------------------------------------------------------------\n    //  Check if the id is already in the new style\n    //-----------------------------------------------------------------------\n    if (id.startsWith(\"UTC\") || id.startsWith(\"GMT\") || id.startsWith(\"Etc/GMT\") || id.startsWith(\"Etc/UTC\")) \n    {\n        return id;\n    }\n    //-----------------------------------------------------------------------\n    //  Check if the id is in the old style\n    //-----------------------------------------------------------------------\n    else if (id.startsWith(\"+\") || id.startsWith(\"-\")) \n    {\n        //-------------------------------------------------------------------\n        //  Get the offset\n        //-------------------------------------------------------------------\n        int offset = Integer.parseInt(id.substring(1));\n        //-------------------------------------------------------------------\n        //  Get the name\n        //-------------------------------------------------------------------\n        String name = \"GMT\";\n        if (offset != 0) \n        {\n            name += offset;\n        }\n        //-------------------------------------------------------------------\n        //  Return the new style id\n        //-------------------------------------------------------------------\n        return name;\n    }\n    //-----------------------------------------------------------------------\n    //  Check if the id is in the old style\n    //-----------------------------------------------------------------------\n    else if (id.startsWith(\"GMT\") || id.startsWith(\"Etc/GMT\")) \n    {\n        //-------------------------------------------------------------------\n        //  Get the offset\n        //-------------------------------------------------------------------\n        int offset = Integer.parseInt(id.substring(3));\n        //-------------------------------------------------------------------\n        //  Get the name\n        //-------------------------------------------------------------------\n        String name = \"GMT\";\n        if (offset != 0) \n        {\n            name += offset;\n        }\n        //-------------------------------------------------------------------\n        //  Return the new style id\n        //-------------------------------------------------------------------\n        return name;\n    }\n    //-----------------------------------------------------------------------\n    //  Check if the id is in the old style\n    //-----------------------------------------------------------------------\n    else if (id.startsWith(\"UTC\")) \n    {\n        //-------------------------------------------------------------------\n        //  Get the offset\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    // TODO: implement this method\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    if (cOldToNew.containsKey(id)) {\n        return cOldToNew.get(id);\n    }\n    String newId = null;\n    if (id.startsWith(\"GMT\") || id.startsWith(\"UTC\")) {\n        newId = id;\n    } else if (id.startsWith(\"UT\")) {\n        newId = \"UTC\" + id.substring(2);\n    } else if (id.startsWith(\"CT\")) {\n        newId = \"CET\" + id.substring(2);\n    } else if (id.startsWith(\"EST\") || id.startsWith(\"EDT\")) {\n        newId = \"Etc/GMT\" + id.substring(3);\n    } else if (id.startsWith(\"CST\") || id.startsWith(\"CDT\")) {\n        newId = \"Etc/GMT\" + id.substring(3) + \"5\";\n    } else if (id.startsWith(\"MST\") || id.startsWith(\"MDT\")) {\n        newId = \"Etc/GMT\" + id.substring(3) + \"7\";\n    } else if (id.startsWith(\"PST\") || id.startsWith(\"PDT\")) {\n        newId = \"Etc/GMT\" + id.substring(3) + \"8\";\n    } else if (id.startsWith(\"A\")) {\n        newId = \"Etc/GMT\" + id.substring(1);\n    } else if (id.startsWith(\"GMT0\")) {\n        newId = \"Etc/GMT\" + id.substring(4);\n    } else if (id.startsWith(\"GMT-\") || id.startsWith(\"GMT+\")) {\n        newId = \"Etc/GMT\" + id.substring(3);\n    } else if (id.startsWith(\"GMT\")) {\n        newId = \"Etc/GMT\" + id.substring(3);\n    } else if (id.startsWith(\"UT-\") || id.startsWith(\"UT+\")) {\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cOldMappings == null) \n    {\n        cOldMappings = new HashMap<String, String>();\n        cOldMappings.put(\"ACT\", \"Australia/Darwin\");\n        cOldMappings.put(\"AET\", \"Australia/Sydney\");\n        cOldMappings.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n        cOldMappings.put(\"ART\", \"Africa/Cairo\");\n        cOldMappings.put(\"AST\", \"America/Anchorage\");\n        cOldMappings.put(\"BET\", \"America/Sao_Paulo\");\n        cOldMappings.put(\"BST\", \"Asia/Dhaka\");\n        cOldMappings.put(\"CAT\", \"Africa/Harare\");\n        cOldMappings.put(\"CNT\", \"America/St_Johns\");\n        cOldMappings.put(\"CST\", \"America/Chicago\");\n        cOldMappings.put(\"CTT\", \"Asia/Shanghai\");\n        cOldMappings.put(\"EAT\", \"Africa/Addis_Ababa\");\n        cOldMappings.put(\"ECT\", \"America/Guayaquil\");\n        cOldMappings.put(\"IET\", \"America/Indiana/Indianapolis\");\n        cOldMappings.put(\"IST\", \"Asia/Kolkata\");\n        cOldMappings.put(\"JST\", \"Asia/Tokyo\");\n        cOldMappings.put(\"MIT\", \"Pacific/Apia\");\n        cOldMappings.put(\"NET\", \"Asia/Yerevan\");\n        cOldMappings.put(\"NST\", \"Pacific/Auckland\");\n        cOldMappings.put(\"PLT\", \"Asia/Karachi\");\n        cOldMappings.put(\"PNT\", \"America/Phoenix\");\n        cOldMappings.put(\"PRT\", \"America/Puerto_Rico\");\n        cOldMappings.put(\"PST\", \"America/Los_Angeles\");\n        cOldMappings.put(\"SST\", \"Pacific/Guadalcanal\");\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    //-----------------------------------------------------------------------\n    // check input\n    //-----------------------------------------------------------------------\n    if (id == null) {\n        return null;\n    }\n\n    //-----------------------------------------------------------------------\n    // check cache\n    //-----------------------------------------------------------------------\n    String convertedId = cConvertedIds.get(id);\n    if (convertedId != null) {\n        return convertedId;\n    }\n\n    //-----------------------------------------------------------------------\n    // check for UTC\n    //-----------------------------------------------------------------------\n    if (id.equals(\"UTC\")) {\n        convertedId = \"Etc/UTC\";\n    } else if (id.equals(\"GMT\")) {\n        convertedId = \"Etc/GMT\";\n    } else if (id.equals(\"GMT+0\")) {\n        convertedId = \"Etc/GMT+0\";\n    } else if (id.equals(\"GMT-0\")) {\n        convertedId = \"Etc/GMT-0\";\n    } else if (id.equals(\"GMT0\")) {\n        convertedId = \"Etc/GMT+0\";\n    } else if (id.equals(\"Greenwich\")) {\n        convertedId = \"Etc/GMT\";\n    } else if (id.equals(\"UCT\")) {\n        convertedId = \"Etc/UTC\";\n    } else if (id.equals(\"Universal\")) {\n        convertedId = \"Etc/UTC\";\n    } else if (id.equals(\"Zulu\")) {\n        convertedId = \"Etc/UTC\";\n    } else if (id.equals(\"WET\")) {\n        convertedId = \"Etc/GMT\";\n    } else if (id.equals(\"W-SU\")) {\n        convertedId = \"Etc/GMT+1\";\n    } else if (id.equals(\"CET\")) {\n        convertedId = \"Europe/Paris\";\n    } else if (id.equals(\"MET\")) {\n        convertedId = \"Europe/Paris\";\n    } else if (id.equals(\"Mitteleuropaeische Zeit\")) {\n        convertedId = \"Europe/Paris\";\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cOldToNewIds == null) \n    {\n        cOldToNewIds = new HashMap<String, String>();\n        cOldToNewIds.put(\"ACT\", \"Australia/Darwin\");\n        cOldToNewIds.put(\"AET\", \"Australia/Sydney\");\n        cOldToNewIds.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n        cOldToNewIds.put(\"ART\", \"Africa/Cairo\");\n        cOldToNewIds.put(\"AST\", \"America/Anchorage\");\n        cOldToNewIds.put(\"BET\", \"America/Sao_Paulo\");\n        cOldToNewIds.put(\"BST\", \"Asia/Dhaka\");\n        cOldToNewIds.put(\"CAT\", \"Africa/Harare\");\n        cOldToNewIds.put(\"CNT\", \"America/St_Johns\");\n        cOldToNewIds.put(\"CST\", \"America/Chicago\");\n        cOldToNewIds.put(\"CTT\", \"Asia/Shanghai\");\n        cOldToNewIds.put(\"EAT\", \"Africa/Addis_Ababa\");\n        cOldToNewIds.put(\"ECT\", \"America/Guayaquil\");\n        cOldToNewIds.put(\"IET\", \"America/Indiana/Indianapolis\");\n        cOldToNewIds.put(\"IST\", \"Asia/Kolkata\");\n        cOldToNewIds.put(\"JST\", \"Asia/Tokyo\");\n        cOldToNewIds.put(\"MIT\", \"Pacific/Apia\");\n        cOldToNewIds.put(\"NET\", \"Asia/Yerevan\");\n        cOldToNewIds.put(\"NST\", \"Pacific/Auckland\");\n        cOldToNewIds.put(\"PLT\", \"Asia/Karachi\");\n        cOldToNewIds.put(\"PNT\", \"America/Phoenix\");\n        cOldToNewIds.put(\"PRT\", \"America/Puerto_Rico\");\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cOldToNew.containsKey(id))\n    {\n        return cOldToNew.get(id);\n    }\n    else\n    {\n        return null;\n    }\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    String newId = cOldToNewIds.get(id);\n    if (newId == null) {\n        newId = cNewToOldIds.get(id);\n    }\n    return newId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cOldToNew.containsKey(id)) \n    {\n        return cOldToNew.get(id);\n    } \n    else \n    {\n        String newId = null;\n        try \n        {\n            newId = cNameProvider.getTimeZoneId(id);\n        } \n        catch (SecurityException ex) \n        {\n            // ignored\n        }\n\n        if (newId == null) \n        {\n            try \n            {\n                newId = cNameProvider.getTimeZoneId(id, null);\n            } \n            catch (SecurityException ex) \n            {\n                // ignored\n            }\n        }\n\n        if (newId == null) \n        {\n            try \n            {\n                newId = cNameProvider.getTimeZoneId(id, Locale.ENGLISH);\n            } \n            catch (SecurityException ex) \n            {\n                // ignored\n            }\n        }\n\n        if (newId == null) \n        {\n            try \n            {\n                newId = cNameProvider.getTimeZoneId(id, Locale.US);\n            } \n            catch (SecurityException ex) \n            {\n                // ignored\n            }\n        }\n\n        if (newId == null) \n        {\n            try \n            {\n                newId = cNameProvider.getTimeZoneId(id, Locale.UK);\n            } \n            catch (SecurityException ex) \n            {\n                // ignored\n            }\n        }\n\n        if (newId == null) \n        {\n            try \n            {\n                newId = cNameProvider.getTimeZoneId(id, Locale.ROOT);\n            } \n            catch (SecurityException ex) \n            {\n                // ignored\n            }\n        }\n\n        cOldToNew.put(id, newId);\n        return newId;\n    }\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cOldMappings == null) \n    {\n        cOldMappings = new HashMap<String, String>();\n        cOldMappings.put(\"GMT\", \"UTC\");\n        cOldMappings.put(\"UTC\", \"UTC\");\n        cOldMappings.put(\"WET\", \"WET\");\n        cOldMappings.put(\"BST\", \"BST\");\n        cOldMappings.put(\"MET\", \"CET\");\n        cOldMappings.put(\"MEWT\", \"WET\");\n        cOldMappings.put(\"MEST\", \"CEST\");\n        cOldMappings.put(\"MESZ\", \"CEST\");\n        cOldMappings.put(\"FWT\", \"WET\");\n        cOldMappings.put(\"FST\", \"CET\");\n        cOldMappings.put(\"FST\", \"CEST\");\n        cOldMappings.put(\"EST\", \"EST\");\n        cOldMappings.put(\"EET\", \"EET\");\n        cOldMappings.put(\"MIT\", \"Pacific/Apia\");\n        cOldMappings.put(\"HST\", \"Pacific/Honolulu\");\n        cOldMappings.put(\"AST\", \"America/Anchorage\");\n        cOldMappings.put(\"ADT\", \"America/Halifax\");\n        cOldMappings.put(\"NST\", \"America/St_Johns\");\n        cOldMappings.put(\"CST\", \"America/Chicago\");\n        cOldMappings.put(\"CDT\", \"America/Chicago\");\n        cOldMappings.put(\"MST\", \"America/Denver\");\n        cOldMappings.put(\"MDT\", \"America/Denver\");\n        cOldMappings.put(\"PST\", \"America/Los_Angeles\");\n        cOldMappings.put(\"PDT\", \"America/Los_Angeles\");\n        cOldMappings.put(\"AKST\", \"America/Juneau\");\n        cOldMappings.put(\"AKDT\", \"America/Juneau\");\n        cOldMappings.put(\"HDT\", \"Pacific/Honolulu\");\n}\n}"
    ],
    [
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    // TODO: Compute the weighted Jacobian matrix.\n    return null;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n        final RealMatrix jacobian = jF.computeJacobian(params);\n        final int nR = jacobian.getRowDimension();\n        final int nC = jacobian.getColumnDimension();\n        final RealMatrix weightedJacobian = MatrixUtils.createRealMatrix(nR, nC);\n        for (int i = 0; i < nR; i++) {\n            for (int j = 0; j < nC; j++) {\n                weightedJacobian.setEntry(i, j, weightMatrixSqrt.getEntry(i, j) * jacobian.getEntry(i, j));\n            }\n        }\n        return weightedJacobian;\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    // TODO: Implement this method\n    return null;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    // Compute the Jacobian matrix.\n    final RealMatrix jacobian = jF.computeJacobian(params);\n\n    // Compute the weighted Jacobian: W^1/2 J.\n    return weightMatrixSqrt.multiply(jacobian);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    return weightMatrixSqrt.multiply(jF.computeJacobian(params));\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    // Compute the Jacobian matrix.\n    final RealMatrix jacobian = jF.computeJacobian(params);\n\n    // Compute the square-root of the weight matrix.\n    final RealMatrix weightMatrixSqrt = this.weightMatrixSqrt;\n\n    // Compute the weighted Jacobian: W<sup>1/2</sup> J.\n    return weightMatrixSqrt.multiply(jacobian);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n        // TODO\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final RealMatrix jacobian = jF.computeJacobian(params);\n    return weightMatrixSqrt.multiply(jacobian);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    return weightMatrixSqrt.multiply(jF.computeJacobian(params));\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    // TODO: implement this method\n    return null;\n}"
    ],
    [
      "private int least()  {\n    start();\n    int leastIndex = -1;\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i)) {\n            if (leastIndex == -1) {\n                leastIndex = i;\n            } else {\n                if (comparator.compare(values.get(i), values.get(leastIndex)) < 0) {\n                    leastIndex = i;\n                }\n            }\n        } else {\n            if (!set(i)) {\n                valueSet.clear(i);\n            } else {\n                if (leastIndex == -1) {\n                    leastIndex = i;\n                } else {\n                    if (comparator.compare(values.get(i), values.get(leastIndex)) < 0) {\n                        leastIndex = i;\n                    }\n                }\n            }\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    if (comparator == null) \n    {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    start();\n    int leastIndex = -1;\n    for (int i = 0; i < iterators.size(); i++) \n    {\n        if (!valueSet.get(i)) \n        {\n            if (!set(i)) \n            {\n                continue;\n            }\n        }\n        if (leastIndex == -1) \n        {\n            leastIndex = i;\n        } \n        else \n        {\n            if (comparator.compare(values.get(i), values.get(leastIndex)) < 0) \n            {\n                leastIndex = i;\n            }\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    start();\n    int leastIndex = -1;\n    for (int i = 0; i < iterators.size(); i++) {\n        if (!valueSet.get(i)) {\n            if (!set(i)) {\n                continue;\n            }\n        }\n        if (leastIndex == -1) {\n            leastIndex = i;\n            continue;\n        }\n        final E v1 = values.get(i);\n        final E v2 = values.get(leastIndex);\n        if (comparator.compare(v1, v2) < 0) {\n            leastIndex = i;\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n        start();\n        if (comparator == null) {\n            throw new NullPointerException(\"No comparator has been set\");\n        }\n        int leastIndex = -1;\n        for (int i = 0; i < iterators.size(); i++) {\n            if (!valueSet.get(i)) {\n                if (!set(i)) {\n                    continue;\n                }\n            }\n            if (leastIndex == -1) {\n                leastIndex = i;\n            } else {\n                final int comparison = comparator.compare(values.get(i), values.get(leastIndex));\n                if (comparison < 0) {\n                    leastIndex = i;\n                }\n            }\n        }\n        return leastIndex;\n    }",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    start();\n    int leastIndex = -1;\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i)) {\n            if (leastIndex == -1) {\n                leastIndex = i;\n            } else {\n                if (comparator.compare(values.get(i), values.get(leastIndex)) < 0) {\n                    leastIndex = i;\n                }\n            }\n        } else {\n            if (!set(i)) {\n                valueSet.clear(i);\n            } else {\n                if (leastIndex == -1) {\n                    leastIndex = i;\n                } else {\n                    if (comparator.compare(values.get(i), values.get(leastIndex)) < 0) {\n                        leastIndex = i;\n                    }\n                }\n            }\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    start();\n    int leastIndex = -1;\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i)) {\n            if (leastIndex == -1) {\n                leastIndex = i;\n            } else {\n                if (comparator.compare(values.get(i), values.get(leastIndex)) < 0) {\n                    leastIndex = i;\n                }\n            }\n        } else {\n            if (!set(i)) {\n                valueSet.clear(i);\n            } else {\n                if (leastIndex == -1) {\n                    leastIndex = i;\n                } else {\n                    if (comparator.compare(values.get(i), values.get(leastIndex)) < 0) {\n                        leastIndex = i;\n                    }\n                }\n            }\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    start();\n    int leastIndex = -1;\n    for (int i = 0; i < iterators.size(); i++) {\n        if (!valueSet.get(i)) {\n            if (!set(i)) {\n                continue;\n            }\n        }\n        if (leastIndex == -1) {\n            leastIndex = i;\n            continue;\n        }\n        if (comparator.compare(values.get(i), values.get(leastIndex)) < 0) {\n            leastIndex = i;\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    start();\n    int leastIndex = -1;\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i)) {\n            if (leastIndex == -1) {\n                leastIndex = i;\n            } else {\n                if (comparator.compare(values.get(i), values.get(leastIndex)) < 0) {\n                    leastIndex = i;\n                }\n            }\n        } else {\n            if (!set(i)) {\n                valueSet.clear(i);\n            } else {\n                if (leastIndex == -1) {\n                    leastIndex = i;\n                } else {\n                    if (comparator.compare(values.get(i), values.get(leastIndex)) < 0) {\n                        leastIndex = i;\n                    }\n                }\n            }\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    start();\n    int leastIndex = -1;\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i)) {\n            if (leastIndex == -1) {\n                leastIndex = i;\n            } else {\n                if (comparator.compare(values.get(i), values.get(leastIndex)) < 0) {\n                    leastIndex = i;\n                }\n            }\n        } else {\n            if (!set(i)) {\n                valueSet.clear(i);\n            } else {\n                if (leastIndex == -1) {\n                    leastIndex = i;\n                } else {\n                    if (comparator.compare(values.get(i), values.get(leastIndex)) < 0) {\n                        leastIndex = i;\n                    }\n                }\n            }\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    start();\n    int leastIndex = -1;\n    for (int i = 0; i < values.size(); i++) {\n        if (!valueSet.get(i)) {\n            if (set(i)) {\n                leastIndex = i;\n            }\n        } else if (leastIndex == -1) {\n            leastIndex = i;\n        } else if (comparator.compare(values.get(i), values.get(leastIndex)) < 0) {\n            leastIndex = i;\n        }\n    }\n    return leastIndex;\n}"
    ],
    [
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    // TODO: Implement this method\n    return null;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    // TODO: Implement this method\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    // TODO: Implement this method\n    return null;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    // TODO: Implement this method\n    return null;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_ATTRIBUTE) {\n            return new AttributeNodePointer(parentPointer, step.getNodeTest());\n        }\n        if (axis == Compiler.AXIS_NAMESPACE) {\n            return new NamespaceNodePointer(parentPointer, step.getNodeTest());\n        }\n        return new ChildNodePointer(parentPointer, step.getNodeTest());\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        // TODO: Implement this method\n        return null;\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        // TODO: Implement this method\n        return null;\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        NodePointer childPointer = null;\n        switch (step.getAxis()) {\n            case Compiler.AXIS_ATTRIBUTE:\n                childPointer = parentPointer.getAttributePointer(\n                        step.getLocalName(), step.getNamespaceURI());\n                break;\n            case Compiler.AXIS_CHILD:\n                childPointer = parentPointer.getChildPointer();\n                break;\n            case Compiler.AXIS_NAMESPACE:\n                childPointer = parentPointer.getNamespacePointer();\n                break;\n            case Compiler.AXIS_PARENT:\n                childPointer = parentPointer.getParentPointer();\n                break;\n            case Compiler.AXIS_SELF:\n                childPointer = parentPointer;\n                break;\n            default:\n                throw new IllegalStateException(\n                        \"Unsupported axis: \" + step.getAxis());\n        }\n        return childPointer;\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    // Create the child pointer\n    NodePointer childPointer = null;\n    switch (step.getAxis()) {\n        case Compiler.AXIS_ATTRIBUTE:\n            childPointer = parentPointer.getAttributePointer(step.getLocalName());\n            break;\n        case Compiler.AXIS_CHILD:\n            childPointer = parentPointer.getChildPointer();\n            break;\n        case Compiler.AXIS_NAMESPACE:\n            childPointer = parentPointer.getNamespacePointer(step.getLocalName());\n            break;\n        case Compiler.AXIS_SELF:\n            childPointer = parentPointer.getSelfPointer();\n            break;\n        default:\n            throw new IllegalStateException(\n                \"Unknown axis: \" + step.getAxis());\n    }\n    return childPointer;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    NodePointer childPointer = null;\n    switch (step.getAxis()) {\n        case Compiler.AXIS_CHILD:\n            childPointer = new ChildNodePointer(\n                    parentPointer,\n                    step.getNodeTest().getNodeType(),\n                    step.getNodeTest().getNamespace(),\n                    step.getNodeTest().getLocalName());\n            break;\n        case Compiler.AXIS_ATTRIBUTE:\n            childPointer = new AttributeNodePointer(\n                    parentPointer,\n                    step.getNodeTest().getNodeType(),\n                    step.getNodeTest().getNamespace(),\n                    step.getNodeTest().getLocalName());\n            break;\n        case Compiler.AXIS_NAMESPACE:\n            childPointer = new NamespaceNodePointer(\n                    parentPointer,\n                    step.getNodeTest().getNodeType(),\n                    step.getNodeTest().getNamespace(),\n                    step.getNodeTest().getLocalName());\n            break;\n        default:\n            throw new IllegalStateException(\"Unsupported axis\");\n    }\n    return childPointer;\n}"
    ],
    [
      "public double getInf()  {\n    final BSPTree<Euclidean1D> tree = getTree(false);\n    if (tree.getCut() == null) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    final OrientedPoint lower = (OrientedPoint) tree.getCut().getHyperplane();\n    if (lower.getLocation().getX() == Double.NEGATIVE_INFINITY) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    return lower.getLocation().getX();\n}",
      "public double getInf()  {\n        if (getTree(false).getCut() == null) {\n            return Double.NEGATIVE_INFINITY;\n        } else {\n            for (final Interval interval : asList()) {\n                if (interval.getInf() != Double.NEGATIVE_INFINITY) {\n                    return interval.getInf();\n                }\n            }\n            return Double.POSITIVE_INFINITY;\n        }\n    }",
      "public double getInf()  {\n    final BSPTree<Euclidean1D> tree = getTree(false);\n    if (tree.getCut() == null) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    final OrientedPoint cut = (OrientedPoint) tree.getCut().getHyperplane();\n    if (cut.getLocation().getX() == Double.NEGATIVE_INFINITY) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    return Double.POSITIVE_INFINITY;\n}",
      "public double getInf()  {\n    // TODO: implement this method\n}",
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        return Double.NEGATIVE_INFINITY;\n    } else {\n        double inf = Double.POSITIVE_INFINITY;\n        for (final Interval interval : asList()) {\n            if (interval.getInf() < inf) {\n                inf = interval.getInf();\n            }\n        }\n        return inf;\n    }\n}",
      "public double getInf()  {\n    // implement here\n}",
      "public double getInf()  {\n    final BSPTree<Euclidean1D> tree = getTree(false);\n    if (tree.getCut() == null) {\n        return Double.POSITIVE_INFINITY;\n    }\n    final SubHyperplane<Euclidean1D> cut = tree.getCut();\n    if (cut.getHyperplane().getOffset(((OrientedPoint) cut.getHyperplane()).getLocation()) < 0) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    final double lower = ((OrientedPoint) cut.getHyperplane()).getLocation().getX();\n    return lower;\n}",
      "public double getInf()  {\n    final BSPTree<Euclidean1D> tree = getTree(false);\n    if (tree.getCut() == null) {\n        return Double.POSITIVE_INFINITY;\n    }\n    final OrientedPoint lower = (OrientedPoint) tree.getCut().getHyperplane();\n    if (lower.getLocation().getX() < 0) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    return lower.getLocation().getX();\n}",
      "public double getInf()  {\n        final BSPTree<Euclidean1D> tree = getTree(false);\n        if (tree.getCut() == null) {\n            return Double.NEGATIVE_INFINITY;\n        }\n        final SubHyperplane<Euclidean1D> cut = tree.getCut();\n        if (cut.getHyperplane().getOffset(((OrientedPoint) cut.getHyperplane()).getLocation()) < 0) {\n            return Double.NEGATIVE_INFINITY;\n        }\n        return ((OrientedPoint) cut.getHyperplane()).getLocation().getX();\n    }",
      "public double getInf()  {\n    // Find the lowest value in the tree\n    return Double.NEGATIVE_INFINITY;\n}"
    ],
    [
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n        return new TextStrategy(field, definingCalendar);\n    }",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get(locale);\n    if (strategy == null) \n    {\n        strategy = field == Calendar.ZONE_OFFSET ? new TimeZoneStrategy(locale) : new CaseInsensitiveTextStrategy(field, definingCalendar, locale);\n        Strategy inCache = cache.putIfAbsent(locale, strategy);\n        if (inCache != null) \n        {\n            return inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    Strategy strategy= cache.get(locale);\n    if(strategy==null) {\n        strategy= field==Calendar.ZONE_OFFSET ?new TimeZoneStrategy() :new CaseInsensitiveTextStrategy(field, definingCalendar);\n        final Strategy actual= cache.putIfAbsent(locale, strategy);\n        if(actual!=null) {\n            return actual;\n        }\n    }\n    return strategy;\n}"
    ],
    [
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        final E object = iterator.next();\n        if (predicate.evaluate(object)) {\n            nextObject = object;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        final E object = iterator.next();\n        if (predicate.test(object)) {\n            nextObject = object;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        final E next = iterator.next();\n        if (predicate.test(next)) {\n            nextObject = next;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        final E object = iterator.next();\n        if (predicate.evaluate(object)) {\n            nextObject = object;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        nextObject = iterator.next();\n        if (predicate.evaluate(nextObject)) {\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        nextObject = iterator.next();\n        if (predicate.evaluate(nextObject)) {\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        final E next = iterator.next();\n        if (predicate.test(next)) {\n            nextObject = next;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        final E object = iterator.next();\n        if (predicate.evaluate(object)) {\n            nextObject = object;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        nextObject = iterator.next();\n        if (predicate.test(nextObject)) {\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    nextObject = null;\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        final E object = iterator.next();\n        if (predicate.test(object)) {\n            nextObject = object;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}"
    ],
    [
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    final double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) \n    {\n        if (x[i] < lB[i]) \n        {\n            repaired[i] = lB[i];\n        } \n        else if (x[i] > uB[i]) \n        {\n            repaired[i] = uB[i];\n        } \n        else \n        {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    for (int i = 0; i < x.length; i++) \n    {\n        if (x[i] < lB[i]) \n        {\n            x[i] = lB[i];\n        }\n        if (x[i] > uB[i]) \n        {\n            x[i] = uB[i];\n        }\n    }\n    return x;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n            final double[] lB = CMAESOptimizer.this.getLowerBound();\n            final double[] uB = CMAESOptimizer.this.getUpperBound();\n            final double[] repaired = x.clone();\n\n            for (int i = 0; i < x.length; i++) {\n                if (x[i] < lB[i]) {\n                    repaired[i] = lB[i];\n                }\n                if (x[i] > uB[i]) {\n                    repaired[i] = uB[i];\n                }\n            }\n            return repaired;\n        }",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n            final double[] lB = CMAESOptimizer.this.getLowerBound();\n            final double[] uB = CMAESOptimizer.this.getUpperBound();\n            final double[] repaired = new double[x.length];\n\n            for (int i = 0; i < x.length; i++) {\n                if (x[i] < lB[i]) {\n                    repaired[i] = lB[i];\n                } else if (x[i] > uB[i]) {\n                    repaired[i] = uB[i];\n                } else {\n                    repaired[i] = x[i];\n                }\n            }\n            return repaired;\n        }",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    final double[] repaired = x.clone();\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        }\n        if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    for (int i = 0; i < x.length; i++) \n    {\n        if (x[i] < lB[i]) \n        {\n            repaired[i] = lB[i];\n        } \n        else if (x[i] > uB[i]) \n        {\n            repaired[i] = uB[i];\n        } \n        else \n        {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    for (int i = 0; i < x.length; i++) \n    {\n        if (x[i] < lB[i]) \n        {\n            x[i] = lB[i];\n        }\n        if (x[i] > uB[i]) \n        {\n            x[i] = uB[i];\n        }\n    }\n    return x;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}"
    ],
    [
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    transformer.transform();\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n        final SchurTransformer transformer = new SchurTransformer(matrix);\n        transformer.transform();\n        return transformer;\n    }",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    transformer.transform();\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n        SchurTransformer transformer = new SchurTransformer(matrix);\n        transformer.transform();\n        return transformer;\n    }",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    transformer.transform();\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n        final int n = matrix.getRowDimension();\n        final double[][] h = matrix.getData();\n        final double[][] z = new double[n][n];\n        final double[] e = new double[n];\n        final double[] realEigenvalues = new double[n];\n        final double[] imagEigenvalues = new double[n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                z[i][j] = 0;\n            }\n            z[i][i] = 1;\n        }\n        for (int i = 0; i < n; i++) {\n            e[i] = h[i][i];\n            realEigenvalues[i] = h[i][i];\n            imagEigenvalues[i] = 0;\n        }\n        int m = n - 1;\n        int j = 0;\n        for (int i = 0; i < n; i++) {\n            int k;\n            double p;\n            for (k = i; k < m; k++) {\n                if (FastMath.abs(h[k + 1][k]) <= Precision.EPSILON * (FastMath.abs(h[k][k]) + FastMath.abs(h[k + 1][k + 1]))) {\n                    break;\n                }\n            }\n            if (k != i) {\n                p = h[i][i];\n                h[i][i] = h[k][k];\n                h[k][k] = p;\n                for (int j = 0; j < n; j++) {\n                    p = z[j][i];\n                    z[j][i] = z[j][k];\n                    z[j][k] = p;\n                }\n            }\n            int its = 0;\n            do {\n                its++;\n                for (m = i; m < n - 1; m++) {\n                    double z = h[m][m];\n}\n}\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    transformer.transform();\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    transformer.transform();\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final SchurTransformer transformer = new SchurTransformer(matrix);\n    transformer.transform();\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final SchurTransformer transformer = new SchurTransformer(matrix);\n    transformer.transform();\n    return transformer;\n}"
    ],
    [
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        final long value = values[i];\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((value & (1 << j)) != 0) {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        long current = values[i];\n        while (current != 0) {\n            final int index = Long.numberOfTrailingZeros(current);\n            current &= ~(1L << index);\n            result.add(enumClass.getEnumConstants()[i * Long.SIZE + index]);\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        final long l = values[i];\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((l & (1 << j)) != 0) {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        long current = values[i];\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((current & 1) == 1) {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n            }\n            current >>>= 1;\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    Validate.notNull(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    final E[] constants = enumClass.getEnumConstants();\n    for (int i = 0; i < values.length; i++) {\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((values[i] & (1 << j)) != 0) {\n                result.add(constants[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    ArrayUtils.reverse(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((values[i] & (1L << j)) != 0) {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        long current = values[i];\n        while (current != 0) {\n            final int index = Long.numberOfTrailingZeros(current);\n            current &= ~(1L << index);\n            result.add(enumClass.getEnumConstants()[Long.SIZE * i + index]);\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    ArrayUtils.reverse(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final E constant : enumClass.getEnumConstants()) {\n        final int ordinal = constant.ordinal();\n        if ((values[ordinal / Long.SIZE] & (1L << (ordinal % Long.SIZE))) != 0) {\n            result.add(constant);\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final E constant : enumClass.getEnumConstants()) {\n        final int ordinal = constant.ordinal();\n        if ((values[ordinal / Long.SIZE] & (1 << (ordinal % Long.SIZE))) != 0) {\n            result.add(constant);\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    ArrayUtils.reverse(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((values[i] & (1 << j)) != 0) {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}"
    ],
    [
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    int offset = getOffset(oldInstant);\n    long instantLocal = oldInstant + offset;\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    int newOffset = newZone.getOffset(instantLocal);\n    long instantNew = instantLocal - newOffset;\n    if (instantNew - instantLocal != newOffset - offset) {\n        throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n    }\n    return instantNew;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    // Convert to local millis\n    long localInstant = convertUTCToLocal(oldInstant);\n    // Convert back to UTC millis\n    long newInstant = newZone.convertLocalToUTC(localInstant, false);\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    int offset = getOffset(oldInstant);\n    long instantLocal = oldInstant + offset;\n    int offsetLocal = newZone.getOffset(instantLocal);\n    long instantNew = instantLocal - offsetLocal;\n    if (instantNew - instantLocal != 0) {\n        throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n    }\n    return instantNew;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    int offset = getOffset(oldInstant);\n    long instantLocal = oldInstant + offset;\n    int offsetNew = newZone.getOffset(instantLocal);\n    long instantNew = instantLocal - offsetNew;\n    return instantNew;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    int offset = getOffset(oldInstant);\n    long instantLocal = oldInstant + offset;\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    int offsetNew = newZone.getOffset(instantLocal);\n    long instantNew = instantLocal - offsetNew;\n    if (instantNew < oldInstant) {\n        throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n    }\n    return instantNew;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    // convert to local millis\n    long localInstant = convertUTCToLocal(oldInstant);\n    // convert back to UTC millis\n    long newInstant = convertLocalToUTC(localInstant, newZone);\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    // convert to local millis\n    long localInstant = convertUTCToLocal(oldInstant);\n    // convert back to UTC millis in new zone\n    long newInstant = newZone.convertLocalToUTC(localInstant, false);\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    // Get the local millis from the UTC millis\n    long localMillis = convertUTCToLocal(oldInstant);\n    // Get the UTC millis from the local millis in the new zone\n    long newInstant = newZone.convertLocalToUTC(localMillis, false);\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    int offset = getOffset(oldInstant);\n    long instantLocal = oldInstant + offset;\n    int offsetNew = newZone.getOffset(instantLocal);\n    long instantNew = instantLocal - offsetNew;\n    return instantNew;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = DateTimeZone.getDefault();\n    }\n    long newInstant = newZone.convertUTCToLocal(oldInstant);\n    newInstant = newZone.convertLocalToUTC(newInstant, false);\n    return newInstant;\n}"
    ],
    [
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance();\n    calendar.setTime(date);\n    DateTickUnitType t = unit.getUnitType();\n    if (t.equals(DateTickUnitType.SECOND)) \n    {\n        int seconds = calendar.get(Calendar.SECOND);\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.set(Calendar.SECOND, seconds + unit.getSize());\n        return calendar.getTime();\n    } \n    else if (t.equals(DateTickUnitType.MINUTE)) \n    {\n        int minutes = calendar.get(Calendar.MINUTE);\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MINUTE, minutes + unit.getSize());\n        return calendar.getTime();\n    } \n    else if (t.equals(DateTickUnitType.HOUR)) \n    {\n        int hours = calendar.get(Calendar.HOUR_OF_DAY);\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.HOUR_OF_DAY, hours + unit.getSize());\n        return calendar.getTime();\n    } \n    else if (t.equals(DateTickUnitType.DAY)) \n    {\n        int days = calendar.get(Calendar.DAY_OF_MONTH);\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.DAY_OF_MONTH, days + unit.getSize());\n        return calendar.getTime();\n    } \n    else if (t.equals(DateTickUnitType.WEEK)) \n    {\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Date result = null;\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    DateTickUnitType t = unit.getUnitType();\n    if (t.equals(DateTickUnitType.SECOND)) \n    {\n        int seconds = calendar.get(Calendar.SECOND);\n        int value = unit.getMultiple();\n        int hours = calendar.get(Calendar.HOUR_OF_DAY);\n        int minutes = calendar.get(Calendar.MINUTE);\n        if (this.tickMarkPosition == DateTickMarkPosition.START) \n        {\n            seconds = value;\n        } \n        else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) \n        {\n            seconds = value / 2;\n        } \n        else \n        {\n            seconds = value - 1;\n        }\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(Calendar.SECOND, seconds);\n        calendar.set(Calendar.MINUTE, minutes);\n        calendar.set(Calendar.HOUR_OF_DAY, hours);\n        result = calendar.getTime();\n        if (result.getTime() <= date.getTime()) \n        {\n            calendar.add(Calendar.SECOND, value);\n            result = calendar.getTime();\n        }\n    } \n    else if (t.equals(DateTickUnitType.MINUTE)) \n    {\n        int minutes = calendar.get(Calendar.MINUTE);\n        int value = unit.getMultiple();\n        int hours = calendar.get(Calendar.HOUR_OF_DAY);\n        if (this.tickMarkPosition == DateTickMarkPosition.START) \n        {\n            minutes = value;\n        } \n        else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) \n        {\n            minutes = value / 2;\n        } \n        else \n        {\n            minutes = value - 1;\n        }\n        calendar.clear(Calendar.MILLISECOND);\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance();\n    calendar.setTime(date);\n    int value = unit.getUnit();\n    DateTickUnitType t = unit.getUnitType();\n    if (t.equals(DateTickUnitType.SECOND)) \n    {\n        int seconds = calendar.get(Calendar.SECOND);\n        if (this.tickMarkPosition == DateTickMarkPosition.START) \n        {\n            seconds = 0;\n        }\n        else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) \n        {\n            seconds = 30;\n        }\n        else \n        {\n            seconds = 59;\n        }\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(Calendar.SECOND, seconds);\n        Date d1 = calendar.getTime();\n        if (d1.getTime() >= date.getTime()) \n        {\n            calendar.set(Calendar.SECOND, seconds - 1);\n            d1 = calendar.getTime();\n        }\n        return d1;\n    }\n    else if (t.equals(DateTickUnitType.MINUTE)) \n    {\n        int minutes = calendar.get(Calendar.MINUTE);\n        if (this.tickMarkPosition == DateTickMarkPosition.START) \n        {\n            minutes = 0;\n        }\n        else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) \n        {\n            minutes = 30;\n        }\n        else \n        {\n            minutes = 59;\n        }\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(Calendar.MINUTE, minutes);\n        Date d2 = calendar.getTime();\n        if (d2.getTime() >= date.getTime()) \n        {\n            calendar.set(Calendar.MINUTE, minutes - 1);\n            d2 = calendar.getTime();\n        }\n        return d2;\n    }\n    else if (t.equals(DateTickUnitType.HOUR)) \n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Date result = null;\n    if (unit.getUnitType() == DateTickUnitType.SECOND) \n    {\n        result = new Date(date.getTime() + unit.getSize() * 1000);\n    } \n    else if (unit.getUnitType() == DateTickUnitType.MINUTE) \n    {\n        result = new Date(date.getTime() + unit.getSize() * 60 * 1000);\n    } \n    else if (unit.getUnitType() == DateTickUnitType.HOUR) \n    {\n        result = new Date(date.getTime() + unit.getSize() * 60 * 60 * 1000);\n    } \n    else if (unit.getUnitType() == DateTickUnitType.DAY) \n    {\n        result = new Date(date.getTime() + unit.getSize() * 24 * 60 * 60 * 1000);\n    } \n    else if (unit.getUnitType() == DateTickUnitType.WEEK) \n    {\n        result = new Date(date.getTime() + unit.getSize() * 7 * 24 * 60 * 60 * 1000);\n    } \n    else if (unit.getUnitType() == DateTickUnitType.MONTH) \n    {\n        result = new Date(date.getTime() + unit.getSize() * 30 * 24 * 60 * 60 * 1000);\n    } \n    else if (unit.getUnitType() == DateTickUnitType.YEAR) \n    {\n        result = new Date(date.getTime() + unit.getSize() * 365 * 24 * 60 * 60 * 1000);\n    }\n    return result;\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Date result = null;\n    DateTickUnitType t = unit.getUnitType();\n    if (t.equals(DateTickUnitType.SECOND)) \n    {\n        int seconds = unit.getMultiple();\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(date);\n        int value = calendar.get(Calendar.SECOND);\n        value = value + seconds;\n        calendar.set(Calendar.SECOND, value);\n        result = calendar.getTime();\n    }\n    else if (t.equals(DateTickUnitType.MINUTE)) \n    {\n        int minutes = unit.getMultiple();\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(date);\n        int value = calendar.get(Calendar.MINUTE);\n        value = value + minutes;\n        calendar.set(Calendar.MINUTE, value);\n        result = calendar.getTime();\n    }\n    else if (t.equals(DateTickUnitType.HOUR)) \n    {\n        int hours = unit.getMultiple();\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(date);\n        int value = calendar.get(Calendar.HOUR_OF_DAY);\n        value = value + hours;\n        calendar.set(Calendar.HOUR_OF_DAY, value);\n        result = calendar.getTime();\n    }\n    else if (t.equals(DateTickUnitType.DAY)) \n    {\n        int days = unit.getMultiple();\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(date);\n        int value = calendar.get(Calendar.DAY_OF_MONTH);\n        value = value + days;\n        calendar.set(Calendar.DAY_OF_MONTH, value);\n        result = calendar.getTime();\n    }\n    else if (t.equals(DateTickUnitType.MONTH)) \n    {\n        int months = unit.getMultiple();\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(date);\n        int value = calendar.get(Calendar.MONTH);\n        value = value + months;\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    // TODO: Implement this method\n    return null;\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Date result = null;\n    DateTickUnitType t = unit.getUnitType();\n    if (t.equals(DateTickUnitType.SECOND)) {\n        int seconds = unit.getMultiple();\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.add(Calendar.SECOND, seconds);\n        result = calendar.getTime();\n    }\n    else if (t.equals(DateTickUnitType.MINUTE)) {\n        int minutes = unit.getMultiple();\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.add(Calendar.MINUTE, minutes);\n        result = calendar.getTime();\n    }\n    else if (t.equals(DateTickUnitType.HOUR)) {\n        int hours = unit.getMultiple();\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.add(Calendar.HOUR, hours);\n        result = calendar.getTime();\n    }\n    else if (t.equals(DateTickUnitType.DAY)) {\n        int days = unit.getMultiple();\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.add(Calendar.DATE, days);\n        result = calendar.getTime();\n    }\n    else if (t.equals(DateTickUnitType.WEEK)) {\n        int weeks = unit.getMultiple();\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.set(Calendar.MILLISECOND, 0);\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    DateTickUnitType t = unit.getUnitType();\n    if (t.equals(DateTickUnitType.SECOND)) \n    {\n        int seconds = calendar.get(Calendar.SECOND);\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(Calendar.SECOND, seconds + unit.getSize());\n        Date d1 = calendar.getTime();\n        if (d1.getTime() >= date.getTime()) \n        {\n            calendar.set(Calendar.SECOND, seconds);\n            d1 = calendar.getTime();\n        }\n        return d1;\n    }\n    else if (t.equals(DateTickUnitType.MINUTE)) \n    {\n        int minutes = calendar.get(Calendar.MINUTE);\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(Calendar.MINUTE, minutes + unit.getSize());\n        Date d2 = calendar.getTime();\n        if (d2.getTime() >= date.getTime()) \n        {\n            calendar.set(Calendar.MINUTE, minutes);\n            d2 = calendar.getTime();\n        }\n        return d2;\n    }\n    else if (t.equals(DateTickUnitType.HOUR)) \n    {\n        int hours = calendar.get(Calendar.HOUR_OF_DAY);\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(Calendar.HOUR_OF_DAY, hours + unit.getSize());\n        Date d3 = calendar.getTime();\n        if (d3.getTime() >= date.getTime()) \n        {\n            calendar.set(Calendar.HOUR_OF_DAY, hours);\n            d3 = calendar.getTime();\n        }\n        return d3;\n    }\n    else if (t.equals(DateTickUnitType.DAY)) \n    {\n        int days = calendar.get(Calendar.DAY_OF_MONTH);\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Date result = null;\n    DateTickUnitType t = unit.getUnitType();\n    if (t.equals(DateTickUnitType.SECOND)) \n    {\n        int seconds = unit.getUnitSize();\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        int value = calendar.get(Calendar.SECOND);\n        value = (value / seconds) * seconds;\n        if (this.tickMarkPosition == DateTickMarkPosition.START) \n        {\n            value = 0;\n        }\n        else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) \n        {\n            value = seconds / 2;\n        }\n        else if (this.tickMarkPosition == DateTickMarkPosition.END) \n        {\n            value = seconds - 1;\n        }\n        calendar.set(Calendar.SECOND, value);\n        calendar.set(Calendar.MILLISECOND, 0);\n        result = calendar.getTime();\n    } \n    else if (t.equals(DateTickUnitType.MINUTE)) \n    {\n        int minutes = unit.getUnitSize();\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        int value = calendar.get(Calendar.MINUTE);\n        value = (value / minutes) * minutes;\n        if (this.tickMarkPosition == DateTickMarkPosition.START) \n        {\n            value = 0;\n        }\n        else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) \n        {\n            value = minutes / 2;\n        }\n        else if (this.tickMarkPosition == DateTickMarkPosition.END) \n        {\n            value = minutes - 1;\n        }\n        calendar.set(Calendar.MINUTE, value);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MILLISECOND, 0);\n        result = calendar.getTime();\n    }\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    // COMPLETE THIS FUNCTION\n}"
    ],
    [
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    // use the variable resolver to get the value\n    final String value = getVariableResolver().resolve(variableName);\n    if (value == null) \n    {\n        // variable unknown\n        return null;\n    }\n    // check that the value does not contain the start or end characters\n    if (value.indexOf(getStartVariableChar()) >= 0 || value.indexOf(getEndVariableChar()) >= 0) \n    {\n        throw new IllegalStateException(\"Variable resolver returned value containing start or end variable character\");\n    }\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final String value = getVariableResolver().resolve(variableName);\n    if (value == null) {\n        final StrBuilder unknown = new StrBuilder(endPos - startPos + 16);\n        unknown.append(buf.buffer(), startPos, endPos);\n        getLogger().warn(\"Unknown property: {}\", unknown);\n    }\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n        final StrLookup<?> resolver = getVariableResolver();\n        if (resolver == null) {\n            return null;\n        }\n        final String value = resolver.lookup(variableName);\n        if (value == null) {\n            return null;\n        }\n        return value;\n    }",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final StrLookup<?> resolver = getVariableResolver();\n    if (resolver == null) {\n        return null;\n    }\n    final String value = resolver.lookup(variableName);\n    if (value == null) {\n        return null;\n    }\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    // Replace with your code\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    // use the resolver to get the value\n    final String value = getVariableResolver().resolve(variableName);\n    if (value == null) {\n        // variable unknown\n        return null;\n    }\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    // Implement this method to return the value of the variable.\n    // The implementation should use the variableName and buf parameters to\n    // determine the variable's value.\n    // If the variable is unknown, then return null.\n    // The implementation may use the startPos and endPos parameters if required.\n    // For example, the implementation may need to check the variable's prefix and suffix.\n    // The implementation may also need to check the variable's name against a list of known variables.\n    // The implementation may also need to use the buf parameter to extract the variable's value from the buffer.\n    // The implementation should not alter the buf parameter.\n    // The implementation should not return a value that contains any prefix or suffix.\n    // The implementation should not return a value that contains any variable references.\n    // The implementation should not return a value that contains any escaped characters.\n    // The implementation should not return a value that contains any unresolved variables.\n    // The implementation should not return a value that contains any malformed variables.\n    // The implementation should not return a value that contains any circular references.\n    // The implementation should not return a value that contains any infinite loops.\n    // The implementation should not return a value that contains any invalid values.\n    // The implementation should not return a value that contains any null values.\n    // The implementation should not return a value that contains any empty values.\n    // The implementation should not return a value that contains any whitespace values.\n    // The implementation should not return a value that contains any non-printable characters.\n    // The implementation should not return a value that contains any non-ASCII characters.\n    // The implementation should not return a value that contains any control characters.\n    // The implementation should not return a value that contains any non-alphanumeric characters.\n    // The implementation should not return a value that contains any non-alphanumeric characters.\n    // The implementation should not return a value that contains any non-alphanumeric characters.\n    // The implementation should not return a value that contains any non-alphanumeric characters.\n    // The implementation should not return a value that contains any non-alphanumeric characters.\n    // The implementation should not return a value that contains any non-alphanumeric characters.\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final String value = getVariableResolver().resolve(variableName);\n    if (value == null) {\n        if (isEnableUndefinedVariableException()) {\n            throw new IllegalArgumentException(\"No value defined for variable: \" + variableName);\n        }\n        return null;\n    }\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n        final String value = getVariableResolver().resolve(variableName);\n        if (value == null) {\n            return null;\n        }\n        return value;\n    }",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n        // resolve the variable\n        final String varValue = getVariableResolver().resolve(variableName);\n        if (varValue != null) {\n            // recursive replace\n            final int varLen = varValue.length();\n            buf.replace(startPos, endPos, varValue);\n            altered = true;\n            int change = substitute(buf, startPos, varLen, priorVariables);\n            change = change + varLen - (endPos - startPos);\n            pos += change;\n            bufEnd += change;\n            lengthChange += change;\n            chars = buf.buffer; // in case buffer was altered\n        }\n        return varValue;\n    }"
    ],
    [
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = SoundexUtils.clean(str);\n    if (str.length() == 0) {\n        return str;\n    }\n    char[] soundex = {str.charAt(0)};\n    int length = 0;\n    for (int i = 1; i < str.length(); i++) {\n        char c = map(str.charAt(i));\n        if (c != '0') {\n            soundex[length] = c;\n            length++;\n        }\n    }\n    return new String(soundex, 0, length);\n}",
      "public String soundex(String str)  {\n        if (str == null) {\n            return null;\n        }\n        str = SoundexUtils.clean(str);\n        if (str.length() == 0) {\n            return str;\n        }\n        final char[] chars = str.toUpperCase().toCharArray();\n        final StringBuilder builder = new StringBuilder();\n        builder.append(chars[0]);\n        for (int i = 1; i < chars.length; i++) {\n            final char ch = chars[i];\n            if (ch != 'H' && ch != 'W') {\n                builder.append(map(ch));\n            }\n        }\n        return builder.toString();\n    }",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = SoundexUtils.clean(str);\n    if (str.length() == 0) {\n        return str;\n    }\n    char[] sArr = new char[str.length()];\n    sArr = str.toUpperCase().toCharArray();\n    char[] soundexArr = new char[this.maxLength];\n    soundexArr[0] = sArr[0];\n    int soundexArrIdx = 1;\n    for (int i = 1; i < sArr.length; i++) {\n        char c = sArr[i];\n        char mappedChar = this.map(c);\n        if (mappedChar != '0') {\n            if (mappedChar != soundexArr[soundexArrIdx - 1]) {\n                soundexArr[soundexArrIdx] = mappedChar;\n                soundexArrIdx++;\n            }\n        }\n    }\n    return new String(soundexArr, 0, soundexArrIdx);\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = SoundexUtils.clean(str);\n    if (str.length() == 0) {\n        return str;\n    }\n    char[] sArr = str.toUpperCase().toCharArray();\n    char[] result = new char[this.maxLength];\n    char last = '*';\n    int count = 0;\n    for (char c : sArr) {\n        char mapped = map(c);\n        if (mapped != 0) {\n            if (mapped != last) {\n                result[count] = mapped;\n                count++;\n            }\n            last = mapped;\n        }\n    }\n    return new String(result, 0, count);\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = SoundexUtils.clean(str);\n    if (str.length() == 0) {\n        return str;\n    }\n    char[] chars = str.toUpperCase().toCharArray();\n    StringBuilder sb = new StringBuilder();\n    sb.append(chars[0]);\n    for (int i = 1; i < chars.length; i++) {\n        char c = chars[i];\n        char mapped = map(c);\n        if (mapped != '0') {\n            sb.append(mapped);\n        }\n    }\n    return sb.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = SoundexUtils.clean(str);\n    if (str.length() == 0) {\n        return str;\n    }\n    char[] soundex = {str.charAt(0)};\n    int length = 0;\n    for (int i = 1; i < str.length(); i++) {\n        char c = str.charAt(i);\n        if (Character.isWhitespace(c)) {\n            continue;\n        }\n        char mapped = map(c);\n        if (mapped != '0') {\n            if (mapped != soundex[length]) {\n                soundex[++length] = mapped;\n            }\n        }\n    }\n    return new String(soundex, 0, length + 1);\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = SoundexUtils.clean(str);\n    if (str.length() == 0) {\n        return str;\n    }\n    final char[] chars = str.toUpperCase().toCharArray();\n    final StringBuilder sb = new StringBuilder();\n    sb.append(chars[0]);\n    for (int i = 1; i < chars.length; i++) {\n        final char c = map(chars[i]);\n        if (c != '0') {\n            sb.append(c);\n        }\n    }\n    while (sb.length() < this.maxLength) {\n        sb.append('0');\n    }\n    return sb.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = SoundexUtils.clean(str);\n    if (str.length() == 0) {\n        return str;\n    }\n    final char[] soundex = { '0', '0', '0', '0' };\n    char last = '\\0';\n    for (int i = 0; i < str.length(); i++) {\n        final char c = str.charAt(i);\n        if (Character.isWhitespace(c)) {\n            continue;\n        }\n        final char mapped = map(c);\n        if (mapped != 0) {\n            if (mapped != last) {\n                soundex[soundex.length - 1] = mapped;\n                if (soundex[0] == '0') {\n                    soundex[0] = mapped;\n                }\n                last = mapped;\n            }\n        }\n    }\n    return new String(soundex);\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = SoundexUtils.clean(str);\n    if (str.length() == 0) {\n        return str;\n    }\n    char[] soundex = {str.charAt(0)};\n    int length = 0;\n    for (int i = 1; i < str.length(); i++) {\n        char c = map(str.charAt(i));\n        if (c != '0') {\n            if (length < this.maxLength) {\n                soundex[length++] = c;\n            }\n        }\n    }\n    return new String(soundex, 0, length);\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = SoundexUtils.clean(str);\n    if (str.length() == 0) {\n        return str;\n    }\n    char[] soundex = {str.charAt(0)};\n    for (int i = 1; i < str.length(); i++) {\n        char c = map(str.charAt(i));\n        if (c != '0') {\n            soundex = SoundexUtils.append(soundex, c);\n        }\n    }\n    return new String(soundex);\n}"
    ],
    [
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == Integer.class) {\n        return CORE_TYPE_INT;\n    } else if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    } else if (clz == Boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    } else if (clz == Double.class) {\n        return CORE_TYPE_DOUBLE;\n    } else if (clz == Float.class) {\n        return CORE_TYPE_FLOAT;\n    } else if (clz == Short.class) {\n        return CORE_TYPE_SHORT;\n    } else if (clz == Byte.class) {\n        return CORE_TYPE_BYTE;\n    } else if (clz == Character.class) {\n        return CORE_TYPE_CHAR;\n    } else if (clz == Void.class) {\n        return CORE_TYPE_VOID;\n    } else {\n        return null;\n    }\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == Integer.class) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    }\n    if (clz == Boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    }\n    if (clz == Double.class) {\n        return CORE_TYPE_DOUBLE;\n    }\n    if (clz == Float.class) {\n        return CORE_TYPE_FLOAT;\n    }\n    if (clz == Byte.class) {\n        return CORE_TYPE_BYTE;\n    }\n    if (clz == Short.class) {\n        return CORE_TYPE_SHORT;\n    }\n    if (clz == Character.class) {\n        return CORE_TYPE_CHAR;\n    }\n    if (clz == Void.class) {\n        return CORE_TYPE_VOID;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // first, let's check if we have a \"well-known\" type\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == Boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    } else if (clz == Integer.class) {\n        return CORE_TYPE_INT;\n    } else if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    } else if (clz == Double.class) {\n        return CORE_TYPE_DOUBLE;\n    } else if (clz == Float.class) {\n        return CORE_TYPE_FLOAT;\n    } else if (clz == Byte.class) {\n        return CORE_TYPE_BYTE;\n    } else if (clz == Character.class) {\n        return CORE_TYPE_CHAR;\n    } else if (clz == Short.class) {\n        return CORE_TYPE_SHORT;\n    } else if (clz == Void.class) {\n        return CORE_TYPE_VOID;\n    } else if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    } else if (clz == Class.class) {\n        return CORE_TYPE_CLASS;\n    } else if (clz == Throwable.class) {\n        return CORE_TYPE_THROWABLE;\n    } else if (clz == Exception.class) {\n        return CORE_TYPE_EXCEPTION;\n    } else if (clz == RuntimeException.class) {\n        return CORE_TYPE_RUNTIME_EXCEPTION;\n    } else if (clz == Error.class) {\n        return CORE_TYPE_ERROR;\n    } else if (clz == Iterable.class) {\n        return CORE_TYPE_ITERABLE;\n    } else if (clz == Iterator.class) {\n        return CORE_TYPE_ITERATOR;\n    } else if (clz == Enum.class) {\n        return CORE_TYPE_ENUM;\n}\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // TODO: implement\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // We only know about a few, hard-coded ones, for now\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == Integer.class) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    }\n    if (clz == Boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    }\n    if (clz == Double.class) {\n        return CORE_TYPE_DOUBLE;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == Integer.class) {\n        return CORE_TYPE_INT;\n    } else if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    } else if (clz == Boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    } else if (clz == Double.class) {\n        return CORE_TYPE_DOUBLE;\n    } else if (clz == Float.class) {\n        return CORE_TYPE_FLOAT;\n    } else if (clz == Byte.class) {\n        return CORE_TYPE_BYTE;\n    } else if (clz == Short.class) {\n        return CORE_TYPE_SHORT;\n    } else if (clz == Character.class) {\n        return CORE_TYPE_CHAR;\n    } else if (clz == Void.class) {\n        return CORE_TYPE_VOID;\n    } else if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // ok to use ==, since we know we are only called with exact matches\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == Boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    } else if (clz == Integer.class) {\n        return CORE_TYPE_INT;\n    } else if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    } else if (clz == Double.class) {\n        return CORE_TYPE_DOUBLE;\n    } else if (clz == Float.class) {\n        return CORE_TYPE_FLOAT;\n    } else if (clz == Short.class) {\n        return CORE_TYPE_SHORT;\n    } else if (clz == Byte.class) {\n        return CORE_TYPE_BYTE;\n    } else if (clz == Character.class) {\n        return CORE_TYPE_CHAR;\n    } else if (clz == BigDecimal.class) {\n        return CORE_TYPE_BIG_DECIMAL;\n    } else if (clz == BigInteger.class) {\n        return CORE_TYPE_BIG_INTEGER;\n    } else if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    } else if (clz == Void.class) {\n        return CORE_TYPE_VOID;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // TODO: implement this method\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == Integer.class) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    }\n    if (clz == Double.class) {\n        return CORE_TYPE_DOUBLE;\n    }\n    if (clz == Boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    }\n    if (clz == Byte.class) {\n        return CORE_TYPE_BYTE;\n    }\n    if (clz == Short.class) {\n        return CORE_TYPE_SHORT;\n    }\n    if (clz == Float.class) {\n        return CORE_TYPE_FLOAT;\n    }\n    if (clz == Character.class) {\n        return CORE_TYPE_CHAR;\n    }\n    if (clz == Void.class) {\n        return CORE_TYPE_VOID;\n    }\n    if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == Integer.class) {\n        return CORE_TYPE_INT;\n    } else if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    } else if (clz == Double.class) {\n        return CORE_TYPE_DOUBLE;\n    } else if (clz == Boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    } else if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    } else {\n        return null;\n    }\n}"
    ],
    [
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isExprResult() && n.getFirstChild().isAssign() && n.getFirstChild().getFirstChild().isGetProp() && n.getFirstChild().getFirstChild().getFirstChild().isName() && n.getFirstChild().getFirstChild().getFirstChild().getString().equals(\"prototype\"))\n    {\n        return new PrototypeMemberDeclaration(n.getFirstChild().getFirstChild(), n);\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n      if (!n.isExprResult()) {\n        return null;\n      }\n      Node lhs = n.getFirstChild();\n      if (!lhs.isAssign()) {\n        return null;\n      }\n      Node rhs = lhs.getLastChild();\n      if (!rhs.isQualifiedName()) {\n        return null;\n      }\n      if (!rhs.getString().equals(\"prototype\")) {\n        return null;\n      }\n      return new PrototypeMemberDeclaration(lhs, n);\n    }",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.isExprResult() && n.getFirstChild().isAssign()) {\n    Node lhs = n.getFirstChild().getFirstChild();\n    if (lhs.isGetProp() && lhs.getFirstChild().isName() &&\n        lhs.getLastChild().getString().equals(\"prototype\")) {\n      return new PrototypeMemberDeclaration(lhs, n);\n    }\n  }\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.isExprResult() && n.getFirstChild().isAssign() &&\n      n.getFirstChild().getFirstChild().isGetProp() &&\n      n.getFirstChild().getFirstChild().getFirstChild().isName() &&\n      n.getFirstChild().getFirstChild().getFirstChild().getString().equals(\"prototype\")) {\n    return new PrototypeMemberDeclaration(\n        n.getFirstChild().getFirstChild(), n);\n  }\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n      if (!n.isExprResult()) {\n        return null;\n      }\n      Node lhs = n.getFirstChild();\n      if (!lhs.isAssign()) {\n        return null;\n      }\n      Node rhs = lhs.getLastChild();\n      if (!rhs.isGetProp()) {\n        return null;\n      }\n      if (!rhs.getLastChild().getString().equals(\"prototype\")) {\n        return null;\n      }\n      return new PrototypeMemberDeclaration(lhs, n);\n    }",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.isExprResult() && n.getFirstChild().isAssign()) {\n    Node lhs = n.getFirstChild().getFirstChild();\n    if (lhs.isGetProp() && lhs.getLastChild().getString().equals(\"prototype\")) {\n      return new PrototypeMemberDeclaration(lhs, n);\n    }\n  }\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isAssign() && n.getFirstChild().isGetProp() && n.getFirstFirstChild().matchesQualifiedName(\"prototype\")) {\n      return new PrototypeMemberDeclaration(n.getFirstFirstChild(), n);\n    }\n    return null;\n  }",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isExprResult() && n.getFirstChild().isAssign() &&\n        n.getFirstChild().getFirstChild().isGetProp() &&\n        n.getFirstChild().getFirstChild().getFirstChild().isName() &&\n        n.getFirstChild().getFirstChild().getFirstChild().getString().equals(\"prototype\"))\n    {\n        return new PrototypeMemberDeclaration(n.getFirstChild().getFirstChild(), n);\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isExprResult() && n.getFirstChild().isAssign()) \n    {\n        Node lhs = n.getFirstChild().getFirstChild();\n        if (lhs.isGetProp() && lhs.getLastChild().getString().equals(\"prototype\")) \n        {\n            return new PrototypeMemberDeclaration(lhs, n);\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.isExprResult() && n.getFirstChild().isAssign() &&\n      n.getFirstChild().getFirstChild().isGetProp() &&\n      n.getFirstChild().getFirstChild().getLastChild().getString().equals(\"prototype\")) {\n    return new PrototypeMemberDeclaration(n.getFirstChild().getFirstChild(), n);\n  }\n  return null;\n}"
    ],
    [
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[n * mat.getRowDimension()][m * mat.getColumnDimension()];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int r = 0; r < mat.getRowDimension(); r++) {\n                for (int c = 0; c < mat.getColumnDimension(); c++) {\n                    d[i * mat.getRowDimension() + r][j * mat.getColumnDimension() + c] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    // Your code here\n    RealMatrix newMatrix = new Array2DRowRealMatrix(n*mat.getRowDimension(), m*mat.getColumnDimension());\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            newMatrix.setSubMatrix(mat.getData(), i*mat.getRowDimension(), (i+1)*mat.getRowDimension()-1, j*mat.getColumnDimension(), (j+1)*mat.getColumnDimension()-1);\n        }\n    }\n    return newMatrix;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[n * mat.getRowDimension()][m * mat.getColumnDimension()];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int r = 0; r < mat.getRowDimension(); r++) {\n                for (int c = 0; c < mat.getColumnDimension(); c++) {\n                    d[i * mat.getRowDimension() + r][j * mat.getColumnDimension() + c] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    RealMatrix rep = mat;\n    for (int i = 0; i < n; i++)\n    {\n        rep = rep.append(mat);\n    }\n    for (int i = 0; i < m; i++)\n    {\n        rep = rep.add(mat);\n    }\n    return rep;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    RealMatrix res = mat.copy();\n    for (int i = 1; i < n; i++) {\n        res = res.append(mat.copy());\n    }\n    for (int i = 1; i < m; i++) {\n        res = res.add(mat.copy());\n    }\n    return res;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[mat.getRowDimension() * n][mat.getColumnDimension() * m];\n    for (int i = 0; i < mat.getRowDimension(); i++) \n    {\n        for (int j = 0; j < mat.getColumnDimension(); j++) \n        {\n            d[i][j] = mat.getEntry(i, j);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    // TODO: implement the function\n    return null;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    // Complete this function\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    RealMatrix res = new Array2DRowRealMatrix(mat.getRowDimension()*n, mat.getColumnDimension()*m);\n    for (int i = 0; i < mat.getRowDimension(); i++)\n    {\n        for (int j = 0; j < mat.getColumnDimension(); j++)\n        {\n            res.setEntry(i*n, j*m, mat.getEntry(i, j));\n        }\n    }\n    return res;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    // TODO: Implement this method\n    return null;\n}"
    ],
    [
      "public Node getNotLarger(final T reference)  {\n        Node candidate = null;\n        for (Node node = top; node != null;) {\n            if (node.element.compareTo(reference) > 0) {\n                if (node.left == null) {\n                    return candidate;\n                }\n                node = node.left;\n            } else {\n                candidate = node;\n                if (node.right == null) {\n                    return candidate;\n                }\n                node = node.right;\n            }\n        }\n        return null;\n    }",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n        Node candidate = null;\n        for (Node node = top; node != null;) {\n            if (node.element.compareTo(reference) > 0) {\n                if (node.left == null) {\n                    return candidate;\n                }\n                node = node.left;\n            } else {\n                candidate = node;\n                if (node.right == null) {\n                    return candidate;\n                }\n                node = node.right;\n            }\n        }\n        return null;\n    }",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n        Node candidate = null;\n        for (Node node = top; node != null;) {\n            if (node.element.compareTo(reference) > 0) {\n                if (node.left == null) {\n                    return candidate;\n                }\n                node = node.left;\n            } else {\n                candidate = node;\n                if (node.right == null) {\n                    return candidate;\n                }\n                node = node.right;\n            }\n        }\n        return null;\n    }"
    ],
    [
      "private long getBytesInflated()  {\n    long inB = inf.getBytesRead();\n    long outB = inf.getBytesWritten();\n    if (inB > outB) {\n        inB = outB;\n    }\n    return inB;\n}",
      "private long getBytesInflated()  {\n    final long bytesRead = current.bytesRead;\n    final long bytesInflated = inf.getBytesWritten();\n    final long diff = bytesRead - bytesInflated;\n    if (diff < 0) {\n        return bytesInflated;\n    }\n    if (diff < 0x100000000L) {\n        return bytesInflated + diff;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesWritten();\n    long bytesRead = current.bytesRead;\n    if (bytesInflated > bytesRead) {\n        bytesInflated = bytesRead;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    final long inB = current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED\n                   ? inf.getBytesWritten() : current.bytesRead;\n    final long diff = current.bytesReadFromStream - inB;\n    return inB + Math.min(diff, 0x100000000L);\n}",
      "private long getBytesInflated()  {\n    final long bytesRead = current.bytesRead;\n    final long bytesInflated = inf.getBytesWritten();\n    final long diff = bytesRead - bytesInflated;\n    if (diff > Integer.MAX_VALUE) {\n        return bytesInflated + diff;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesWritten();\n    if (bytesInflated < 0) {\n        bytesInflated += 0x100000000L;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    final long inB = current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED\n                   ? inf.getBytesRead() : current.bytesRead;\n    final int diff = (int) (current.bytesReadFromStream - inB);\n    return inB + Math.min(diff, Integer.MAX_VALUE);\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesRead();\n    if (bytesInflated < 0) {\n        bytesInflated += 0x100000000L;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesWritten();\n    long bytesRead = current.bytesRead;\n    if (bytesInflated < bytesRead) {\n        bytesInflated += 0x100000000L;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    final long inB = current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED\n            ? inf.getBytesRead() : current.bytesRead;\n    final int diff = (int) (current.bytesReadFromStream - inB);\n    return inB + Math.min(diff, Integer.MAX_VALUE);\n}"
    ],
    [
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    } \n    else if (object instanceof Collection<?>) \n    {\n        return ((Collection<?>) object).isEmpty();\n    } \n    else if (object instanceof Map<?, ?>) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    } \n    else if (object instanceof Iterator<?>) \n    {\n        return !((Iterator<?>) object).hasNext();\n    } \n    else if (object instanceof Enumeration<?>) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } \n    else \n    {\n        try \n        {\n            return Array.getLength(object) == 0;\n        } \n        catch (final IllegalArgumentException ex) \n        {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Iterable<?>) {\n        return IterableUtils.sizeIsEmpty((Iterable<?>) object);\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return ((Iterator<?>) object).hasNext() == false;\n    }\n    if (object instanceof Enumeration<?>) {\n        return ((Enumeration<?>) object).hasMoreElements() == false;\n    }\n    try {\n        return Array.getLength(object) == 0;\n    } catch (final IllegalArgumentException ex) {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    return size(object) == 0;\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    }\n    if (object instanceof Collection<?>) \n    {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?,?>) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Iterable<?>) \n    {\n        return IterableUtils.sizeIsEmpty((Iterable<?>) object);\n    }\n    if (object instanceof Object[]) \n    {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) \n    {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try \n    {\n        return Array.getLength(object) == 0;\n    }\n    catch (final IllegalArgumentException ex) \n    {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    }\n    if (object instanceof Collection<?>) \n    {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?,?>) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Iterable<?>) \n    {\n        return IterableUtils.sizeIsEmpty((Iterable<?>) object);\n    }\n    if (object instanceof Object[]) \n    {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) \n    {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try \n    {\n        return Array.getLength(object) == 0;\n    } \n    catch (final IllegalArgumentException ex) \n    {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    } \n    else if (object instanceof Collection<?>) \n    {\n        return ((Collection<?>) object).isEmpty();\n    } \n    else if (object instanceof Map<?,?>) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    } \n    else if (object instanceof Object[]) \n    {\n        return ((Object[]) object).length == 0;\n    } \n    else if (object instanceof Iterator<?>) \n    {\n        return !((Iterator<?>) object).hasNext();\n    } \n    else if (object instanceof Enumeration<?>) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } \n    else \n    {\n        try \n        {\n            return Array.getLength(object) == 0;\n        } \n        catch (final IllegalArgumentException ex) \n        {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.sizeIsEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    } \n    else if (object instanceof Collection<?>) \n    {\n        return ((Collection<?>) object).isEmpty();\n    } \n    else if (object instanceof Map<?, ?>) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    } \n    else if (object instanceof Object[]) \n    {\n        return ((Object[]) object).length == 0;\n    } \n    else if (object instanceof Iterator<?>) \n    {\n        return !((Iterator<?>) object).hasNext();\n    } \n    else if (object instanceof Enumeration<?>) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } \n    else \n    {\n        try \n        {\n            return Array.getLength(object) == 0;\n        } \n        catch (final IllegalArgumentException ex) \n        {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    } \n    else if (object instanceof Collection<?>) \n    {\n        return ((Collection<?>) object).isEmpty();\n    } \n    else if (object instanceof Map<?, ?>) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    } \n    else if (object instanceof Object[]) \n    {\n        return ((Object[]) object).length == 0;\n    } \n    else if (object instanceof Iterator<?>) \n    {\n        return !((Iterator<?>) object).hasNext();\n    } \n    else if (object instanceof Enumeration<?>) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } \n    else \n    {\n        try \n        {\n            return Array.getLength(object) == 0;\n        } \n        catch (final IllegalArgumentException ex) \n        {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}"
    ],
    [
      "public static boolean isValidQualifiedName(String name)  {\n    if (!isValidSimpleName(name)) {\n      return false;\n    }\n\n    // We only allow \".\" in qualified names if it is followed by a valid\n    // identifier.\n    int startIndex = name.indexOf('.');\n    if (startIndex == -1) {\n      return true;\n    }\n\n    int endIndex = name.length();\n    while (startIndex != -1) {\n      if (startIndex == 0 || startIndex == endIndex) {\n        return false;\n      }\n\n      String part = name.substring(startIndex + 1, endIndex);\n      if (!isValidSimpleName(part)) {\n        return false;\n      }\n\n      startIndex = name.indexOf('.', startIndex + 1);\n    }\n\n    return true;\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    return TokenStream.isJSIdentifier(name) &&\n        !TokenStream.isKeyword(name) &&\n        // no Unicode escaped characters - some browsers are less tolerant\n        // of Unicode characters that might be valid according to the\n        // language spec.\n        // Note that by this point, Unicode escapes have been converted\n        // to UTF-16 characters, so we're only searching for character\n        // values, not escapes.\n        isLatin(name);\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    String[] parts = name.split(\"\\\\.\");\n    for (String part : parts) {\n      if (!isValidSimpleName(part)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    return TokenStream.isJSQualifiedName(name) &&\n        // no Unicode escaped characters - some browsers are less tolerant\n        // of Unicode characters that might be valid according to the\n        // language spec.\n        // Note that by this point, Unicode escapes have been converted\n        // to UTF-16 characters, so we're only searching for character\n        // values, not escapes.\n        isLatin(name);\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    if (name.length() == 0) {\n      return false;\n    }\n    int lastDot = name.lastIndexOf('.');\n    if (lastDot == -1) {\n      return isValidSimpleName(name);\n    }\n    String prefix = name.substring(0, lastDot);\n    String suffix = name.substring(lastDot + 1);\n    return isValidSimpleName(prefix) && isValidSimpleName(suffix);\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    if (!TokenStream.isJSIdentifier(name)) {\n      return false;\n    }\n    if (TokenStream.isKeyword(name)) {\n      return false;\n    }\n    if (!isLatin(name)) {\n      return false;\n    }\n    // Split the name into parts, and verify that each part is a valid\n    // simple name.\n    String[] parts = name.split(\"\\\\.\");\n    for (String part : parts) {\n      if (!isValidSimpleName(part)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    if (!isValidSimpleName(name)) {\n      return false;\n    }\n    String[] parts = name.split(\"\\\\.\");\n    for (String part : parts) {\n      if (!isValidSimpleName(part)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    String[] parts = name.split(\"\\\\.\");\n    for (String part : parts) {\n      if (!isValidSimpleName(part)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    return TokenStream.isJSQualifiedName(name) &&\n        // no Unicode escaped characters - some browsers are less tolerant\n        // of Unicode characters that might be valid according to the\n        // language spec.\n        // Note that by this point, Unicode escapes have been converted\n        // to UTF-16 characters, so we're only searching for character\n        // values, not escapes.\n        isLatin(name);\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    return name.split(\"\\\\.\").allMatch(SimpleNameChecker::isValidSimpleName);\n  }"
    ],
    [
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int startIdx = il;\n    // Initialize the householder vector\n    for (int i = il; i <= iu; i++) {\n        hVec[i] = matrixT[i][i];\n    }\n\n    // Apply the similarity transformation to matrix T and householder vector\n    for (int i = il; i < iu; i++) {\n        final double factor = matrixT[i][i] / hVec[i];\n        hVec[i + 1] = hVec[i + 1] * factor;\n        for (int j = i; j <= iu; j++) {\n            matrixT[i][j] = matrixT[i][j] * factor;\n        }\n    }\n\n    // Update the shift information\n    shift.exShift += shift.x;\n    shift.x = matrixT[iu][iu];\n    shift.y = shift.w = 0.0;\n    if (il > 0) {\n        shift.y = matrixT[iu - 1][iu - 1];\n        shift.w = matrixT[iu][iu - 1] * matrixT[iu - 1][iu];\n    }\n    return startIdx;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int startIdx = 0;\n    if (il == iu) {\n        hVec[il] = 1.0;\n        startIdx = il + 1;\n    } else {\n        double scale = 0.0;\n        double h = 0.0;\n        for (int i = il; i <= iu; i++) {\n            scale += FastMath.abs(matrixT[i][i]);\n        }\n        if (scale == 0.0) {\n            hVec[il] = hVec[iu] = 1.0;\n        } else {\n            for (int i = il; i <= iu; i++) {\n                hVec[i] = matrixT[i][i] / scale;\n                h += hVec[i] * hVec[i];\n            }\n            double f = hVec[il];\n            double g = FastMath.sqrt(h);\n            if (f > 0) {\n                g = -g;\n            }\n            h -= f * g;\n            hVec[il] = f - g;\n            for (int i = il + 1; i <= iu; i++) {\n                hVec[i] = matrixT[i][i] / h;\n            }\n        }\n        startIdx = il;\n    }\n    return startIdx;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int startIdx = 0;\n    if (il == iu) {\n        // 1x1 matrix\n        hVec[0] = 1.0;\n        hVec[1] = 0.0;\n    } else {\n        // 2x2 matrix\n        double s = FastMath.abs(matrixT[il][il]) + FastMath.abs(matrixT[il + 1][il + 1]);\n        double t = FastMath.abs(matrixT[il + 1][il]) + FastMath.abs(matrixT[il][il + 1]);\n        if (s <= t) {\n            hVec[0] = matrixT[il + 1][il + 1];\n            hVec[1] = matrixT[il][il + 1] * (-1.0);\n        } else {\n            hVec[0] = matrixT[il][il];\n            hVec[1] = matrixT[il + 1][il] * (-1.0);\n        }\n        startIdx = il;\n    }\n    return startIdx;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // initialize the householder vectors\n    for (int i = il; i <= iu; i++) {\n        hVec[i] = matrixT[i][i];\n    }\n\n    // scale the householder vectors\n    double scale = 0.0;\n    for (int i = il; i <= iu; i++) {\n        scale = FastMath.max(scale, FastMath.abs(hVec[i]));\n    }\n    if (scale == 0.0) {\n        return il;\n    }\n    for (int i = il; i <= iu; i++) {\n        hVec[i] /= scale;\n    }\n\n    // apply the similarity transformation to matrix T and hVec\n    for (int i = il; i <= iu; i++) {\n        for (int j = i; j <= iu; j++) {\n            matrixT[i][j] = hVec[i] * hVec[j];\n        }\n    }\n    for (int i = il; i <= iu; i++) {\n        hVec[i] = scale * hVec[i];\n    }\n\n    // return the start index for the QR step\n    return il;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // Initialize the householder vectors\n    int startIdx = il;\n    for (int i = il; i <= iu; i++) {\n        hVec[i] = matrixT[i][i];\n        for (int j = il; j <= i - 1; j++) {\n            hVec[i] -= matrixT[i][j] * matrixT[j][i];\n        }\n        hVec[i] *= shift.tau;\n    }\n    return startIdx;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int startIdx = 0;\n    if (il == iu) {\n        hVec[il] = 1.0;\n        startIdx = il + 1;\n    } else {\n        final double scale = FastMath.max(FastMath.abs(matrixT[il][il - 1]), FastMath.abs(matrixT[il - 1][il - 2]));\n        double h = matrixT[il - 1][il - 1] - shift.x;\n        double t = FastMath.abs(h) + FastMath.sqrt(h * h + shift.y * shift.y);\n        hVec[il - 1] = h / t;\n        hVec[il] = matrixT[il][il - 1] / t;\n        startIdx = il;\n    }\n    return startIdx;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n        int startIdx = il;\n        if (il == iu) {\n            hVec[il] = 1.0;\n        } else {\n            final double scale = FastMath.sqrt(2.0 * (FastMath.abs(matrixT[il][il]) + FastMath.abs(matrixT[il + 1][il + 1])));\n            hVec[il] = matrixT[il + 1][il] / scale;\n            hVec[il + 1] = matrixT[il][il] - shift.exShift / scale;\n            startIdx = il + 1;\n        }\n        return startIdx;\n    }",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n        // Initialize the householder vectors\n        int startIdx = il;\n        for (int i = il; i <= iu; i++) {\n            hVec[i] = matrixT[i][i] - shift.x;\n        }\n        return startIdx;\n    }",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n        int startIdx = 0;\n        if (il == iu) {\n            hVec[il] = 1.0;\n        } else {\n            double scale = 0.0;\n            for (int i = il; i <= iu; i++) {\n                scale += FastMath.abs(matrixT[i][i]);\n            }\n            if (scale == 0.0) {\n                hVec[il] = 1.0;\n            } else {\n                for (int i = il; i <= iu; i++) {\n                    hVec[i] = matrixT[i][i] / scale;\n                    hVec[il] += hVec[i] * hVec[i];\n                }\n                final double fudge = FastMath.sqrt(hVec[il]) * FastMath.sqrt(hVec[il]);\n                hVec[il] = scale * fudge;\n            }\n        }\n        startIdx = il;\n        return startIdx;\n    }",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n        // Initialize the householder vectors\n        int startIdx = 0;\n        if (il == iu) {\n            hVec[il] = 1.0;\n        } else {\n            final double scale = FastMath.sqrt(2.0 * (FastMath.abs(matrixT[il][il]) + FastMath.abs(matrixT[iu - 1][iu - 1])));\n            hVec[il] = FastMath.abs(matrixT[il][il + 1]) + scale;\n            hVec[iu - 1] = FastMath.abs(matrixT[iu - 1][iu - 2]) + scale;\n            startIdx = il;\n        }\n        return startIdx;\n    }"
    ],
    [
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode) {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes)\n    {\n        if (node instanceof TextNode)\n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode) {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode) {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes)\n    {\n        if (node instanceof TextNode)\n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode) {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode) {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode) {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode) {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes)\n    {\n        if (node instanceof TextNode)\n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}"
    ],
    [
      "public boolean inIncludeSegments()  {\n    for (long i = this.segmentStart; i <= this.segmentEnd; i++) {\n        Segment segment = getSegment(i);\n        if (!segment.isIncluded() || segment.isException()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n\n    Segment start = getSegment(this.segmentStart);\n    Segment end = getSegment(this.segmentEnd);\n\n    if (start.getSegmentStart() == this.segmentStart\n        && end.getSegmentEnd() == this.segmentEnd) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}",
      "public boolean inIncludeSegments()  {\n    return (this.segmentCount == 1);\n}",
      "public boolean inIncludeSegments()  {\n    for (long i = this.segmentStart; i <= this.segmentEnd; i++) {\n        Segment segment = getSegment(i);\n        if (!segment.isIncluded() || segment.isException()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n\n    Segment start = getSegment(this.segmentStart);\n    Segment end = getSegment(this.segmentEnd);\n    if (start.getSegmentStart() != this.segmentStart\n        || end.getSegmentEnd() != this.segmentEnd) {\n        return false;\n    }\n    else {\n        return true;\n    }\n}",
      "public boolean inIncludeSegments()  {\n\n    long start = this.segmentStart;\n    long end = this.segmentEnd;\n    for (long i = start; i <= end; i++) {\n        Segment segment = getSegment(i);\n        if (!segment.isIncluded() || segment.isException()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    return (this.segmentCount == 1);\n}",
      "public boolean inIncludeSegments()  {\n    long segmentCount = this.segmentCount;\n    long segmentNumber = this.segmentNumber;\n    long segmentStart = this.segmentStart;\n    long segmentEnd = this.segmentEnd;\n    for (long i = 0; i < segmentCount; i++) \n    {\n        Segment segment = getSegment(segmentNumber + i);\n        if (!segment.isIncluded() || segment.isException()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    long segmentNumber = this.segmentNumber;\n    long segmentCount = this.segmentCount;\n    for (long i = 0; i < segmentCount; i++) \n    {\n        Segment segment = getSegment(segmentNumber);\n        if (!segment.isIncluded() || segment.isException()) \n        {\n            return false;\n        }\n        segmentNumber++;\n    }\n    return true;\n}"
    ],
    [
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) \n    {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (zeroInstance == null) \n    {\n        throw new IllegalArgumentException(\"ReadablePeriod object must not be null\");\n    }\n    if (start.size() != end.size() || start.size() != zeroInstance.size()) \n    {\n        throw new IllegalArgumentException(\"ReadablePartial objects must contain the same fields\");\n    }\n    int[] startValues = start.getValues();\n    int[] endValues = end.getValues();\n    int[] zeroValues = zeroInstance.getValues();\n    int size = startValues.length;\n    int[] diff = new int[size];\n    for (int i = 0; i < size; i++) \n    {\n        diff[i] = endValues[i] - startValues[i];\n        if (diff[i] < 0) \n        {\n            diff[i] += zeroValues[i];\n        }\n    }\n    return PeriodType.standard().getPeriodType().getPeriod(diff);\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must contain the same fields\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"Zero instance must not be null\");\n    }\n    int[] startValues = new int[start.size()];\n    int[] endValues = new int[end.size()];\n    start.get(startValues);\n    end.get(endValues);\n    int[] zeroValues = zeroInstance.getValues();\n    int[] diff = new int[start.size()];\n    for (int i = 0; i < diff.length; i++) {\n        diff[i] = endValues[i] - startValues[i];\n    }\n    int[] total = new int[start.size()];\n    for (int i = 0; i < total.length; i++) {\n        total[i] = diff[i] + zeroValues[i];\n    }\n    return FieldUtils.safeMultiply(total, 1);\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"ReadablePeriod object must not be null\");\n    }\n    if (start.size() != end.size() || start.size() != zeroInstance.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must contain the same fields\");\n    }\n    int[] startValues = new int[start.size()];\n    int[] endValues = new int[end.size()];\n    int[] zeroValues = new int[zeroInstance.size()];\n    for (int i = 0; i < start.size(); i++) {\n        startValues[i] = start.getValue(i);\n        endValues[i] = end.getValue(i);\n        zeroValues[i] = zeroInstance.getValue(i);\n    }\n    return FieldUtils.safeSubtract(endValues, startValues, zeroValues);\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"ReadablePeriod must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must contain the same fields\");\n    }\n    int[] startValues = new int[start.size()];\n    int[] endValues = new int[end.size()];\n    start.getValues(startValues);\n    end.getValues(endValues);\n    int[] zeroValues = zeroInstance.getValues();\n    int[] diff = new int[start.size()];\n    for (int i = 0; i < start.size(); i++) {\n        diff[i] = endValues[i] - startValues[i];\n    }\n    int[] min = new int[start.size()];\n    for (int i = 0; i < start.size(); i++) {\n        min[i] = Math.min(Math.abs(diff[i]), Math.abs(diff[i] + zeroValues[i]));\n    }\n    int sum = 0;\n    for (int i = 0; i < start.size(); i++) {\n        sum += min[i];\n    }\n    return sum;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) \n    {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) \n    {\n        throw new IllegalArgumentException(\"ReadablePartial objects must contain the same fields\");\n    }\n    if (zeroInstance == null) \n    {\n        throw new IllegalArgumentException(\"ReadablePeriod object must not be null\");\n    }\n    MutablePeriod period = new MutablePeriod(zeroInstance);\n    int size = start.size();\n    for (int i = 0; i < size; i++) \n    {\n        DurationFieldType fieldType = start.getFieldType(i);\n        int startValue = start.getValue(i);\n        int endValue = end.getValue(i);\n        int diff = endValue - startValue;\n        period.setValue(fieldType, diff);\n    }\n    return period.get(zeroInstance.getPeriodType());\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"ReadablePeriod object must not be null\");\n    }\n    if (start.size() != end.size() || start.size() != zeroInstance.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must contain the same fields\");\n    }\n    MutablePeriod period = new MutablePeriod();\n    for (int i = 0; i < start.size(); i++) {\n        DurationFieldType type = start.getFieldType(i);\n        period.setValue(type, end.get(type) - start.get(type));\n    }\n    return period.get(zeroInstance);\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"ReadablePeriod must not be null\");\n    }\n    if (start.size() != end.size() || start.size() != zeroInstance.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must contain the same fields\");\n    }\n    int[] startValues = new int[start.size()];\n    int[] endValues = new int[end.size()];\n    int[] zeroValues = new int[zeroInstance.size()];\n    for (int i = 0; i < start.size(); i++) {\n        startValues[i] = start.getValue(i);\n        endValues[i] = end.getValue(i);\n        zeroValues[i] = zeroInstance.getValue(i);\n    }\n    int[] differences = new int[start.size()];\n    for (int i = 0; i < start.size(); i++) {\n        differences[i] = FieldUtils.safeSubtract(endValues[i], startValues[i]);\n    }\n    int[] periods = new int[start.size()];\n    for (int i = 0; i < start.size(); i++) {\n        periods[i] = FieldUtils.safeSubtract(differences[i], zeroValues[i]);\n    }\n    return FieldUtils.safeMultiply(periods, zeroInstance.getValues());\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"ReadablePeriod must not be null\");\n    }\n    // Validate period type\n    PeriodType startType = start.getPeriodType();\n    PeriodType endType = end.getPeriodType();\n    if (startType != endType) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same PeriodType\");\n    }\n    // Calculate difference\n    int[] startValues = start.getValues();\n    int[] endValues = end.getValues();\n    int[] zeroValues = zeroInstance.getValues();\n    int[] diff = new int[startValues.length];\n    for (int i = 0; i < startValues.length; i++) {\n        diff[i] = endValues[i] - startValues[i];\n    }\n    // Normalize\n    for (int i = 0; i < diff.length; i++) {\n        if (diff[i] < 0) {\n            for (int j = 0; j < diff.length; j++) {\n                diff[j] += zeroValues[j];\n            }\n            diff[i] = endValues[i] - startValues[i];\n        }\n    }\n    return FieldUtils.safeMultiply(diff, startType.getIndexedFields().length);\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must contain the same fields\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"Zero instance must not be null\");\n    }\n    int[] startArray = new int[start.size()];\n    int[] endArray = new int[start.size()];\n    start.get(startArray);\n    end.get(endArray);\n    int[] zeroArray = zeroInstance.get(start.getChronology());\n    int[] diffArray = new int[start.size()];\n    for (int i = 0; i < start.size(); i++) {\n        diffArray[i] = FieldUtils.safeSubtract(endArray[i], startArray[i]);\n    }\n    int[] minArray = new int[start.size()];\n    for (int i = 0; i < start.size(); i++) {\n        minArray[i] = Math.min(diffArray[i], zeroArray[i]);\n    }\n    int[] maxArray = new int[start.size()];\n    for (int i = 0; i < start.size(); i++) {\n        maxArray[i] = Math.max(diffArray[i], zeroArray[i]);\n    }\n    int[] sumArray = new int[start.size()];\n    for (int i = 0; i < start.size(); i++) {\n        sumArray[i] = minArray[i] + maxArray[i];\n    }\n    int sum = 0;\n    for (int i = 0; i < start.size(); i++) {\n        sum += sumArray[i];\n    }\n    return sum;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) \n    {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (zeroInstance == null) \n    {\n        throw new IllegalArgumentException(\"ReadablePeriod object must not be null\");\n    }\n    if (start.size() != end.size() || start.size() != zeroInstance.size()) \n    {\n        throw new IllegalArgumentException(\"ReadablePartial objects must contain the same fields\");\n    }\n    MutablePeriod period = new MutablePeriod(zeroInstance);\n    int[] startValues = start.getValues();\n    int[] endValues = end.getValues();\n    int[] zeroValues = zeroInstance.getValues();\n    for (int i = 0; i < startValues.length; i++) \n    {\n        int startValue = startValues[i];\n        int endValue = endValues[i];\n        int zeroValue = zeroValues[i];\n        if (startValue != endValue) \n        {\n            int diff = endValue - startValue;\n            if (diff < 0) \n            {\n                diff += zeroValue;\n            }\n            period.add(i, diff);\n        }\n    }\n    return period.get(getFieldType());\n}"
    ],
    [
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= this.subtitles.size()) {\n        return null;\n    }\n    Title title = this.subtitles.get(index);\n    if (title instanceof LegendTitle) {\n        return (LegendTitle) title;\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    // TODO: Implement this method\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    // Add code here\n}",
      "public LegendTitle getLegend(int index)  {\n    LegendTitle legend = null;\n    if (index < this.subtitles.size()) {\n        Title subtitle = this.subtitles.get(index);\n        if (subtitle instanceof LegendTitle) {\n            legend = (LegendTitle) subtitle;\n        }\n    }\n    return legend;\n}",
      "public LegendTitle getLegend(int index)  {\n    LegendTitle legend = null;\n    int count = 0;\n    for (int i = 0; i < this.subtitles.size(); i++) \n    {\n        Title subtitle = this.subtitles.get(i);\n        if (subtitle instanceof LegendTitle) \n        {\n            if (count == index) \n            {\n                legend = (LegendTitle) subtitle;\n                break;\n            }\n            count++;\n        }\n    }\n    return legend;\n}",
      "public LegendTitle getLegend(int index)  {\n    int count = 0;\n    for (int i = 0; i < this.subtitles.size(); i++) \n    {\n        Title title = this.subtitles.get(i);\n        if (title instanceof LegendTitle) \n        {\n            if (count == index) \n            {\n                return (LegendTitle) title;\n            }\n            count++;\n        }\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    if (this.subtitles == null) \n    {\n        return null;\n    }\n    else \n    {\n        int count = 0;\n        for (int i = 0; i < this.subtitles.size(); i++) \n        {\n            Title subtitle = (Title) this.subtitles.get(i);\n            if (subtitle instanceof LegendTitle) \n            {\n                if (count == index) \n                {\n                    return (LegendTitle) subtitle;\n                }\n                else \n                {\n                    count++;\n                }\n            }\n        }\n        return null;\n    }\n}",
      "public LegendTitle getLegend(int index)  {\n    int count = 0;\n    Title[] titles = getTitles();\n    for (Title title : titles) \n    {\n        if (title instanceof LegendTitle) \n        {\n            if (count == index) \n            {\n                return (LegendTitle) title;\n            }\n            count++;\n        }\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    LegendTitle legend = null;\n    if (this.subtitles != null) {\n        for (int i = 0; i < this.subtitles.size(); i++) {\n            Title subtitle = this.subtitles.get(i);\n            if (subtitle instanceof LegendTitle) {\n                if (i == index) {\n                    legend = (LegendTitle) subtitle;\n                    break;\n                }\n            }\n        }\n    }\n    return legend;\n}",
      "public LegendTitle getLegend(int index)  {\n    // TODO: implement this method\n    return null;\n}"
    ],
    [
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    final List<ZipArchiveEntry> entriesInPhysicalOrder = new ArrayList<ZipArchiveEntry>();\n    for (final ZipArchiveEntry zipArchiveEntry : entries) {\n        entriesInPhysicalOrder.add(zipArchiveEntry);\n    }\n    Collections.sort(entriesInPhysicalOrder, new Comparator<ZipArchiveEntry>() {\n}\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entriesInPhysicalOrder);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    final ZipArchiveEntry[] orderedEntries = entries.toArray(new ZipArchiveEntry[entries.size()]);\n    Arrays.sort(orderedEntries, new Comparator<ZipArchiveEntry>() {\n}\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entriesInPhysicalOrder);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entriesInPhysicalOrder);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n        return Collections.enumeration(entriesInPhysicalOrder);\n    }",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entriesInPhysicalOrder);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n        return Collections.enumeration(entriesInPhysicalOrder);\n    }",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entriesInPhysicalOrder);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n        return Collections.enumeration(entriesInPhysicalOrder);\n    }"
    ],
    [
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    if (match(JsDocToken.ELLIPSIS)) {\n      next();\n      Node typeNode = parseTopLevelTypeExpression(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n      return typeNode;\n    } else {\n      Node typeNode = parseTopLevelTypeExpression(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (match(JsDocToken.ASSIGN)) {\n          next();\n        }\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n      return typeNode;\n    }\n  } else {\n    return parseTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    token = next();\n    if (token == JsDocToken.ELLIPSIS) {\n      skipEOLs();\n      Node typeNode = parseTopLevelTypeExpression(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n      return typeNode;\n    } else {\n      Node typeNode = parseOptionalParameterType(token);\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n      return typeNode;\n    }\n  } else {\n    return parseTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = parseOptionalParameterType();\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  } else {\n    return parseTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (match(JsDocToken.EQ)) {\n        next();\n        skipEOLs();\n      }\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n    return typeNode;\n  } else {\n    return parseTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    if (match(JsDocToken.ELLIPSIS)) {\n      skipEOLs();\n      Node typeNode = parseTopLevelTypeExpression(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n      return typeNode;\n    } else {\n      Node typeNode = parseOptionalParameterType(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n      return typeNode;\n    }\n  } else {\n    return parseTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = null;\n    if (match(JsDocToken.ELLIPSIS)) {\n      typeNode = parseTopLevelTypeExpression(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n    } else {\n      typeNode = parseOptionalParameterType(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n    }\n\n    return typeNode;\n  } else {\n    return parseTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    if (match(JsDocToken.ELLIPSIS)) {\n      next();\n      Node typeNode = parseTopLevelTypeExpression(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n      return typeNode;\n    } else {\n      Node typeNode = parseOptionalParameterType(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n      return typeNode;\n    }\n  } else {\n    return parseTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = null;\n    if (match(JsDocToken.ELLIPSIS)) {\n      next();\n      typeNode = parseTopLevelTypeExpression(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n    } else {\n      typeNode = parseTopLevelTypeExpression(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (match(JsDocToken.ASSIGN)) {\n          next();\n          skipEOLs();\n        }\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n    }\n    return typeNode;\n  } else {\n    return parseTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (match(JsDocToken.EQUALS)) {\n        next();\n        skipEOLs();\n        return typeNode;\n      } else if (match(JsDocToken.RC)) {\n        next();\n        return typeNode;\n      } else {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      }\n    }\n  }\n\n  return null;\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = null;\n    if (match(JsDocToken.ELLIPSIS)) {\n      next();\n      typeNode = parseTopLevelTypeExpression(next());\n    } else {\n      typeNode = parseTopLevelTypeExpression(next());\n    }\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n    return typeNode;\n  } else {\n    return parseTypeExpression(token);\n  }\n}"
    ],
    [
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String[] lines = getStackFrames(stackTrace);\n    final int len = lines.length;\n    final List<String> list = new ArrayList<String>(len);\n    for (int i = 0; i < len; i++) {\n        final String line = lines[i];\n        if (line.startsWith(\"at \")) {\n            // Remove the \"at \" from the front of the line\n            list.add(line.substring(3));\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String[] lines = getStackFrames(stackTrace);\n    final int lastFrame = lines.length - 1;\n    final List<String> list = new ArrayList<String>(lastFrame + 1);\n    for (int i = 0; i < lastFrame; i++) {\n        list.add(lines[i]);\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String[] lines = getStackFrames(stackTrace);\n    final int len = lines.length - 1;\n    final List<String> list = new ArrayList<String>(len);\n    for (int i = 0; i < len; i++) {\n        list.add(lines[i]);\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String[] lines = getStackFrames(stackTrace);\n    final int lastDirectCause = getLastDirectCause(lines);\n    final int lastCause = getLastCause(lines);\n    final int lastTrace = getLastTrace(lines);\n    final int length = lastTrace + 1;\n    final List<String> list = new ArrayList<String>(length);\n    for (int i = 0; i < length; i++) {\n        list.add(lines[i]);\n    }\n    if (lastDirectCause != -1) {\n        for (int i = lastDirectCause; i < lastCause; i++) {\n            list.remove(lastTrace - i + lastDirectCause);\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String[] lines = getStackFrames(stackTrace);\n    final int len = lines.length;\n    final List<String> list = new ArrayList<String>(len);\n    for (int i = 0; i < len; i++) {\n        final String line = lines[i];\n        if (line.startsWith(\"at \")) {\n            // frame is ok, add it\n            list.add(line);\n        } else if (line.startsWith(\"Caused by: \")) {\n            // caused by frame, stop here\n            break;\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    boolean traceStarted = false;\n    while (frames.hasMoreTokens()) {\n        final String token = frames.nextToken();\n        // Determine if the line starts with <whitespace>at\n        final int at = token.indexOf(\"at\");\n        if (at != -1 && token.substring(0, at).trim().isEmpty()) {\n            traceStarted = true;\n            list.add(token);\n        } else if (traceStarted) {\n            break;\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String[] lines = getStackFrames(stackTrace);\n    final int len = lines.length;\n    final List<String> list = new ArrayList<String>(len);\n    for (int i = 0; i < len; i++) {\n        list.add(lines[i]);\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String[] lines = getStackFrames(stackTrace);\n    final int lastFrame = lines.length - 1;\n    int frameCount = 0;\n    for (int i = 0; i < lines.length; i++) {\n        if (lines[i].startsWith(\"at \")) {\n            frameCount++;\n        }\n    }\n    final List<String> frames = new ArrayList<String>(frameCount);\n    for (int i = 0; i < lastFrame; i++) {\n        if (lines[i].startsWith(\"at \")) {\n            frames.add(lines[i]);\n        }\n    }\n    return frames;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    boolean traceStarted = false;\n    while (frames.hasMoreTokens()) {\n        final String token = frames.nextToken();\n        // Determine if the line starts with <whitespace>at\n        final int at = token.indexOf(\"at\");\n        if (at != -1 && token.substring(0, at).trim().isEmpty()) {\n            traceStarted = true;\n            list.add(token);\n        } else if (traceStarted) {\n            break;\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    boolean traceStarted = false;\n    while (frames.hasMoreTokens()) {\n        final String token = frames.nextToken();\n        // Determine if the line starts with <whitespace>at\n        final int at = token.indexOf(\"at\");\n        if (at != -1 && token.substring(0, at).trim().isEmpty()) {\n            traceStarted = true;\n            list.add(token);\n        } else if (traceStarted) {\n            break;\n        }\n    }\n    return list;\n}"
    ],
    [
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } else if (p == PEEKED_FALSE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    } else {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } \n    else if (p == PEEKED_FALSE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  } else if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  } else {\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n  }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    }\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } else if (p == PEEKED_FALSE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    } else {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }"
    ],
    [
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) \n    {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) \n    {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}"
    ],
    [
      "private boolean argsMayHaveSideEffects(Node call)  {\n  for (Node arg = call.getFirstChild().getNext(); arg != null; arg = arg.getNext()) {\n    if (NodeUtil.mayHaveSideEffects(arg)) {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    for (Node arg = call.getFirstChild().getNext();\n         arg != null;\n         arg = arg.getNext()) {\n      if (NodeUtil.mayHaveSideEffects(arg)) {\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  for (Node arg = call.getFirstChild().getNext(); arg != null;\n      arg = arg.getNext()) {\n    if (NodeUtil.mayHaveSideEffects(arg)) {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    if (call.getChildCount() == 1) {\n      return false;\n    }\n\n    Node arg = call.getSecondChild();\n    while (arg != null) {\n      if (NodeUtil.mayHaveSideEffects(arg)) {\n        return true;\n      }\n      arg = arg.getNext();\n    }\n    return false;\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node arg = call.getFirstChild().getNext();\n    while (arg != null) {\n      if (NodeUtil.mayHaveSideEffects(arg)) {\n        return true;\n      }\n      arg = arg.getNext();\n    }\n    return false;\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  if (call.getChildCount() < 2) {\n    return false;\n  }\n\n  Node args = call.getSecondChild();\n  for (Node arg = args.getFirstChild(); arg != null; arg = arg.getNext()) {\n    if (NodeUtil.mayHaveSideEffects(arg)) {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  Node args = call.getLastChild();\n  for (Node arg = args.getFirstChild(); arg != null; arg = arg.getNext()) {\n    if (NodeUtil.mayHaveSideEffects(arg)) {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    if (call.getChildCount() < 2) {\n      return false;\n    }\n\n    Node args = call.getChildAtIndex(1);\n    for (Node arg = args.getFirstChild(); arg != null; arg = arg.getNext()) {\n      if (NodeUtil.mayHaveSideEffects(arg)) {\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  for (Node child = call.getFirstChild().getNext();\n       child != null;\n       child = child.getNext()) {\n    if (NodeUtil.mayHaveSideEffects(child)) {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    if (call.getChildCount() == 2) {\n      return NodeUtil.mayHaveSideEffects(call.getSecondChild());\n    }\n    return false;\n  }"
    ],
    [
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(pivot[i], i, field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(pivot[i], i, field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(pivot[i], i, field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(pivot[i], i, field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(pivot[i], i, field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(pivot[i], i, field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(pivot[i], i, field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}"
    ],
    [
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n        final List<byte[]> v = new ArrayList<>();\n        for (final ZipExtraField ze : data) {\n            v.add(ze.getLocalFileDataData());\n        }\n        return merge(v);\n    }",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n        final List<byte[]> result = new ArrayList<>();\n        for (final ZipExtraField field : data) {\n            final byte[] local = field.getLocalFileDataData();\n            if (local != null) {\n                result.add(local);\n            }\n        }\n        return Arrays.copyOf(result.toArray(), result.size());\n    }",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final List<byte[]> v = new ArrayList<>();\n    for (final ZipExtraField ze : data) {\n        final byte[] b = ze.getLocalFileDataData();\n        if (b != null) {\n            v.add(b);\n        }\n    }\n    return merge(v);\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n        final List<byte[]> v = new ArrayList<>();\n        for (final ZipExtraField ze : data) {\n            final byte[] b = ze.getLocalFileDataData();\n            if (b != null) {\n                v.add(b);\n            }\n        }\n        return merge(v);\n    }",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  throws ZipException {\n        if (data == null) {\n            return null;\n        }\n        final List<byte[]> v = new ArrayList<>();\n        for (final ZipExtraField ze : data) {\n            final byte[] b = ze.getLocalFileDataData();\n            if (b != null) {\n                v.add(b);\n            }\n        }\n        return merge(v);\n    }",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final List<byte[]> v = new ArrayList<>();\n    for (final ZipExtraField ze : data) {\n        final byte[] b = ze.getLocalFileDataData();\n        if (b.length > 0) {\n            v.add(b);\n        }\n    }\n    return ZipUtil.combine(v);\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n        final List<byte[]> v = new ArrayList<>();\n        for (final ZipExtraField ze : data) {\n            v.add(ze.getLocalFileDataData());\n        }\n        return merge(v);\n    }",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final List<byte[]> v = new ArrayList<>();\n    for (final ZipExtraField ze : data) {\n        final byte[] b = ze.getLocalFileDataData();\n        if (b.length > 0) {\n            v.add(b);\n        }\n    }\n    return merge(v);\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  throws ZipException {\n    final List<byte[]> v = new ArrayList<>();\n    for (final ZipExtraField element : data) {\n        final byte[] fieldData = element.getLocalFileDataData();\n        if (fieldData != null) {\n            v.add(fieldData);\n        }\n    }\n    return merge(v);\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  throws ZipException {\n    final List<byte[]> v = new ArrayList<>();\n    for (final ZipExtraField ze : data) {\n        v.add(ze.getLocalFileDataData());\n    }\n    return merge(v);\n}"
    ],
    [
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n        BSPTree<Euclidean1D> node = getTree(false);\n        double  sup  = Double.NEGATIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n            sup  = op.getLocation().getX();\n            node = op.isDirect() ? node.getPlus() : node.getMinus();\n        }\n        return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n    }",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}"
    ],
    [
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // add removed blanks when not ignoring whitespace chars...\n    while (!isEndOfFile(ch) && !isDelimiter(ch) && !isEndOfLine(ch)) {\n        token.content.append((char) ch);\n        ch = reader.read();\n    }\n    token.type = TOKEN;\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (true) \n    {\n        // add removed blanks when not ignoring whitespace chars...\n        if (isWhitespace(ch) && !ignoreSurroundingSpaces) \n        {\n            token.content.append((char) ch);\n        }\n        else if (isDelimiter(ch)) \n        {\n            token.type = TOKEN;\n            return token;\n        }\n        else if (isEndOfLine(ch)) \n        {\n            token.type = EORECORD;\n            return token;\n        }\n        else if (isEndOfFile(ch)) \n        {\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n            return token;\n        }\n        else \n        {\n            token.content.append((char) ch);\n        }\n        ch = reader.read();\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // start with the current char\n    token.content.append((char) ch);\n    // read until the end of the token\n    while (!isEndOfFile(ch)) {\n        // read the next char\n        ch = reader.read();\n        // check for end of line\n        if (isEndOfLine(ch)) {\n            // end of line reached\n            token.type = EORECORD;\n            return token;\n        }\n        // check for delimiter\n        if (isDelimiter(ch)) {\n            // delimiter reached\n            token.type = TOKEN;\n            return token;\n        }\n        // check for escaped delimiter\n        if (isEscapeChar(ch)) {\n            // read the next char\n            ch = reader.read();\n            // check for escaped delimiter\n            if (isDelimiter(ch)) {\n                // escaped delimiter reached\n                token.content.append((char) ch);\n            } else {\n                // not an escaped delimiter\n                reader.pushBack(ch);\n            }\n        } else {\n            // not an escaped delimiter\n            token.content.append((char) ch);\n        }\n    }\n    // end of stream reached\n    token.type = EOF;\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // add removed blanks when not ignoring whitespace chars...\n    if (ignoreSurroundingSpaces) {\n        while (isWhitespace(ch) && !readEndOfLine(ch)) {\n            ch = reader.read();\n        }\n    }\n\n    // ok, start of token reached: encapsulated, or token\n    if (isDelimiter(ch)) {\n        // empty token return TOKEN(\"\")\n        token.type = TOKEN;\n    } else if (readEndOfLine(ch)) {\n        // empty token return EORECORD(\"\")\n        // noop: token.content.append(\"\");\n        token.type = EORECORD;\n    } else if (isQuoteChar(ch)) {\n        // consume encapsulated token\n        parseEncapsulatedToken(token);\n    } else if (isEndOfFile(ch)) {\n        // end of file return EOF()\n        // noop: token.content.append(\"\");\n        token.type = EOF;\n        token.isReady = true; // there is data at EOF\n    } else {\n        // next token must be a simple token\n        // add removed blanks when not ignoring whitespace chars...\n        parseSimpleToken(token, ch);\n    }\n\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // add removed blanks when not ignoring whitespace chars...\n    while (!isEndOfFile(ch) && !isDelimiter(ch)) \n    {\n        if (isEscapeChar(ch)) \n        {\n            ch = reader.read();\n            if (isEndOfFile(ch)) \n            {\n                token.type = EOF;\n                return token;\n            }\n        }\n        token.content.append((char) ch);\n        ch = reader.read();\n    }\n    token.type = TOKEN;\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // add removed blanks when not ignoring whitespace chars...\n    if (!ignoreSurroundingSpaces) {\n        token.content.append((char) ch);\n    }\n\n    // consume until EOL or EOF\n    while (true) {\n        ch = reader.read();\n        if (isEndOfFile(ch)) {\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n            break;\n        }\n        if (isDelimiter(ch)) {\n            token.type = TOKEN;\n            break;\n        }\n        if (isEndOfLine(ch)) {\n            token.type = EORECORD;\n            break;\n        }\n        if (isEscapeChar(ch)) {\n            ch = reader.read();\n            if (isEndOfFile(ch)) {\n                token.type = EOF;\n                token.isReady = true; // there is data at EOF\n                break;\n            }\n            if (isDelimiter(ch)) {\n                token.content.append((char) ch);\n            }\n        }\n        token.content.append((char) ch);\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // parse the token\n    boolean isEscaped = false;\n    while (!isEndOfFile(ch) && !isDelimiter(ch) && !isEndOfLine(ch)) {\n        // check if the current char is escaped\n        if (isEscapeChar(ch)) {\n            isEscaped = !isEscaped;\n        } else if (isEscaped) {\n            // escaped char, so add it\n            token.content.append((char) ch);\n            isEscaped = false;\n        } else {\n            // add the char to the token\n            token.content.append((char) ch);\n        }\n        // read the next char\n        ch = reader.read();\n    }\n    // check if we reached the end of the line\n    if (isEndOfLine(ch)) {\n        token.type = EORECORD;\n    } else if (isEndOfFile(ch)) {\n        token.type = EOF;\n        token.isReady = true; // there is data at EOF\n    } else {\n        token.type = TOKEN;\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // empty token return TOKEN(\"\")\n    if (isDelimiter(ch)) {\n        token.type = TOKEN;\n        return token;\n    }\n    // end of file return EOF()\n    // noop: token.content.append(\"\");\n    if (isEndOfFile(ch)) {\n        token.type = EOF;\n        token.isReady = true; // there is data at EOF\n        return token;\n    }\n    // add removed blanks when not ignoring whitespace chars...\n    if (ignoreSurroundingSpaces) {\n        while (isWhitespace(ch) && !eol) {\n            ch = reader.read();\n            eol = readEndOfLine(ch);\n        }\n    }\n    // ok, start of token reached: encapsulated, or token\n    if (isDelimiter(ch)) {\n        // empty token return TOKEN(\"\")\n        token.type = TOKEN;\n        return token;\n    } else if (eol) {\n        // empty token return EORECORD(\"\")\n        // noop: token.content.append(\"\");\n        token.type = EORECORD;\n        return token;\n    } else if (isQuoteChar(ch)) {\n        // consume encapsulated token\n        parseEncapsulatedToken(token);\n    } else if (isEndOfFile(ch)) {\n        // end of file return EOF()\n        // noop: token.content.append(\"\");\n        token.type = EOF;\n        token.isReady = true; // there is data at EOF\n        return token;\n    } else {\n        // next token must be a simple token\n        // add removed blanks when not ignoring whitespace chars...\n        parseSimpleToken(token, ch);\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n        // empty token return TOKEN(\"\")\n        token.type = TOKEN;\n        // add removed blanks when not ignoring whitespace chars...\n        while (!isEndOfFile(ch) && !isDelimiter(ch)) {\n            // escape char ?\n            if (isEscapeChar(ch)) {\n                // escaped delimiter ?\n                if (isDelimiter(reader.peek())) {\n                    // consume escaped delimiter\n                    ch = reader.read();\n                }\n            }\n            token.content.append((char) ch);\n            ch = reader.read();\n        }\n        return token;\n    }",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // empty token return TOKEN(\"\")\n    token.type = TOKEN;\n    // add removed blanks when not ignoring whitespace chars...\n    while (!isEndOfFile(ch) && !isDelimiter(ch)) {\n        if (isEscapeChar(ch)) {\n            // escaped char ahead\n            ch = reader.read();\n            if (isEndOfFile(ch)) {\n                break;\n            }\n        }\n        token.content.append((char) ch);\n        ch = reader.read();\n    }\n    return token;\n}"
    ],
    [
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    int offset = index;\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = offset / uniCounterOffset[i];\n        offset = offset % uniCounterOffset[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n\n    int[] counts = new int[dimension];\n    int i = dimension - 1;\n    counts[i] = index / uniCounterOffset[i];\n    index %= uniCounterOffset[i];\n    while (i > 0) {\n        i--;\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index = index % uniCounterOffset[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i] % size[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n        if (index < 0 || index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize);\n        }\n        int[] counts = new int[dimension];\n        int[] counter = new int[dimension];\n        for (int i = 0; i < dimension; i++) {\n            counter[i] = index / uniCounterOffset[i];\n            index = index % uniCounterOffset[i];\n        }\n        return counter;\n    }",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    int[] counts = new int[dimension];\n    int k = index;\n    for (int i = last; i >= 0; i--) {\n        counts[i] = k / uniCounterOffset[i];\n        k = k % uniCounterOffset[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    int[] counter = new int[dimension];\n    int tS = totalSize;\n    for (int i = 0; i < dimension; i++) {\n        counter[i] = index / tS;\n        index = index % tS;\n        tS = tS / size[i];\n    }\n    return counter;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n        if (index < 0 || index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize);\n        }\n        int[] counts = new int[dimension];\n        for (int i = 0; i < dimension; i++) {\n            counts[i] = index / uniCounterOffset[i];\n            index %= uniCounterOffset[i];\n        }\n        return counts;\n    }",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    int c = index;\n    for (int i = last; i >= 0; i--) {\n        counts[i] = c / uniCounterOffset[i];\n        c %= uniCounterOffset[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    int[] counts = new int[dimension];\n    int c = index;\n    for (int i = last; i >= 0; i--) {\n        counts[i] = c / uniCounterOffset[i];\n        c %= uniCounterOffset[i];\n    }\n    return counts;\n}"
    ],
    [
      "public JsonPointer last()  {\n    JsonPointer leaf = this;\n    while (leaf._nextSegment != null) {\n        leaf = leaf._nextSegment;\n    }\n    return leaf;\n}",
      "public JsonPointer last()  {\n    JsonPointer tail = this;\n    for (; tail._nextSegment != null; tail = tail._nextSegment) {\n    }\n    return tail;\n}",
      "public JsonPointer last()  {\n    if (_nextSegment == null) {\n        return this;\n    }\n    return _nextSegment.last();\n}",
      "public JsonPointer last()  {\n    if (this.matches()) {\n        return this;\n    }\n    JsonPointer tail = this;\n    while (tail._nextSegment != null) {\n        tail = tail._nextSegment;\n    }\n    return tail;\n}",
      "public JsonPointer last()  {\n    if (this.matches()) {\n        return this;\n    }\n    JsonPointer leaf = this;\n    while (!leaf.matches()) {\n        leaf = leaf._nextSegment;\n    }\n    return leaf;\n}",
      "public JsonPointer last()  {\n    JsonPointer leaf = this;\n    while (leaf._nextSegment != null) {\n        leaf = leaf._nextSegment;\n    }\n    return leaf;\n}",
      "public JsonPointer last()  {\n    JsonPointer leaf = this;\n    while (leaf._nextSegment != null) {\n        leaf = leaf._nextSegment;\n    }\n    return leaf;\n}",
      "public JsonPointer last()  {\n    if (this == EMPTY) {\n        return this;\n    }\n    JsonPointer p = this;\n    while (p._nextSegment != null) {\n        p = p._nextSegment;\n    }\n    return p;\n}",
      "public JsonPointer last()  {\n    if (_nextSegment == null) {\n        return this;\n    }\n    return _nextSegment.last();\n}",
      "public JsonPointer last()  {\n    if (this == EMPTY) {\n        return this;\n    }\n    JsonPointer leaf = this;\n    while (leaf._nextSegment != null) {\n        leaf = leaf._nextSegment;\n    }\n    return leaf;\n}"
    ],
    [
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n        final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n        int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n        while (read > -1) {\n            digest.update(buffer, 0, read);\n            read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n        }\n\n        return digest;\n    }",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n        final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n        int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n        while (read > -1) {\n            digest.update(buffer, 0, read);\n            read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n        }\n\n        return digest;\n    }",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n        final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n        int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n        while (read > -1) {\n            digest.update(buffer, 0, read);\n            read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n        }\n\n        return digest;\n    }",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[1024];\n    int read = data.read(buffer, 0, 1024);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, 1024);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}"
    ],
    [
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        final Class<?> cls = obj.getClass();\n        try {\n            @SuppressWarnings(\"unchecked\") // clone() is not generified\n            final T clone = (T) cls.getMethod(\"clone\").invoke(obj);\n            return clone;\n        } catch (final Exception ex) {\n            throw new CloneFailedException(cls, ex);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        final Class<?> cls = obj.getClass();\n        try {\n            @SuppressWarnings(\"unchecked\") // OK because obj is checked to be an instance of cls\n            final\n            T clone = (T) cls.getMethod(\"clone\").invoke(obj);\n            return clone;\n        } catch (final Exception ex) {\n            throw new CloneFailedException(cls, ex);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  {\n    T result = null;\n    if (obj instanceof Cloneable) {\n        try {\n            final Class<?> cls = obj.getClass();\n            final Method cloneMethod = cls.getMethod(\"clone\");\n            result = cls.cast(cloneMethod.invoke(obj));\n        } catch (final NoSuchMethodException ex) {\n            throw new CloneFailedException(\"Clone not supported\", ex);\n        } catch (final IllegalAccessException ex) {\n            throw new CloneFailedException(\"Clone not supported\", ex);\n        } catch (final InvocationTargetException ex) {\n            throw new CloneFailedException(\"Clone failed\", ex);\n        }\n    }\n    return result;\n}",
      "public static <T> T clone(final T obj)  {\n    T result = null;\n    if (obj instanceof Cloneable) {\n        try {\n            final Method clone = obj.getClass().getMethod(\"clone\");\n            result = obj.getClass().cast(clone.invoke(obj));\n        } catch (final NoSuchMethodException | IllegalAccessException | InvocationTargetException ex) {\n            throw new CloneFailedException(\"Cloneable type \" + obj.getClass().getName() + \" has no clone method\", ex);\n        }\n    }\n    return result;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        final Class<?> cls = obj.getClass();\n        try {\n            final Method clone = cls.getMethod(\"clone\");\n            return cls.cast(clone.invoke(obj));\n        } catch (final NoSuchMethodException ex) {\n            throw new CloneFailedException(\"Cloneable type \" + cls.getName() + \" has no clone() method\", ex);\n        } catch (final IllegalAccessException ex) {\n            throw new CloneFailedException(\"Cannot clone Cloneable type \" + cls.getName(), ex);\n        } catch (final InvocationTargetException ex) {\n            throw new CloneFailedException(\"Exception cloning Cloneable type \" + cls.getName(), ex.getCause());\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        final Class<?> cls = obj.getClass();\n        try {\n            @SuppressWarnings(\"unchecked\") // OK because obj is checked to be of type Cloneable\n            final\n            T clone = (T) cls.getMethod(\"clone\").invoke(obj);\n            return clone;\n        } catch (final Exception ex) {\n            throw new CloneFailedException(\"Clone not supported: \" + obj, ex);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  {\n    T result = null;\n    if (obj instanceof Cloneable) {\n        try {\n            final Method clone = obj.getClass().getMethod(\"clone\");\n            result = (T) clone.invoke(obj);\n        } catch (final NoSuchMethodException | IllegalAccessException | InvocationTargetException ex) {\n            throw new CloneFailedException(ex);\n        }\n    }\n    return result;\n}",
      "public static <T> T clone(final T obj)  {\n    T result = null;\n    if (obj instanceof Cloneable) {\n        try {\n            final Class<?> cls = obj.getClass();\n            @SuppressWarnings(\"unchecked\") // OK because input is of type T\n            final\n            T clone = (T) cls.getMethod(\"clone\").invoke(obj);\n            result = clone;\n        } catch (final Exception ex) {\n            throw new CloneFailedException(ex);\n        }\n    }\n    return result;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        final Class<?> cls = obj.getClass();\n        try {\n            @SuppressWarnings(\"unchecked\") // clone() is not generic\n            final T clone = (T) cls.getMethod(\"clone\").invoke(obj);\n            return clone;\n        } catch (final Exception ex) {\n            throw new CloneFailedException(cls, ex);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        Class<?> cls = obj.getClass();\n        try {\n            @SuppressWarnings(\"unchecked\") // OK because obj is checked to be an instance of cls\n            final T clone = (T) cls.getMethod(\"clone\").invoke(obj);\n            return clone;\n        } catch (final Exception ex) {\n            throw new CloneFailedException(cls, ex);\n        }\n    }\n    return null;\n}"
    ],
    [
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  if (sym.isFunction()) {\n    SymbolScope scope = sym.scope;\n    if (scope != null) {\n      for (Symbol param : scope.getSymbols()) {\n        if (param.name.equals(paramName)) {\n          return param;\n        }\n      }\n    }\n  }\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.isFunction()) {\n      SymbolScope scope = sym.scope;\n      for (Symbol param : scope.getSymbols()) {\n        if (param.name.equals(paramName)) {\n          return param;\n        }\n      }\n    }\n    return null;\n  }",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  // If sym is not a function, return null\n  if (!sym.getType().isFunctionType()) {\n    return null;\n  }\n\n  // Get the function node\n  Node functionNode = sym.getDeclaration().getNode();\n\n  // If the function node is not a function, return null\n  if (!functionNode.isFunction()) {\n    return null;\n  }\n\n  // Get the parameter list\n  Node paramList = functionNode.getFirstChild().getNext();\n\n  // If the parameter list is not a parameter list, return null\n  if (!paramList.isParamList()) {\n    return null;\n  }\n\n  // Iterate through the parameters\n  for (Node param : paramList.children()) {\n    // If the parameter name matches the given name, return the symbol\n    if (param.getString().equals(paramName)) {\n      return getSymbolDeclaredBy(param);\n    }\n  }\n\n  // If we didn't find a matching parameter, return null\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    // If the symbol is not a function, we can't find a parameter.\n    if (!sym.isFunction()) {\n      return null;\n    }\n\n    // If the symbol is a function, we need to find the function's\n    // scope and look for a parameter with the given name.\n    SymbolScope functionScope = sym.scope;\n    for (Symbol param : functionScope.getSymbols()) {\n      if (param.getName().equals(paramName)) {\n        return param;\n      }\n    }\n\n    // If we couldn't find a parameter with the given name, return null.\n    return null;\n  }",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.getType() != SymbolType.FUNCTION) {\n      return null;\n    }\n\n    SymbolScope scope = sym.scope;\n    for (Symbol param : scope.getSymbols()) {\n      if (param.name.equals(paramName)) {\n        return param;\n      }\n    }\n\n    return null;\n  }",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  // TODO: Implement this method\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.isFunction()) {\n      for (Symbol param : sym.getParameters()) {\n        if (param.getName().equals(paramName)) {\n          return param;\n        }\n      }\n    }\n    return null;\n  }",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.isFunction()) {\n      SymbolScope scope = sym.scope;\n      for (Symbol param : scope.getChildren()) {\n        if (param.getName().equals(paramName)) {\n          return param;\n        }\n      }\n    }\n    return null;\n  }",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  if (sym.isFunction()) {\n    SymbolScope scope = sym.scope;\n    while (scope != null) {\n      for (Symbol param : scope.getSymbols()) {\n        if (param.getName().equals(paramName)) {\n          return param;\n        }\n      }\n      scope = scope.getParentScope();\n    }\n  }\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.getType() != SymbolType.FUNCTION) {\n      return null;\n    }\n\n    SymbolScope scope = sym.scope;\n    SymbolScope parentScope = scope.getParentScope();\n\n    // If the function is not in the global scope, we need to find the\n    // corresponding parameter in the parent scope.\n    if (parentScope != null) {\n      for (Symbol param : parentScope.getSymbols()) {\n        if (param.getName().equals(paramName)) {\n          return param;\n        }\n      }\n    }\n\n    return null;\n  }"
    ],
    [
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        int n = matrix.getColumnDimension();\n        RealMatrix covarianceMatrix = new BlockRealMatrix(n, n);\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                double covariance = computeCovariance(matrix.getColumn(i), matrix.getColumn(j), biasCorrected);\n                covarianceMatrix.setEntry(i, j, covariance);\n                covarianceMatrix.setEntry(j, i, covariance);\n            }\n        }\n        return covarianceMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        RealMatrix covarianceMatrix = new BlockRealMatrix(matrix.getColumnDimension(), matrix.getColumnDimension());\n        for (int i = 0; i < matrix.getColumnDimension(); i++) {\n            for (int j = i; j < matrix.getColumnDimension(); j++) {\n                double covariance = computeCovariance(matrix.getColumn(i), matrix.getColumn(j), biasCorrected);\n                covarianceMatrix.setEntry(i, j, covariance);\n                covarianceMatrix.setEntry(j, i, covariance);\n            }\n        }\n        return covarianceMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        RealMatrix covarianceMatrix = matrix.subtract(matrix.getColumnMean()).transpose().multiply(matrix.subtract(matrix.getColumnMean()));\n        if (biasCorrected) {\n            covarianceMatrix = covarianceMatrix.scalarMultiply((1.0 / (n - 1.0)));\n        } else {\n            covarianceMatrix = covarianceMatrix.scalarMultiply((1.0 / n));\n        }\n        return covarianceMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        RealMatrix covarianceMatrix = new Array2DRowRealMatrix(matrix.getColumnDimension(), matrix.getColumnDimension());\n        for (int i = 0; i < matrix.getColumnDimension(); i++) {\n            for (int j = i; j < matrix.getColumnDimension(); j++) {\n                double covariance = 0;\n                for (int k = 0; k < matrix.getRowDimension(); k++) {\n                    covariance += (matrix.getEntry(k, i) - matrix.getEntry(k, j)) * (matrix.getEntry(k, i) - matrix.getEntry(k, j));\n                }\n                if (biasCorrected) {\n                    covarianceMatrix.setEntry(i, j, covariance / (matrix.getRowDimension() - 1));\n                } else {\n                    covarianceMatrix.setEntry(i, j, covariance / matrix.getRowDimension());\n                }\n            }\n        }\n        return covarianceMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        int n = matrix.getRowDimension();\n        int m = matrix.getColumnDimension();\n        RealMatrix covarianceMatrix = MatrixUtils.createRealMatrix(m, m);\n        for (int i = 0; i < m; i++) {\n            for (int j = i; j < m; j++) {\n                double covariance = computeCovariance(matrix, i, j, biasCorrected);\n                covarianceMatrix.setEntry(i, j, covariance);\n                covarianceMatrix.setEntry(j, i, covariance);\n            }\n        }\n        return covarianceMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n\n        // Get the number of columns\n        int numCols = matrix.getColumnDimension();\n\n        // Create a new matrix for the covariance\n        RealMatrix covarianceMatrix = MatrixUtils.createRealMatrix(numCols, numCols);\n\n        // Loop through each column\n        for (int i = 0; i < numCols; i++) {\n\n            // Get the column vector\n            RealVector colVector = matrix.getColumnVector(i);\n\n            // Loop through each row\n            for (int j = 0; j < numCols; j++) {\n\n                // Get the row vector\n                RealVector rowVector = matrix.getRowVector(j);\n\n                // Calculate the covariance\n                double covariance = colVector.dotProduct(rowVector) / (n - 1);\n\n                // Set the covariance in the matrix\n                covarianceMatrix.setEntry(i, j, covariance);\n            }\n        }\n\n        // Return the covariance matrix\n        return covarianceMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        RealMatrix covarianceMatrix = matrix.subtract(matrix.getColumnMean());\n        if (biasCorrected) {\n            covarianceMatrix = covarianceMatrix.scalarMultiply(1.0 / (matrix.getRowDimension() - 1));\n        } else {\n            covarianceMatrix = covarianceMatrix.scalarMultiply(1.0 / matrix.getRowDimension());\n        }\n        return covarianceMatrix.multiply(covarianceMatrix.transpose());\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        RealMatrix covarianceMatrix = new BlockRealMatrix(matrix.getColumnDimension(), matrix.getColumnDimension());\n        for (int i = 0; i < matrix.getColumnDimension(); i++) {\n            for (int j = i; j < matrix.getColumnDimension(); j++) {\n                double covariance = 0;\n                for (int k = 0; k < matrix.getRowDimension(); k++) {\n                    covariance += (matrix.getEntry(k, i) - mean[i]) * (matrix.getEntry(k, j) - mean[j]);\n                }\n                if (biasCorrected) {\n                    covariance /= (matrix.getRowDimension() - 1);\n                } else {\n                    covariance /= matrix.getRowDimension();\n                }\n                covarianceMatrix.setEntry(i, j, covariance);\n                covarianceMatrix.setEntry(j, i, covariance);\n            }\n        }\n        return covarianceMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        int n = matrix.getColumnDimension();\n        RealMatrix covarianceMatrix = matrix.copy();\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                double[] colI = matrix.getColumn(i);\n                double[] colJ = matrix.getColumn(j);\n                double covariance = new Covariance(colI, colJ).getCovariance();\n                if (biasCorrected) {\n                    covariance *= (n - 1) / (n - 2);\n                }\n                covarianceMatrix.setEntry(i, j, covariance);\n                covarianceMatrix.setEntry(j, i, covariance);\n            }\n        }\n        return covarianceMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        // Check input data\n        checkSufficientData(matrix);\n        // Compute covariance matrix\n        RealMatrix covarianceMatrix = matrix.subtract(matrix.getColumnMean()).transpose().multiply(matrix.subtract(matrix.getColumnMean()));\n        // Bias-corrected covariance matrix\n        if (biasCorrected) {\n            covarianceMatrix = covarianceMatrix.scalarMultiply((1.0 - 1.0 / n));\n        }\n        return covarianceMatrix;\n    }"
    ],
    [
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 1 and \" + MAXIMUM_CACHE_SIZE);\n    }\n\n    if (bitsCachedSize >= count) {\n        final long result = bitsCached & MASKS[count];\n        bitsCached >>>= count;\n        bitsCachedSize -= count;\n        return result;\n    }\n\n    long result = 0;\n    int bitsRead = bitsCachedSize;\n    if (bitsRead > 0) {\n        result = bitsCached;\n        bitsCached = 0;\n        bitsCachedSize = 0;\n    }\n\n    while (bitsRead < count) {\n        final int read = in.read();\n        if (read == -1) {\n            return -1;\n        }\n        result = result << 8 | read;\n        bitsRead += 8;\n    }\n\n    result = result & MASKS[count];\n    bitsRead -= count;\n    if (bitsRead > 0) {\n        bitsCached = result >>> bitsRead;\n        bitsCachedSize = bitsRead;\n    }\n\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be a positive number not bigger than \" + MAXIMUM_CACHE_SIZE);\n    }\n    long result = 0;\n    int bitsToRead = count;\n    while (bitsToRead > 0) {\n        if (bitsCachedSize == 0) {\n            final int read = in.read();\n            if (read == -1) {\n                return -1;\n            }\n            bitsCached = read & 0xFF;\n            bitsCachedSize = 8;\n        }\n        final int bitsToCopy = Math.min(bitsToRead, bitsCachedSize);\n        final long mask = MASKS[bitsToCopy];\n        result <<= bitsToCopy;\n        result |= (bitsCached & mask) >>> (bitsCachedSize - bitsToCopy);\n        bitsToRead -= bitsToCopy;\n        bitsCachedSize -= bitsToCopy;\n        bitsCached &= ~mask;\n    }\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 1 and \" + MAXIMUM_CACHE_SIZE);\n    }\n\n    if (count <= bitsCachedSize) {\n        final long result = bitsCached & MASKS[count];\n        bitsCached >>>= count;\n        bitsCachedSize -= count;\n        return result;\n    }\n\n    final int bitsToRead = count - bitsCachedSize;\n    final int bytesToRead = bitsToRead / 8;\n    final int bitsToCache = bitsToRead % 8;\n    final long result = bitsCached << bitsToCache;\n    bitsCachedSize = 0;\n    bitsCached = 0;\n\n    final int read = in.read(new byte[bytesToRead]);\n    if (read == -1) {\n        return -1;\n    }\n\n    if (byteOrder == ByteOrder.BIG_ENDIAN) {\n        for (int i = 0; i < read; i++) {\n            final int b = in.read();\n            if (b == -1) {\n                return -1;\n            }\n            result |= (b & 0xffL) << (8 * (read - i - 1));\n        }\n    } else {\n        for (int i = 0; i < read; i++) {\n            final int b = in.read();\n            if (b == -1) {\n                return -1;\n            }\n            result |= (b & 0xffL) << (8 * i);\n        }\n    }\n\n    if (bitsToCache > 0) {\n        final int b = in.read();\n        if (b == -1) {\n            return -1;\n        }\n        bitsCached = b & MASKS[bitsToCache];\n        bitsCachedSize = bitsToCache;\n    }\n\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 1 and \" + MAXIMUM_CACHE_SIZE);\n    }\n\n    if (bitsCachedSize < count) {\n        // we need to read more bits from the underlying stream\n        final int bytesToRead = (count - bitsCachedSize + 7) / 8;\n        final int bytesRead = in.read(new byte[bytesToRead]);\n        if (bytesRead < 0) {\n            // end of stream reached\n            return -1;\n        }\n\n        // read the bits from the underlying stream\n        final long bitsRead = readBitsFromStream(bytesRead);\n\n        // concatenate the bits with the bits already cached\n        bitsCached = (bitsCached << bytesRead * 8) | bitsRead;\n        bitsCachedSize += bytesRead * 8;\n    }\n\n    // return the requested number of bits\n    final long result = bitsCached & MASKS[count];\n    bitsCached >>= count;\n    bitsCachedSize -= count;\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 0 and \" + MAXIMUM_CACHE_SIZE);\n    }\n\n    if (bitsCachedSize >= count) {\n        final long result = bitsCached & MASKS[count];\n        bitsCached >>>= count;\n        bitsCachedSize -= count;\n        return result;\n    }\n\n    long result = bitsCached;\n    final int bitsLeftInCache = bitsCachedSize;\n    bitsCached = 0;\n    bitsCachedSize = 0;\n    int bitsRead = 0;\n    while (bitsRead < count) {\n        final int read = in.read();\n        if (read == -1) {\n            return -1;\n        }\n        result |= ((long) read) << bitsRead;\n        bitsRead += 8;\n    }\n    if (bitsLeftInCache > 0) {\n        bitsCached = result & MASKS[bitsLeftInCache];\n        result >>>= bitsLeftInCache;\n        bitsCachedSize = bitsLeftInCache;\n    }\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 0 and \" + MAXIMUM_CACHE_SIZE);\n    }\n\n    long result = 0;\n    int bitsRead = 0;\n\n    while (bitsRead < count) {\n        if (bitsCachedSize == 0) {\n            final int nextByte = in.read();\n            if (nextByte == -1) {\n                return -1;\n            }\n            bitsCached = byteOrder == ByteOrder.BIG_ENDIAN ? (long) nextByte << 56 : (long) nextByte;\n            bitsCachedSize = 8;\n        }\n\n        final int bitsToRead = Math.min(count - bitsRead, bitsCachedSize);\n        result |= (bitsCached >> (bitsCachedSize - bitsToRead)) & MASKS[bitsToRead];\n        bitsCached <<= bitsToRead;\n        bitsCachedSize -= bitsToRead;\n        bitsRead += bitsToRead;\n    }\n\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be a positive number not bigger than \" + MAXIMUM_CACHE_SIZE);\n    }\n\n    long result = 0;\n    int bitsToRead = count;\n    while (bitsToRead > 0) {\n        if (bitsCachedSize == 0) {\n            final int b = in.read();\n            if (b < 0) {\n                return -1;\n            }\n            bitsCached = (byteOrder == ByteOrder.BIG_ENDIAN) ? b << (8 - bitsToRead) : b;\n            bitsCachedSize = 8;\n        }\n        final int bitsToReadFromCache = Math.min(bitsCachedSize, bitsToRead);\n        result <<= bitsToReadFromCache;\n        result |= (bitsCached >> (bitsCachedSize - bitsToReadFromCache)) & MASKS[bitsToReadFromCache];\n        bitsCachedSize -= bitsToReadFromCache;\n        bitsCached &= MASKS[bitsCachedSize];\n        bitsToRead -= bitsToReadFromCache;\n    }\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 0 and \" + MAXIMUM_CACHE_SIZE);\n    }\n    long result = 0;\n    while (bitsCachedSize < count) {\n        final int b = in.read();\n        if (b < 0) {\n            return -1;\n        }\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n            result <<= 8;\n            result |= b;\n        } else {\n            result = (result << 8) | b;\n        }\n        bitsCachedSize += 8;\n    }\n    result &= MASKS[count];\n    bitsCachedSize -= count;\n    bitsCached <<= count;\n    bitsCached |= result;\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be a positive number not bigger than 63\");\n    }\n\n    long bits = 0;\n    int bitsRead = 0;\n    while (bitsRead < count) {\n        if (bitsCachedSize == 0) {\n            final int read = in.read();\n            if (read == -1) {\n                return -1;\n            }\n            bitsCached = read;\n            bitsCachedSize = 8;\n        }\n        final int bitsToRead = Math.min(bitsCachedSize, count - bitsRead);\n        final long mask = MASKS[bitsToRead];\n        bits <<= bitsToRead;\n        bits |= (bitsCached & mask) >>> (bitsCachedSize - bitsToRead);\n        bitsCachedSize -= bitsToRead;\n        bitsCached &= MASKS[bitsCachedSize];\n        bitsRead += bitsToRead;\n    }\n\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n        bits = Long.reverseBytes(bits);\n    }\n    return bits;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 1 and \" + MAXIMUM_CACHE_SIZE);\n    }\n\n    long result = 0;\n    int bitsRead = 0;\n    while (bitsRead < count) {\n        if (bitsCachedSize == 0) {\n            final int read = in.read();\n            if (read == -1) {\n                return -1;\n            }\n            bitsCached = read & 0xFF;\n            bitsCachedSize = 8;\n        }\n\n        final int bitsToRead = Math.min(bitsCachedSize, count - bitsRead);\n        result <<= bitsToRead;\n        result |= (bitsCached >>> (bitsCachedSize - bitsToRead)) & MASKS[bitsToRead];\n        bitsCached &= MASKS[bitsCachedSize - bitsToRead];\n        bitsCachedSize -= bitsToRead;\n        bitsRead += bitsToRead;\n    }\n\n    return byteOrder == ByteOrder.LITTLE_ENDIAN ? result : Long.reverse(result);\n}"
    ],
    [
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n        final int m = data.length;\n        final int n = v.data.length;\n        final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                out.setEntry(i, j, data[i].multiply(v.data[j]));\n            }\n        }\n        return out;\n    }",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n        final int m = data.length;\n        final int n = v.data.length;\n        final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                out.setEntry(i, j, data[i].multiply(v.data[j]));\n            }\n        }\n        return out;\n    }",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n        final int m = data.length;\n        final int n = v.data.length;\n        final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                out.setEntry(i, j, data[i].multiply(v.data[j]));\n            }\n        }\n        return out;\n    }",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}"
    ],
    [
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    return target.getFirstChild().getString().equals(label);\n  }",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  if (target.isLabel()) {\n    return label.equals(target.getString());\n  }\n  return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    if (target.getType() == Token.LABEL) {\n      return target.getFirstChild().getString().equals(label);\n    }\n    return false;\n  }",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  if (target.getType() == Token.LABEL) {\n    return label.equals(target.getFirstChild().getString());\n  }\n  return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  if (target.getType() == Token.LABEL) {\n    Node labelNode = target.getFirstChild();\n    return labelNode.getString().equals(label);\n  }\n  return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  Node labelNode = target.getFirstChild();\n  return labelNode.isName() && labelNode.getString().equals(label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    return target.getFirstChild().getString().equals(label);\n  }",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    Node labelNode = target.getFirstChild();\n    if (labelNode.isName()) {\n      return label.equals(labelNode.getString());\n    }\n    return false;\n  }",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  Node labelNode = target.getFirstChild();\n  if (labelNode.isName()) {\n    return label.equals(labelNode.getString());\n  }\n  return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    return target.getFirstChild().getString().equals(label);\n  }"
    ],
    [
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        result = (String) urls.get(item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) \n    {\n        result = (String) urls.get(item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) \n    {\n        result = (String) urls.get(item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String url = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        url = (String) urls.get(item);\n    }\n    return url;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        result = (String) urls.get(item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        result = (String) urls.get(item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        result = (String) urls.get(item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String url = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        url = (String) urls.get(item);\n    }\n    return url;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        result = (String) urls.get(item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        result = (String) urls.get(item);\n    }\n    return result;\n}"
    ],
    [
      "private final static int _parseIndex(String str)  {\n    int index = str.indexOf(']');\n    if (index < 0) {\n        throw new IllegalArgumentException(\"Missing ']' for array index in JSON Pointer: '\"+str+\"'\");\n    }\n    return Integer.parseInt(str.substring(1, index));\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    int ix = 0;\n    while (ix < len) {\n        char c = str.charAt(ix);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n        ++ix;\n    }\n    return Integer.parseInt(str);\n}",
      "private final static int _parseIndex(String str)  {\n    // 07-Sep-2017, tatu: Should we verify that it's a valid number?\n    return Integer.parseInt(str);\n}",
      "private final static int _parseIndex(String str)  {\n    int index = -1;\n    try {\n        index = Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        //do nothing\n    }\n    return index;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        throw new IllegalArgumentException(\"Empty String\");\n    }\n    if (str.charAt(0) != '0') {\n        return Integer.parseInt(str);\n    }\n    if (len == 1) {\n        return 0;\n    }\n    throw new IllegalArgumentException(\"Leading zeroes not allowed\");\n}",
      "private final static int _parseIndex(String str)  {\n    int ix = str.indexOf(']');\n    if (ix < 0) {\n        throw new IllegalArgumentException(\"Missing ']' for array index: \"+str);\n    }\n    try {\n        return Integer.parseInt(str.substring(1, ix));\n    } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Invalid array index value '\"+str.substring(1, ix)+\"': \"+e.getMessage());\n    }\n}",
      "private final static int _parseIndex(String str)  {\n    // First: let's trim leading/trailing white space\n    int i = 0;\n    int len = str.length();\n    while ((i < len) && (str.charAt(i) <= ' ')) {\n        ++i;\n    }\n    while ((i < len) && (str.charAt(len-1) <= ' ')) {\n        --len;\n    }\n    // And then, if it starts with a digit, parse it\n    if (i < len) {\n        char c = str.charAt(i);\n        if (c >= '0' && c <= '9') {\n            int value = 0;\n            while (i < len) {\n                c = str.charAt(i);\n                if (c >= '0' && c <= '9') {\n                    value = value * 10 + (c - '0');\n                    ++i;\n                } else {\n                    break;\n                }\n            }\n            return value;\n        }\n    }\n    return -1;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        throw new IllegalArgumentException(\"Can not parse empty String as index\");\n    }\n    int result = 0;\n    for (int i = 0; i < len; ++i) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            throw new IllegalArgumentException(\"Can not parse '\"+str+\"' as index: non-numeric character '\"+c+\"'\");\n        }\n        result = result * 10 + (c - '0');\n    }\n    return result;\n}",
      "private final static int _parseIndex(String str)  {\n    // 04-Mar-2017, tatu: Not super efficient, but should be fine for\n    //    JSON Pointers, which are not expected to be long\n    int len = str.length();\n    int ix = 0;\n    while (ix < len) {\n        char c = str.charAt(ix);\n        if (c >= '0' && c <= '9') {\n            return Integer.parseInt(str.substring(ix));\n        }\n        ++ix;\n    }\n    return -1;\n}",
      "private final static int _parseIndex(String str)  {\n    int index = 0;\n    try {\n        index = Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        // Not a valid index, return -1\n        index = -1;\n    }\n    return index;\n}"
    ],
    [
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n                                               k);\n    }\n\n    Object[] sample = c.toArray();\n    MathArrays.shuffle(sample, getRandomGenerator());\n\n    // Return a new array containing the first \"k\" entries of \"index\".\n    return MathArrays.copyOf(sample, k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    int n = c.size();\n    if (k > n) {\n        throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n                                            k, n, true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n                                               k);\n    }\n\n    Object[] index = c.toArray();\n    MathArrays.shuffle(index, getRandomGenerator());\n\n    // Return a new array containing the first \"k\" entries of \"index\".\n    return MathArrays.copyOf(index, k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    int n = c.size();\n    if (k > n) {\n        throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n                                            k, n, true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n                                               k);\n    }\n\n    Object[] index = c.toArray();\n    MathArrays.shuffle(index, getRandomGenerator());\n\n    // Return a new array containing the first \"k\" entries of \"index\".\n    return MathArrays.copyOf(index, k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n                                               k);\n    }\n\n    Object[] sample = c.toArray();\n    int[] index = getNatural(c.size());\n    MathArrays.shuffle(index, getRandomGenerator());\n\n    // Return a new array containing the first \"k\" entries of \"index\".\n    return MathArrays.copyOf(index, k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    int n = c.size();\n    if (k > n) {\n        throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n                                            k, n, true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n                                               k);\n    }\n\n    Object[] index = c.toArray();\n    MathArrays.shuffle(index, getRandomGenerator());\n\n    // Return a new array containing the first \"k\" entries of \"index\".\n    return MathArrays.copyOf(index, k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n                                               k);\n    }\n\n    Object[] index = c.toArray();\n    MathArrays.shuffle(index, getRandomGenerator());\n\n    // Return a new array containing the first \"k\" entries of \"index\".\n    return MathArrays.copyOf(index, k);\n}"
    ],
    [
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node method = NodeUtil.newQName(compiler, methodName);\n    Node call = IR.call(method, argumentNode);\n    call.useSourceInfoIfMissingFromForTree(srcref);\n    return call;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = IR.call(IR.name(methodName), argumentNode);\n    callNode.useSourceInfoIfMissingFromForTree(srcref);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = IR.call(IR.name(methodName), argumentNode);\n    callNode.srcrefTreeIfMissing(srcref);\n    return callNode;\n  }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = IR.call(IR.name(methodName), argumentNode);\n    callNode.useSourceInfoIfMissingFromForTree(srcref);\n    return callNode;\n  }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = IR.call(IR.name(methodName), argumentNode);\n    callNode.useSourceInfoIfMissingFromForTree(srcref);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = IR.call(IR.name(methodName), argumentNode);\n    callNode.useSourceInfoIfMissingFromForTree(srcref);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node methodNode = NodeUtil.newQName(compiler, methodName);\n    Node callNode = new Node(Token.CALL, methodNode, argumentNode);\n    callNode.useSourceInfoIfMissingFromForTree(srcref);\n    return callNode;\n  }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node callNode = IR.call(IR.name(methodName), argumentNode);\n      callNode.useSourceInfoIfMissingFromForTree(srcref);\n      return callNode;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = IR.call(IR.name(methodName), argumentNode);\n    callNode.useSourceInfoIfMissingFromForTree(srcref);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node methodNode = NodeUtil.newQName(compiler,\n                                        \"goog.string.format\");\n    Node args = NodeUtil.newNode(Token.ARRAYLIT);\n    args.addChildToBack(argumentNode);\n    Node callNode = NodeUtil.newCallNode(methodNode, args);\n    callNode.setSourceFileForTesting(srcref.getSourceFileName());\n    callNode.setSourcePositionForTesting(srcref.getLineno(),\n                                         srcref.getCharno());\n    return callNode;\n}"
    ],
    [
      "private int[] sortedIndices(final double[] doubles)  {\n    int[] idx = new int[doubles.length];\n    for (int i = 0; i < idx.length; i++) {\n        idx[i] = i;\n    }\n    Arrays.sort(idx, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] idx = new int[doubles.length];\n    for (int i = 0; i < idx.length; i++) {\n        idx[i] = i;\n    }\n    Arrays.sort(idx, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() {\n}\n}"
    ],
    [
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}"
    ],
    [
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) {\n        group = this.defaultGroup;\n    }\n    return group;\n}"
    ],
    [
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n        if (set == null) {\n            throw new NullPointerException(\"Set must not be null\");\n        }\n        if (transformer == null) {\n            throw new NullPointerException(\"Transformer must not be null\");\n        }\n        return new TransformedSet<E>(set, transformer);\n    }",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    return new TransformedSet<E>(set, transformer);\n}"
    ],
    [
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity * 2];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity * 2];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity * 2];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity * 2];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity * 2];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity * 2];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity * 2];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity < 0) {\n        throw new StringIndexOutOfBoundsException(capacity);\n    }\n    if (capacity > buffer.length) {\n        final char[] newBuffer = new char[capacity * 2];\n        System.arraycopy(buffer, 0, newBuffer, 0, size);\n        buffer = newBuffer;\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity * 2];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}"
    ],
    [
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = 0.0;\n    double maximum = 0.0;\n    boolean hasValidData = false;\n    for (int itemNo = 0; itemNo < dataset.getItemCount(); itemNo++) \n    {\n        double total = 0.0;\n        for (int seriesNo = 0; seriesNo < dataset.getSeriesCount(); seriesNo++) \n        {\n            double value = dataset.getYValue(seriesNo, itemNo);\n            if (!Double.isNaN(value)) \n            {\n                total = total + value;\n                hasValidData = true;\n            }\n        }\n        if (hasValidData) \n        {\n            minimum = Math.min(minimum, total);\n            maximum = Math.max(maximum, total);\n        }\n    }\n    if (hasValidData) \n    {\n        return new Range(minimum, maximum);\n    }\n    else \n    {\n        return null;\n    }\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    for (int itemNo = 0; itemNo < dataset.getItemCount(); itemNo++) {\n        double total = 0.0;\n        boolean hasValidData = false;\n        for (int seriesNo = 0; seriesNo < dataset.getSeriesCount(); seriesNo++) {\n            double value = dataset.getValue(seriesNo, itemNo);\n            if (!Double.isNaN(value)) {\n                hasValidData = true;\n                total = total + value;\n            }\n        }\n        if (hasValidData) {\n            minimum = Math.min(minimum, total);\n            maximum = Math.max(maximum, total);\n        }\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    for (int itemNo = 0; itemNo < dataset.getItemCount(); itemNo++) \n    {\n        double total = 0.0;\n        boolean hasValidData = false;\n        for (int seriesNo = 0; seriesNo < dataset.getSeriesCount(); seriesNo++) \n        {\n            double value = dataset.getYValue(seriesNo, itemNo);\n            if (!Double.isNaN(value)) \n            {\n                hasValidData = true;\n                total += value;\n            }\n        }\n        if (hasValidData) \n        {\n            minimum = Math.min(minimum, total);\n            maximum = Math.max(maximum, total);\n        }\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = 0.0;\n    double maximum = 0.0;\n    boolean hasValidData = false;\n    for (int itemNo = 0; itemNo < dataset.getItemCount(); itemNo++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getSeriesCount();\n        for (int seriesNo = 0; seriesNo < seriesCount; seriesNo++) \n        {\n            double y = dataset.getYValue(seriesNo, itemNo);\n            if (!Double.isNaN(y)) \n            {\n                total = total + y;\n                hasValidData = true;\n            }\n        }\n        if (hasValidData) \n        {\n            minimum = Math.min(minimum, total);\n            maximum = Math.max(maximum, total);\n        }\n    }\n    if (hasValidData) \n    {\n        return new Range(minimum, maximum);\n    }\n    else \n    {\n        return null;\n    }\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    for (int seriesNo = 0; seriesNo < seriesCount; seriesNo++) {\n        int itemCount = dataset.getItemCount(seriesNo);\n        double total = 0.0;\n        for (int itemNo = 0; itemNo < itemCount; itemNo++) {\n            double value = dataset.getValue(seriesNo, itemNo);\n            if (!Double.isNaN(value)) {\n                total = total + value;\n                if (total < minimum) {\n                    minimum = total;\n                }\n                if (total > maximum) {\n                    maximum = total;\n                }\n            }\n        }\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    for (int itemNo = 0; itemNo < dataset.getItemCount(); itemNo++) {\n        double total = 0.0;\n        boolean hasValidData = false;\n        for (int seriesNo = 0; seriesNo < dataset.getSeriesCount(); seriesNo++) {\n            double y = dataset.getYValue(seriesNo, itemNo);\n            if (!Double.isNaN(y)) {\n                hasValidData = true;\n                total = total + y;\n            }\n        }\n        if (hasValidData) {\n            minimum = Math.min(minimum, total);\n            maximum = Math.max(maximum, total);\n        }\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    for (int itemNo = 0; itemNo < dataset.getItemCount(); itemNo++) {\n        double total = 0.0;\n        boolean hasValidData = false;\n        for (int seriesNo = 0; seriesNo < dataset.getSeriesCount(); seriesNo++) {\n            double value = dataset.getValue(seriesNo, itemNo);\n            if (!Double.isNaN(value)) {\n                hasValidData = true;\n                total += value;\n            }\n        }\n        if (hasValidData) {\n            minimum = Math.min(minimum, total);\n            maximum = Math.max(maximum, total);\n        }\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    for (int itemNo = 0; itemNo < dataset.getItemCount(); itemNo++) \n    {\n        double total = 0.0;\n        boolean hasValidData = false;\n        for (int seriesNo = 0; seriesNo < dataset.getSeriesCount(); seriesNo++) \n        {\n            double value = dataset.getValue(seriesNo, itemNo);\n            if (!Double.isNaN(value)) \n            {\n                hasValidData = true;\n                total = total + value;\n            }\n        }\n        if (hasValidData) \n        {\n            minimum = Math.min(minimum, total);\n            maximum = Math.max(maximum, total);\n        }\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    for (int itemNo = 0; itemNo < dataset.getItemCount(); itemNo++) {\n        double total = 0.0;\n        boolean hasValidData = false;\n        for (int seriesNo = 0; seriesNo < dataset.getSeriesCount(); seriesNo++) {\n            double y = dataset.getYValue(seriesNo, itemNo);\n            if (!Double.isNaN(y)) {\n                hasValidData = true;\n                total = total + y;\n            }\n        }\n        if (hasValidData) {\n            minimum = Math.min(minimum, total);\n            maximum = Math.max(maximum, total);\n        }\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    for (int itemNo = 0; itemNo < dataset.getItemCount(); itemNo++) {\n        double total = 0.0;\n        boolean hasValidData = false;\n        for (int seriesNo = 0; seriesNo < dataset.getSeriesCount(); seriesNo++) {\n            double value = dataset.getYValue(seriesNo, itemNo);\n            if (!Double.isNaN(value)) {\n                hasValidData = true;\n                total = total + value;\n            }\n        }\n        if (hasValidData) {\n            minimum = Math.min(minimum, total);\n            maximum = Math.max(maximum, total);\n        }\n    }\n    return new Range(minimum, maximum);\n}"
    ],
    [
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return DateTimeZone.UTC;\n    }\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes must be positive when hours are positive\");\n    }\n    if (hoursOffset < 0 && minutesOffset > 0) {\n        throw new IllegalArgumentException(\"Minutes must be negative when hours are negative\");\n    }\n    long offset = (hoursOffset * 60L + minutesOffset) * 60L * 1000L;\n    if (offset > 23 * 60 * 60 * 1000L || offset < -23 * 60 * 60 * 1000L) {\n        throw new IllegalArgumentException(\"Offset too large or too small\");\n    }\n    String id = printOffset(offset);\n    return fixedOffsetZone(id, offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hour offset must be between -23 and 23 inclusive: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minute offset must be between -59 and 59 inclusive: \" + minutesOffset);\n    }\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return DateTimeZone.UTC;\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minute offset must be positive when hour offset is positive\");\n    }\n    if (hoursOffset < 0 && minutesOffset > 0) {\n        throw new IllegalArgumentException(\"Minute offset must be negative when hour offset is negative\");\n    }\n    long offset = (hoursOffset * 60L + minutesOffset) * 60L * 1000L;\n    if (offset == 0L) {\n        return DateTimeZone.UTC;\n    }\n    String id = printOffset(offset);\n    return fixedOffsetZone(id, offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"The hours offset must be in the range -23 to +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"The minutes offset must be in the range -59 to +59\");\n    }\n    if (hoursOffset >= 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"The minutes offset must be positive when the hours offset is positive\");\n    }\n    if (hoursOffset < 0 && minutesOffset > 0) {\n        throw new IllegalArgumentException(\"The minutes offset must be negative when the hours offset is negative\");\n    }\n    int totalMinutes = hoursOffset * 60 + minutesOffset;\n    if (totalMinutes < -1439 || totalMinutes > 1439) {\n        throw new IllegalArgumentException(\"The resulting offset must be between -23:59:59.000 and +23:59:59.000\");\n    }\n    String id = printOffset(totalMinutes);\n    return fixedOffsetZone(id, totalMinutes * 60000);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return DateTimeZone.UTC;\n    }\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes must be positive when hours is positive\");\n    }\n    if (hoursOffset < 0 && minutesOffset > 0) {\n        throw new IllegalArgumentException(\"Minutes must be negative when hours is negative\");\n    }\n    int totalMinutes = (hoursOffset * 60) + minutesOffset;\n    if (totalMinutes < -1439 || totalMinutes > 1439) {\n        throw new IllegalArgumentException(\"Offset out of range: \" + totalMinutes);\n    }\n    String id = (hoursOffset >= 0 ? \"+\" : \"-\") +\n                (hoursOffset < 10 ? \"0\" : \"\") + Math.abs(hoursOffset) +\n                (minutesOffset < 10 ? \":0\" : \":\") + Math.abs(minutesOffset);\n    return fixedOffsetZone(id, totalMinutes * 60000);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return DateTimeZone.UTC;\n    }\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"The offset hours is invalid: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"The offset minutes is invalid: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"The offset hours and minutes are invalid: \" + hoursOffset + \":\" + minutesOffset);\n    }\n    int offset = (hoursOffset * 60 + minutesOffset) * 60 * 1000;\n    return fixedOffsetZone(printOffset(offset), offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours offset must be in the range -23 to +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes offset must be in the range -59 to +59\");\n    }\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return DateTimeZone.UTC;\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes offset must be positive when hours offset is positive\");\n    }\n    if (hoursOffset < 0 && minutesOffset > 0) {\n        throw new IllegalArgumentException(\"Minutes offset must be negative when hours offset is negative\");\n    }\n    if (Math.abs(hoursOffset) == 23 && Math.abs(minutesOffset) == 59) {\n        throw new IllegalArgumentException(\"The resulting offset exceeds +/- 23:59:59.000\");\n    }\n    String id = printOffset(hoursOffset, minutesOffset);\n    return fixedOffsetZone(id, hoursOffset, minutesOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hour offset must be between -23 and 23 inclusive\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minute offset must be between -59 and 59 inclusive\");\n    }\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return DateTimeZone.UTC;\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minute offset must be positive when hour offset is positive\");\n    }\n    if (hoursOffset < 0 && minutesOffset > 0) {\n        throw new IllegalArgumentException(\"Minute offset must be negative when hour offset is negative\");\n    }\n    long offset = (((long) hoursOffset) * 60L + (long) minutesOffset) * 60L * 1000L;\n    if (offset > 23 * 60 * 60 * 1000L || offset < -23 * 60 * 60 * 1000L) {\n        throw new IllegalArgumentException(\"Total offset must be between -23:59:59.000 and +23:59:59.000 inclusive\");\n    }\n    String id = \"GMT\" + (hoursOffset >= 0 ? \"+\" : \"\") + hoursOffset + (minutesOffset < 10 ? \":0\" : \":\") + minutesOffset;\n    return fixedOffsetZone(id, offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return DateTimeZone.UTC;\n    }\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hour offset must be in the range -23 to +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minute offset must be in the range -59 to +59\");\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minute offset must be positive when hour offset is positive\");\n    }\n    if (hoursOffset < 0 && minutesOffset > 0) {\n        throw new IllegalArgumentException(\"Minute offset must be negative when hour offset is negative\");\n    }\n    long offset = (((long) hoursOffset) * 60L + (long) minutesOffset) * 60L * 1000L;\n    return fixedOffsetZone(hoursOffset + \":\" + minutesOffset, offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"The offset hours value must be in the range -23 to +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"The offset minutes value must be in the range -59 to +59\");\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"The offset minutes value must be positive when the offset hours value is positive\");\n    }\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return DateTimeZone.UTC;\n    }\n    int offset = (hoursOffset * 60 + minutesOffset) * 60 * 1000;\n    return fixedOffsetZone(hoursOffset + \":\" + minutesOffset, offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset == 0 && minutesOffset == 0) \n    {\n        return DateTimeZone.UTC;\n    }\n    else \n    {\n        String id = printOffset(hoursOffset, minutesOffset);\n        return fixedOffsetZone(id, hoursOffset, minutesOffset);\n    }\n}"
    ],
    [
      "public String chompBalanced(char open, char close)  {\n    int start = -1;\n    int end = -1;\n    int depth = 0;\n    char last = 0;\n    boolean inQuote = false;\n    for (int i = pos; i < queue.length(); i++) \n    {\n        char c = queue.charAt(i);\n        if (c == open) \n        {\n            if (!inQuote && depth++ == 0) \n            {\n                start = i;\n            }\n        } \n        else if (c == close) \n        {\n            if (!inQuote && --depth <= 0) \n            {\n                end = i;\n                break;\n            }\n        } \n        else if (c == '\\'' || c == '\"') \n        {\n            if (last != '\\\\') \n            {\n                inQuote = !inQuote;\n            }\n        }\n        last = c;\n    }\n    if (start != -1 && end != -1) \n    {\n        String matched = queue.substring(start + 1, end);\n        queue = queue.substring(end + 1);\n        pos = 0;\n        return matched;\n    } \n    else \n    {\n        return \"\";\n    }\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = -1;\n    int end = -1;\n    int depth = 0;\n    char last = 0;\n    boolean inQuote = false;\n    boolean inEscape = false;\n    for (int i = pos; i < queue.length(); i++) {\n        char c = queue.charAt(i);\n        if (inEscape) {\n            inEscape = false;\n            continue;\n        }\n        if (c == '\\\\') {\n            inEscape = true;\n            continue;\n        }\n        if (c == '\\'' || c == '\"') {\n            if (inQuote && last != '\\\\') {\n                inQuote = false;\n            } else if (!inQuote && last != '\\\\') {\n                inQuote = true;\n            }\n            continue;\n        }\n        if (inQuote) {\n            continue;\n        }\n        if (c == open) {\n            depth++;\n            if (start == -1)\n                start = i;\n        } else if (c == close) {\n            depth--;\n            if (depth == 0) {\n                end = i;\n                break;\n            }\n        }\n        last = c;\n    }\n    if (start != -1 && end != -1) {\n        String matched = queue.substring(start, end + 1);\n        queue = queue.substring(end + 1);\n        pos = 0;\n        return matched;\n    }\n    return null;\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = -1;\n    int end = -1;\n    int depth = 0;\n    char current;\n    boolean inQuote = false;\n    boolean inEscape = false;\n    StringBuilder sb = new StringBuilder();\n    for (int i = pos; i < queue.length(); i++) {\n        current = queue.charAt(i);\n        if (inEscape) {\n            sb.append(current);\n            inEscape = false;\n        } else if (current == '\\\\') {\n            inEscape = true;\n        } else if (current == '\\'' || current == '\"') {\n            inQuote = !inQuote;\n            sb.append(current);\n        } else if (!inQuote) {\n            if (current == open) {\n                depth++;\n                if (start == -1)\n                    start = i;\n            } else if (current == close) {\n                depth--;\n                if (depth == 0) {\n                    end = i;\n                    break;\n                }\n            }\n        }\n        sb.append(current);\n    }\n    if (start != -1 && end != -1) {\n        pos = end + 1;\n        return sb.toString();\n    }\n    return \"\";\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = -1;\n    int end = -1;\n    int depth = 0;\n    char last = 0;\n    boolean inQuote = false;\n    for (int i = pos; i < queue.length(); i++) {\n        char c = queue.charAt(i);\n        if (c == '\\\\') {\n            i++;\n            continue;\n        }\n        if (c == '\\'' || c == '\"') {\n            if (inQuote && last != '\\\\') {\n                inQuote = false;\n            } else if (!inQuote && last != '\\\\') {\n                inQuote = true;\n            }\n        }\n        if (inQuote)\n            continue;\n        if (c == open) {\n            depth++;\n            if (start == -1)\n                start = i;\n        } else if (c == close) {\n            depth--;\n            if (depth == 0) {\n                end = i;\n                break;\n            }\n        }\n        last = c;\n    }\n    if (end == -1 || start == -1)\n        throw new IllegalStateException(\"Could not find balanced marker: \" + open + \", \" + close);\n    String balanced = queue.substring(start, end + 1);\n    pos = end + 1;\n    return balanced;\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = -1;\n    int end = -1;\n    int depth = 0;\n    boolean inQuote = false;\n    boolean inEscape = false;\n    char c;\n    for (int i = pos; i < queue.length(); i++) \n    {\n        c = queue.charAt(i);\n        if (inEscape) \n        {\n            inEscape = false;\n        } \n        else if (c == '\\\\') \n        {\n            inEscape = true;\n        } \n        else if (c == '\\'' || c == '\"') \n        {\n            inQuote = !inQuote;\n        } \n        else if (c == open) \n        {\n            if (!inQuote) \n            {\n                depth++;\n                if (start == -1) \n                {\n                    start = i;\n                }\n            }\n        } \n        else if (c == close) \n        {\n            if (!inQuote) \n            {\n                depth--;\n                if (depth == 0 && start != -1) \n                {\n                    end = i;\n                    break;\n                }\n            }\n        }\n    }\n    if (start != -1 && end != -1) \n    {\n        String matched = queue.substring(start, end + 1);\n        queue = queue.substring(end + 1);\n        pos = 0;\n        return matched;\n    } \n    else \n    {\n        return null;\n    }\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = -1;\n    int end = -1;\n    int depth = 0;\n    char last = 0;\n    boolean inQuote = false;\n    for (int i = pos; i < queue.length(); i++) \n    {\n        char c = queue.charAt(i);\n        if (c == open) \n        {\n            if (inQuote) \n            {\n                if (last == '\\\\') \n                {\n                    depth++;\n                }\n            } \n            else \n            {\n                depth++;\n                start = i;\n            }\n        } \n        else if (c == close) \n        {\n            if (inQuote) \n            {\n                if (last == '\\\\') \n                {\n                    depth--;\n                }\n            } \n            else \n            {\n                depth--;\n                end = i;\n            }\n        } \n        else if (c == '\\'' || c == '\"') \n        {\n            if (inQuote && last != '\\\\') \n            {\n                inQuote = false;\n            } \n            else if (!inQuote && last != '\\\\') \n            {\n                inQuote = true;\n            }\n        }\n        last = c;\n        if (depth == 0) \n        {\n            break;\n        }\n    }\n    if (start != -1 && end != -1) \n    {\n        String data = queue.substring(start, end + 1);\n        pos = end + 1;\n        return data;\n    } \n    else \n    {\n        return null;\n    }\n}",
      "public String chompBalanced(char open, char close)  {\n    // todo: implement\n    return null;\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = -1;\n    int end = -1;\n    int depth = 0;\n    boolean inQuote = false;\n    boolean inEscape = false;\n    for (int i = pos; i < queue.length(); i++) {\n        char c = queue.charAt(i);\n        if (c == open) {\n            if (!inEscape && (inQuote && queue.charAt(i-1) == '\\\\' || !inQuote)) {\n                depth++;\n                if (start == -1)\n                    start = i;\n            }\n        } else if (c == close) {\n            if (!inEscape && (inQuote && queue.charAt(i-1) == '\\\\' || !inQuote)) {\n                depth--;\n                if (depth == 0) {\n                    end = i;\n                    break;\n                }\n            }\n        } else if (c == '\"' || c == '\\'') {\n            if (!inEscape) {\n                if (inQuote && queue.charAt(i-1) != '\\\\')\n                    inQuote = false;\n                else if (!inQuote && queue.charAt(i-1) != '\\\\')\n                    inQuote = true;\n            }\n        } else if (c == '\\\\') {\n            if (!inEscape)\n                inEscape = true;\n            else\n                inEscape = false;\n        } else {\n            inEscape = false;\n        }\n    }\n    if (end == -1 || start == -1)\n        throw new IllegalStateException(\"Unbalanced brackets\");\n    String data = queue.substring(start, end+1);\n    pos = end+1;\n    return data;\n}",
      "public String chompBalanced(char open, char close)  {\n    //start from the current position\n    int start = pos;\n    //count the number of openers\n    int openerCount = 0;\n    //count the number of closers\n    int closerCount = 0;\n    //loop through the queue\n    while(!isEmpty())\n    {\n        //get the current character\n        char c = queue.charAt(pos);\n        //if the current character is an opener\n        if(c == open)\n        {\n            //increment the opener count\n            openerCount++;\n        }\n        //if the current character is a closer\n        else if(c == close)\n        {\n            //increment the closer count\n            closerCount++;\n        }\n        //if the opener count is greater than the closer count\n        if(openerCount > closerCount)\n        {\n            //increment the position\n            pos++;\n        }\n        //if the closer count is greater than the opener count\n        else if(closerCount > openerCount)\n        {\n            //decrement the position\n            pos--;\n        }\n        //if the opener count is equal to the closer count\n        else\n        {\n            //return the substring\n            return queue.substring(start, pos);\n        }\n    }\n    //if the queue is empty\n    return queue.substring(start, pos);\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = -1;\n    int end = -1;\n    int depth = 0;\n    String data = \"\";\n    boolean inQuote = false;\n    char last = 0;\n\n    for (int i = pos; i < queue.length(); i++) \n    {\n        char c = queue.charAt(i);\n        if (c == '\\\\') \n        {\n            i++;\n            continue;\n        }\n        if (c == '\\'' || c == '\"') \n        {\n            if (inQuote && last != '\\\\') \n            {\n                inQuote = false;\n            }\n            else if (!inQuote) \n            {\n                inQuote = true;\n            }\n        }\n        if (c == open) \n        {\n            if (depth == 0) \n            {\n                start = i;\n            }\n            depth++;\n        }\n        else if (c == close) \n        {\n            depth--;\n            if (depth == 0) \n            {\n                end = i;\n                break;\n            }\n        }\n        last = c;\n    }\n\n    if (start != -1 && end != -1) \n    {\n        data = queue.substring(start, end + 1);\n        pos = end + 1;\n    }\n    else \n    {\n        pos = queue.length();\n    }\n    return data;\n}"
    ],
    [
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final int p = getBeta().getDimension();\n        final RealMatrix qrR = qr.getR();\n        final RealMatrix r = qrR.getSubMatrix(0, p - 1, 0, qrR.getColumnDimension() - 1);\n        final RealMatrix rtR = r.transpose().multiply(r);\n        return rtR.inverse();\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final int n = getX().getRowDimension();\n        final int p = getX().getColumnDimension();\n        final RealMatrix inv = qr.getSolver().getInverse();\n        final RealMatrix cov = inv.getSubMatrix(0, p - 1, 0, p - 1);\n        return cov;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final RealMatrix invXtX = qr.getSolver().getInverse();\n        final int p = getBeta().getDimension();\n        return invXtX.getSubMatrix(0, p - 1, 0, p - 1);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final RealMatrix r = qr.getR();\n        final int p = getBeta().getDimension();\n        final RealMatrix rt = r.getSubMatrix(0, p - 1, 0, r.getColumnDimension() - 1);\n        final RealMatrix rtR = rt.multiply(rt.transpose());\n        return rtR.inverse();\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final RealMatrix xTx = getX().transpose().multiply(getX());\n        final RealMatrix r = qr.getR();\n        final int p = getX().getColumnDimension();\n        final int n = getX().getRowDimension();\n        final RealMatrix rTxTx = r.getSubMatrix(0, p - 1, 0, n - 1);\n        final RealMatrix rTxTxInv = new LUDecomposition(rTxTx).getSolver().getInverse();\n        return rTxTxInv.multiply(xTx).multiply(rTxTxInv.transpose());\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // No advertised DME, args are valid\n        final RealMatrix r = qr.getR();\n        final int p = getBeta().getDimension();\n        final RealMatrix rt = r.getSubMatrix(0, p - 1, 0, r.getColumnDimension() - 1);\n        final RealMatrix rtR = rt.multiply(r);\n        final RealMatrix invRtR = new LUDecomposition(rtR).getSolver().getInverse();\n        return invRtR;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final RealMatrix xTx = getX().transpose().multiply(getX());\n        final RealMatrix rTxTx = qr.getR().getSubMatrix(0, qr.getR().getRowDimension() - 1, 0, getX().getColumnDimension() - 1).transpose().multiply(xTx);\n        return rTxTx.getSolver().solve(rTxTx);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final RealMatrix r = qr.getR();\n        final RealMatrix rt = r.transpose();\n        final RealMatrix rtr = rt.multiply(r);\n        final RealMatrix rtrInv = new LUDecomposition(rtr).getSolver().getInverse();\n        return rtrInv;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final RealMatrix xTx = getX().transpose().multiply(getX());\n        final RealMatrix rTx = qr.getR().getSubMatrix(0, getX().getColumnDimension() - 1, 0, getX().getColumnDimension() - 1).transpose();\n        final RealMatrix rTr = rTx.multiply(rTx.transpose());\n        final RealMatrix invRTr = new LUDecomposition(rTr).getSolver().getInverse();\n        return invRTr.multiply(xTx).multiply(invRTr);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final RealMatrix xTx = getX().transpose().multiply(getX());\n        final RealMatrix rTx = qr.getQT().multiply(xTx);\n        final RealMatrix rTxInv = new LUDecomposition(rTx).getSolver().getInverse();\n        return rTxInv.multiply(rTx.transpose());\n    }"
    ],
    [
      "private static String printOffset(int offset)  {\n    // Can't use a real chronology if called during class\n    // initialization. Offset parser doesn't need it anyhow.\n}",
      "private static String printOffset(int offset)  {\n    // Backwards compatible with TimeZone.\n    if (offset == 0) {\n        return \"Z\";\n    }\n    if (offset % (60 * 1000) == 0) {\n        return String.format(\"%+03d\", offset / (60 * 1000));\n    }\n    return String.format(\"%+03d:%02d\", offset / (60 * 1000), Math.abs((offset % (60 * 1000)) / 1000));\n}",
      "private static String printOffset(int offset)  {\n    // Use the default chronology to avoid initialization issues.\n    Chronology chrono = ISOChronology.getInstance();\n    String str = offsetFormatter().withChronology(chrono).print(offset);\n    if (offset < 0) {\n        str = \"-\" + str;\n    }\n    return str;\n}",
      "private static String printOffset(int offset)  {\n    // Convert to hours and minutes\n    int hours = Math.abs(offset / 60);\n    int minutes = Math.abs(offset % 60);\n\n    // Build the string\n    StringBuilder buf = new StringBuilder();\n    buf.append(offset < 0 ? \"-\" : \"+\");\n    buf.append(hours < 10 ? \"0\" : \"\");\n    buf.append(hours);\n    buf.append(minutes < 10 ? \":0\" : \":\");\n    buf.append(minutes);\n    return buf.toString();\n}",
      "private static String printOffset(int offset)  {\n    return offsetFormatter().print(offset);\n}",
      "private static String printOffset(int offset)  {\n    // Can't use a real chronology if called during class\n    // initialization. Offset parser doesn't need it anyhow.\n    Chronology chrono = new BaseChronology() \n}",
      "private static String printOffset(int offset)  {\n    // TODO: Implement this method\n}",
      "private static String printOffset(int offset)  {\n    return offsetFormatter().print(offset);\n}",
      "private static String printOffset(int offset)  {\n    return offsetFormatter().print(offset);\n}",
      "private static String printOffset(int offset)  {\n    // Backwards compatibility with TimeZone.\n    if (offset == 0) {\n        return \"Z\";\n    }\n    String sign = offset > 0 ? \"+\" : \"-\";\n    offset = Math.abs(offset);\n    int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n    int minutes = (offset - (hours * DateTimeConstants.MILLIS_PER_HOUR)) / DateTimeConstants.MILLIS_PER_MINUTE;\n    return sign + String.format(\"%02d:%02d\", hours, minutes);\n}"
    ],
    [
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Integer index = (Integer) this.indexMap.get(key);\n    if (index != null) {\n        return index.intValue();\n    }\n    else {\n        return -1;\n    }\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Integer index = (Integer) this.indexMap.get(key);\n    if (index != null) {\n        return index.intValue();\n    }\n    else {\n        return -1;\n    }\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Integer index = (Integer) this.indexMap.get(key);\n    if (index != null) \n    {\n        return index.intValue();\n    }\n    else \n    {\n        return -1;\n    }\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Integer index = (Integer) this.indexMap.get(key);\n    if (index != null) \n    {\n        return index.intValue();\n    }\n    else \n    {\n        return -1;\n    }\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Integer index = (Integer) this.indexMap.get(key);\n    if (index != null) {\n        return index.intValue();\n    }\n    else {\n        return -1;\n    }\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Integer index = (Integer) this.indexMap.get(key);\n    if (index != null) {\n        return index.intValue();\n    }\n    else {\n        return -1;\n    }\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Integer index = (Integer) this.indexMap.get(key);\n    if (index != null) \n    {\n        return index.intValue();\n    }\n    else \n    {\n        return -1;\n    }\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Integer index = (Integer) this.indexMap.get(key);\n    if (index != null) {\n        return index.intValue();\n    }\n    else {\n        return -1;\n    }\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Integer index = (Integer) this.indexMap.get(key);\n    if (index != null) \n    {\n        return index.intValue();\n    }\n    else \n    {\n        return -1;\n    }\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Integer index = (Integer) this.indexMap.get(key);\n    if (index != null) {\n        return index.intValue();\n    }\n    else {\n        return -1;\n    }\n}"
    ],
    [
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> flowSlots = new HashMap<>();\n  LinkedFlowScope linkedA = (LinkedFlowScope) a;\n  LinkedFlowScope linkedB = (LinkedFlowScope) b;\n  linkedA.frozen = true;\n  linkedB.frozen = true;\n  if (linkedA.optimize() == linkedB.optimize()) {\n    return linkedA.createChildFlowScope();\n  }\n  return new LinkedFlowScope(new FlatFlowScopeCache(linkedA, linkedB));\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> allSlots = new HashMap<>();\n  for (String name : cache.dirtySymbols) {\n    StaticSlot<JSType> slot = getSlot(name);\n    if (slot != null) {\n      allSlots.put(name, slot);\n    }\n  }\n  return allSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> result = new HashMap<>();\n    for (String name : cache.dirtySymbols) {\n      StaticSlot<JSType> slot = getSlot(name);\n      if (slot != null) {\n        result.put(name, slot);\n      }\n    }\n    return result;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> flowSlots = new HashMap<>();\n  LinkedFlowScope linkedA = (LinkedFlowScope) a;\n  LinkedFlowScope linkedB = (LinkedFlowScope) b;\n  linkedA.frozen = true;\n  linkedB.frozen = true;\n  if (linkedA.optimize() == linkedB.optimize()) {\n    return linkedA.createChildFlowScope();\n  }\n  return new LinkedFlowScope(new FlatFlowScopeCache(linkedA, linkedB));\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> result = new HashMap<>();\n    if (cache != null) {\n      for (String name : cache.dirtySymbols) {\n        StaticSlot<JSType> slot = getSlot(name);\n        if (slot != null) {\n          result.put(name, slot);\n        }\n      }\n    }\n    return result;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> allSlots = new HashMap<>();\n  for (StaticSlot<JSType> slot : getSlots()) {\n    if (slot.getType() != null) {\n      allSlots.put(slot.getName(), slot);\n    }\n  }\n  return allSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  if (cache == null) {\n    return getParentScope().allFlowSlots();\n  }\n\n  Map<String, StaticSlot<JSType>> allSlots = new HashMap<>();\n  for (String name : cache.dirtySymbols) {\n    StaticSlot<JSType> slot = getSlot(name);\n    if (slot != null) {\n      allSlots.put(name, slot);\n    }\n  }\n  return allSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> result = new HashMap<>();\n    for (StaticSlot<JSType> slot : getParentScope().getAllSlots()) {\n      if (slot.getType() != null) {\n        result.put(slot.getName(), slot);\n      }\n    }\n    return result;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> allSlots = new HashMap<>();\n  if (cache != null) {\n    for (String name : cache.dirtySymbols) {\n      allSlots.put(name, getSlot(name));\n    }\n  }\n  return allSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> allSlots = new HashMap<>();\n    for (StaticSlot<JSType> slot : cache.getFlowSlots()) {\n      if (slot.getType() != null) {\n        allSlots.put(slot.getName(), slot);\n      }\n    }\n    return allSlots;\n  }"
    ],
    [
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        final int nRows = columnData.length;\n        final RealMatrix m = createRealMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        final int nRows = columnData.length;\n        final RealMatrix m = createRealMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        final int nRows = columnData.length;\n        final RealMatrix m = createRealMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        final int nRows = columnData.length;\n        final RealMatrix m = createRealMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        final int nRows = columnData.length;\n        final RealMatrix m = createRealMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        final int nRows = columnData.length;\n        final RealMatrix m = createRealMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}"
    ],
    [
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n\n    double result;\n    if (a > 0.5) {\n        double hiPrec[] = new double[2];\n        // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n        expm1(x*2.0, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        /* Numerator */\n        double na = ya;\n        double nb = yb;\n\n        /* Denominator */\n        double da = 2.0 + ya;\n        double db = -(da - 2.0 - ya);\n        double temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n\n        temp = da * HEX_40000000;\n        double daa = da + temp - temp;\n        double dab = da - daa;\n\n        // ratio = na/da\n        double ratio = na/da;\n        temp = ratio * HEX_40000000;\n        double ratioa = ratio + temp - temp;\n        double ratiob = ratio - ratioa;\n\n        // Correct for rounding in division\n        ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n        // Account for nb\n        ratiob += nb / da;\n        // Account for db\n        ratiob += -db * na / da / da;\n\n        result = ratioa + ratiob;\n    }\n    else {\n        double hiPrec[] = new double[2];\n        // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n        expm1(x*2.0, hiPrec);\n\n}\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n\n    double result;\n    if (a > 0.5) {\n        double hiPrec[] = new double[2];\n        // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n        expm1(x*2.0, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        /* Numerator */\n        double na = ya;\n        double nb = yb;\n\n        /* Denominator */\n        double da = 2.0 + ya;\n        double db = -(da - 2.0 - ya);\n        double temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n\n        temp = da * HEX_40000000;\n        double daa = da + temp - temp;\n        double dab = da - daa;\n\n        // ratio = na/da\n        double ratio = na/da;\n        temp = ratio * HEX_40000000;\n        double ratioa = ratio + temp - temp;\n        double ratiob = ratio - ratioa;\n\n        // Correct for rounding in division\n        ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n        // Account for nb\n        ratiob += nb / da;\n        // Account for db\n        ratiob += -db * na / da / da;\n\n        result = ratioa + ratiob;\n    }\n    else {\n        double hiPrec[] = new double[2];\n        // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n        expm1(x*2.0, hiPrec);\n\n}\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n\n    double result;\n    if (a > 0.5) {\n        double hiPrec[] = new double[2];\n        // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n        expm1(x*2.0, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        /* Numerator */\n        double na = ya;\n        double nb = yb;\n\n        /* Denominator */\n        double da = 2.0 + ya;\n        double db = -(da - 2.0 - ya);\n        double temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n\n        temp = da * HEX_40000000;\n        double daa = da + temp - temp;\n        double dab = da - daa;\n\n        // ratio = na/da\n        double ratio = na/da;\n        temp = ratio * HEX_40000000;\n        double ratioa = ratio + temp - temp;\n        double ratiob = ratio - ratioa;\n\n        // Correct for rounding in division\n        ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n        // Account for nb\n        ratiob += nb / da;\n        // Account for db\n        ratiob += -db * na / da / da;\n\n        result = ratioa + ratiob;\n    }\n    else {\n        double hiPrec[] = new double[2];\n        // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n        expm1(x*2.0, hiPrec);\n\n}\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n\n    double result;\n    if (a > 0.5) {\n        double hiPrec[] = new double[2];\n        // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n        expm1(x*2.0, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        /* Numerator */\n        double na = ya;\n        double nb = yb;\n\n        /* Denominator */\n        double da = 2.0 + ya;\n        double db = -(da - 2.0 - ya);\n        double temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n\n        temp = da * HEX_40000000;\n        double daa = da + temp - temp;\n        double dab = da - daa;\n\n        // ratio = na/da\n        double ratio = na/da;\n        temp = ratio * HEX_40000000;\n        double ratioa = ratio + temp - temp;\n        double ratiob = ratio - ratioa;\n\n        // Correct for rounding in division\n        ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n        // Account for nb\n        ratiob += nb / da;\n        // Account for db\n        ratiob += -db * na / da / da;\n\n        result = ratioa + ratiob;\n    }\n    else {\n        double hiPrec[] = new double[2];\n        // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n        expm1(x*2.0, hiPrec);\n\n}\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n\n    double result;\n    if (a > 0.5) {\n        double hiPrec[] = new double[2];\n        // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n        expm1(x*2.0, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        /* Numerator */\n        double na = ya;\n        double nb = yb;\n\n        /* Denominator */\n        double da = 2.0 + ya;\n        double db = -(da - 2.0 - ya);\n        double temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n\n        temp = da * HEX_40000000;\n        double daa = da + temp - temp;\n        double dab = da - daa;\n\n        // ratio = na/da\n        double ratio = na/da;\n        temp = ratio * HEX_40000000;\n        double ratioa = ratio + temp - temp;\n        double ratiob = ratio - ratioa;\n\n        // Correct for rounding in division\n        ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n        // Account for nb\n        ratiob += nb / da;\n        // Account for db\n        ratiob += -db * na / da / da;\n\n        result = ratioa + ratiob;\n    }\n    else {\n        double hiPrec[] = new double[2];\n        // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n        expm1(x*2.0, hiPrec);\n\n}\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n\n    double result;\n    if (a > 0.5) {\n        double hiPrec[] = new double[2];\n        // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n        expm1(x*2.0, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        /* Numerator */\n        double na = ya;\n        double nb = yb;\n\n        /* Denominator */\n        double da = 2.0 + ya;\n        double db = -(da - 2.0 - ya);\n        double temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n\n        temp = da * HEX_40000000;\n        double daa = da + temp - temp;\n        double dab = da - daa;\n\n        // ratio = na/da\n        double ratio = na/da;\n        temp = ratio * HEX_40000000;\n        double ratioa = ratio + temp - temp;\n        double ratiob = ratio - ratioa;\n\n        // Correct for rounding in division\n        ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n        // Account for nb\n        ratiob += nb / da;\n        // Account for db\n        ratiob += -db * na / da / da;\n\n        result = ratioa + ratiob;\n    }\n    else {\n        double hiPrec[] = new double[2];\n        // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n        expm1(x*2.0, hiPrec);\n\n}\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n\n    double result;\n    if (a > 0.5) {\n        double hiPrec[] = new double[2];\n        // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n        expm1(x*2.0, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        /* Numerator */\n        double na = ya;\n        double nb = yb;\n\n        /* Denominator */\n        double da = 2.0 + ya;\n        double db = -(da - 2.0 - ya);\n        double temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n\n        temp = da * HEX_40000000;\n        double daa = da + temp - temp;\n        double dab = da - daa;\n\n        // ratio = na/da\n        double ratio = na/da;\n        temp = ratio * HEX_40000000;\n        double ratioa = ratio + temp - temp;\n        double ratiob = ratio - ratioa;\n\n        // Correct for rounding in division\n        ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n        // Account for nb\n        ratiob += nb / da;\n        // Account for db\n        ratiob += -db * na / da / da;\n\n        result = ratioa + ratiob;\n    }\n    else {\n        double hiPrec[] = new double[2];\n        // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n        expm1(x*2.0, hiPrec);\n\n}\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n\n    double result;\n    if (a > 0.5) {\n        double hiPrec[] = new double[2];\n        // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n        expm1(x*2.0, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        /* Numerator */\n        double na = ya;\n        double nb = yb;\n\n        /* Denominator */\n        double da = 2.0 + ya;\n        double db = -(da - 2.0 - ya);\n        double temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n\n        temp = da * HEX_40000000;\n        double daa = da + temp - temp;\n        double dab = da - daa;\n\n        // ratio = na/da\n        double ratio = na/da;\n        temp = ratio * HEX_40000000;\n        double ratioa = ratio + temp - temp;\n        double ratiob = ratio - ratioa;\n\n        // Correct for rounding in division\n        ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n        // Account for nb\n        ratiob += nb / da;\n        // Account for db\n        ratiob += -db * na / da / da;\n\n        result = ratioa + ratiob;\n    }\n    else {\n        double hiPrec[] = new double[2];\n        // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n        expm1(x*2.0, hiPrec);\n\n}\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n\n    double result;\n    if (a > 0.5) {\n        double hiPrec[] = new double[2];\n        // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n        expm1(x*2.0, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        /* Numerator */\n        double na = ya;\n        double nb = yb;\n\n        /* Denominator */\n        double da = 2.0 + ya;\n        double db = -(da - 2.0 - ya);\n        double temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n\n        temp = da * HEX_40000000;\n        double daa = da + temp - temp;\n        double dab = da - daa;\n\n        // ratio = na/da\n        double ratio = na/da;\n        temp = ratio * HEX_40000000;\n        double ratioa = ratio + temp - temp;\n        double ratiob = ratio - ratioa;\n\n        // Correct for rounding in division\n        ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n        // Account for nb\n        ratiob += nb / da;\n        // Account for db\n        ratiob += -db * na / da / da;\n\n        result = ratioa + ratiob;\n    }\n    else {\n        double hiPrec[] = new double[2];\n        // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n        expm1(x*2.0, hiPrec);\n\n}\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n\n    double result;\n    if (a > 0.5) {\n        double hiPrec[] = new double[2];\n        // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n        expm1(x*2.0, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        /* Numerator */\n        double na = ya;\n        double nb = yb;\n\n        /* Denominator */\n        double da = 2.0 + ya;\n        double db = -(da - 2.0 - ya);\n        double temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n\n        temp = da * HEX_40000000;\n        double daa = da + temp - temp;\n        double dab = da - daa;\n\n        // ratio = na/da\n        double ratio = na/da;\n        temp = ratio * HEX_40000000;\n        double ratioa = ratio + temp - temp;\n        double ratiob = ratio - ratioa;\n\n        // Correct for rounding in division\n        ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n        // Account for nb\n        ratiob += nb / da;\n        // Account for db\n        ratiob += -db * na / da / da;\n\n        result = ratioa + ratiob;\n    }\n    else {\n        double hiPrec[] = new double[2];\n        // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n        expm1(x*2.0, hiPrec);\n\n}\n}"
    ],
    [
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n        if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NAN_VALUE_IN_SUM);\n        }\n\n        double sum = 0;\n        for (int i = 0; i < values.length; i++) {\n            if (!Double.isNaN(values[i])) {\n                sum += values[i];\n            }\n        }\n\n        if (sum == 0) {\n            throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_SUM_TO_ZERO);\n        }\n\n        double[] normalized = new double[values.length];\n        for (int i = 0; i < values.length; i++) {\n            if (!Double.isNaN(values[i])) {\n                normalized[i] = values[i] * normalizedSum / sum;\n            }\n        }\n        return normalized;\n    }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n        if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NAN_VALUE_IS_NOT_ALLOWED);\n        }\n\n        double sum = 0;\n        for (int i = 0; i < values.length; i++) {\n            if (!Double.isNaN(values[i])) {\n                sum += values[i];\n            }\n        }\n\n        if (sum == 0) {\n            throw new MathArithmeticException(LocalizedFormats.SUM_OF_NON_NAN_VALUES_IS_ZERO);\n        }\n\n        double[] normalized = new double[values.length];\n        for (int i = 0; i < values.length; i++) {\n            if (!Double.isNaN(values[i])) {\n                normalized[i] = values[i] * normalizedSum / sum;\n            } else {\n                normalized[i] = values[i];\n            }\n        }\n\n        return normalized;\n    }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.NORMALIZED_SUM_INFINITE_OR_NAN,\n                normalizedSum);\n    }\n\n    double sum = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n\n    if (sum == 0) {\n        throw new MathArithmeticException(\n                LocalizedFormats.CANNOT_NORMALIZE_ARRAY_WITH_SUMS_TO_ZERO);\n    }\n\n    double[] normalized = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            normalized[i] = values[i] * normalizedSum / sum;\n        } else {\n            normalized[i] = values[i];\n        }\n    }\n\n    return normalized;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n    // Check if the input array is valid\n    if (values == null) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NULL_NOT_ALLOWED);\n    }\n\n    // Check if the target sum is valid\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NAN_NOT_ALLOWED);\n    }\n\n    // Calculate the sum of the input array\n    double sum = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n\n    // Check if the input array contains any infinite elements\n    if (Double.isInfinite(sum)) {\n        throw new MathArithmeticException(LocalizedFormats.INFINITE_NOT_ALLOWED);\n    }\n\n    // Check if the input array sums to zero\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NOT_ALLOWED);\n    }\n\n    // Normalize the input array\n    double[] normalizedValues = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            normalizedValues[i] = values[i] * normalizedSum / sum;\n        }\n    }\n\n    return normalizedValues;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n        double sum = 0;\n        for (int i = 0; i < values.length; i++) {\n            if (!Double.isNaN(values[i])) {\n                sum += values[i];\n            }\n        }\n\n        if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NAN_VALUE_IN_SUM);\n        }\n\n        if (sum == 0) {\n            throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_SUM_IS_ZERO);\n        }\n\n        double[] normalizedValues = new double[values.length];\n        for (int i = 0; i < values.length; i++) {\n            if (!Double.isNaN(values[i])) {\n                normalizedValues[i] = values[i] * normalizedSum / sum;\n            }\n        }\n        return normalizedValues;\n    }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NAN_VALUE_IN_SUM, normalizedSum);\n    }\n\n    double sum = 0;\n    for (double value : values) {\n        if (!Double.isNaN(value)) {\n            sum += value;\n        }\n    }\n\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NOT_ALLOWED);\n    }\n\n    double[] normalizedValues = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            normalizedValues[i] = values[i] * normalizedSum / sum;\n        }\n    }\n\n    return normalizedValues;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n        double sum = 0;\n        for (double v : values) {\n            if (!Double.isNaN(v)) {\n                sum += v;\n            }\n        }\n\n        if (Double.isInfinite(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NAN_VALUE_IN_SUM, normalizedSum);\n        }\n\n        if (sum == 0) {\n            throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_SUM_TO_ZERO);\n        }\n\n        double[] normalized = new double[values.length];\n        for (int i = 0; i < values.length; i++) {\n            if (!Double.isNaN(values[i])) {\n                normalized[i] = values[i] * normalizedSum / sum;\n            }\n        }\n        return normalized;\n    }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n        double sum = 0;\n        for (int i = 0; i < values.length; i++) {\n            if (!Double.isNaN(values[i])) {\n                sum += values[i];\n            }\n        }\n        if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NAN_VALUE_IN_SUM);\n        }\n        if (sum == 0) {\n            throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_SUM_TO_ZERO);\n        }\n        double[] normalized = new double[values.length];\n        for (int i = 0; i < values.length; i++) {\n            if (!Double.isNaN(values[i])) {\n                normalized[i] = values[i] * normalizedSum / sum;\n            }\n        }\n        return normalized;\n    }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n    // Check for NaN and Infinity\n    if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NAN_VALUE_IS_INVALID);\n    }\n\n    // Initialize sum to 0\n    double sum = 0;\n\n    // Iterate over the input array\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n\n    // Check if sum is 0 or infinite\n    if (sum == 0 || Double.isInfinite(sum)) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);\n    }\n\n    // Initialize the normalized array\n    double[] normalizedArray = new double[values.length];\n\n    // Iterate over the input array and normalize\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            normalizedArray[i] = values[i] * normalizedSum / sum;\n        }\n    }\n\n    return normalizedArray;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n        double sum = 0;\n        for (int i = 0; i < values.length; i++) {\n            if (!Double.isNaN(values[i])) {\n                sum += values[i];\n            }\n        }\n        if (sum == 0) {\n            throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_SUM_IS_ZERO);\n        }\n        if (Double.isInfinite(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_IS_INFINITE);\n        }\n        double[] normalizedValues = new double[values.length];\n        for (int i = 0; i < values.length; i++) {\n            if (!Double.isNaN(values[i])) {\n                normalizedValues[i] = values[i] * normalizedSum / sum;\n            } else {\n                normalizedValues[i] = values[i];\n            }\n        }\n        return normalizedValues;\n    }"
    ],
    [
      "public static String capitalize(final String str, final char... delimiters)  {\n    int delimLen = (delimiters == null ? -1 : delimiters.length);\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int[] newCodePoints = new int[strLen];\n    int outOffset = 0;\n    for (int offset = 0, cp = 0; offset < strLen;) {\n        cp = str.codePointAt(offset);\n        offset += Character.charCount(cp);\n        boolean capitalize = true;\n        if (offset < strLen) {\n            int peek = str.codePointAt(offset);\n            if (delimiters != null) {\n                for (int i = 0; i < delimLen; i++) {\n                    if (peek == delimiters[i]) {\n                        capitalize = false;\n                        break;\n                    }\n                }\n            } else if (Character.isWhitespace(peek)) {\n                capitalize = false;\n            }\n        }\n        if (capitalize) {\n            newCodePoints[outOffset++] = Character.toTitleCase(cp);\n        } else {\n            newCodePoints[outOffset++] = cp;\n        }\n    }\n    if (outOffset == strLen) {\n        return str;\n    }\n    return new String(newCodePoints, 0, outOffset);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    int delimLen = (delimiters == null ? -1 : delimiters.length);\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (str == null || str.length() == 0 || delimLen == 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int[] newCodePoints = new int[strLen];\n    int count = 0;\n    boolean capitalizeNext = true;\n    for (int cp : str.codePoints().toArray()) {\n        if (isDelimiter(cp, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            newCodePoints[count++] = Character.toTitleCase(cp);\n            capitalizeNext = false;\n        } else {\n            newCodePoints[count++] = cp;\n        }\n    }\n    if (count == strLen) {\n        return str;\n    }\n    return new String(newCodePoints, 0, count);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    int delimLen = (delimiters == null ? -1 : delimiters.length);\n    if (str == null || str.length() == 0 || delimLen == 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int[] newCodePoints = new int[strLen];\n    int outOffset = 0;\n    for (int offset = 0, codePoint; offset < strLen; offset += Character.charCount(codePoint)) {\n        codePoint = str.codePointAt(offset);\n        if (Character.isWhitespace(codePoint) ||\n                (delimLen > 0 && Character.toString(delimiters[0]).indexOf(codePoint) > -1)) {\n            // Whitespace or delimiter, add whitespace\n            newCodePoints[outOffset++] = codePoint;\n            for (int j = 1; j < delimLen; j++) {\n                if (delimiters[j] == codePoint) {\n                    newCodePoints[outOffset++] = codePoint;\n                    break;\n                }\n            }\n        } else {\n            // Convert to title case\n            newCodePoints[outOffset++] = Character.toTitleCase(codePoint);\n        }\n    }\n    if (outOffset == strLen) {\n        return str;\n    }\n    return new String(newCodePoints, 0, outOffset);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    int delimLen = (delimiters == null ? -1 : delimiters.length);\n    if (str == null || str.length() == 0 || delimLen == 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int[] newCodePoints = new int[strLen];\n    int outOffset = 0;\n    for (int offset = 0, codePoint; offset < strLen;) {\n        codePoint = str.codePointAt(offset);\n        if (Character.isWhitespace(codePoint) || Character.isSpaceChar(codePoint)) {\n            newCodePoints[outOffset++] = codePoint;\n            offset += Character.charCount(codePoint);\n        } else {\n            newCodePoints[outOffset++] = Character.toTitleCase(codePoint);\n            offset += Character.charCount(codePoint);\n            if (offset < strLen) {\n                codePoint = str.codePointAt(offset);\n                if (delimLen > 0) {\n                    for (int i = 0; i < delimLen; i++) {\n                        if (codePoint == delimiters[i]) {\n                            newCodePoints[outOffset++] = codePoint;\n                            offset += Character.charCount(codePoint);\n                            break;\n                        }\n                    }\n                } else {\n                    if (Character.isWhitespace(codePoint) || Character.isSpaceChar(codePoint)) {\n                        newCodePoints[outOffset++] = codePoint;\n                        offset += Character.charCount(codePoint);\n                    }\n                }\n            }\n        }\n    }\n    return new String(newCodePoints, 0, outOffset);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (str == null || str.length() == 0 || delimLen == 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int[] positions = new int[strLen];\n    int count = 0;\n    boolean containsDelimiter = false;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            containsDelimiter = true;\n        } else if (Character.isWhitespace(ch)) {\n            containsDelimiter = true;\n        } else {\n            positions[count++] = i;\n        }\n    }\n    if (!containsDelimiter) {\n        return str;\n    }\n    final StringBuilder builder = new StringBuilder(strLen);\n    builder.append(Character.toTitleCase(str.charAt(0)));\n    for (int i = 1; i < count; i++) {\n        builder.append(str.substring(positions[i - 1] + 1, positions[i])).append(Character.toTitleCase(str.charAt(positions[i])));\n    }\n    if (count < positions.length) {\n        builder.append(str.substring(positions[count - 1] + 1));\n    }\n    return builder.toString();\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (str == null || str.length() == 0 || delimLen == 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int[] newCodePoints = new int[strLen];\n    int outOffset = 0;\n    for (int offset = 0, cp = 0; offset < strLen;) {\n        final int oldOffset = offset;\n        final int oldCp = cp;\n        offset += Character.toChars(cp, newCodePoints, offset);\n        if (offset < strLen && isDelimiter(delimiters, delimLen, cp)) {\n            newCodePoints[outOffset++] = cp;\n            offset = oldOffset;\n            cp = oldCp;\n        } else if (Character.isLowerCase(cp) || Character.isTitleCase(cp)) {\n            newCodePoints[outOffset++] = Character.toTitleCase(cp);\n        } else {\n            newCodePoints[outOffset++] = cp;\n        }\n    }\n    return new String(newCodePoints, 0, outOffset);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (str == null || str.length() == 0 || delimLen == 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int[] newCodePoints = new int[strLen];\n    int outOffset = 0;\n    for (int offset = 0, cp = 0; offset < strLen;) {\n        final int oldOffset = offset;\n        final int oldCodePoint = cp;\n        offset += Character.charCount(cp);\n        cp = str.codePointAt(offset);\n        if (offset > 0) {\n            if (Character.isLowerCase(oldCodePoint) \n                && (!Character.isLowerCase(cp) || isDelimiter(delimiters, oldCodePoint))) {\n                newCodePoints[outOffset++] = Character.toTitleCase(oldCodePoint);\n                for (int i = oldOffset + Character.charCount(oldCodePoint); i < offset; i += Character.charCount(cp)) {\n                    cp = str.codePointAt(i);\n                    newCodePoints[outOffset++] = Character.toLowerCase(cp);\n                }\n            } else {\n                for (int i = oldOffset; i < offset; i += Character.charCount(cp)) {\n                    cp = str.codePointAt(i);\n                    newCodePoints[outOffset++] = cp;\n                }\n            }\n        }\n    }\n    if (outOffset == 0) {\n        return str;\n    }\n    return new String(newCodePoints, 0, outOffset);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (str == null || str.length() == 0 || delimLen == 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int[] newCodePoints = new int[strLen];\n    int outOffset = 0;\n    for (int offset = 0, cp = 0; offset < strLen;) {\n        final int oldOffset = offset;\n        final int cpLen = Character.charCount(cp);\n        if (offset + cpLen >= strLen) {\n            throw new StringIndexOutOfBoundsException(\"Invalid code point at offset \" + offset + \".\");\n        }\n        offset += cpLen;\n        final boolean delim = delimiters != null;\n        for (int i = 0; i < delimLen; i++) {\n            if (delimiters[i] == cp) {\n                newCodePoints[outOffset++] = cp;\n                cp = 0;\n                break;\n            }\n        }\n        if (cp != 0) {\n            final int titleCase = Character.toTitleCase(cp);\n            if (titleCase == cp) {\n                newCodePoints[outOffset++] = cp;\n            } else {\n                final int titleCaseLen = Character.toChars(titleCase, newCodePoints, outOffset);\n                outOffset += titleCaseLen;\n            }\n            cp = 0;\n        }\n        offset = oldOffset + cpLen;\n    }\n    if (cp != 0) {\n        newCodePoints[outOffset++] = cp;\n    }\n    if (outOffset != newCodePoints.length) {\n        final int[] newCodePoints2 = new int[outOffset];\n        System.arraycopy(newCodePoints, 0, newCodePoints2, 0, outOffset);\n        newCodePoints = newCodePoints2;\n    }\n    return new String(newCodePoints, 0, outOffset);\n}"
    ],
    [
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime mdt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                mdt = mdt.withZone(iZone);\n            }\n            return mdt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime mdt = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                mdt = mdt.withZone(iZone);\n            }\n            return mdt;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return new MutableDateTime(millis, chrono);\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime mdt = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                mdt = mdt.withZone(iZone);\n            }\n            return mdt;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime mdt = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                mdt = mdt.withZone(iZone);\n            }\n            return mdt;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}"
    ],
    [
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealMatrix XT = this.X.transpose();\n        RealMatrix XTOmegaInverse = XT.multiply(OmegaInverse);\n        RealMatrix XTOmegaInverseX = XTOmegaInverse.multiply(this.X);\n        RealMatrix XTOmegaInverseXT = XTOmegaInverse.multiply(XT);\n        RealMatrix betaMatrix = new LUDecomposition(XTOmegaInverseX).getSolver().getInverse();\n        RealVector betaVector = betaMatrix.operate(XTOmegaInverseXT.operate(this.y));\n        return betaVector;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealMatrix XT = this.X.transpose();\n        RealMatrix XTOmegaInverseX = XT.multiply(OmegaInverse).multiply(this.X);\n        RealMatrix XTOmegaInverseY = XT.multiply(OmegaInverse).operate(this.y);\n        RealMatrix betaMatrix = new LUDecomposition(XTOmegaInverseX).getSolver().getInverse().multiply(XTOmegaInverseY);\n        return betaMatrix.getColumnVector(0);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealMatrix XTransposeOmegaInverseX =\n                OmegaInverse.multiply(XTranspose).multiply(X);\n        RealMatrix XTransposeOmegaInverseY =\n                OmegaInverse.multiply(XTranspose).operate(y);\n        return new LUDecomposition(XTransposeOmegaInverseX).getSolver().solve(XTransposeOmegaInverseY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealMatrix XtOmegaInverseX =\n            OmegaInverse.multiply(X.transpose()).multiply(X);\n        RealMatrix XtOmegaInverseY =\n            OmegaInverse.multiply(X.transpose()).operate(new ArrayRealVector(y, false));\n        return new LUDecomposition(XtOmegaInverseX).getSolver().solve(XtOmegaInverseY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealMatrix XTransposeOmegaInverseX =\n            OmegaInverse.multiply(X.transpose()).multiply(X);\n        RealMatrix XTransposeOmegaInverseY =\n            OmegaInverse.multiply(X.transpose()).operate(y);\n        return new LUDecomposition(XTransposeOmegaInverseX).getSolver().solve(XTransposeOmegaInverseY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealMatrix XT = MatrixUtils.createRealMatrix(getX()).transpose();\n        RealMatrix XTOmegaInverseX = XT.multiply(OmegaInverse).multiply(MatrixUtils.createRealMatrix(getX()));\n        RealMatrix XTOmegaInverseY = XT.multiply(OmegaInverse).operate(new ArrayRealVector(getY(), false));\n        return new LUDecomposition(XTOmegaInverseX).getSolver().solve(XTOmegaInverseY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealMatrix XTranspose = getXTranspose();\n        RealMatrix XtOmegaX = XTranspose.multiply(OmegaInverse).multiply(getX());\n        RealMatrix XtOmegaXInverse = new LUDecomposition(XtOmegaX).getSolver().getInverse();\n        RealMatrix XtOmegaY = XTranspose.multiply(OmegaInverse).multiply(getY());\n        return XtOmegaXInverse.multiply(XtOmegaY).getColumnVector(0);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealMatrix XtOmegaInverseX =\n            OmegaInverse.multiply(X.transpose()).multiply(X);\n        RealMatrix XtOmegaInverseY =\n            OmegaInverse.multiply(X.transpose()).operate(y);\n        return new LUDecomposition(XtOmegaInverseX).getSolver().solve(XtOmegaInverseY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealMatrix XT = getX().transpose();\n        RealMatrix XTOmegaInverseX = XT.multiply(OmegaInverse).multiply(getX());\n        RealMatrix XTOmegaInverseY = XT.multiply(OmegaInverse).operate(getY());\n        return new LUDecomposition(XTOmegaInverseX).getSolver().solve(XTOmegaInverseY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealMatrix XT = this.X.transpose();\n        RealMatrix XT_OmegaInverse_X = XT.multiply(OmegaInverse).multiply(this.X);\n        RealMatrix XT_OmegaInverse_Y = XT.multiply(OmegaInverse).operate(this.y);\n        return new LUDecomposition(XT_OmegaInverse_X).getSolver().solve(XT_OmegaInverse_Y);\n    }"
    ],
    [
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    if (id.equals(this.id())) {\n        return this;\n    }\n    Elements elements = Collector.collect(new Evaluator.Id(id), this);\n    return elements.size() > 0 ? elements.get(0) : null;\n}",
      "public Element getElementById(String id)  {\n        Validate.notEmpty(id);\n        if (id.equals(this.id()))\n            return this;\n        else\n            return Collector.collect(new Evaluator.Id(id), this).get(0);\n    }",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    if (id.equals(this.id())) \n    {\n        return this;\n    }\n    else \n    {\n        Elements elements = Collector.collect(new Evaluator.Id(id), this);\n        return elements.size() > 0 ? elements.get(0) : null;\n    }\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    if (id.equals(id()))\n        return this;\n    else\n        return Collector.collect(new Evaluator.Id(id), this).first();\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    if (id.equals(id()))\n        return this;\n    Elements els = Collector.collect(new Evaluator.Id(id), this);\n    return els.size() > 0 ? els.get(0) : null;\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    Elements elements = Collector.collect(new Evaluator.Id(id), this);\n    return elements.size() > 0 ? elements.get(0) : null;\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    Elements elements = Collector.collect(new Evaluator.Id(id), this);\n    return elements.size() > 0 ? elements.get(0) : null;\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    Elements elements = Collector.collect(new Evaluator.Id(id), this);\n    return elements.size() > 0 ? elements.get(0) : null;\n}",
      "public Element getElementById(String id)  {\n        Validate.notEmpty(id);\n        if (id.equals(this.id())) {\n            return this;\n        }\n        Elements elements = Collector.collect(new Evaluator.Id(id), this);\n        return elements.size() > 0 ? elements.get(0) : null;\n    }",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    if (id.equals(id()))\n        return this;\n    Elements els = Collector.collect(new Evaluator.Id(id), this);\n    return els.size() > 0 ? els.get(0) : null;\n}"
    ],
    [
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder();\n    final ParsePosition pos = new ParsePosition(0);\n    for (; pos.getIndex() < pattern.length(); next(pos)) {\n        char c = pattern.charAt(pos.getIndex());\n        if (c == START_FE) {\n            result.append(START_FE);\n            next(pos);\n            c = pattern.charAt(pos.getIndex());\n            if (c == START_FMT) {\n                result.append(START_FMT);\n                next(pos);\n                final int index = readArgumentIndex(pattern, pos);\n                result.append(index);\n                next(pos);\n                c = pattern.charAt(pos.getIndex());\n                if (c == START_FMT) {\n                    result.append(START_FMT);\n                    next(pos);\n                    final String format = parseFormatDescription(pattern, pos);\n                    result.append(format);\n                    next(pos);\n                    c = pattern.charAt(pos.getIndex());\n                    if (c == END_FMT) {\n                        result.append(END_FMT);\n                        next(pos);\n                    }\n                }\n            }\n            if (c == END_FE) {\n                result.append(END_FE);\n                next(pos);\n            }\n        } else {\n            result.append(c);\n        }\n    }\n    if (customPatterns != null) {\n        for (final String customPattern : customPatterns) {\n            result.append(START_FE);\n            result.append(customPattern);\n            result.append(END_FE);\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    // TODO: Implement this method\n    return pattern;\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder();\n    final ParsePosition pos = new ParsePosition(0);\n    while (pos.getIndex() < pattern.length()) {\n        if (pattern.charAt(pos.getIndex()) == START_FE) {\n            pos.setIndex(pos.getIndex() + 1);\n            final int index = readArgumentIndex(pattern, pos);\n            final String desc = parseFormatDescription(pattern, pos);\n            final String format = getFormat(desc).toPattern();\n            result.append(START_FE);\n            result.append(index);\n            result.append(END_FE);\n            result.append(format);\n            result.append(START_FE);\n            result.append(END_FE);\n            if (customPatterns != null && customPatterns.size() > 0) {\n                result.append(START_FE);\n                result.append(customPatterns.get(index));\n                result.append(END_FE);\n            }\n        } else {\n            result.append(pattern.charAt(pos.getIndex()));\n            pos.setIndex(pos.getIndex() + 1);\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder();\n    final ParsePosition pos = new ParsePosition(0);\n    for (; pos.getIndex() < pattern.length(); next(pos)) {\n        char c = pattern.charAt(pos.getIndex());\n        if (c == START_FE) {\n            result.append(START_FE);\n            pos.setIndex(pos.getIndex() + 1);\n            c = pattern.charAt(pos.getIndex());\n            if (c == QUOTE) {\n                result.append(getQuotedString(pattern, pos, false));\n            } else {\n                result.append(readArgumentIndex(pattern, pos));\n                result.append(START_FMT);\n                result.append(parseFormatDescription(pattern, pos));\n                result.append(END_FMT);\n            }\n        } else if (c == START_FMT) {\n            result.append(START_FMT);\n            pos.setIndex(pos.getIndex() + 1);\n            result.append(parseFormatDescription(pattern, pos));\n            result.append(END_FMT);\n        } else {\n            result.append(c);\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    if (registry == null || customPatterns == null) {\n        return pattern;\n    }\n    final StringBuilder result = new StringBuilder();\n    final ParsePosition pos = new ParsePosition(0);\n    while (pos.getIndex() < pattern.length()) {\n        final int start = pos.getIndex();\n        seekNonWs(pattern, pos);\n        if (pos.getIndex() >= pattern.length()) {\n            break;\n        }\n        final char c = pattern.charAt(pos.getIndex());\n        if (c == START_FE) {\n            result.append(pattern, start, pos.getIndex());\n            pos.setIndex(pos.getIndex() + 1);\n            final int index = readArgumentIndex(pattern, pos);\n            final String desc = parseFormatDescription(pattern, pos);\n            final Format format = getFormat(desc);\n            if (format != null) {\n                final String customPattern = customPatterns.get(index);\n                if (customPattern != null) {\n                    result.append(START_FE).append(index).append(END_FE)\n                            .append(customPattern).append(START_FE).append(END_FE);\n                } else {\n                    result.append(START_FE).append(index).append(END_FE)\n                            .append(format.toPattern()).append(START_FE).append(END_FE);\n                }\n            } else {\n                result.append(START_FE).append(index).append(END_FE)\n                        .append(desc).append(START_FE).append(END_FE);\n            }\n        } else {\n            result.append(pattern, start, pos.getIndex());\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder();\n    int pos = 0;\n    for (final String element : customPatterns) {\n        result.append(pattern.substring(pos, element.indexOf(START_FMT)));\n        result.append(START_FMT);\n        result.append(element.substring(element.indexOf(START_FMT) + 1));\n        pos = element.indexOf(END_FE) + 1;\n    }\n    result.append(pattern.substring(pos));\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder();\n    final ParsePosition pos = new ParsePosition(0);\n    while (pos.getIndex() < pattern.length()) {\n        final int start = pos.getIndex();\n        seekNonWs(pattern, pos);\n        if (pos.getIndex() > start) {\n            result.append(pattern, start, pos.getIndex());\n        }\n        if (pos.getIndex() >= pattern.length()) {\n            break;\n        }\n        final char c = pattern.charAt(pos.getIndex());\n        if (c == START_FE) {\n            result.append(START_FE);\n            next(pos);\n            final int index = readArgumentIndex(pattern, pos);\n            final String desc = parseFormatDescription(pattern, pos);\n            final Format format = getFormat(desc);\n            if (format != null) {\n                result.append(START_FMT);\n                result.append(index);\n                result.append(END_FMT);\n            } else {\n                result.append(desc);\n            }\n            if (customPatterns != null) {\n                customPatterns.add(desc);\n            }\n        } else if (c == START_FMT) {\n            result.append(START_FMT);\n            next(pos);\n            final int index = readArgumentIndex(pattern, pos);\n            final String desc = parseFormatDescription(pattern, pos);\n            result.append(index);\n            result.append(END_FMT);\n            if (customPatterns != null) {\n                customPatterns.add(desc);\n            }\n        } else {\n            throw new IllegalArgumentException(\"Invalid format element\");\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder();\n    int pos = 0;\n    int next = pattern.indexOf(START_FMT, pos);\n    while (next >= 0) {\n        result.append(pattern.substring(pos, next));\n        pos = next;\n        next = pattern.indexOf(END_FMT, pos);\n        if (next < 0) {\n            throw new IllegalArgumentException(\"Unterminated format element at position \" + pos);\n        }\n        final String desc = pattern.substring(pos + 1, next);\n        final int i = desc.indexOf(START_FMT);\n        if (i > 0) {\n            result.append(desc.substring(0, i).trim());\n            final String args = desc.substring(i + 1).trim();\n            if (args.length() > 0) {\n                result.append(START_FMT);\n                result.append(args);\n                result.append(END_FMT);\n            }\n        } else {\n            if (customPatterns != null) {\n                for (final String customPattern : customPatterns) {\n                    if (desc.equals(customPattern)) {\n                        result.append(desc);\n                        break;\n                    }\n                }\n            }\n        }\n        pos = next + 1;\n        next = pattern.indexOf(START_FMT, pos);\n    }\n    result.append(pattern.substring(pos));\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder();\n    final ParsePosition pos = new ParsePosition(0);\n    while (pos.getIndex() < pattern.length()) {\n        if (pattern.charAt(pos.getIndex()) == START_FE) {\n            final int index = readArgumentIndex(pattern, pos);\n            final String desc = parseFormatDescription(pattern, pos);\n            if (index >= 0 && index < customPatterns.size()) {\n                result.append(customPatterns.get(index));\n            } else {\n                result.append(desc);\n            }\n        } else {\n            result.append(pattern.charAt(pos.getIndex()));\n        }\n        next(pos);\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    if (registry == null) {\n        return pattern;\n    }\n    final StringBuilder result = new StringBuilder();\n    final ParsePosition pos = new ParsePosition(0);\n    while (pos.getIndex() < pattern.length()) {\n        if (pattern.charAt(pos.getIndex()) == START_FE) {\n            next(pos);\n            final int index = readArgumentIndex(pattern, pos);\n            final String desc = parseFormatDescription(pattern, pos);\n            final Format format = getFormat(desc);\n            if (format != null) {\n                final String customPattern = customPatterns.get(index);\n                if (customPattern != null) {\n                    result.append(customPattern);\n                } else {\n                    result.append(START_FMT).append(desc).append(END_FMT);\n                }\n            } else {\n                result.append(START_FE).append(index).append(END_FE);\n            }\n        } else {\n            result.append(pattern.charAt(pos.getIndex()));\n            next(pos);\n        }\n    }\n    return result.toString();\n}"
    ],
    [
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}"
    ],
    [
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n  Type fromRawType = from.getRawType();\n  Type toRawType = to.getRawType();\n  if (!fromRawType.equals(toRawType)) {\n    return false;\n  }\n  Type[] fromArgs = from.getActualTypeArguments();\n  Type[] toArgs = to.getActualTypeArguments();\n  if (fromArgs.length != toArgs.length) {\n    return false;\n  }\n  for (int i = 0; i < fromArgs.length; i++) {\n    Type fromArg = fromArgs[i];\n    Type toArg = toArgs[i];\n    while (fromArg instanceof TypeVariable<?>) {\n      TypeVariable<?> v = (TypeVariable<?>) fromArg;\n      fromArg = typeVarMap.get(v.getName());\n    }\n    while (toArg instanceof TypeVariable<?>) {\n      TypeVariable<?> v = (TypeVariable<?>) toArg;\n      toArg = typeVarMap.get(v.getName());\n    }\n    if (!fromArg.equals(toArg)) {\n      return false;\n    }\n  }\n  return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    Type fromRawType = from.getRawType();\n    Type toRawType = to.getRawType();\n    if (!fromRawType.equals(toRawType)) {\n      return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n      while (fromArg instanceof TypeVariable<?>) {\n        fromArg = typeVarMap.get(((TypeVariable<?>) fromArg).getName());\n      }\n      while (toArg instanceof TypeVariable<?>) {\n        toArg = typeVarMap.get(((TypeVariable<?>) toArg).getName());\n      }\n      if (!fromArg.equals(toArg)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n      while (fromArg instanceof TypeVariable<?>) {\n        fromArg = typeVarMap.get(((TypeVariable<?>) fromArg).getName());\n      }\n      while (toArg instanceof TypeVariable<?>) {\n        toArg = typeVarMap.get(((TypeVariable<?>) toArg).getName());\n      }\n      if (!fromArg.equals(toArg)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    Type fromRawType = from.getRawType();\n    Type toRawType = to.getRawType();\n    if (!fromRawType.equals(toRawType)) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n      while (fromArg instanceof TypeVariable<?>) {\n        fromArg = typeVarMap.get(((TypeVariable<?>) fromArg).getName());\n      }\n      while (toArg instanceof TypeVariable<?>) {\n        toArg = typeVarMap.get(((TypeVariable<?>) toArg).getName());\n      }\n      if (!fromArg.equals(toArg)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n      while (fromArg instanceof TypeVariable<?>) {\n        fromArg = typeVarMap.get(((TypeVariable<?>) fromArg).getName());\n      }\n      while (toArg instanceof TypeVariable<?>) {\n        toArg = typeVarMap.get(((TypeVariable<?>) toArg).getName());\n      }\n      if (!fromArg.equals(toArg)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n      while (fromArg instanceof TypeVariable<?>) {\n        fromArg = typeVarMap.get(((TypeVariable<?>) fromArg).getName());\n      }\n      while (toArg instanceof TypeVariable<?>) {\n        toArg = typeVarMap.get(((TypeVariable<?>) toArg).getName());\n      }\n      if (!fromArg.equals(toArg)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n  Type[] fromArgs = from.getActualTypeArguments();\n  Type[] toArgs = to.getActualTypeArguments();\n  if (fromArgs.length != toArgs.length) {\n    return false;\n  }\n  for (int i = 0; i < fromArgs.length; i++) {\n    Type fromArg = fromArgs[i];\n    Type toArg = toArgs[i];\n    while (fromArg instanceof TypeVariable<?>) {\n      fromArg = typeVarMap.get(((TypeVariable<?>) fromArg).getName());\n    }\n    while (toArg instanceof TypeVariable<?>) {\n      toArg = typeVarMap.get(((TypeVariable<?>) toArg).getName());\n    }\n    if (!fromArg.equals(toArg)) {\n      return false;\n    }\n  }\n  return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.equals(to)) {\n      return true;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n      while (fromArg instanceof TypeVariable<?>) {\n        fromArg = typeVarMap.get(fromArg);\n      }\n      while (toArg instanceof TypeVariable<?>) {\n        toArg = typeVarMap.get(toArg);\n      }\n      if (!fromArg.equals(toArg)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.equals(to)) {\n      return true;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n      while (fromArg instanceof TypeVariable<?>) {\n        TypeVariable<?> v = (TypeVariable<?>) fromArg;\n        fromArg = typeVarMap.get(v.getName());\n      }\n      while (toArg instanceof TypeVariable<?>) {\n        TypeVariable<?> v = (TypeVariable<?>) toArg;\n        toArg = typeVarMap.get(v.getName());\n      }\n      if (!fromArg.equals(toArg)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.equals(to)) {\n      return true;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n      while (fromArg instanceof TypeVariable<?>) {\n        TypeVariable<?> v = (TypeVariable<?>) fromArg;\n        fromArg = typeVarMap.get(v.getName());\n      }\n      while (toArg instanceof TypeVariable<?>) {\n        TypeVariable<?> v = (TypeVariable<?>) toArg;\n        toArg = typeVarMap.get(v.getName());\n      }\n      if (!fromArg.equals(toArg)) {\n        return false;\n      }\n    }\n    return true;\n  }"
    ],
    [
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        return iterator;\n    }\n    return new UnmodifiableIterator<>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        return iterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        return iterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) \n    {\n        return iterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) \n    {\n        return iterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) \n    {\n        return iterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        return iterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) \n    {\n        return iterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        return iterator;\n    }\n    return new UnmodifiableIterator<>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        return iterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}"
    ],
    [
      "public N getPartitionSuperNode(N node)  {\n  int color = graph.getNode(node).getAnnotation();\n  return colorToNodeMap[color];\n}",
      "public N getPartitionSuperNode(N node)  {\n    int color = getColor(node);\n    if (colorToNodeMap[color] == null) {\n      colorToNodeMap[color] = node;\n    }\n    return colorToNodeMap[color];\n  }",
      "public N getPartitionSuperNode(N node)  {\n    // get the color of the node\n    int color = ((Color) node.getAnnotation()).getColor();\n\n    // if the color is not in the map, create a new node and add it to the map\n    if (colorToNodeMap[color] == null) {\n        colorToNodeMap[color] = node;\n        return node;\n    }\n\n    // otherwise, return the node in the map\n    return colorToNodeMap[color];\n}",
      "public N getPartitionSuperNode(N node)  {\n  // TODO: Implement this method\n}",
      "public N getPartitionSuperNode(N node)  {\n    // TODO(user): Implement this method.\n    return null;\n  }",
      "public N getPartitionSuperNode(N node)  {\n  int color = graph.getNode(node).getAnnotation();\n  return colorToNodeMap[color];\n}",
      "public N getPartitionSuperNode(N node)  {\n  Preconditions.checkNotNull(node);\n  int color = graph.getNode(node).getAnnotation();\n  if (colorToNodeMap[color] == null) {\n    colorToNodeMap[color] = node;\n  }\n  return colorToNodeMap[color];\n}",
      "public N getPartitionSuperNode(N node)  {\n  Preconditions.checkNotNull(node);\n  int color = getColor(node);\n  if (colorToNodeMap[color] == null) {\n    colorToNodeMap[color] = node;\n  }\n  return colorToNodeMap[color];\n}",
      "public N getPartitionSuperNode(N node)  {\n    int color = graph.getNode(node).getAnnotation();\n    return colorToNodeMap[color];\n  }",
      "public N getPartitionSuperNode(N node)  {\n    Preconditions.checkNotNull(node);\n    Color color = graph.getNode(node).getAnnotation();\n    Preconditions.checkNotNull(color);\n    return colorToNodeMap[color.getColor()];\n  }"
    ],
    [
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n        List<Integer> nanPositions = new ArrayList<>();\n        for (int i = 0; i < ranks.length; i++) {\n            if (Double.isNaN(ranks[i].getValue())) {\n                nanPositions.add(i);\n            }\n        }\n        return nanPositions;\n    }",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n        List<Integer> nanPositions = new ArrayList<Integer>();\n        for (int i = 0; i < ranks.length; i++) {\n            if (Double.isNaN(ranks[i].getValue())) {\n                nanPositions.add(i);\n            }\n        }\n        return nanPositions;\n    }",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n        List<Integer> nanPositions = new ArrayList<Integer>();\n        for (int i = 0; i < ranks.length; i++) {\n            if (Double.isNaN(ranks[i].getValue())) {\n                nanPositions.add(i);\n            }\n        }\n        return nanPositions;\n    }",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n        List<Integer> nanPositions = new ArrayList<Integer>();\n        for (int i = 0; i < ranks.length; i++) {\n            if (Double.isNaN(ranks[i].getValue())) {\n                nanPositions.add(i);\n            }\n        }\n        return nanPositions;\n    }",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n        List<Integer> nanPositions = new ArrayList<Integer>();\n        for (int i = 0; i < ranks.length; i++) {\n            if (Double.isNaN(ranks[i].getValue())) {\n                nanPositions.add(i);\n            }\n        }\n        return nanPositions;\n    }",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}"
    ],
    [
      "public double integrate(UnivariateFunction f)  {\n    double result = 0;\n    for (int i = 0; i < points.length; i++) {\n        result += weights[i] * f.value(points[i]);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0;\n    for (int i = 0; i < points.length; i++) {\n        result += weights[i] * f.value(points[i]);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0;\n    for (int i = 0; i < points.length; i++) {\n        result += weights[i] * f.value(points[i]);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0;\n    for (int i = 0; i < points.length; i++) {\n        result += weights[i] * f.value(points[i]);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0;\n    for (int i = 0; i < points.length; i++) {\n        result += weights[i] * f.value(points[i]);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}"
    ],
    [
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size())\n        return false;\n    Set set1 = map1.entrySet();\n    Iterator iterator1 = set1.iterator();\n    while (iterator1.hasNext())\n    {\n        Map.Entry entry1 = (Map.Entry)iterator1.next();\n        Comparable key1 = (Comparable)entry1.getKey();\n        Paint value1 = (Paint)entry1.getValue();\n        Paint value2 = (Paint)map2.get(key1);\n        if (!value1.equals(value2))\n            return false;\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    for (Object key : keys) {\n        if (!map2.containsKey(key)) {\n            return false;\n        }\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!p1.equals(p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    else \n    {\n        Set keys = map1.keySet();\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) \n        {\n            Comparable key = (Comparable) iterator.next();\n            Paint p1 = (Paint) map1.get(key);\n            Paint p2 = (Paint) map2.get(key);\n            if (!p1.equals(p2)) \n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n        if (map1.size() != map2.size()) {\n            return false;\n        }\n        Set keys = map1.keySet();\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Comparable key = (Comparable) iterator.next();\n            Paint paint1 = (Paint) map1.get(key);\n            Paint paint2 = (Paint) map2.get(key);\n            if (!paint1.equals(paint2)) {\n                return false;\n            }\n        }\n        return true;\n    }",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        if (!map2.containsKey(key)) {\n            return false;\n        }\n        if (!map1.get(key).equals(map2.get(key))) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!p1.equals(p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Iterator iterator = map1.keySet().iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    for (Object key : keys) {\n        Comparable category = (Comparable) key;\n        Paint paint1 = (Paint) map1.get(category);\n        Paint paint2 = (Paint) map2.get(category);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    for (Object key : map1.keySet()) \n    {\n        if (!map2.containsKey(key)) \n        {\n            return false;\n        }\n        if (!map1.get(key).equals(map2.get(key))) \n        {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  // TODO: Implement this method\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  if (expr.isString()) {\n    String shortName = shortenString(expr.getString());\n    if (shortName != null) {\n      Node replacement = NodeUtil.newString(t.getCompiler(), shortName);\n      parent.replaceChild(expr, replacement);\n      return replacement;\n    }\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) {\n      String encoded = encodeString(expr.getString());\n      if (encoded != null) {\n        Node replacement = NodeUtil.newString(t.getSourceName(), encoded);\n        parent.replaceChild(expr, replacement);\n        return replacement;\n      }\n    }\n    return expr;\n  }",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    // Replace the expression with a short encoded string expression.\n    String shortString = shortenString(expr.getString());\n    Node replacement = NodeUtil.newString(t.getCompiler(), shortString);\n    parent.replaceChild(expr, replacement);\n    return replacement;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    // TODO: Implement this method\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) {\n      String value = expr.getString();\n      if (value.length() > 10) {\n        String encoded = encodeString(value);\n        if (encoded != null) {\n          Node replacement = NodeUtil.newString(t.getCompiler(), encoded);\n          parent.replaceChild(expr, replacement);\n          return replacement;\n        }\n      }\n    }\n    return expr;\n  }",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    // TODO: Implement this method.\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) {\n        String shortened = shortenString(expr.getString());\n        if (shortened != null) {\n            Node replacement = NodeUtil.newString(t.getCompiler(), shortened);\n            parent.replaceChild(expr, replacement);\n            return replacement;\n        }\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  if (expr.isString()) {\n    String encoded = encodeString(expr.getString());\n    if (encoded != null) {\n      Node replacement = NodeUtil.newString(t.getCompiler(), encoded);\n      parent.replaceChild(expr, replacement);\n      return replacement;\n    }\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    // TODO: Implement this method.\n    return expr;\n}"
    ],
    [
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n        double[] out = new double[a.length];\n        System.arraycopy(a, 0, out, 0, a.length);\n        return out;\n    }",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n        double[] out = new double[a.length];\n        System.arraycopy(a, 0, out, 0, a.length);\n        return out;\n    }",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n        double[] out = new double[a.length];\n        System.arraycopy(a, 0, out, 0, a.length);\n        return out;\n    }",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}"
    ],
    [
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  if (node != null && node.isExprResult()) {\n    Node exprNode = node.getFirstChild();\n    if (exprNode != null && exprNode.isAssign()) {\n      Node nameNode = exprNode.getFirstChild();\n      if (nameNode != null && nameNode.isName()) {\n        String name = nameNode.getString();\n        if (name.equals(builder.getKey())) {\n          Node valueNode = nameNode.getNext();\n          if (valueNode != null && valueNode.isCall()) {\n            Node callNameNode = valueNode.getFirstChild();\n            if (callNameNode != null && callNameNode.isName() &&\n                callNameNode.getString().equals(\"goog.getMsg\")) {\n              Node descNode = callNameNode.getNext();\n              if (descNode != null && descNode.isString()) {\n                String desc = extractStringFromStringExprNode(descNode);\n                if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n                  builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n                  builder.setIsHidden(true);\n                } else {\n                  builder.setDesc(desc);\n                }\n                return true;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  if (node.isExprResult()) {\n    Node exprNode = node.getFirstChild();\n    if (exprNode.isAssign()) {\n      Node lhsNode = exprNode.getFirstChild();\n      if (lhsNode.isGetProp()) {\n        Node rhsNode = lhsNode.getNext();\n        if (rhsNode.isCall()) {\n          Node callNameNode = rhsNode.getFirstChild();\n          if (callNameNode.getString().equals(\"goog.getMsg\")) {\n            Node callArgsNode = callNameNode.getNext();\n            if (callArgsNode.isString()) {\n              String desc = callArgsNode.getString();\n              if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n                builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n                builder.setIsHidden(true);\n              } else {\n                builder.setDesc(desc);\n              }\n              return true;\n            }\n          }\n        }\n      }\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  if (node != null && node.isExprResult()) {\n    Node exprNode = node.getFirstChild();\n    if (exprNode != null && exprNode.isCall()) {\n      Node calleeNode = exprNode.getFirstChild();\n      if (calleeNode != null && calleeNode.isName()\n          && calleeNode.getString().equals(\"goog.getMsg\")) {\n        Node jsDocNode = node.getJSDocInfo();\n        if (jsDocNode != null) {\n          JSDocInfo jsDoc = jsDocNode.getInfo();\n          if (jsDoc != null) {\n            String desc = jsDoc.getDescription();\n            if (desc != null) {\n              if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n                builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n                builder.setIsHidden(true);\n              } else {\n                builder.setDesc(desc);\n              }\n              return true;\n            }\n          }\n        }\n      }\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    if (node != null && node.isExprResult()) {\n      Node firstChild = node.getFirstChild();\n      if (firstChild != null && firstChild.isCall()) {\n        Node callee = firstChild.getFirstChild();\n        if (callee != null && callee.isName() && callee.getString().equals(\"goog.getMsg\")) {\n          Node descNode = callee.getNext();\n          if (descNode != null && descNode.isString()) {\n            String desc = descNode.getString();\n            if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n              builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n              builder.setIsHidden(true);\n            } else {\n              builder.setDesc(desc);\n            }\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info != null) {\n    String desc = info.getDescription();\n    if (desc != null) {\n      if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n        builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n        builder.setIsHidden(true);\n      } else {\n        builder.setDesc(desc);\n      }\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  if (node == null || !node.isExprResult()) {\n    return false;\n  }\n  Node jsDocNode = node.getFirstChild();\n  if (jsDocNode == null || !jsDocNode.isString()) {\n    return false;\n  }\n  String jsDoc = jsDocNode.getString();\n  if (jsDoc.startsWith(HIDDEN_DESC_PREFIX)) {\n    builder.setDesc(jsDoc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n    builder.setIsHidden(true);\n    return true;\n  }\n  builder.setDesc(jsDoc);\n  return true;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  if (node != null && node.isExprResult()) {\n    Node jsDocNode = node.getFirstChild();\n    if (jsDocNode != null && jsDocNode.isString()) {\n      String jsDoc = jsDocNode.getString();\n      if (jsDoc.startsWith(HIDDEN_DESC_PREFIX)) {\n        builder.setDesc(jsDoc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n        builder.setIsHidden(true);\n        return true;\n      }\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  if (node == null || !node.isExprResult()) {\n    return false;\n  }\n  Node jsDocNode = node.getFirstChild();\n  if (jsDocNode == null || !jsDocNode.isJsDocInfo()) {\n    return false;\n  }\n  JsDocInfo jsDocInfo = jsDocNode.getJsDocInfo();\n  String desc = jsDocInfo.getDescription();\n  if (desc == null || desc.isEmpty()) {\n    return false;\n  }\n  if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n    builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n    builder.setIsHidden(true);\n  } else {\n    builder.setDesc(desc);\n  }\n  return true;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    if (node == null) {\n      return false;\n    }\n    JSDocInfo info = node.getJSDocInfo();\n    if (info == null) {\n      return false;\n    }\n    String desc = info.getDescription();\n    if (desc == null) {\n      return false;\n    }\n    if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n      builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n      builder.setIsHidden(true);\n    } else {\n      builder.setDesc(desc);\n    }\n    return true;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info != null) {\n    String desc = info.getDescription();\n    if (desc != null) {\n      if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n        builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n        builder.setIsHidden(true);\n      } else {\n        builder.setDesc(desc);\n      }\n      return true;\n    }\n  }\n  return false;\n}"
    ],
    [
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int changes = 0;\n        for (int i = 0; i < points.size(); i++) {\n            final T point = points.iterator().next();\n            double minDistance = Double.POSITIVE_INFINITY;\n            int minIndex = 0;\n            for (int j = 0; j < clusters.size(); j++) {\n                final double distance = distance(point, clusters.get(j).getCenter());\n                if (distance < minDistance) {\n                    minDistance = distance;\n                    minIndex = j;\n                }\n            }\n            if (minIndex != assignments[i]) {\n                changes++;\n            }\n            assignments[i] = minIndex;\n            clusters.get(minIndex).getPoints().add(point);\n        }\n        return changes;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n\n        // sanity checks\n        MathUtils.checkNotNull(clusters);\n        MathUtils.checkNotNull(points);\n        MathUtils.checkNotNull(assignments);\n\n        // initialize the number of points assigned to different clusters as the iteration before\n        int changes = 0;\n\n        // for each point, find the closest cluster and add the point to it\n        for (int i = 0; i < points.size(); i++) {\n            final T point = points.toArray(new T[points.size()])[i];\n            double minDistance = Double.POSITIVE_INFINITY;\n            int minIndex = -1;\n            for (int j = 0; j < clusters.size(); j++) {\n                final double distance = distance(clusters.get(j).getCenter(), point);\n                if (distance < minDistance) {\n                    minDistance = distance;\n                    minIndex = j;\n                }\n            }\n            if (minIndex != assignments[i]) {\n                changes++;\n            }\n            assignments[i] = minIndex;\n            clusters.get(minIndex).getPoints().add(point);\n        }\n        return changes;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int changes = 0;\n        for (int i = 0; i < points.size(); i++) {\n            final T point = points.iterator().next();\n            double minDistance = Double.POSITIVE_INFINITY;\n            int minIndex = 0;\n            for (int j = 0; j < clusters.size(); j++) {\n                final double distance = distance(point, clusters.get(j).getCenter());\n                if (distance < minDistance) {\n                    minDistance = distance;\n                    minIndex = j;\n                }\n            }\n            if (minIndex != assignments[i]) {\n                changes++;\n            }\n            assignments[i] = minIndex;\n            clusters.get(minIndex).getPoints().add(point);\n        }\n        return changes;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n\n        // initialize the number of points assigned to different clusters\n        // to the number of points assigned in the previous iteration\n        int changes = 0;\n\n        // iterate through all points\n        for (int i = 0; i < points.size(); i++) {\n            // get the point\n            final T point = points.iterator().next();\n\n            // find the closest cluster\n            double minDistance = Double.POSITIVE_INFINITY;\n            int minIndex = -1;\n            for (int j = 0; j < clusters.size(); j++) {\n                final double distance = distance(point, clusters.get(j).getCenter().getPoint());\n                if (distance < minDistance) {\n                    minDistance = distance;\n                    minIndex = j;\n                }\n            }\n\n            // if the point is not assigned to the closest cluster\n            // or if the point is assigned to a cluster but the cluster is empty\n            // assign the point to the closest cluster\n            if (assignments[i] != minIndex || clusters.get(minIndex).getPoints().isEmpty()) {\n                changes++;\n                assignments[i] = minIndex;\n                clusters.get(minIndex).getPoints().add(point);\n            }\n        }\n        return changes;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n\n        // iterate through all points and assign them to the closest cluster\n        int changes = 0;\n        int index = 0;\n        for (final T point : points) {\n            double minDistance = Double.POSITIVE_INFINITY;\n            int closestClusterIndex = -1;\n            for (int i = 0; i < clusters.size(); i++) {\n                final double distance = distance(point, clusters.get(i).getCenter());\n                if (distance < minDistance) {\n                    minDistance = distance;\n                    closestClusterIndex = i;\n                }\n            }\n            if (closestClusterIndex != assignments[index]) {\n                changes++;\n            }\n            assignments[index] = closestClusterIndex;\n            clusters.get(closestClusterIndex).getPoints().add(point);\n            index++;\n        }\n        return changes;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int changes = 0;\n        for (int i = 0; i < points.size(); i++) {\n            final T point = points.toArray(new T[0])[i];\n            final int previousAssignment = assignments[i];\n            final double[] pointArray = point.getPoint();\n            double minDistance = Double.POSITIVE_INFINITY;\n            int minCluster = -1;\n            for (int j = 0; j < clusters.size(); j++) {\n                final CentroidCluster<T> cluster = clusters.get(j);\n                final double distance = distance(pointArray, cluster.getCenter().getPoint());\n                if (distance < minDistance) {\n                    minDistance = distance;\n                    minCluster = j;\n                }\n            }\n            if (minCluster != previousAssignment) {\n                changes++;\n            }\n            assignments[i] = minCluster;\n            clusters.get(minCluster).getPoints().add(point);\n        }\n        return changes;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int changes = 0;\n        for (int i = 0; i < points.size(); i++) {\n            final T point = points.toArray(new T[points.size()])[i];\n            double minDistance = Double.POSITIVE_INFINITY;\n            int minIndex = -1;\n            for (int j = 0; j < clusters.size(); j++) {\n                final double distance = distance(point, clusters.get(j).getCenter());\n                if (distance < minDistance) {\n                    minDistance = distance;\n                    minIndex = j;\n                }\n            }\n            if (minIndex != assignments[i]) {\n                changes++;\n            }\n            assignments[i] = minIndex;\n            clusters.get(minIndex).getPoints().add(point);\n        }\n        return changes;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int changes = 0;\n        for (int i = 0; i < points.size(); i++) {\n            final T point = points.iterator().next();\n            final int previous = assignments[i];\n            int minDistance = Integer.MAX_VALUE;\n            int minIndex = -1;\n            for (int j = 0; j < clusters.size(); j++) {\n                final double distance = distance(point, clusters.get(j).getCenter().getPoint());\n                if (distance < minDistance) {\n                    minDistance = distance;\n                    minIndex = j;\n                }\n            }\n            if (minIndex != previous) {\n                changes++;\n            }\n            assignments[i] = minIndex;\n            clusters.get(minIndex).getPoints().add(point);\n        }\n        return changes;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n\n        // sanity checks\n        MathUtils.checkNotNull(clusters);\n        MathUtils.checkNotNull(points);\n        MathUtils.checkNotNull(assignments);\n\n        // initialize the number of changes to 0\n        int changes = 0;\n\n        // iterate through all points and find the closest cluster\n        for (int i = 0; i < points.size(); i++) {\n            final T point = points.toArray(new T[points.size()])[i];\n            final int currentAssignment = assignments[i];\n            final CentroidCluster<T> currentCluster = clusters.get(currentAssignment);\n            final double currentDistance = distance(currentCluster.getCenter(), point);\n\n            // find the closest cluster\n            int closestClusterIndex = currentAssignment;\n            double closestDistance = currentDistance;\n            for (int j = 0; j < clusters.size(); j++) {\n                final CentroidCluster<T> cluster = clusters.get(j);\n                final double distance = distance(cluster.getCenter(), point);\n                if (distance < closestDistance) {\n                    closestDistance = distance;\n                    closestClusterIndex = j;\n                }\n            }\n\n            // if the closest cluster has changed, update the assignment\n            if (closestClusterIndex != currentAssignment) {\n                assignments[i] = closestClusterIndex;\n                changes++;\n            }\n        }\n\n        // add the points to the clusters\n        for (int i = 0; i < clusters.size(); i++) {\n            final CentroidCluster<T> cluster = clusters.get(i);\n            final List<T> pointsInCluster = new ArrayList<T>();\n            for (int j = 0; j < assignments.length; j++) {\n                if (assignments[j] == i) {\n                    pointsInCluster.add(points.toArray(new T[points.size()])[j]);\n                }\n            }\n            cluster.getPoints().addAll(pointsInCluster);\n        }\n\n        return changes;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n\n        int changes = 0;\n        for (int i = 0; i < points.size(); i++) {\n            final T point = points.toArray(new T[0])[i];\n            double minDistance = Double.POSITIVE_INFINITY;\n            int minIndex = 0;\n            for (int j = 0; j < clusters.size(); j++) {\n                final double distance = distance(clusters.get(j).getCenter().getPoint(), point);\n                if (distance < minDistance) {\n                    minDistance = distance;\n                    minIndex = j;\n                }\n            }\n            if (assignments[i] != minIndex) {\n                changes++;\n            }\n            assignments[i] = minIndex;\n            clusters.get(minIndex).getPoints().add(point);\n        }\n        return changes;\n    }"
    ],
    [
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_LENGTHS,\n                xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA,\n                2, xArray.length);\n    }\n    double sum = 0;\n    double sumX = 0;\n    double sumY = 0;\n    double sumX2 = 0;\n    double sumY2 = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sum += xArray[i] * yArray[i];\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumX2 += xArray[i] * xArray[i];\n        sumY2 += yArray[i] * yArray[i];\n    }\n    double cov = (sum - sumX * sumY / xArray.length) / (xArray.length - 1);\n    if (biasCorrected) {\n        cov = cov * xArray.length / (xArray.length - 1);\n    }\n    return cov;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n\n        if (xArray.length != yArray.length) {\n            throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_LENGTHS,\n                    xArray.length, yArray.length);\n        }\n\n        if (xArray.length < 2) {\n            throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA,\n                    xArray.length, 2);\n        }\n\n        double xMean = new Mean().evaluate(xArray);\n        double yMean = new Mean().evaluate(yArray);\n\n        double sum = 0;\n        for (int i = 0; i < xArray.length; i++) {\n            sum += (xArray[i] - xMean) * (yArray[i] - yMean);\n        }\n\n        if (biasCorrected) {\n            sum /= xArray.length - 1;\n        } else {\n            sum /= xArray.length;\n        }\n\n        return sum;\n    }",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n\n        if (xArray.length != yArray.length) {\n            throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_LENGTHS,\n                    xArray.length, yArray.length);\n        }\n\n        if (xArray.length < 2) {\n            throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA,\n                    xArray.length, 2);\n        }\n\n        double xMean = new Mean().evaluate(xArray);\n        double yMean = new Mean().evaluate(yArray);\n\n        double sum = 0;\n        for (int i = 0; i < xArray.length; i++) {\n            sum += (xArray[i] - xMean) * (yArray[i] - yMean);\n        }\n\n        if (biasCorrected) {\n            return sum / (xArray.length - 1);\n        } else {\n            return sum / xArray.length;\n        }\n    }",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_LENGTHS,\n                xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA,\n                xArray.length, 2);\n    }\n    double sumProduct = 0;\n    double sumX = 0;\n    double sumY = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sumProduct += xArray[i] * yArray[i];\n        sumX += xArray[i];\n        sumY += yArray[i];\n    }\n    double meanX = sumX / xArray.length;\n    double meanY = sumY / xArray.length;\n    double covariance = sumProduct / (xArray.length - 1);\n    if (biasCorrected) {\n        covariance -= meanX * meanY;\n    }\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_LENGTHS,\n                xArray.length, yArray.length);\n    }\n\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA, 2, xArray.length);\n    }\n\n    double xMean = 0;\n    double yMean = 0;\n    if (biasCorrected) {\n        xMean = new Mean().evaluate(xArray);\n        yMean = new Mean().evaluate(yArray);\n    }\n\n    double covariance = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        covariance += (xArray[i] - xMean) * (yArray[i] - yMean);\n    }\n    return covariance / (xArray.length - 1);\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    int n = xArray.length;\n    if (n != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_LENGTHS, n, yArray.length);\n    }\n    if (n < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA, n, 2);\n    }\n    double xBar = new Mean().evaluate(xArray);\n    double yBar = new Mean().evaluate(yArray);\n    double sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum += (xArray[i] - xBar) * (yArray[i] - yBar);\n    }\n    if (biasCorrected) {\n        sum /= (n - 1);\n    } else {\n        sum /= n;\n    }\n    return sum;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n\n        if (xArray.length != yArray.length) {\n            throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_LENGTHS_IN_COVARIANCE,\n                    xArray.length, yArray.length);\n        }\n        if (xArray.length < 2) {\n            throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA_FOR_COVARIANCE,\n                    xArray.length, 2);\n        }\n\n        double sum = 0;\n        double sumX = 0;\n        double sumY = 0;\n        double sumXY = 0;\n        double sumX2 = 0;\n        double sumY2 = 0;\n\n        for (int i = 0; i < xArray.length; i++) {\n            sum++;\n            sumX += xArray[i];\n            sumY += yArray[i];\n            sumXY += xArray[i] * yArray[i];\n            sumX2 += xArray[i] * xArray[i];\n            sumY2 += yArray[i] * yArray[i];\n        }\n\n        double cov = (sumXY - sumX * sumY / sum) / (sum - 1);\n        if (biasCorrected) {\n            cov *= sum / (sum - 1);\n        }\n        return cov;\n    }",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_LENGTHS,\n                xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA_FOR_COVARIANCE,\n                xArray.length);\n    }\n    double xMean = new Mean().evaluate(xArray);\n    double yMean = new Mean().evaluate(yArray);\n    double sum = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sum += (xArray[i] - xMean) * (yArray[i] - yMean);\n    }\n    if (biasCorrected) {\n        sum /= xArray.length - 1;\n    } else {\n        sum /= xArray.length;\n    }\n    return sum;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_LENGTHS,\n                xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA, 2, xArray.length);\n    }\n    double xMean = new Mean().evaluate(xArray);\n    double yMean = new Mean().evaluate(yArray);\n    double sum = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sum += (xArray[i] - xMean) * (yArray[i] - yMean);\n    }\n    if (biasCorrected) {\n        sum /= xArray.length - 1;\n    } else {\n        sum /= xArray.length;\n    }\n    return sum;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n\n        if (xArray.length != yArray.length) {\n            throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_LENGTHS,\n                    xArray.length, yArray.length);\n        }\n\n        if (xArray.length < 2) {\n            throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA_FOR_COVARIANCE,\n                    xArray.length, 2);\n        }\n\n        double xMean = new Mean().evaluate(xArray);\n        double yMean = new Mean().evaluate(yArray);\n\n        double sum = 0;\n        for (int i = 0; i < xArray.length; i++) {\n            sum += (xArray[i] - xMean) * (yArray[i] - yMean);\n        }\n\n        if (biasCorrected) {\n            sum /= (xArray.length - 1);\n        } else {\n            sum /= xArray.length;\n        }\n\n        return sum;\n    }"
    ],
    [
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) {\n        final long toSkip = Math.min(value - skipped, Integer.MAX_VALUE);\n        final int ret = in.read(buf.array(), 0, (int) toSkip);\n        if (ret < 0) {\n            break;\n        }\n        skipped += ret;\n    }\n    bytesRead += skipped;\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value <= 0) {\n        return;\n    }\n    final int length = (int) Math.min(value, Integer.MAX_VALUE);\n    final byte[] buf = new byte[length];\n    int total = 0;\n    while (total < length) {\n        final int read = in.read(buf, total, length - total);\n        if (read < 0) {\n            break;\n        }\n        total += read;\n    }\n    if (total < length) {\n        throw new EOFException(\"Unable to skip \" + length + \" bytes\");\n    }\n    bytesRead += length;\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) {\n        final long n = in.skip(value - skipped);\n        if (n <= 0) {\n            break;\n        }\n        skipped += n;\n    }\n    bytesRead += skipped;\n}",
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    while (remaining > 0) {\n        final long skipped = in.skip(remaining);\n        if (skipped == 0) {\n            throw new EOFException();\n        }\n        remaining -= skipped;\n    }\n    bytesRead += value;\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value < 0) {\n        throw new IllegalArgumentException(\"negative skip length: \" + value);\n    }\n    final int length = (int) value;\n    final int remaining = length;\n    while (remaining > 0) {\n        final int actual = in.read(buf.array(), 0, Math.min(remaining, buf.capacity()));\n        if (actual < 0) {\n            throw new EOFException(\"unexpected end of ZIP file\");\n        }\n        realSkipBytesRead += actual;\n        remaining -= actual;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    while (remaining > 0) {\n        final int read = in.read(buf.array(), 0, (int) Math.min(remaining, buf.capacity()));\n        if (read == -1) {\n            break;\n        }\n        remaining -= read;\n    }\n    bytesRead += value - remaining;\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value < 0) {\n        throw new IllegalArgumentException(\"negative value: \" + value);\n    }\n    if (value == 0) {\n        return;\n    }\n    final long skipped = IOUtils.skip(in, value);\n    if (skipped != value) {\n        throw new IOException(\"Unable to skip \" + value + \" bytes, \"\n                              + \"only skipped \" + skipped);\n    }\n    bytesRead += skipped;\n}",
      "private void realSkip(final long value) throws IOException  {\n    final long skipped = in.skip(value);\n    bytesRead += skipped;\n    if (skipped != value) {\n        throw new EOFException(\"Unable to skip \" + value + \" bytes\");\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    while (remaining > 0) {\n        final int read = in.read(buf.array(), 0, (int) Math.min(remaining, buf.capacity()));\n        if (read == -1) {\n            break;\n        }\n        remaining -= read;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value <= 0) {\n        return;\n    }\n    final int toSkip = (int) Math.min(value, Integer.MAX_VALUE);\n    final byte[] b = new byte[toSkip];\n    int skipped = 0;\n    while (skipped < toSkip) {\n        final int n = in.read(b, skipped, toSkip - skipped);\n        if (n < 0) {\n            throw new EOFException();\n        }\n        skipped += n;\n    }\n    bytesRead += skipped;\n}"
    ],
    [
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}"
    ],
    [
      "private static String fingerprint(List<CharSequence> messageParts)  {\n  String message = messageParts.stream().map(Object::toString).collect(Collectors.joining());\n  byte[] hash = MessageDigest.getInstance(\"SHA-256\").digest(message.getBytes());\n  return BaseEncoding.base64Url().omitPadding().encode(hash).substring(0, 8).toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // TODO: Implement the fingerprint generation\n    return \"\";\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    String fingerprint = \"\";\n    for (CharSequence part : messageParts) {\n        fingerprint += part.toString();\n    }\n    fingerprint = fingerprint.toUpperCase();\n    return fingerprint;\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n  // Compute a 63-bit hash of the message parts.\n  long hash = 0;\n  for (CharSequence part : messageParts) {\n    hash = hash * 31 + part.hashCode();\n  }\n\n  // Convert the hash to a compact uppercase alphanumeric text representation.\n  String result = Long.toString(hash, 36);\n  while (result.length() < 6) {\n    result = \"0\" + result;\n  }\n  return result.toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n  String fingerprint = \"\";\n  try {\n    MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n    for (CharSequence part : messageParts) {\n      md.update(part.toString().getBytes(\"UTF-8\"));\n    }\n    byte[] digest = md.digest();\n    for (byte b : digest) {\n      fingerprint += String.format(\"%02x\", b);\n    }\n  } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {\n    e.printStackTrace();\n  }\n  return fingerprint.toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        md.update(part.toString().getBytes());\n    }\n    byte[] digest = md.digest();\n    for (int i = 0; i < digest.length; i++) {\n        sb.append(Integer.toString((digest[i] & 0xff) + 0x100, 16).substring(1));\n    }\n    return sb.toString();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n  // We use a 63-bit fingerprint, so we can use 63 bits of the 64-bit hash\n  // value.\n  long hash = 0;\n  for (CharSequence part : messageParts) {\n    hash = 31 * hash + part.hashCode();\n  }\n  hash = hash & 0x7FFFFFFFFFFFFFFFL;\n\n  // We use a compact uppercase alphanumeric text representation of the\n  // fingerprint.\n  char[] fingerprint = new char[12];\n  for (int i = 0; i < 12; i++) {\n    fingerprint[i] = ALPHABET[(int) (hash % 62)];\n    hash /= 62;\n  }\n  return new String(fingerprint);\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n  return new BigInteger(1, MessageDigest.getInstance(\"SHA-256\").digest(\n      messageParts.toString().getBytes())).toString(36).toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // TODO: Implement this method\n    return \"\";\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // TODO: Implement this method\n    return \"\";\n}"
    ],
    [
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    boolean found = false;\n    long currDistance = maxDistanceFromEnd;\n    while (!found && currDistance >= minDistanceFromEnd) {\n        final long currPos = archive.length() - currDistance;\n        archive.position(currPos);\n        final int bytesToRead = (int) Math.min(WORD, currDistance);\n        final byte[] buf = new byte[bytesToRead];\n        IOUtils.readFully(archive, buf);\n        found = Arrays.equals(sig, buf);\n        currDistance -= WORD;\n    }\n    return found;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long maxDistanceFromEndAbs = Math.abs(maxDistanceFromEnd);\n    final long minDistanceFromEndAbs = Math.abs(minDistanceFromEnd);\n    if (maxDistanceFromEndAbs < minDistanceFromEndAbs) {\n        throw new IllegalArgumentException(\"maxDistanceFromEnd < minDistanceFromEnd\");\n    }\n    if (minDistanceFromEndAbs < 0) {\n        throw new IllegalArgumentException(\"minDistanceFromEnd < 0\");\n    }\n    if (maxDistanceFromEndAbs < 0) {\n        throw new IllegalArgumentException(\"maxDistanceFromEnd < 0\");\n    }\n    if (sig.length != WORD) {\n        throw new IllegalArgumentException(\"sig.length != WORD\");\n    }\n    final long length = archive.length();\n    long startPos = length - minDistanceFromEndAbs;\n    if (startPos < 0) {\n        startPos = 0;\n    }\n    long endPos = length - maxDistanceFromEndAbs;\n    if (endPos < 0) {\n        endPos = 0;\n    }\n    long pos = startPos;\n    while (pos >= endPos) {\n        archive.position(pos);\n        byteBuf.rewind();\n        IOUtils.readFully(archive, byteBuf);\n        if (Arrays.equals(byteBuf, sig)) {\n            return true;\n        }\n        pos--;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long minDistance = Math.min(minDistanceFromEnd, maxDistanceFromEnd);\n    final long maxDistance = Math.max(minDistanceFromEnd, maxDistanceFromEnd);\n    long distance = minDistance;\n    long position = archive.length() - distance;\n    while (distance <= maxDistance) {\n        archive.position(position);\n        byteBuf.rewind();\n        IOUtils.readFully(archive, byteBuf, 0, sig.length);\n        if (Arrays.equals(byteBuf.array(), sig)) {\n            return true;\n        }\n        position = archive.length() - ++distance;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long distance = Math.min(minDistanceFromEnd, maxDistanceFromEnd);\n    long pos = archive.length() - distance;\n    boolean found = false;\n    while (!found && pos >= 0) {\n        archive.seek(pos);\n        byte[] buf = new byte[sig.length];\n        archive.read(buf);\n        found = Arrays.equals(buf, sig);\n        if (!found) {\n            distance = Math.min(distance * 2, maxDistanceFromEnd);\n            pos = archive.length() - distance;\n        }\n    }\n    if (found) {\n        archive.seek(pos);\n    }\n    return found;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    boolean found = false;\n    long distance = minDistanceFromEnd;\n    while (!found && distance <= maxDistanceFromEnd) {\n        archive.seek(archive.length() - distance);\n        wordBbuf.rewind();\n        IOUtils.readFully(archive, wordBbuf);\n        if (Arrays.equals(wordBuf, sig)) {\n            found = true;\n        } else {\n            distance *= 2;\n            if (distance > maxDistanceFromEnd) {\n                distance = maxDistanceFromEnd;\n            }\n        }\n    }\n    if (found) {\n        archive.seek(archive.length() - distance);\n    }\n    return found;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    boolean found = false;\n    final long length = archive.length();\n    long pos = length - minDistanceFromEnd;\n    if (pos < 0) {\n        pos = 0;\n    }\n    while (!found && pos < length - maxDistanceFromEnd) {\n        archive.position(pos);\n        final int remaining = (int) (length - pos);\n        if (remaining < sig.length) {\n            break;\n        }\n        final byte[] buf = new byte[sig.length];\n        IOUtils.readFully(archive, buf);\n        found = Arrays.equals(buf, sig);\n        if (!found) {\n            pos++;\n        }\n    }\n    if (found) {\n        archive.position(pos);\n    }\n    return found;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long pos = archive.length() - minDistanceFromEnd;\n    if (pos < 0) {\n        pos = 0;\n    }\n    final long maxPos = archive.length() - maxDistanceFromEnd;\n    if (maxPos < 0) {\n        return false;\n    }\n    while (pos > maxPos) {\n        archive.position(pos);\n        wordBbuf.rewind();\n        IOUtils.readFully(archive, wordBbuf);\n        if (Arrays.equals(wordBuf, sig)) {\n            return true;\n        }\n        pos--;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        final long minDistance = Math.min(minDistanceFromEnd, maxDistanceFromEnd);\n        final long maxDistance = Math.max(minDistanceFromEnd, maxDistanceFromEnd);\n        long distance = minDistance;\n        while (distance <= maxDistance) {\n            archive.seek(archive.length() - distance);\n            wordBbuf.rewind();\n            IOUtils.readFully(archive, wordBbuf);\n            if (Arrays.equals(wordBuf, sig)) {\n                return true;\n            }\n            distance *= 2;\n            if (distance > maxDistance) {\n                distance = maxDistance;\n            }\n        }\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long maxDistanceFromEndOfArchive = archive.length() - maxDistanceFromEnd;\n    final long minDistanceFromEndOfArchive = archive.length() - minDistanceFromEnd;\n    long currentDistanceFromEnd = minDistanceFromEndOfArchive;\n    while (currentDistanceFromEnd >= maxDistanceFromEndOfArchive) {\n        archive.position(currentDistanceFromEnd);\n        wordBbuf.rewind();\n        IOUtils.readFully(archive, wordBbuf);\n        if (Arrays.equals(wordBuf, sig)) {\n            return true;\n        }\n        currentDistanceFromEnd--;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long distance = minDistanceFromEnd;\n    while (distance < maxDistanceFromEnd) {\n        archive.seek(archive.length() - distance);\n        wordBbuf.rewind();\n        IOUtils.readFully(archive, wordBbuf);\n        if (Arrays.equals(wordBuf, sig)) {\n            return true;\n        }\n        distance *= 2;\n        if (distance > maxDistanceFromEnd) {\n            distance = maxDistanceFromEnd;\n        }\n    }\n    return false;\n}"
    ],
    [
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    RectangleEdge result = null;\n    AxisLocation location = getDomainAxisLocation(index);\n    if (location != null) \n    {\n        result = Plot.resolveDomainAxisLocation(location, this.getOrientation());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    RectangleEdge result = null;\n    AxisLocation location = getDomainAxisLocation(index);\n    if (location == AxisLocation.TOP_OR_RIGHT) \n    {\n        result = RectangleEdge.TOP;\n    } \n    else if (location == AxisLocation.BOTTOM_OR_LEFT) \n    {\n        result = RectangleEdge.BOTTOM;\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = null;\n    if (location == AxisLocation.TOP_OR_RIGHT) {\n        result = RectangleEdge.TOP;\n    }\n    else if (location == AxisLocation.BOTTOM_OR_LEFT) {\n        result = RectangleEdge.BOTTOM;\n    }\n    else if (location == AxisLocation.TOP_OR_LEFT) {\n        result = RectangleEdge.LEFT;\n    }\n    else if (location == AxisLocation.BOTTOM_OR_RIGHT) {\n        result = RectangleEdge.RIGHT;\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    RectangleEdge result = null;\n    AxisLocation location = getDomainAxisLocation(index);\n    if (location != null) \n    {\n        if (location == AxisLocation.TOP_OR_RIGHT) \n        {\n            result = RectangleEdge.TOP;\n        } \n        else if (location == AxisLocation.BOTTOM_OR_LEFT) \n        {\n            result = RectangleEdge.BOTTOM;\n        }\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = null;\n    if (location == AxisLocation.TOP_OR_RIGHT) {\n        result = RectangleEdge.TOP;\n    }\n    else if (location == AxisLocation.BOTTOM_OR_LEFT) {\n        result = RectangleEdge.BOTTOM;\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = null;\n    if (location == AxisLocation.TOP_OR_RIGHT) {\n        result = RectangleEdge.TOP;\n    }\n    else if (location == AxisLocation.BOTTOM_OR_LEFT) {\n        result = RectangleEdge.BOTTOM;\n    }\n    else if (location == AxisLocation.LEFT) {\n        result = RectangleEdge.LEFT;\n    }\n    else if (location == AxisLocation.RIGHT) {\n        result = RectangleEdge.RIGHT;\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = null;\n    if (location == AxisLocation.TOP_OR_RIGHT) \n    {\n        result = RectangleEdge.TOP;\n    } \n    else if (location == AxisLocation.BOTTOM_OR_LEFT) \n    {\n        result = RectangleEdge.BOTTOM;\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    RectangleEdge result = null;\n    AxisLocation location = getDomainAxisLocation(index);\n    if (location == AxisLocation.TOP_OR_RIGHT) \n    {\n        result = RectangleEdge.TOP;\n    } \n    else if (location == AxisLocation.BOTTOM_OR_LEFT) \n    {\n        result = RectangleEdge.BOTTOM;\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = null;\n    if (location == AxisLocation.TOP_OR_RIGHT) {\n        result = RectangleEdge.TOP;\n    }\n    else if (location == AxisLocation.BOTTOM_OR_LEFT) {\n        result = RectangleEdge.BOTTOM;\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = null;\n    if (location == AxisLocation.TOP_OR_RIGHT) \n    {\n        result = RectangleEdge.TOP;\n    } \n    else if (location == AxisLocation.BOTTOM_OR_LEFT) \n    {\n        result = RectangleEdge.BOTTOM;\n    }\n    return result;\n}"
    ],
    [
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}"
    ],
    [
      "public InputStream getDataStream()  {\n    if (_originalStream == null)\n    {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    else\n    {\n        return new SequenceInputStream(new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength), _originalStream);\n    }\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null)\n    {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    else\n    {\n        return new SequenceInputStream(new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength), _originalStream);\n    }\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    // otherwise, need to create a composite stream\n    return new SequenceInputStream(new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength), _originalStream);\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null)\n    {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    else\n    {\n        return new SequenceInputStream(new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength), _originalStream);\n    }\n}",
      "public InputStream getDataStream()  {\n    return new SequenceInputStream(new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength), _originalStream);\n}",
      "public InputStream getDataStream()  {\n    return new SequenceInputStream(new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength), _originalStream);\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    // otherwise, need to combine buffers\n    byte[] buffer = new byte[_bufferedLength + _bufferedStart];\n    System.arraycopy(_bufferedData, _bufferedStart, buffer, 0, _bufferedLength);\n    int offset = _bufferedLength;\n    int count;\n    try {\n        while ((count = _originalStream.read(buffer, offset, buffer.length - offset)) > 0) {\n            offset += count;\n        }\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n    return new ByteArrayInputStream(buffer, 0, offset);\n}"
    ],
    [
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    if (section < this.dataset.getSeriesCount()) {\n        key = this.dataset.getSeriesKey(section);\n    }\n    if (key == null) {\n        key = \"Section \" + section;\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (section < this.dataset.getSeriesCount()) {\n        result = this.dataset.getSeriesKey(section);\n    }\n    if (result == null) {\n        result = Integer.valueOf(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    // is there a section for the specified index?\n    if (section < this.dataset.getSeriesCount()) {\n        key = this.dataset.getSeriesKey(section);\n    }\n    // no key defined - generate one\n    if (key == null) {\n        key = \"Section \" + section;\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    // if there is a dataset, use it to look up the key\n    if (getDataset() != null) {\n        result = getDataset().getSectionKey(section);\n    }\n    // if there is no dataset, or the dataset can't provide a key,\n    // generate a key\n    if (result == null) {\n        result = new Integer(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (this.dataset != null) {\n        result = this.dataset.getSectionKey(section);\n    }\n    if (result == null) {\n        result = Integer.valueOf(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    // if there is a dataset, use it to find the key\n    if (getDataset() != null) {\n        key = getDataset().getSectionKey(section);\n    }\n    // if the dataset doesn't have a key, we generate one\n    if (key == null) {\n        key = \"Section \" + section;\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (this.dataset != null) {\n        result = this.dataset.getSectionKey(section);\n    }\n    if (result == null) {\n        result = Integer.valueOf(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    if (section >= 0 && section < this.dataset.getSeriesCount()) {\n        key = this.dataset.getSeriesKey(section);\n    }\n    if (key == null) {\n        key = new Integer(section);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    // is there a section key for this section?\n    if (section < this.sectionKeys.size()) {\n        key = this.sectionKeys.get(section);\n    }\n    // if not, generate one\n    if (key == null) {\n        key = new Integer(section);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    // is there a section for this index?\n    if (section < this.sectionMap.size()) {\n        result = this.sectionMap.getKey(section);\n    }\n    // no section found, so we generate a key\n    if (result == null) {\n        result = Integer.valueOf(section);\n    }\n    return result;\n}"
    ],
    [
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_INT\n                    || _currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Object ob = _currentObject();\n                if (ob instanceof Double) {\n                    return ((Double) ob).isNaN();\n                }\n                if (ob instanceof Float) {\n                    return ((Float) ob).isNaN();\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            // 19-Apr-2017, tatu: This is bit tricky, as we can not just\n            //   call `Double.isNaN()` on current value, as it may not\n            //   be a valid number. But, we can check current token, and\n            //   if it is a number, we can call `isNaN()` on it.\n            //   But if it is not a number, we can not call it, so\n            //   need to return false.\n            //   One more thing: if we do get a valid number, need to\n            //   check that it is not a valid number, and if so, return\n            //   false.\n            //   So that's what this method does.\n            // 20-Apr-2017, tatu: As per [databind#1998], we need to\n            //   also check for \"NaN\" String.\n            if (_currToken == JsonToken.VALUE_NUMBER_INT\n                    || _currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Object value = _currentObject();\n                if (value instanceof Double) {\n                    return Double.isNaN((Double) value);\n                }\n                if (value instanceof Float) {\n                    return Float.isNaN((Float) value);\n                }\n                if (value instanceof String) {\n                    return \"NaN\".equals(value);\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            // only works for native numbers\n            if (_currToken == JsonToken.VALUE_NUMBER_INT\n                    || _currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                return ClassUtil.isFpNaN(_numberValue);\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                return (_numberType == NumberType.BIG_DECIMAL) && (_numberBigDecimal == null)\n                        || (_numberType == NumberType.DOUBLE) && (Double.isNaN(_numberDouble));\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            // only works for floating point numbers\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Object ob = _currentObject();\n                if (ob instanceof Double) {\n                    return ((Double) ob).isNaN();\n                }\n                if (ob instanceof Float) {\n                    return ((Float) ob).isNaN();\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            // only works for native numbers\n            if (_currToken == JsonToken.VALUE_NUMBER_INT || _currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Object ob = _currentObject();\n                if (ob instanceof Number) {\n                    return ((Number) ob).doubleValue() == Double.NaN;\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            // only works for floating point numbers\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Object ob = _currentObject();\n                if (ob instanceof Double) {\n                    return ((Double) ob).isNaN();\n                }\n                if (ob instanceof Float) {\n                    return ((Float) ob).isNaN();\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            // only works for native numbers, not custom ones\n            if (_currToken == JsonToken.VALUE_NUMBER_INT || _currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                return Double.isNaN(getDoubleValue());\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Object ob = _currentObject();\n                if (ob instanceof Double) {\n                    return ((Double) ob).isNaN();\n                }\n                if (ob instanceof Float) {\n                    return ((Float) ob).isNaN();\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            // 14-Mar-2017, tatu: Not sure if we can reliably detect this, so let's\n            //    not try for now.\n            return false;\n        }"
    ],
    [
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n        if (str == null || prefix == null) {\n            return (str == null && prefix == null);\n        }\n        if (prefix.length() > str.length()) {\n            return false;\n        }\n        for (int i = 0; i < prefix.length(); i++) {\n            final char strChar = str.charAt(i);\n            final char prefixChar = prefix.charAt(i);\n            if (strChar != prefixChar && !Character.toLowerCase(strChar) == Character.toLowerCase(prefixChar)) {\n                return false;\n            }\n        }\n        return true;\n    }",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return (str == null && prefix == null);\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return (str == null && prefix == null);\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    if (ignoreCase) {\n        for (int i = 0; i < prefix.length(); i++) {\n            final char strChar = Character.toLowerCase(str.charAt(i));\n            final char prefixChar = Character.toLowerCase(prefix.charAt(i));\n            if (strChar != prefixChar) {\n                return false;\n            }\n        }\n    } else {\n        for (int i = 0; i < prefix.length(); i++) {\n            if (str.charAt(i) != prefix.charAt(i)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return (str == null && prefix == null);\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return (str == null && prefix == null);\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    for (int i = 0; i < prefix.length(); i++) \n    {\n        final char strChar = str.charAt(i);\n        final char prefixChar = prefix.charAt(i);\n        if (strChar != prefixChar && !Character.toLowerCase(strChar) == Character.toLowerCase(prefixChar)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return (str == null && prefix == null);\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return (str == null && prefix == null);\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return (str == null && prefix == null);\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    if (ignoreCase) \n    {\n        for (int i = 0; i < prefix.length(); i++) \n        {\n            final char strChar = Character.toLowerCase(str.charAt(i));\n            final char prefixChar = Character.toLowerCase(prefix.charAt(i));\n            if (strChar != prefixChar) \n            {\n                return false;\n            }\n        }\n    } \n    else \n    {\n        for (int i = 0; i < prefix.length(); i++) \n        {\n            if (str.charAt(i) != prefix.charAt(i)) \n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return (str == null && prefix == null);\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    for (int i = 0; i < prefix.length(); i++) \n    {\n        final char strChar = str.charAt(i);\n        final char prefixChar = prefix.charAt(i);\n        if (strChar != prefixChar && !ignoreCase && Character.toLowerCase(strChar) != Character.toLowerCase(prefixChar)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return (str == null && prefix == null);\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    for (int i = 0; i < prefix.length(); i++) \n    {\n        final char strChar = str.charAt(i);\n        final char prefixChar = prefix.charAt(i);\n        if (strChar != prefixChar && !Character.toLowerCase(strChar) == Character.toLowerCase(prefixChar)) \n        {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "public String nextString() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  String result;\n  if (p == PEEKED_UNQUOTED_NAME) {\n    result = nextUnquotedValue();\n  } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n    result = nextQuotedValue('\\'');\n  } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n    result = nextQuotedValue('\"');\n  } else {\n    throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return result;\n}",
      "public String nextString() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  String result;\n  if (p == PEEKED_UNQUOTED_NAME) {\n    result = nextUnquotedValue();\n  } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n    result = nextQuotedValue('\\'');\n  } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n    result = nextQuotedValue('\"');\n  } else {\n    throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return result;\n}",
      "public String nextString() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  String result;\n  if (p == PEEKED_UNQUOTED_NAME) {\n    result = nextUnquotedValue();\n  } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n    result = nextQuotedValue('\\'');\n  } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n    result = nextQuotedValue('\"');\n  } else {\n    throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextString() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  String result;\n  if (p == PEEKED_UNQUOTED_NAME) {\n    result = nextUnquotedValue();\n  } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n    result = nextQuotedValue('\\'');\n  } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n    result = nextQuotedValue('\"');\n  } else {\n    throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n        result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n        result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n        result = nextQuotedValue('\"');\n    } else {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextString() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  String result;\n  if (p == PEEKED_UNQUOTED_NAME) {\n    result = nextUnquotedValue();\n  } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n    result = nextQuotedValue('\\'');\n  } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n    result = nextQuotedValue('\"');\n  } else {\n    throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}"
    ],
    [
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (maxWidth < 4) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) \n    {\n        return str;\n    }\n    if (offset > str.length()) \n    {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) \n    {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) \n    {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) \n    {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}"
    ],
    [
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null && s2 == null) {\n        return true;\n    }\n    if (s1 == null || s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null && s2 == null) \n    {\n        return true;\n    }\n    if (s1 == null || s2 == null) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!s1[i].equals(s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null && s2 == null)\n        return true;\n    if (s1 == null || s2 == null)\n        return false;\n    if (s1.length != s2.length)\n        return false;\n    for (int i = 0; i < s1.length; i++)\n    {\n        if (!s1[i].equals(s2[i]))\n            return false;\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null && s2 == null) {\n        return true;\n    }\n    if (s1 == null || s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null && s2 == null) \n    {\n        return true;\n    }\n    if (s1 == null || s2 == null) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!s1[i].equals(s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null && s2 == null)\n        return true;\n    if (s1 == null || s2 == null)\n        return false;\n    if (s1.length != s2.length)\n        return false;\n    for (int i = 0; i < s1.length; i++)\n    {\n        if (!s1[i].equals(s2[i]))\n            return false;\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null && s2 == null) \n    {\n        return true;\n    }\n    if (s1 == null || s2 == null) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!s1[i].equals(s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) \n    {\n        return s2 == null;\n    } \n    else if (s2 == null) \n    {\n        return false;\n    } \n    else if (s1.length != s2.length) \n    {\n        return false;\n    } \n    else \n    {\n        for (int i = 0; i < s1.length; i++) \n        {\n            if (!s1[i].equals(s2[i])) \n            {\n                return false;\n            }\n        }\n        return true;\n    }\n}"
    ],
    [
      "private int getNameId(String symbolName)  {\n  Integer index = nameMap.get(symbolName);\n  if (index != null) {\n    return index;\n  } else {\n    int id = nameMap.size();\n    nameMap.put(symbolName, id);\n    return id;\n  }\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) \n    {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) \n        {\n            lastSymbolNameIndex = index;\n        } \n        else \n        {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n  if (symbolName != lastSymbolName) {\n    lastSymbolName = symbolName;\n    Integer index = symbolNameMap.get(symbolName);\n    if (index != null) {\n      lastSymbolNameIndex = index;\n    } else {\n      lastSymbolNameIndex = symbolNameMap.size();\n      symbolNameMap.put(symbolName, lastSymbolNameIndex);\n    }\n  }\n  return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) {\n      lastSymbolName = symbolName;\n      Integer index = symbolNameMap.get(symbolName);\n      if (index != null) {\n        lastSymbolNameIndex = index;\n      } else {\n        lastSymbolNameIndex = symbolNameMap.size();\n        symbolNameMap.put(symbolName, lastSymbolNameIndex);\n      }\n    }\n    return lastSymbolNameIndex;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) \n    {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) \n        {\n            lastSymbolNameIndex = index;\n        } \n        else \n        {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) {\n      lastSymbolName = symbolName;\n      Integer index = symbolNameMap.get(symbolName);\n      if (index != null) {\n        lastSymbolNameIndex = index;\n      } else {\n        lastSymbolNameIndex = symbolNameMap.size();\n        symbolNameMap.put(symbolName, lastSymbolNameIndex);\n      }\n    }\n    return lastSymbolNameIndex;\n  }",
      "private int getNameId(String symbolName)  {\n    Integer index = nameMap.get(symbolName);\n    if (index != null) {\n      return index;\n    }\n    int newIndex = nameMap.size();\n    nameMap.put(symbolName, newIndex);\n    return newIndex;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) \n    {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) \n        {\n            lastSymbolNameIndex = index;\n        } \n        else \n        {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) {\n      lastSymbolName = symbolName;\n      Integer index = symbolNameMap.get(symbolName);\n      if (index != null) {\n        lastSymbolNameIndex = index;\n      } else {\n        lastSymbolNameIndex = symbolNameMap.size();\n        symbolNameMap.put(symbolName, lastSymbolNameIndex);\n      }\n    }\n    return lastSymbolNameIndex;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) \n    {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) \n        {\n            lastSymbolNameIndex = index;\n        } \n        else \n        {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}"
    ],
    [
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) {\n        result = (double) peekedLong;\n    } else if (p == PEEKED_NUMBER) {\n        result = Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n    } else {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) {\n      result = (double) peekedLong;\n    } else if (p == PEEKED_NUMBER) {\n      result = Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) {\n      result = (double) peekedLong;\n    } else if (p == PEEKED_NUMBER) {\n      result = Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) {\n        result = (double) peekedLong;\n    } else if (p == PEEKED_NUMBER) {\n        result = Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n        pos += peekedNumberLength;\n    } else {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_LONG) {\n      peekedString = Long.toString(peekedLong);\n      peeked = PEEKED_BUFFERED;\n    } else if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n      peeked = PEEKED_BUFFERED;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      peeked = PEEKED_BUFFERED;\n    } else if (p == PEEKED_UNQUOTED) {\n      peekedString = nextUnquotedValue();\n      peeked = PEEKED_BUFFERED;\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    double result = Double.parseDouble(peekedString);\n    if (Double.isNaN(result) || Double.isInfinite(result)) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + result);\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_LONG) {\n        peekedLong = 0;\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return (double) peekedLong;\n    } else if (p == PEEKED_NUMBER) {\n        peekedString = null;\n        pos += peekedNumberLength;\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return Double.parseDouble(new String(buffer, pos - peekedNumberLength, peekedNumberLength));\n    } else {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_LONG) {\n      peekedString = null;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return (double)peekedLong;\n    } else if (p == PEEKED_NUMBER) {\n      peekedString = null;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_LONG) {\n      peekedString = Long.toString(peekedLong);\n      peeked = PEEKED_BUFFERED;\n    } else if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      peeked = PEEKED_BUFFERED;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      peeked = PEEKED_BUFFERED;\n    } else if (p == PEEKED_UNQUOTED) {\n      peekedString = nextUnquotedValue();\n      peeked = PEEKED_BUFFERED;\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    double result = Double.parseDouble(peekedString);\n    if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + result);\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) {\n      result = (double)peekedLong;\n    } else if (p == PEEKED_NUMBER) {\n      result = Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) {\n        result = (double) peekedLong;\n    } else if (p == PEEKED_NUMBER) {\n        result = Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n        pos += peekedNumberLength;\n    } else {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}"
    ],
    [
      "public static String repeat(final String str, final int repeat)  {\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return repeat(str.charAt(0), repeat);\n        }\n\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                return repeat(str.charAt(0), repeat);\n            case 2 :\n                final char ch0 = str.charAt(0);\n                final char ch1 = str.charAt(1);\n                final char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                final StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }",
      "public static String repeat(final String str, final int repeat)  {\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return repeat(str.charAt(0), repeat);\n        }\n\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                return repeat(str.charAt(0), repeat);\n            case 2 :\n                final char ch0 = str.charAt(0);\n                final char ch1 = str.charAt(1);\n                final char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                final StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }",
      "public static String repeat(final String str, final int repeat)  {\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return repeat(str.charAt(0), repeat);\n        }\n\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1:\n                return repeat(str.charAt(0), repeat);\n            case 2:\n                final char ch0 = str.charAt(0);\n                final char ch1 = str.charAt(1);\n                final char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default:\n                final StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }",
      "public static String repeat(final String str, final int repeat)  {\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return repeat(str.charAt(0), repeat);\n        }\n\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                return repeat(str.charAt(0), repeat);\n            case 2 :\n                final char ch0 = str.charAt(0);\n                final char ch1 = str.charAt(1);\n                final char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                final StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1:\n            return repeat(str.charAt(0), repeat);\n        case 2:\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default:\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return \"\";\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1:\n            return repeat(str.charAt(0), repeat);\n        case 2:\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default:\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1:\n            return repeat(str.charAt(0), repeat);\n        case 2:\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default:\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return \"\";\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1:\n            return repeat(str.charAt(0), repeat);\n        case 2:\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default:\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1:\n            return repeat(str.charAt(0), repeat);\n        case 2:\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default:\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return repeat(str.charAt(0), repeat);\n        }\n\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                return repeat(str.charAt(0), repeat);\n            case 2 :\n                final char ch0 = str.charAt(0);\n                final char ch1 = str.charAt(1);\n                final char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                final StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }"
    ],
    [
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> c = implementations.get(headerId);\n    if (c != null) {\n        return (ZipExtraField) c.newInstance();\n    }\n    return new UnrecognizedExtraField(headerId);\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> c = implementations.get(headerId);\n    if (c != null) {\n        return (ZipExtraField) c.newInstance();\n    }\n    return new UnrecognizedExtraField(headerId);\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> c = implementations.get(headerId);\n    if (c != null) {\n        return (ZipExtraField) c.newInstance();\n    }\n    return new UnrecognizedExtraField(headerId);\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> c = implementations.get(headerId);\n    if (c != null) {\n        return (ZipExtraField) c.newInstance();\n    }\n    return new UnrecognizedExtraField(headerId);\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> impl = implementations.get(headerId);\n    if (impl != null) {\n        return (ZipExtraField) impl.newInstance();\n    }\n    return new UnrecognizedExtraField(headerId);\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> c = implementations.get(headerId);\n    if (c != null) {\n        return (ZipExtraField) c.newInstance();\n    }\n    return new UnrecognizedExtraField(headerId);\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> c = implementations.get(headerId);\n    if (c != null) {\n        return (ZipExtraField) c.newInstance();\n    }\n    return new UnrecognizedExtraField(headerId);\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> c = implementations.get(headerId);\n    if (c != null) {\n        return (ZipExtraField) c.newInstance();\n    }\n    return new UnrecognizedExtraField(headerId);\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> c = implementations.get(headerId);\n    if (c != null) {\n        return (ZipExtraField) c.newInstance();\n    }\n    return new UnrecognizedExtraField(headerId);\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> c = implementations.get(headerId);\n    if (c != null) {\n        return (ZipExtraField) c.newInstance();\n    }\n    return new UnrecognizedExtraField(headerId);\n}"
    ],
    [
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}"
    ],
    [
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) ObjectUtilities.deepClone(map);\n    for (Iterator iterator = clone.entrySet().iterator(); iterator.hasNext();) \n    {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        entry.setValue((Object) ObjectUtilities.deepClone(entry.getValue()));\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n\n    Map clone = new HashMap();\n    for (Iterator iterator = map.keySet().iterator(); iterator.hasNext();) {\n        Comparable key = (Comparable) iterator.next();\n        List value = (List) map.get(key);\n        if (value != null) {\n            List clonedValue = (List) ObjectUtilities.deepClone(value);\n            clone.put(key, clonedValue);\n        }\n    }\n    return clone;\n\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n\n        Map result = new HashMap();\n        Iterator iterator = map.entrySet().iterator();\n        while (iterator.hasNext()) {\n            Map.Entry entry = (Map.Entry) iterator.next();\n            Object key = entry.getKey();\n            Object value = entry.getValue();\n            if (value instanceof PublicCloneable) {\n                PublicCloneable pc = (PublicCloneable) value;\n                Object clone = pc.clone();\n                result.put(key, clone);\n            }\n            else {\n                result.put(key, value);\n            }\n        }\n        return result;\n\n    }",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    Iterator iterator = map.keySet().iterator();\n    while (iterator.hasNext()) \n    {\n        Comparable key = (Comparable) iterator.next();\n        Marker marker = (Marker) map.get(key);\n        clone.put(key, marker.clone());\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map result = (Map) ObjectUtilities.deepClone(map);\n    Iterator iterator = result.values().iterator();\n    while (iterator.hasNext()) {\n        Object next = iterator.next();\n        if (next instanceof PublicCloneable) {\n            PublicCloneable pc = (PublicCloneable) next;\n            Object clone = pc.clone();\n            iterator.set(clone);\n        }\n    }\n    return result;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    for (Iterator iterator = map.entrySet().iterator(); iterator.hasNext();) \n    {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        clone.put(entry.getKey(), (List) ObjectUtilities.deepClone(entry.getValue()));\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) ObjectUtilities.deepClone(map);\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) ObjectUtilities.deepClone(map);\n    Iterator iterator = clone.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        entry.setValue((Object) ObjectUtilities.deepClone(entry.getValue()));\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) ObjectUtilities.deepClone(map);\n    Iterator iterator = clone.entrySet().iterator();\n    while (iterator.hasNext()) \n    {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Marker marker = (Marker) entry.getValue();\n        if (marker instanceof PublicCloneable) \n        {\n            PublicCloneable pc = (PublicCloneable) marker;\n            Marker cloneMarker = (Marker) pc.clone();\n            entry.setValue(cloneMarker);\n        }\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map result = new HashMap();\n    for (Iterator iterator = map.entrySet().iterator(); iterator.hasNext();) \n    {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Object key = entry.getKey();\n        Object value = entry.getValue();\n        if (value instanceof PublicCloneable) \n        {\n            PublicCloneable pc = (PublicCloneable) value;\n            Object clone = pc.clone();\n            result.put(key, clone);\n        } \n        else \n        {\n            result.put(key, value);\n        }\n    }\n    return result;\n}"
    ],
    [
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getCentralDirectoryData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getCentralDirectoryData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getCentralDirectoryData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getCentralDirectoryData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n        final boolean lastIsUnparseableHolder = data.length > 0\n            && data[data.length - 1] instanceof UnparseableExtraFieldData;\n        final int regularExtraFieldCount =\n            lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n        int sum = WORD * regularExtraFieldCount;\n        for (final ZipExtraField element : data) {\n            sum += element.getCentralDirectoryLength().getValue();\n        }\n\n        final byte[] result = new byte[sum];\n        int start = 0;\n        for (int i = 0; i < regularExtraFieldCount; i++) {\n            System.arraycopy(data[i].getHeaderId().getBytes(),\n                             0, result, start, 2);\n            System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                             0, result, start + 2, 2);\n            start += WORD;\n            final byte[] local = data[i].getCentralDirectoryData();\n            if (local != null) {\n                System.arraycopy(local, 0, result, start, local.length);\n                start += local.length;\n            }\n        }\n        if (lastIsUnparseableHolder) {\n            final byte[] local = data[data.length - 1].getCentralDirectoryData();\n            if (local != null) {\n                System.arraycopy(local, 0, result, start, local.length);\n            }\n        }\n        return result;\n    }",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n        final boolean lastIsUnparseableHolder = data.length > 0\n            && data[data.length - 1] instanceof UnparseableExtraFieldData;\n        final int regularExtraFieldCount =\n            lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n        int sum = WORD * regularExtraFieldCount;\n        for (final ZipExtraField element : data) {\n            sum += element.getCentralDirectoryLength().getValue();\n        }\n\n        final byte[] result = new byte[sum];\n        int start = 0;\n        for (int i = 0; i < regularExtraFieldCount; i++) {\n            System.arraycopy(data[i].getHeaderId().getBytes(),\n                             0, result, start, 2);\n            System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                             0, result, start + 2, 2);\n            start += WORD;\n            final byte[] local = data[i].getCentralDirectoryData();\n            if (local != null) {\n                System.arraycopy(local, 0, result, start, local.length);\n                start += local.length;\n            }\n        }\n        if (lastIsUnparseableHolder) {\n            final byte[] local = data[data.length - 1].getCentralDirectoryData();\n            if (local != null) {\n                System.arraycopy(local, 0, result, start, local.length);\n            }\n        }\n        return result;\n    }",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getCentralDirectoryData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getCentralDirectoryData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getCentralDirectoryData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getCentralDirectoryData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n        final boolean lastIsUnparseableHolder = data.length > 0\n            && data[data.length - 1] instanceof UnparseableExtraFieldData;\n        final int regularExtraFieldCount =\n            lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n        int sum = WORD * regularExtraFieldCount;\n        for (final ZipExtraField element : data) {\n            sum += element.getCentralDirectoryLength().getValue();\n        }\n\n        final byte[] result = new byte[sum];\n        int start = 0;\n        for (int i = 0; i < regularExtraFieldCount; i++) {\n            System.arraycopy(data[i].getHeaderId().getBytes(),\n                             0, result, start, 2);\n            System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                             0, result, start + 2, 2);\n            start += WORD;\n            final byte[] local = data[i].getCentralDirectoryData();\n            if (local != null) {\n                System.arraycopy(local, 0, result, start, local.length);\n                start += local.length;\n            }\n        }\n        if (lastIsUnparseableHolder) {\n            final byte[] local = data[data.length - 1].getCentralDirectoryData();\n            if (local != null) {\n                System.arraycopy(local, 0, result, start, local.length);\n            }\n        }\n        return result;\n    }"
    ],
    [
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds elements if they are not contained already\n        for (final E element : coll) {\n            add(index++, element);\n        }\n\n        // compares sizes to detect if collection changed\n        return sizeBefore != size();\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds elements if unique\n        for (final E object : coll) {\n            add(index, object);\n            index++;\n        }\n\n        // compares sizes to detect if collection changed\n        return sizeBefore != size();\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds elements if they are not contained already\n        for (E object : coll) \n        {\n            add(index, object);\n        }\n\n        // compares sizes to detect if collection changed\n        return sizeBefore != size();\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds elements if they are not contained already\n        for (final E element : coll) {\n            if (set.contains(element) == false) {\n                super.add(index++, element);\n                set.add(element);\n            }\n        }\n\n        // compares sizes to detect if collection changed\n        return sizeBefore != size();\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds elements if they are not already contained\n        for (final E element : coll) {\n            if (set.contains(element) == false) {\n                super.add(index, element);\n                set.add(element);\n                index++;\n            }\n        }\n\n        // compares sizes to detect if collection changed\n        return sizeBefore != size();\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds elements if they are not contained already\n        for (final E object : coll) {\n            add(index++, object);\n        }\n\n        // compares sizes to detect if collection changed\n        return sizeBefore != size();\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds elements if they are not contained already\n        for (final E element : coll) {\n            if (set.contains(element) == false) {\n                super.add(index++, element);\n                set.add(element);\n            }\n        }\n\n        // compares sizes to detect if collection changed\n        return sizeBefore != size();\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds elements if they are not already contained\n        for (final E object : coll) {\n            add(index++, object);\n        }\n\n        // compares sizes to detect if collection changed\n        return sizeBefore != size();\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds elements if they are not contained already\n        for (final E element : coll) {\n            add(index++, element);\n        }\n\n        // compares sizes to detect if collection changed\n        return sizeBefore != size();\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds elements if unique\n        for (final E object : coll) {\n            add(index, object);\n            index++;\n        }\n\n        // compares sizes to detect if collection changed\n        return sizeBefore != size();\n    }"
    ],
    [
      "private double eval(UnivariateFunction f, double x)  {\n        if (evaluations.incrementCount() > getMaxEvaluations()) {\n            throw new TooManyEvaluationsException(getMaxEvaluations());\n        }\n        return f.value(x);\n    }",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n        evaluations.incrementCount();\n        return f.value(x);\n    }",
      "private double eval(UnivariateFunction f, double x)  {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n        evaluations.incrementCount();\n        return f.value(x);\n    }",
      "private double eval(UnivariateFunction f, double x)  {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    evaluations.incrementCount();\n    return f.value(x);\n}"
    ],
    [
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n\n    // create a new list to store the normalized constraints\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n\n    // loop through the original constraints\n    for (LinearConstraint originalConstraint : originalConstraints) {\n\n        // get the right hand side of the constraint\n        double rightHandSide = originalConstraint.getValue();\n\n        // if the right hand side is positive, just add the constraint to the list\n        if (rightHandSide > 0) {\n            normalizedConstraints.add(originalConstraint);\n        }\n\n        // if the right hand side is negative, create a new constraint with a positive right hand side\n        else if (rightHandSide < 0) {\n            normalizedConstraints.add(new LinearConstraint(originalConstraint.getCoefficients(),\n                    originalConstraint.getRelationship(), -rightHandSide));\n        }\n    }\n\n    // return the list of normalized constraints\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getValue() < 0) {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(),\n                    constraint.getRelationship().reverse(), -constraint.getValue()));\n        } else {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        if (constraint.getValue() < 0) \n        {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1),\n                    constraint.getRelationship().invert(), -constraint.getValue()));\n        } \n        else \n        {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getValue() < 0) {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(),\n                    constraint.getRelationship().reverse(), -constraint.getValue()));\n        } else {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        if (constraint.getValue() < 0) \n        {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1),\n                    Relationship.GEQ, -constraint.getValue()));\n        } \n        else \n        {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        if (constraint.getValue() < 0) \n        {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1),\n                    constraint.getRelationship().opposite(), -1 * constraint.getValue()));\n        } \n        else \n        {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getValue() < 0) {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(),\n                    Relationship.GEQ, -constraint.getValue()));\n        } else {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(),\n                    Relationship.LEQ, constraint.getValue()));\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        if (constraint.getValue() < 0) \n        {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), Relationship.GEQ, -1 * constraint.getValue()));\n        } \n        else \n        {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getValue() < 0) {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(),\n                    Relationship.GEQ, -constraint.getValue()));\n        } else {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getValue() < 0) {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(),\n                    Relationship.GEQ, -constraint.getValue()));\n        } else {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}"
    ],
    [
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (this.lowerBound <= bin.getLowerBound() && this.upperBound >= bin.getUpperBound()) {\n        return true;\n    }\n    if (this.lowerBound >= bin.getLowerBound() && this.lowerBound <= bin.getUpperBound()) {\n        return true;\n    }\n    if (this.upperBound >= bin.getLowerBound() && this.upperBound <= bin.getUpperBound()) {\n        return true;\n    }\n    return false;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    return (this.lowerBound <= bin.upperBound && this.upperBound >= bin.lowerBound);\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    return this.lowerBound <= bin.getUpperBound() && this.upperBound >= bin.getLowerBound();\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (this.lowerBound <= bin.lowerBound) {\n        if (this.upperBound >= bin.upperBound) {\n            return true;\n        }\n    }\n    return false;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if(this.lowerBound > bin.getUpperBound() || this.upperBound < bin.getLowerBound())\n    {\n        return false;\n    }\n    else\n    {\n        return true;\n    }\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    return (this.getLowerBound() <= bin.getUpperBound() && this.getUpperBound() >= bin.getLowerBound());\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (this.lowerBound < bin.getUpperBound()) \n    {\n        return true;\n    }\n    return false;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (this.lowerBound <= bin.getLowerBound() && this.upperBound >= bin.getUpperBound()) \n    {\n        return true;\n    } \n    else if (this.lowerBound >= bin.getLowerBound() && this.upperBound <= bin.getUpperBound()) \n    {\n        return true;\n    } \n    else if (this.lowerBound <= bin.getLowerBound() && this.upperBound >= bin.getLowerBound()) \n    {\n        return true;\n    } \n    else if (this.lowerBound <= bin.getUpperBound() && this.upperBound >= bin.getUpperBound()) \n    {\n        return true;\n    } \n    else \n    {\n        return false;\n    }\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin.getLowerBound() > this.getUpperBound())\n        return false;\n    if (bin.getUpperBound() < this.getLowerBound())\n        return false;\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (this.lowerBound < bin.lowerBound) \n    {\n        if (this.upperBound < bin.lowerBound) \n        {\n            return false;\n        }\n    }\n    else \n    {\n        if (this.lowerBound > bin.upperBound) \n        {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.length() == 0) {\n        return new String[0];\n    }\n    char[] chars = str.toCharArray();\n    List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(chars[tokenStart]);\n    for (int pos = tokenStart + 1; pos < chars.length; pos++) {\n        int type = Character.getType(chars[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(chars, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(chars, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(chars, tokenStart, chars.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return new String[0];\n    }\n    char[] c = str.toCharArray();\n    List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(c[tokenStart]);\n    for (int pos = tokenStart + 1; pos < c.length; pos++) {\n        int type = Character.getType(c[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(c, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(c, tokenStart, c.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return new String[0];\n    }\n    char[] c = str.toCharArray();\n    List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(c[tokenStart]);\n    for (int pos = tokenStart + 1; pos < c.length; pos++) {\n        int type = Character.getType(c[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(c, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(c, tokenStart, c.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n        if (str == null) {\n            return null;\n        }\n        if (str.isEmpty()) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        final char[] c = str.toCharArray();\n        final List<String> list = new ArrayList<>();\n        int tokenStart = 0;\n        int currentType = Character.getType(c[tokenStart]);\n        for (int pos = tokenStart + 1; pos < c.length; pos++) {\n            final int type = Character.getType(c[pos]);\n            if (type == currentType) {\n                continue;\n            }\n            if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n                final int newTokenStart = pos - 1;\n                if (newTokenStart != tokenStart) {\n                    list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                    tokenStart = newTokenStart;\n                }\n            } else {\n                list.add(new String(c, tokenStart, pos - tokenStart));\n                tokenStart = pos;\n            }\n            currentType = type;\n        }\n        list.add(new String(c, tokenStart, c.length - tokenStart));\n        return list.toArray(new String[list.size()]);\n    }",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n        if (str == null) {\n            return null;\n        }\n        if (str.length() == 0) {\n            return new String[0];\n        }\n        char[] chars = str.toCharArray();\n        List<String> list = new ArrayList<String>();\n        int tokenStart = 0;\n        int currentType = Character.getType(chars[tokenStart]);\n        for (int pos = tokenStart + 1; pos < chars.length; pos++) {\n            int type = Character.getType(chars[pos]);\n            if (type == currentType) {\n                continue;\n            }\n            if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n                int newTokenStart = pos - 1;\n                if (newTokenStart != tokenStart) {\n                    list.add(new String(chars, tokenStart, newTokenStart - tokenStart));\n                    tokenStart = newTokenStart;\n                }\n            } else {\n                list.add(new String(chars, tokenStart, pos - tokenStart));\n                tokenStart = pos;\n            }\n            currentType = type;\n        }\n        list.add(new String(chars, tokenStart, chars.length - tokenStart));\n        return list.toArray(new String[list.size()]);\n    }",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n        if (str == null) {\n            return null;\n        }\n        if (str.length() == 0) {\n            return new String[0];\n        }\n        char[] chars = str.toCharArray();\n        List<String> list = new ArrayList<String>();\n        int tokenStart = 0;\n        int currentType = Character.getType(chars[tokenStart]);\n        for (int pos = tokenStart + 1; pos < chars.length; pos++) {\n            int type = Character.getType(chars[pos]);\n            if (type == currentType) {\n                continue;\n            }\n            if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n                int newTokenStart = pos - 1;\n                if (newTokenStart != tokenStart) {\n                    list.add(new String(chars, tokenStart, newTokenStart - tokenStart));\n                    tokenStart = newTokenStart;\n                }\n            } else {\n                list.add(new String(chars, tokenStart, pos - tokenStart));\n                tokenStart = pos;\n            }\n            currentType = type;\n        }\n        list.add(new String(chars, tokenStart, chars.length - tokenStart));\n        return list.toArray(new String[list.size()]);\n    }",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n        if (str == null) {\n            return null;\n        }\n        if (str.isEmpty()) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        final char[] c = str.toCharArray();\n        final List<String> list = new ArrayList<>();\n        int tokenStart = 0;\n        int currentType = Character.getType(c[tokenStart]);\n        for (int pos = tokenStart + 1; pos < c.length; pos++) {\n            final int type = Character.getType(c[pos]);\n            if (type == currentType) {\n                continue;\n            }\n            if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n                final int newTokenStart = pos - 1;\n                if (newTokenStart != tokenStart) {\n                    list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                    tokenStart = newTokenStart;\n                }\n            } else {\n                list.add(new String(c, tokenStart, pos - tokenStart));\n                tokenStart = pos;\n            }\n            currentType = type;\n        }\n        list.add(new String(c, tokenStart, c.length - tokenStart));\n        return list.toArray(new String[list.size()]);\n    }",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (str.length() == 0) \n    {\n        return new String[0];\n    }\n    char[] chars = str.toCharArray();\n    List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(chars[tokenStart]);\n    for (int pos = tokenStart + 1; pos < chars.length; pos++) \n    {\n        int type = Character.getType(chars[pos]);\n        if (type == currentType) \n        {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) \n        {\n            int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) \n            {\n                list.add(new String(chars, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } \n        else \n        {\n            list.add(new String(chars, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(chars, tokenStart, chars.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.length() == 0) {\n        return new String[0];\n    }\n    char[] chars = str.toCharArray();\n    List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(chars[tokenStart]);\n    for (int pos = tokenStart + 1; pos < chars.length; pos++) {\n        int type = Character.getType(chars[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(chars, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(chars, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(chars, tokenStart, chars.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n        if (str == null) {\n            return null;\n        }\n        if (str.isEmpty()) {\n            return new String[0];\n        }\n        final char[] c = str.toCharArray();\n        final List<String> list = new ArrayList<String>();\n        int tokenStart = 0;\n        int currentType = Character.getType(c[tokenStart]);\n        for (int pos = tokenStart + 1; pos < c.length; pos++) {\n            final int type = Character.getType(c[pos]);\n            if (type == currentType) {\n                continue;\n            }\n            if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n                final int newTokenStart = pos - 1;\n                if (newTokenStart != tokenStart) {\n                    list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                    tokenStart = newTokenStart;\n                }\n            } else {\n                list.add(new String(c, tokenStart, pos - tokenStart));\n                tokenStart = pos;\n            }\n            currentType = type;\n        }\n        list.add(new String(c, tokenStart, c.length - tokenStart));\n        return list.toArray(new String[list.size()]);\n    }"
    ],
    [
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    if (parser == null) {\n        throw new UnsupportedOperationException(\"Parsing not supported\");\n    }\n    if (text == null) {\n        throw new IllegalArgumentException(\"Text must not be null\");\n    }\n    long instant = 0;\n    Chronology chrono = null;\n    int defaultYear = iDefaultYear;\n    int pivot = iPivotYear;\n    DateTimeZone zone = iZone;\n    int offset = 0;\n    if (iLocale != null) {\n        chrono = selectChronology(null);\n        if (chrono != null) {\n            defaultYear = chrono.year().get(instant);\n            pivot = defaultYear;\n        }\n    }\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        instant, chrono, iLocale, pivot, defaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        instant = bucket.computeMillis(false, text);\n        if (bucket.getZone() != null) {\n            zone = bucket.getZone();\n        }\n        if (bucket.getOffsetInteger() != null) {\n            offset = bucket.getOffsetInteger();\n        }\n    } else {\n        throw new IllegalArgumentException(\"Invalid format: \\\"\" + text + \"\\\"\");\n    }\n    return instant + (zone == null ? 0 : zone.getOffset(instant)) + offset;\n}",
      "public long parseMillis(String text)  {\n    // Complete this method\n    // You may need to make use of the provided context\n    // You may need to use the DateTimeFormatter class\n    // You may need to use the DateTimeUtils class\n    // You may need to use the DateTimeZone class\n    // You may need to use the Chronology class\n    // You may need to use the Locale class\n    // You may need to use the DateTimeFieldType class\n    // You may need to use the DateTimeField class\n    // You may need to use the ReadablePartial class\n    // You may need to use the ReadableInstant class\n    // You may need to use the ReadableInterval class\n    // You may need to use the ReadablePeriod class\n    // You may need to use the Period class\n    // You may need to use the Interval class\n    // You may need to use the DateTimeUtils class\n    // You may need to use the DurationFieldType class\n    // You may need to use the DurationField class\n    // You may need to use the Duration class\n    // You may need to use the TimeOfDay class\n    // You may need to use the YearMonth class\n    // You may need to use the YearMonthDay class\n    // You may need to use the TimeOfDay class\n    // You may need to use the TimeOfDay class\n    // You may need to use the TimeOfDay class\n    // You may need to use the TimeOfDay class\n    // You may need to use the TimeOfDay class\n    // You may need to use the TimeOfDay class\n    // You may need to use the TimeOfDay class\n    // You may need to use the TimeOfDay class\n    // You may need to use the TimeOfDay class\n    // You may need to use the TimeOfDay class\n    // You may need to use the TimeOfDay class\n    // You may need to use the TimeOfDay class\n    // You may need to use the TimeOfDay class\n    // You may need to use the TimeOfDay class\n    // You may need to use the TimeOfDay class\n    // You may need to use the TimeOfDay class\n    // You may need to use the TimeOfDay class\n    // You may need to use the TimeOfDay class\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = ISOChronology.getInstance();\n    int defaultYear = 1970;\n    long instantLocal = 0;\n    chrono = selectChronology(chrono);\n    \n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        throw new IllegalArgumentException(\"Invalid format: \" + text);\n    }\n    return bucket.computeMillis(false, text);\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    if (parser == null) {\n        throw new UnsupportedOperationException(\"Parsing not supported\");\n    }\n    Chronology chrono = getChronology();\n    int defaultYear = DateTimeUtils.getChronology(chrono).year().get(System.currentTimeMillis());\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        0L, chrono, iLocale, iPivotYear, defaultYear);\n    int position = parser.parseInto(bucket, text, 0);\n    if (position >= 0) {\n        return bucket.computeMillis(false, text);\n    } else {\n        throw new IllegalArgumentException(\"Invalid format: \" + text);\n    }\n}",
      "public long parseMillis(String text)  {\n    return parseInto(new MutableDateTime(), text, 0);\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    int defaultYear = DateTimeUtils.getCurrentYear();\n    long instantLocal = 0;\n    int offset = 0;\n    DateTimeZone zone = null;\n    int newPos = parser.parseInto(new DateTimeParserBucket(\n        instantLocal, chrono, iLocale, iPivotYear, defaultYear), text, 0);\n    if (newPos >= 0) {\n        instantLocal = parser.getMillis(parser.getParsedFields(), chrono);\n        if (iOffsetParsed && parser.getOffsetInteger() != null) {\n            offset = parser.getOffsetInteger();\n        } else if (parser.getZone() != null) {\n            zone = parser.getZone();\n        }\n    }\n    if (iZone != null) {\n        zone = iZone;\n    }\n    return chrono.getZone().convertUTCToLocal(instantLocal + offset) + (zone == null ? 0 : zone.getOffset(instantLocal + offset));\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    if (text == null) {\n        throw new IllegalArgumentException(\"Text must not be null\");\n    }\n    \n    Chronology chrono = selectChronology(null);\n    int defaultYear = DateTimeUtils.getCurrentYear(chrono);\n    long instantLocal = 0;\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        return bucket.computeMillis(false, text);\n    } else {\n        throw new IllegalArgumentException(\"Invalid format: \\\"\" + text + \"\\\"\");\n    }\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    if (parser == null) {\n        throw new UnsupportedOperationException(\"Parsing not supported\");\n    }\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        iDefaultYear, iChronology, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        throw new IllegalArgumentException(\"Invalid format: \\\"\" + text + \"\\\"\");\n    }\n    return bucket.computeMillis(false, text);\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    int defaultYear = iChronology.year().get(iInstant);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        iInstant, chrono, iLocale, iPivotYear, defaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        return bucket.computeMillis(false, text);\n    } else {\n        throw new IllegalArgumentException(\"Invalid format: \\\"\" + text + \"\\\"\");\n    }\n}",
      "public long parseMillis(String text)  {\n    // TODO: Implement this method\n}"
    ],
    [
      "static MinimizedCondition unoptimized(Node n)  {\n    Node placeholder = swapWithPlaceholderNode(n);\n    MeasuredNode positive = MeasuredNode.fromNode(n);\n    MeasuredNode negative = MeasuredNode.fromNode(new Node(Token.SCRIPT, n.getSourceFileName()));\n    return new MinimizedCondition(positive, negative).setPlaceholder(placeholder);\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n  return new MinimizedCondition(\n    MeasuredNode.fromNode(n),\n    MeasuredNode.fromNode(new Node(Token.SCRIPT, n.getSourceFileName()))\n      .changeLength(1000));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Node placeholder = swapWithPlaceholderNode(n);\n  return new MinimizedCondition(MeasuredNode.fromNode(n),\n      MeasuredNode.fromNode(new Node(Token.SCRIPT, n.getSourceFileName()))\n          .change());\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Node placeholder = swapWithPlaceholderNode(n);\n    MeasuredNode positive = MeasuredNode.fromNode(n);\n    MeasuredNode negative = MeasuredNode.fromNode(\n        new Node(Token.SCRIPT, n.getSourceFileName())).change();\n    return new MinimizedCondition(positive, negative).setPlaceholder(placeholder);\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n  MeasuredNode positive = new MeasuredNode(n);\n  Node placeholder = swapWithPlaceholderNode(n);\n  return new MinimizedCondition(positive, new MeasuredNode(placeholder))\n      .setPlaceholder(placeholder);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  MeasuredNode positive = MeasuredNode.fromNode(n);\n  Node placeholder = swapWithPlaceholderNode(n);\n  return new MinimizedCondition(positive,\n      MeasuredNode.fromNode(new Node(Token.SCRIPT).setLength(1000))).setPlaceholder(placeholder);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  MeasuredNode positive = MeasuredNode.fromNode(n);\n  Node placeholder = swapWithPlaceholderNode(n);\n  return new MinimizedCondition(positive, MeasuredNode.fromNode(placeholder))\n      .setPlaceholder(placeholder);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  MeasuredNode positive = new MeasuredNode(n);\n  Node placeholder = swapWithPlaceholderNode(n);\n  return new MinimizedCondition(positive, new MeasuredNode(placeholder))\n      .setPlaceholder(placeholder);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Node placeholder = swapWithPlaceholderNode(n);\n  return new MinimizedCondition(\n      new MeasuredNode(n, MeasuredNode.length(n)),\n      new MeasuredNode(\n          Node.newScript(Token.SCRIPT).srcref(n),\n          Integer.MAX_VALUE)).setPlaceholder(placeholder);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Node placeholder = swapWithPlaceholderNode(n);\n    MeasuredNode positive = MeasuredNode.fromNode(n);\n    MeasuredNode negative = MeasuredNode.fromNode(\n        new Node(Token.SCRIPT, n.getSourceFileName()));\n    return new MinimizedCondition(positive, negative).setPlaceholder(placeholder);\n  }"
    ],
    [
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    final int size = values.size();\n    final long[] result = new long[size / 64 + (size % 64 == 0 ? 0 : 1)];\n    int i = 0;\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        result[i / 64] |= 1L << constant.ordinal();\n        i++;\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    final int numLongs = (enumClass.getEnumConstants().length + 63) / 64;\n    final long[] bitVectors = new long[numLongs];\n    int i = 0;\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        bitVectors[i] |= 1L << constant.ordinal();\n        i++;\n    }\n    return bitVectors;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    final int size = values.spliterator().getExactSizeIfKnown();\n    final long[] result = new long[size == -1 ? 1 : size];\n    int index = 0;\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        result[index++] = 1L << constant.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    final int enumSize = enumClass.getEnumConstants().length;\n    final int longSize = 64;\n    final int longCount = enumSize / longSize;\n    final int remainder = enumSize % longSize;\n    final long[] bitVectors = new long[longCount + (remainder > 0 ? 1 : 0)];\n    int i = 0;\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        final int index = constant.ordinal() / longSize;\n        final int offset = constant.ordinal() % longSize;\n        bitVectors[index] |= 1L << offset;\n        i++;\n    }\n    return bitVectors;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    final int length = (enumClass.getEnumConstants().length - 1) / 64 + 1;\n    final long[] result = new long[length];\n    int index = 0;\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        result[index] |= 1L << constant.ordinal();\n        if (constant.ordinal() % 64 == 63) {\n            index++;\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    final int numLongs = (enumClass.getEnumConstants().length + Long.SIZE - 1) / Long.SIZE;\n    final long[] bitVectors = new long[numLongs];\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        final int index = constant.ordinal() / Long.SIZE;\n        final int bit = constant.ordinal() % Long.SIZE;\n        bitVectors[index] |= 1L << bit;\n    }\n    return bitVectors;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    final long[] result = new long[Long.SIZE / Integer.SIZE];\n    int i = 0;\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        result[i] |= 1 << constant.ordinal();\n        i++;\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    final long[] result = new long[Long.SIZE / Integer.SIZE];\n    int i = 0;\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        result[i++] |= 1 << constant.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    final int size = values.spliterator().getExactSizeIfKnown();\n    final long[] vector = new long[size == -1 ? 1 : size];\n    int index = 0;\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        vector[index++] = 1 << constant.ordinal();\n    }\n    return vector;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    final long[] bitVectors = new long[values.spliterator().getExactSizeIfKnown()];\n    int i = 0;\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        bitVectors[i++] = 1 << constant.ordinal();\n    }\n    return bitVectors;\n}"
    ],
    [
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.add(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) {\n      return scope.getDepth();\n    } else if (scope.isPropertyScope()) {\n      SymbolScope parentScope = scope.getParentScope();\n      return getLexicalScopeDepth(parentScope) + 1;\n    } else {\n      return 0;\n    }\n  }",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getDepth();\n  } else if (scope.isPropertyScope()) {\n    return getLexicalScopeDepth(scope.getParentScope()) + 1;\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getDepth();\n  } else if (scope.isPropertyScope()) {\n    SymbolScope lexicalScope = scope.getLexicalScope();\n    return getLexicalScopeDepth(lexicalScope) + lexicalScope.getDepth();\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getDepth();\n  } else if (scope.isPropertyScope()) {\n    return getLexicalScopeDepth(scope.getParentScope()) + 1;\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getDepth();\n  } else if (scope.isPropertyScope()) {\n    SymbolScope parent = scope.getParentScope();\n    while (!parent.isLexicalScope()) {\n      parent = parent.getParentScope();\n    }\n    return parent.getDepth() + 1;\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) {\n      return scope.getDepth();\n    } else if (scope.isPropertyScope()) {\n      SymbolScope parent = scope.getParentScope();\n      return getLexicalScopeDepth(parent) + parent.getDepth();\n    } else {\n      return 0;\n    }\n  }",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getDepth();\n  } else if (scope.isPropertyScope()) {\n    SymbolScope parent = scope.getParentScope();\n    while (!parent.isLexicalScope()) {\n      parent = parent.getParentScope();\n    }\n    return parent.getDepth() + 1;\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getDepth();\n  } else if (scope.isPropertyScope()) {\n    return getLexicalScopeDepth(scope.getParentScope()) + 1;\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getDepth();\n  } else if (scope.isPropertyScope()) {\n    return getLexicalScopeDepth(scope.getParentScope()) + 1;\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    int depth = 0;\n    while (!scope.isLexicalScope()) {\n      scope = scope.getParentScope();\n      depth++;\n    }\n    return depth + scope.getDepth();\n  }"
    ],
    [
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            blocks[index] = new double[iHeight * blockWidth(jBlock)];\n            for (int i = 0; i < iHeight; ++i) {\n                System.arraycopy(rawData[iBlock * BLOCK_SIZE + i],\n                                 jBlock * BLOCK_SIZE,\n                                 blocks[index], i * blockWidth(jBlock),\n                                 blockWidth(jBlock));\n            }\n        }\n    }\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    // number of blocks\n    final int blockRows = (rawData.length + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (rawData[0].length + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    final double[][] blocks = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            blocks[index] = new double[iHeight * blockWidth(jBlock)];\n            for (int i = 0; i < iHeight; ++i) {\n                System.arraycopy(rawData[iBlock * BLOCK_SIZE + i],\n                                 jBlock * BLOCK_SIZE,\n                                 blocks[index],\n                                 i * blockWidth(jBlock),\n                                 blockWidth(jBlock));\n            }\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    // number of rows and columns in the matrix\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n\n    // number of blocks\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    final double[][] blocks = createBlocksLayout(rows, columns);\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            // copy the data from raw layout to blocks layout\n            System.arraycopy(rawData[iBlock * BLOCK_SIZE], jBlock * BLOCK_SIZE,\n                             blocks[index], 0, iHeight * blockWidth(jBlock));\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n\n    // number of blocks\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    final double[][] blocks = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            blocks[index] = new double[iHeight * blockWidth(jBlock)];\n            int k = 0;\n            for (int i = iBlock * BLOCK_SIZE; i < iBlock * BLOCK_SIZE + iHeight; ++i) {\n                for (int j = jBlock * BLOCK_SIZE; j < jBlock * BLOCK_SIZE + blockWidth(jBlock); ++j) {\n                    if (i < rows && j < columns) {\n                        blocks[index][k++] = rawData[i][j];\n                    }\n                }\n            }\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    // number of blocks\n    final int blockRows = (rawData.length + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (rawData[0].length + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    final double[][] blocks = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            blocks[index] = new double[iHeight * blockWidth(jBlock)];\n            int k = 0;\n            for (int i = iBlock * BLOCK_SIZE; i < iBlock * BLOCK_SIZE + iHeight; ++i) {\n                for (int j = jBlock * BLOCK_SIZE; j < jBlock * BLOCK_SIZE + blockWidth(jBlock); ++j) {\n                    blocks[index][k++] = rawData[i][j];\n                }\n            }\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    // number of rows and columns\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n\n    // number of blocks\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    final double[][] blocks = createBlocksLayout(rows, columns);\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            final int jWidth = blockWidth(jBlock);\n            for (int i = 0; i < iHeight; ++i) {\n                System.arraycopy(rawData[iBlock * BLOCK_SIZE + i],\n                                 jBlock * BLOCK_SIZE,\n                                 blocks[index],\n                                 i * jWidth,\n                                 jWidth);\n            }\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    // check dimensions\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    for (int i = 1; i < rawData.length; ++i) {\n        if (rawData[i].length != columns) {\n            throw new DimensionMismatchException(rawData[i].length, columns);\n        }\n    }\n\n    // number of blocks\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    final double[][] blocks = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            blocks[index] = new double[iHeight * blockWidth(jBlock)];\n            int k = 0;\n            for (int i = iBlock * BLOCK_SIZE; i < iBlock * BLOCK_SIZE + iHeight; ++i) {\n                for (int j = jBlock * BLOCK_SIZE; j < jBlock * BLOCK_SIZE + blockWidth(jBlock); ++j) {\n                    blocks[index][k++] = rawData[i][j];\n                }\n            }\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    // number of rows and columns\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n\n    // number of blocks\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    final double[][] blocks = createBlocksLayout(rows, columns);\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            if (rawData[iBlock * BLOCK_SIZE][jBlock * BLOCK_SIZE].length != iHeight * blockWidth(jBlock)) {\n                throw new DimensionMismatchException(rawData[iBlock * BLOCK_SIZE][jBlock * BLOCK_SIZE].length,\n                                                     iHeight * blockWidth(jBlock));\n            }\n            blocks[index] = rawData[iBlock * BLOCK_SIZE][jBlock * BLOCK_SIZE].clone();\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n\n    // number of blocks\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    final double[][] blocks = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            blocks[index] = new double[iHeight * blockWidth(jBlock)];\n            int k = 0;\n            for (int i = iBlock * BLOCK_SIZE; i < iBlock * BLOCK_SIZE + iHeight; ++i) {\n                for (int j = jBlock * BLOCK_SIZE; j < jBlock * BLOCK_SIZE + blockWidth(jBlock); ++j) {\n                    if (i < rows && j < columns) {\n                        blocks[index][k] = rawData[i][j];\n                    } else {\n                        blocks[index][k] = 0;\n                    }\n                    ++k;\n                }\n            }\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    // number of rows and columns in rawData\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n\n    // number of blocks\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    final double[][] blocks = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            blocks[index] = new double[iHeight * blockWidth(jBlock)];\n            for (int i = 0; i < iHeight; ++i) {\n                final int iRow = iBlock * BLOCK_SIZE + i;\n                if (iRow < rows) {\n                    final double[] rawRow = rawData[iRow];\n                    final int jWidth = blockWidth(jBlock);\n                    for (int j = 0; j < jWidth; ++j) {\n                        final int jCol = jBlock * BLOCK_SIZE + j;\n                        if (jCol < columns) {\n                            blocks[index][i * jWidth + j] = rawRow[jCol];\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return blocks;\n}"
    ],
    [
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n        if (enumClass == null) {\n            throw new NullPointerException(\"The class must not be null\");\n        }\n        if (values == null) {\n            throw new NullPointerException(\"The values must not be null\");\n        }\n        if (!enumClass.isEnum()) {\n            throw new IllegalArgumentException(\"Enumeration '\" + enumClass.getName() + \"' is not an enum\");\n        }\n        final E[] enumConstants = enumClass.getEnumConstants();\n        if (enumConstants.length > 64) {\n            throw new IllegalArgumentException(\"Enumeration '\" + enumClass.getName() + \"' has more than 64 values\");\n        }\n        long bitVector = 0;\n        for (final E value : values) {\n            if (value == null) {\n                throw new IllegalArgumentException(\"The values must not contain null\");\n            }\n            final long bit = 1L << value.ordinal();\n            if ((bitVector & bit) != 0) {\n                throw new IllegalArgumentException(\"The value '\" + value + \"' appears more than once in the values\");\n            }\n            bitVector |= bit;\n        }\n        return bitVector;\n    }",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n        if (enumClass == null) {\n            throw new NullPointerException(\"The class must not be null\");\n        }\n        if (!enumClass.isEnum()) {\n            throw new IllegalArgumentException(\"The class must be an Enum class\");\n        }\n        if (values == null) {\n            throw new NullPointerException(\"The values must not be null\");\n        }\n        long bitVector = 0;\n        int count = 0;\n        for (final E e : enumClass.getEnumConstants()) {\n            if (values.contains(e)) {\n                bitVector |= 1L << count;\n            }\n            count++;\n            if (count == 64) {\n                throw new IllegalArgumentException(\"Cannot have more than 64 values in an enum\");\n            }\n        }\n        return bitVector;\n    }",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n        // Validate\n        if (enumClass == null) {\n            throw new NullPointerException(\"The class must not be null\");\n        }\n        if (!enumClass.isEnum()) {\n            throw new IllegalArgumentException(\"The class must be an enum\");\n        }\n        if (values == null) {\n            throw new NullPointerException(\"The values must not be null\");\n        }\n        long bitVector = 0;\n        for (final E value : values) {\n            if (value == null) {\n                throw new IllegalArgumentException(\"The values must not contain null\");\n            }\n            bitVector |= 1L << value.ordinal();\n        }\n        return bitVector;\n    }",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null) {\n        throw new NullPointerException(\"The class must not be null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"The class must be an Enum class\");\n    }\n    if (values == null) {\n        throw new NullPointerException(\"The values must not be null\");\n    }\n    final E[] enumConstants = enumClass.getEnumConstants();\n    if (enumConstants.length > 64) {\n        throw new IllegalArgumentException(\"The Enum must have no more than 64 values\");\n    }\n    long bitVector = 0;\n    for (final E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"The values must not contain null\");\n        }\n        bitVector |= 1L << value.ordinal();\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null) {\n        throw new NullPointerException(\"The class must not be null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"Enumeration '\"+enumClass.getName()+\"' is not an enum\");\n    }\n    final E[] enumConstants = enumClass.getEnumConstants();\n    if (enumConstants.length > Long.SIZE) {\n        throw new IllegalArgumentException(\"Enumeration '\"+enumClass.getName()+\"' has more than 64 values\");\n    }\n    long bitVector = 0;\n    for (final E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"The values must not contain null\");\n        }\n        bitVector |= 1 << value.ordinal();\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    Objects.requireNonNull(enumClass, \"The enum class must not be null\");\n    Objects.requireNonNull(values, \"The iterable of enum values must not be null\");\n    validateEnumClass(enumClass);\n    long bitVector = 0;\n    for (final E value : values) {\n        validateEnumValue(enumClass, value);\n        bitVector |= 1 << value.ordinal();\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    // Check that the class is an enum\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"The class \" + enumClass.getName() + \" is not an enum\");\n    }\n\n    // Check that the enum has less than 64 values\n    if (enumClass.getEnumConstants().length > 64) {\n        throw new IllegalArgumentException(\"The enum \" + enumClass.getName() + \" has more than 64 values\");\n    }\n\n    // Check that the values are not null\n    for (final E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"The values cannot contain null\");\n        }\n    }\n\n    // Generate the bit vector\n    long bitVector = 0;\n    for (final E value : values) {\n        final int valueIndex = value.ordinal();\n        bitVector |= 1L << valueIndex;\n    }\n\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n        // Validate parameters\n        if (enumClass == null) {\n            throw new NullPointerException(\"The class must not be null\");\n        }\n        if (!enumClass.isEnum()) {\n            throw new IllegalArgumentException(\"The class must be an enum\");\n        }\n        if (values == null) {\n            throw new NullPointerException(\"The values must not be null\");\n        }\n        long bitVector = 0;\n        int count = 0;\n        for (final E e : values) {\n            if (e == null) {\n                throw new IllegalArgumentException(\"The values must not contain null\");\n            }\n            final long bit = 1L << e.ordinal();\n            if ((bitVector & bit) != 0) {\n                throw new IllegalArgumentException(\"The values must be unique\");\n            }\n            bitVector |= bit;\n            ++count;\n        }\n        if (count > Long.SIZE) {\n            throw new IllegalArgumentException(\"The values must not be greater than \" + Long.SIZE);\n        }\n        return bitVector;\n    }",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n        Objects.requireNonNull(enumClass, \"The class must not be null\");\n        Objects.requireNonNull(values, \"The values must not be null\");\n        final long[] bitVectors = generateBitVectors(enumClass, values);\n        return bitVectors[0];\n    }",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null) {\n        throw new NullPointerException(\"The class must not be null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"The class must be an enum\");\n    }\n    if (values == null) {\n        throw new NullPointerException(\"The values must not be null\");\n    }\n    long bitVector = 0;\n    int count = 0;\n    for (final E e : values) {\n        if (e == null) {\n            throw new IllegalArgumentException(\"The values must not contain null\");\n        }\n        final long bit = 1L << e.ordinal();\n        if ((bitVector & bit) != 0) {\n            throw new IllegalArgumentException(\"The values must be unique\");\n        }\n        bitVector |= bit;\n        ++count;\n    }\n    if (count > Long.SIZE) {\n        throw new IllegalArgumentException(\"The values must not be greater than \" + Long.SIZE);\n    }\n    return bitVector;\n}"
    ],
    [
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp one = a.getOne();\n    final Dfp two = a.newInstance(2);\n    final Dfp factorial = one;\n    final Dfp result = one;\n    final Dfp aSquared = a.multiply(a);\n    final Dfp aCubed = aSquared.multiply(a);\n    final Dfp aFourth = aCubed.multiply(a);\n    final Dfp aFifth = aFourth.multiply(a);\n    final Dfp aSixth = aFifth.multiply(a);\n    final Dfp aSeventh = aSixth.multiply(a);\n    final Dfp aEighth = aSeventh.multiply(a);\n    final Dfp aNinth = aEighth.multiply(a);\n    final Dfp aTenth = aNinth.multiply(a);\n    final Dfp aEleventh = aTenth.multiply(a);\n    final Dfp aTwelfth = aEleventh.multiply(a);\n    final Dfp aThirteenth = aTwelfth.multiply(a);\n    final Dfp aFourteenth = aThirteenth.multiply(a);\n    final Dfp aFifteenth = aFourteenth.multiply(a);\n    final Dfp aSixteenth = aFifteenth.multiply(a);\n    final Dfp aSeventeenth = aSixteenth.multiply(a);\n    final Dfp aEighteenth = aSeventeenth.multiply(a);\n    final Dfp aNineteenth = aEighteenth.multiply(a);\n    final Dfp aTwentieth = aNineteenth.multiply(a);\n    final Dfp aTwentyFirst = aTwentieth.multiply(a);\n    final Dfp aTwentySecond = aTwentyFirst.multiply(a);\n    final Dfp aTwentyThird = aTwentySecond.multiply(a);\n    final Dfp aTwentyFourth = aTwentyThird.multiply(a);\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = a.getOne();\n    Dfp term = a;\n    int i = 2;\n    while (term.abs().compareTo(result.getOne().divide(Dfp.getRadix())) > 0) \n    {\n        term = term.multiply(a);\n        result = result.add(term.divide(new Dfp(i)));\n        i++;\n    }\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    // Use the classic Taylor series.  1 + x**2/2! + x**3/3! + x**4/4!  ...\n    Dfp result = a.getOne();\n    Dfp term = a;\n    int i = 2;\n    do {\n        term = term.multiply(a);\n        result = result.add(term.divide(new Dfp(i)));\n        i++;\n    } while (term.getExponent() > -20);\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n\n        final Dfp x = a;\n        final Dfp x2 = x.multiply(x);\n        final Dfp x3 = x2.multiply(x);\n        final Dfp x4 = x3.multiply(x);\n        final Dfp x5 = x4.multiply(x);\n        final Dfp x6 = x5.multiply(x);\n        final Dfp x7 = x6.multiply(x);\n        final Dfp x8 = x7.multiply(x);\n        final Dfp x9 = x8.multiply(x);\n        final Dfp x10 = x9.multiply(x);\n        final Dfp x11 = x10.multiply(x);\n        final Dfp x12 = x11.multiply(x);\n        final Dfp x13 = x12.multiply(x);\n        final Dfp x14 = x13.multiply(x);\n        final Dfp x15 = x14.multiply(x);\n        final Dfp x16 = x15.multiply(x);\n        final Dfp x17 = x16.multiply(x);\n        final Dfp x18 = x17.multiply(x);\n        final Dfp x19 = x18.multiply(x);\n        final Dfp x20 = x19.multiply(x);\n        final Dfp x21 = x20.multiply(x);\n        final Dfp x22 = x21.multiply(x);\n        final Dfp x23 = x22.multiply(x);\n        final Dfp x24 = x23.multiply(x);\n        final Dfp x25 = x24.multiply(x);\n        final Dfp x26 = x25.multiply(x);\n        final Dfp x27 = x26.multiply(x);\n        final Dfp x28 = x27.multiply(x);\n        final Dfp x29 = x28.multiply(x);\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n\n        final Dfp x = a.abs();\n        final Dfp x2 = x.multiply(x);\n        final Dfp x3 = x2.multiply(x);\n        final Dfp x4 = x3.multiply(x);\n        final Dfp x5 = x4.multiply(x);\n        final Dfp x6 = x5.multiply(x);\n        final Dfp x7 = x6.multiply(x);\n        final Dfp x8 = x7.multiply(x);\n        final Dfp x9 = x8.multiply(x);\n        final Dfp x10 = x9.multiply(x);\n        final Dfp x11 = x10.multiply(x);\n        final Dfp x12 = x11.multiply(x);\n        final Dfp x13 = x12.multiply(x);\n        final Dfp x14 = x13.multiply(x);\n        final Dfp x15 = x14.multiply(x);\n        final Dfp x16 = x15.multiply(x);\n        final Dfp x17 = x16.multiply(x);\n        final Dfp x18 = x17.multiply(x);\n        final Dfp x19 = x18.multiply(x);\n        final Dfp x20 = x19.multiply(x);\n        final Dfp x21 = x20.multiply(x);\n        final Dfp x22 = x21.multiply(x);\n        final Dfp x23 = x22.multiply(x);\n        final Dfp x24 = x23.multiply(x);\n        final Dfp x25 = x24.multiply(x);\n        final Dfp x26 = x25.multiply(x);\n        final Dfp x27 = x26.multiply(x);\n        final Dfp x28 = x27.multiply(x);\n        final Dfp x29 = x28.multiply(x);\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n        Dfp result = a.getOne();\n        Dfp x = a;\n        int n = 2;\n        while (x.abs().compareTo(x.getOne()) > 0) {\n            x = x.multiply(a);\n            result = result.add(x.divide(new Dfp(n)));\n            n += 1;\n        }\n        return result;\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n\n        Dfp result = a.getOne();\n        Dfp term = a;\n        int n = 1;\n        do {\n            term = term.multiply(a);\n            result = result.add(term.divide(n));\n            n++;\n        } while (term.abs().compareTo(result.ulp()) > 0);\n\n        return result;\n\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n    // Compute e to the given power.\n    // a is broken into two parts, such that a = n+m  where n is an integer.\n    // We use pow() to compute e<sup>n</sup> and a Taylor series to compute\n    // e<sup>m</sup>.  We return e*<sup>n</sup> &times; e<sup>m</sup>\n    final Dfp inta = a.rint();\n    final Dfp fraca = a.subtract(inta);\n\n    final int ia = inta.intValue();\n    if (ia > 2147483646) {\n        // return +Infinity\n        return a.newInstance((byte)1, Dfp.INFINITE);\n    }\n\n    if (ia < -2147483646) {\n        // return 0;\n        return a.newInstance();\n    }\n\n    final Dfp einta = splitPow(a.getField().getESplit(), ia);\n    final Dfp efraca = expInternal(fraca);\n\n    return einta.multiply(efraca);\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    // Use the classic Taylor series.  1 + x**2/2! + x**3/3! + x**4/4!  ...\n    // 1 + x**2/2! + x**3/3! + x**4/4!  ...\n    Dfp result = a.getOne();\n    Dfp x = a;\n    int i = 2;\n    do {\n        x = x.multiply(a);\n        result = result.add(x.divide(new Dfp(i)));\n        i++;\n    } while (x.getExponent() > -20);\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = a.getOne();\n    Dfp term = a;\n    int i = 1;\n    while (term.abs().getExponent() > -10) {\n        result = result.add(term);\n        term = term.multiply(a).divide(new Dfp(i++));\n    }\n    return result;\n}"
    ],
    [
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final T s = getNorm();\n    if (s.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n    }\n    return new FieldVector3D<T>(y.negate().divide(s), z.divide(s), x.negate().divide(s));\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    if (x.getReal() == 0) {\n        if (y.getReal() == 0) {\n            if (z.getReal() == 0) {\n                throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n            } else {\n                return new FieldVector3D<T>(x, y.negate(), z);\n            }\n        } else {\n            return new FieldVector3D<T>(x, y.negate(), z);\n        }\n    } else {\n        return new FieldVector3D<T>(x.negate(), y, z);\n    }\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final T s = getNorm();\n    if (s.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n    }\n    return new FieldVector3D<T>(y.negate(), z, x);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final T s = getNorm();\n    if (s.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n    }\n    if (x.getReal() == 0) {\n        return new FieldVector3D<T>(y.negate(), z.negate(), x);\n    } else if (y.getReal() == 0) {\n        return new FieldVector3D<T>(z.negate(), x.negate(), y);\n    } else {\n        return new FieldVector3D<T>(x.negate(), y.negate(), z);\n    }\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    if (x.getReal() == 0) {\n        if (y.getReal() == 0) {\n            if (z.getReal() == 0) {\n                throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n            } else {\n                return new FieldVector3D<T>(x.getField().getZero(), z.negate(), y.getField().getZero());\n            }\n        } else {\n            return new FieldVector3D<T>(x.getField().getZero(), y.getField().getZero(), z.negate());\n        }\n    } else {\n        return new FieldVector3D<T>(y.getField().getZero(), z.getField().getZero(), x.negate());\n    }\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final T s = getNorm();\n    if (s.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n    }\n    if (x.getReal() == 0) {\n        return new FieldVector3D<T>(y.negate(), z, x);\n    } else if (y.getReal() == 0) {\n        return new FieldVector3D<T>(z, x.negate(), y);\n    } else {\n        return new FieldVector3D<T>(x, y.negate(), z);\n    }\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    T x = this.x;\n    T y = this.y;\n    T z = this.z;\n    T n = x.multiply(x).add(y.multiply(y)).add(z.multiply(z));\n    if (n.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n    }\n    return new FieldVector3D<T>(y.negate().divide(n),\n                                z.negate().divide(n),\n                                x.divide(n));\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final T s = getNorm();\n    if (s.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n    }\n    if (x.getReal() == 0) {\n        return new FieldVector3D<T>(y.getField().getOne(), y.getField().getZero(), x.getField().getZero(), x.getField().getOne());\n    } else if (y.getReal() == 0) {\n        return new FieldVector3D<T>(x.getField().getZero(), y.getField().getOne(), x.getField().getZero(), x.getField().getOne());\n    } else if (z.getReal() == 0) {\n        return new FieldVector3D<T>(x.getField().getZero(), x.getField().getZero(), y.getField().getOne(), x.getField().getOne());\n    }\n    return new FieldVector3D<T>(x.getField().getZero(), y.getField().getZero(), z.getField().getOne(), x.getField().getOne());\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final T s = getNorm();\n    if (s.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n    }\n    if (x.getReal() == 0) {\n        return new FieldVector3D<T>(y.getField().getOne(), y.getField().getZero(), x.getField().getZero(),\n                                    y.getField().getZero(), y.getField().getOne(), x.getField().getZero());\n    } else if (y.getReal() == 0) {\n        return new FieldVector3D<T>(x.getField().getZero(), y.getField().getOne(), x.getField().getZero(),\n                                    x.getField().getZero(), y.getField().getZero(), x.getField().getOne());\n    } else {\n        return new FieldVector3D<T>(y.getField().getZero(), x.getField().getZero(), x.getField().getOne(),\n                                    y.getField().getZero(), x.getField().getZero(), y.getField().getOne());\n    }\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final T s = getNorm();\n    if (s.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n    }\n    return new FieldVector3D<T>(y.negate(), z, x);\n}"
    ],
    [
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    if (isAfter(other.minimum)) {\n        return new Range<>(other.minimum, minimum);\n    } else {\n        return new Range<>(minimum, other.maximum);\n    }\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) \n    {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    return Range.between(\n            (minimum.compareTo(other.minimum) >= 0) ? minimum : other.minimum,\n            (maximum.compareTo(other.maximum) <= 0) ? maximum : other.maximum);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"Other range is null\");\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    if (contains(other)) {\n        return this;\n    }\n    if (other.contains(this)) {\n        return other;\n    }\n    return new Range<T>(\n        (minimum.compareTo(other.minimum) < 0 ? other.minimum : minimum),\n        (maximum.compareTo(other.maximum) > 0 ? other.maximum : maximum));\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) \n    {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    if (other.contains(minimum)) \n    {\n        return other.intersectionWith(this);\n    }\n    return new Range<>(minimum, other.maximum);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"Range must not be null\");\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    if (equals(other)) {\n        return this;\n    }\n    return new Range<T>(\n        minimum.compareTo(other.minimum) > 0 ? minimum : other.minimum,\n        maximum.compareTo(other.maximum) < 0 ? maximum : other.maximum);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    final T newMin = (isBefore(other.minimum)) ? other.minimum : minimum;\n    final T newMax = (isAfter(other.maximum)) ? other.maximum : maximum;\n    return new Range<>(newMin, newMax);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"Range must not be null\");\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap to calculate intersection\");\n    }\n    final T min = minimum.compareTo(other.minimum) >= 0 ? minimum : other.minimum;\n    final T max = maximum.compareTo(other.maximum) <= 0 ? maximum : other.maximum;\n    return new Range<T>(min, max);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"Range must not be null\");\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap to calculate intersection\");\n    }\n    if (equals(other)) {\n        return this;\n    }\n    final T min = minimum.compareTo(other.minimum) <= 0 ? minimum : other.minimum;\n    final T max = maximum.compareTo(other.maximum) >= 0 ? maximum : other.maximum;\n    return new Range<>(min, max);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"Range must not be null\");\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap to calculate intersection\");\n    }\n    if (equals(other)) {\n        return this;\n    }\n    return new Range<>(\n        maximum(minimum, other.minimum),\n        minimum(maximum, other.maximum)\n    );\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"Range must not be null\");\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap to calculate intersection\");\n    }\n    final T min = minimum.compareTo(other.minimum) <= 0 ? minimum : other.minimum;\n    final T max = maximum.compareTo(other.maximum) >= 0 ? maximum : other.maximum;\n    return new Range<>(min, max);\n}"
    ],
    [
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8Generator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    UTF8Generator gen = new UTF8Generator(ctxt, _generatorFeatures, _objectCodec, out);\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    UTF8JsonGenerator gen = new UTF8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8Generator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8Generator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    UTF8Generator gen = new UTF8Generator(ctxt, _generatorFeatures, _objectCodec, out);\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}"
    ],
    [
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n    if (o1 instanceof Annotation) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return Objects.equals(o1, o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (o1 == o2) {\n        return true;\n    }\n    if (o1 == null || o2 == null) {\n        return false;\n    }\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n    if (o1 instanceof Annotation) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return Objects.equals(o1, o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n    if (o1 instanceof Annotation) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (o1 == o2) {\n        return true;\n    }\n    if (o1 == null || o2 == null) {\n        return false;\n    }\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (o1 instanceof Annotation) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n    if (o1 instanceof Annotation) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return Objects.equals(o1, o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (o1 == o2) {\n        return true;\n    }\n    if (o1 == null || o2 == null) {\n        return false;\n    }\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (o1 instanceof Annotation) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n    if (type.isAnnotation()) {\n        return hashCode((Annotation) o1) == hashCode((Annotation) o2);\n    }\n    return o1.equals(o2);\n}"
    ],
    [
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n      return type;\n    }\n    if (type.isUnionType()) {\n      JSType filtered = type.toMaybeUnionType().filterNoResolvedType();\n      if (filtered != null) {\n        return filtered;\n      }\n    }\n    return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n  }",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n      return type;\n    }\n    if (type.isUnionType()) {\n      JSType filtered = type.toMaybeUnionType().filterNoResolvedType();\n      return filtered == null ? type : filtered;\n    }\n    return type;\n  }",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  } else if (type.isUnionType()) {\n    JSType filtered = type.toMaybeUnionType().filterNoResolvedType();\n    return filtered.isNoType() ? type : filtered;\n  } else if (type.isTemplatizedType()) {\n    JSType filtered = type.toMaybeTemplatizedType().filterNoResolvedType();\n    return filtered.isNoType() ? type : filtered;\n  } else if (type.isFunctionType()) {\n    JSType filtered = type.toMaybeFunctionType().filterNoResolvedType();\n    return filtered.isNoType() ? type : filtered;\n  } else if (type.isRecordType()) {\n    JSType filtered = type.toMaybeRecordType().filterNoResolvedType();\n    return filtered.isNoType() ? type : filtered;\n  }\n  return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  } else if (type.isUnionType()) {\n    return type.toMaybeUnionType().filterNoResolvedType();\n  } else if (type.isTemplatizedType()) {\n    return type.toMaybeTemplatizedType().filterNoResolvedType();\n  } else if (type.isRecordType()) {\n    return type.toMaybeRecordType().filterNoResolvedType();\n  }\n  return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  }\n  return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  }\n  if (type.isUnionType()) {\n    JSType filtered = type.toMaybeUnionType().filterNoResolvedType();\n    if (filtered != null) {\n      return filtered;\n    }\n  }\n  return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  }\n  if (type.isUnionType()) {\n    return type.toMaybeUnionType().filterNoResolvedType();\n  }\n  return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n      return type;\n    } else if (type.isUnionType()) {\n      return type.toMaybeUnionType().filterNoResolvedType();\n    } else if (type.isTemplatizedType()) {\n      return type.toMaybeTemplatizedType().filterNoResolvedType();\n    } else if (type.isRecordType()) {\n      return type.toMaybeRecordType().filterNoResolvedType();\n    } else if (type.isEnumElementType()) {\n      return type.toMaybeEnumElementType().filterNoResolvedType();\n    }\n    return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n  }",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  }\n  if (type.isUnionType()) {\n    JSType filteredType = type.toMaybeUnionType().filterNoResolvedType();\n    if (filteredType != null) {\n      return filteredType;\n    }\n  }\n  return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  }\n  if (type.isUnionType()) {\n    JSType filtered = type.toMaybeUnionType().filterNoResolvedType();\n    return filtered.isNoType() ?\n        type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE) : filtered;\n  }\n  return type;\n}"
    ],
    [
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null || restrictedType.equals(originalType)) {\n      return blindScope;\n    }\n    FlowScope informed = blindScope.createChildFlowScope();\n    informed.inferSlotType(node.getString(), restrictedType);\n    return informed;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null) {\n      return blindScope;\n    }\n    if (originalType.isEquivalentTo(restrictedType)) {\n      return blindScope;\n    }\n    FlowScope informed = blindScope.createChildFlowScope();\n    informed.inferSlotType(node.getString(), restrictedType);\n    return informed;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null) {\n      return blindScope;\n    }\n    if (originalType == null) {\n      return blindScope;\n    }\n    if (restrictedType.equals(originalType)) {\n      return blindScope;\n    }\n    FlowScope informed = blindScope.createChildFlowScope();\n    informed.inferSlotType(node.getString(), restrictedType);\n    return informed;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null) {\n      return blindScope;\n    }\n    if (originalType == null) {\n      return blindScope;\n    }\n    if (restrictedType.equals(originalType)) {\n      return blindScope;\n    }\n    FlowScope newScope = blindScope.createChildFlowScope();\n    newScope.inferSlotType(node.getString(), restrictedType);\n    return newScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null) {\n      return blindScope;\n    }\n    if (originalType == null) {\n      originalType = node.getJSType();\n    }\n    if (originalType.isEquivalentTo(restrictedType)) {\n      return blindScope;\n    }\n    if (blindScope.isDeclared(node, originalType)) {\n      return blindScope;\n    }\n    FlowScope informed = blindScope.createChildFlowScope();\n    informed.inferSlotType(node.getString(), restrictedType);\n    return informed;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null || restrictedType.equals(originalType)) {\n      return blindScope;\n    }\n    FlowScope informed = blindScope.createChildFlowScope();\n    if (node.isName()) {\n      informed.inferSlotType(node.getString(), restrictedType);\n    }\n    return informed;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null) {\n      return blindScope;\n    }\n    if (originalType == null) {\n      return blindScope;\n    }\n    if (restrictedType.equals(originalType)) {\n      return blindScope;\n    }\n    FlowScope newScope = blindScope.createChildFlowScope();\n    newScope.inferSlotType(node.getString(), restrictedType);\n    return newScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null || originalType.equals(restrictedType)) {\n      return blindScope;\n    }\n    FlowScope informed = blindScope.createChildFlowScope();\n    informed.inferSlotType(node.getString(), restrictedType);\n    return informed;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null) {\n      return blindScope;\n    }\n    if (originalType.equals(restrictedType)) {\n      return blindScope;\n    }\n    if (node.isName()) {\n      return restrictName(blindScope, node.getString(), restrictedType);\n    } else {\n      return blindScope.createChildFlowScope();\n    }\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null || restrictedType.equals(originalType)) {\n      return blindScope;\n    }\n    FlowScope informed = blindScope.createChildFlowScope();\n    informed.inferSlotType(node.getString(), restrictedType);\n    return informed;\n  }"
    ],
    [
      "private Node parseFunctionType(JsDocToken token)  {\n  if (token == JsDocToken.STRING) {\n    String functionString = stream.getString();\n    if (\"function\".equals(functionString)) {\n      next();\n      skipEOLs();\n      if (match(JsDocToken.LT)) {\n        next();\n        skipEOLs();\n        Node typeParams = parseTypeExpressionList(next());\n        if (typeParams != null) {\n          skipEOLs();\n          if (match(JsDocToken.LP)) {\n            next();\n            skipEOLs();\n            if (match(JsDocToken.THIS)) {\n              next();\n              skipEOLs();\n              if (match(JsDocToken.COLON)) {\n                next();\n                skipEOLs();\n                Node typeName = parseTypeName(next());\n                if (typeName != null) {\n                  skipEOLs();\n                  if (match(JsDocToken.COMMA)) {\n                    next();\n                    skipEOLs();\n                    Node params = parseParametersType(next());\n                    if (params != null) {\n                      skipEOLs();\n                      if (match(JsDocToken.RP)) {\n                        next();\n                        skipEOLs();\n                        Node resultType = parseResultType(next());\n                        if (resultType != null) {\n                          return wrapNode(Token.FUNCTION, typeParams, typeName, params, resultType);\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return reportGenericTypeSyntaxWarning();\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  if (token != JsDocToken.STRING) {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  String functionType = stream.getString();\n  int lineno = stream.getLineno();\n  int charno = stream.getCharno();\n\n  if (!functionType.equals(\"function\")) {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  skipEOLs();\n  if (!match(JsDocToken.LP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n\n  next();\n  skipEOLs();\n  if (!match(JsDocToken.STRING)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n  }\n\n  String thisType = stream.getString();\n  if (!thisType.equals(\"this\")) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n  }\n\n  skipEOLs();\n  if (!match(JsDocToken.COLON)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n  }\n\n  next();\n  skipEOLs();\n  Node thisTypeNode = parseTypeName(next());\n  if (thisTypeNode == null) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.type\");\n  }\n\n  skipEOLs();\n  if (!match(JsDocToken.COMMA)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.comma\");\n  }\n\n  next();\n  skipEOLs();\n  Node parametersType = parseParametersType(next());\n  if (parametersType == null) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.type\");\n  }\n\n  skipEOLs();\n  if (!match(JsDocToken.RP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n\n  next();\n  skipEOLs();\n  Node resultType = parseResultType(next());\n  if (resultType == null) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.type\");\n  }\n\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  if (token != JsDocToken.STRING || !\"function\".equals(stream.getString())) {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  next();\n  skipEOLs();\n\n  Node functionTypeNode = newNode(Token.FUNCTION);\n\n  // Type parameters\n  if (match(JsDocToken.LT)) {\n    next();\n    skipEOLs();\n    Node typeParams = parseTypeExpressionList(next());\n    if (typeParams != null) {\n      functionTypeNode.addChildToFront(typeParams);\n\n      skipEOLs();\n      if (!match(JsDocToken.GT)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n      }\n\n      next();\n    }\n  }\n\n  // '('\n  if (!match(JsDocToken.LP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n  next();\n  skipEOLs();\n\n  // 'this'\n  if (!match(JsDocToken.STRING) || !\"this\".equals(stream.getString())) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n  }\n  next();\n  skipEOLs();\n\n  // ':'\n  if (!match(JsDocToken.COLON)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n  }\n  next();\n  skipEOLs();\n\n  // Type name\n  Node typeName = parseTypeName(next());\n  if (typeName == null) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.type\");\n  }\n  functionTypeNode.addChildToBack(typeName);\n\n  // ')'\n  if (!match(JsDocToken.RP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n  next();\n  skipEOLs();\n\n  // Parameters\n  Node params = parseParametersType(next());\n  if (params != null) {\n    functionTypeNode.addChildToBack(params);\n  }\n\n  // Result type\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  if (token != JsDocToken.STRING || !\"function\".equals(stream.getString())) {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  Node functionTypeNode = newNode(Token.FUNCTION);\n\n  if (match(JsDocToken.LT)) {\n    next();\n    skipEOLs();\n    Node typeParameters = parseTypeExpressionList(next());\n    if (typeParameters != null) {\n      functionTypeNode.addChildToFront(typeParameters);\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.GT)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n    }\n\n    next();\n  }\n\n  skipEOLs();\n  if (!match(JsDocToken.LP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n\n  next();\n  skipEOLs();\n  if (!match(JsDocToken.THIS)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n  }\n\n  next();\n  skipEOLs();\n  if (!match(JsDocToken.COLON)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n  }\n\n  next();\n  skipEOLs();\n  Node thisType = parseContextTypeExpression(next());\n  if (thisType == null) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.type\");\n  }\n\n  functionTypeNode.addChildToFront(thisType);\n\n  skipEOLs();\n  if (!match(JsDocToken.COMMA)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.comma\");\n  }\n\n  next();\n  skipEOLs();\n  Node parametersType = parseParametersType(next());\n  if (parametersType == null) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.type\");\n  }\n\n  functionTypeNode.addChildToFront(parametersType);\n\n  skipEOLs();\n  if (!match(JsDocToken.RP)) {\n}\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  if (token == JsDocToken.STRING && \"function\".equals(stream.getString())) {\n    next();\n    skipEOLs();\n    Node functionType = newNode(Token.FUNCTION);\n\n    if (match(JsDocToken.LT)) {\n      next();\n      skipEOLs();\n      Node typeParams = parseTypeExpressionList(next());\n      if (typeParams != null) {\n        functionType.addChildToFront(typeParams);\n        skipEOLs();\n        if (!match(JsDocToken.GT)) {\n          return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n        }\n        next();\n      }\n    }\n\n    if (match(JsDocToken.LP)) {\n      next();\n      skipEOLs();\n      if (match(JsDocToken.STRING) && \"this\".equals(stream.getString())) {\n        next();\n        skipEOLs();\n        if (!match(JsDocToken.COLON)) {\n          return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n        }\n        next();\n        skipEOLs();\n        Node thisType = parseTypeExpression(next());\n        if (thisType != null) {\n          functionType.addChildToFront(thisType);\n        }\n      }\n\n      skipEOLs();\n      Node params = parseParametersType(next());\n      if (params != null) {\n        functionType.addChildToFront(params);\n      }\n\n      skipEOLs();\n      if (!match(JsDocToken.RP)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n      }\n      next();\n\n      skipEOLs();\n      Node resultType = parseResultType(next());\n      if (resultType != null) {\n        functionType.addChildToFront(resultType);\n      }\n    }\n\n    return functionType;\n  }\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  if (token != JsDocToken.STRING) {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  String functionType = stream.getString();\n  int lineno = stream.getLineno();\n  int charno = stream.getCharno();\n\n  while (match(JsDocToken.EOL) &&\n      functionType.charAt(functionType.length() - 1) == '.') {\n    skipEOLs();\n    if (match(JsDocToken.STRING)) {\n      next();\n      functionType += stream.getString();\n    }\n  }\n\n  Node functionTypeNode = newStringNode(functionType, lineno, charno);\n\n  if (match(JsDocToken.LT)) {\n    next();\n    skipEOLs();\n    Node memberType = parseTypeExpressionList(next());\n    if (memberType != null) {\n      functionTypeNode.addChildToFront(memberType);\n\n      skipEOLs();\n      if (!match(JsDocToken.GT)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n      }\n\n      next();\n    }\n  }\n\n  if (match(JsDocToken.LP)) {\n    next();\n    skipEOLs();\n    if (match(JsDocToken.STRING) && \"this\".equals(stream.getString())) {\n      next();\n      skipEOLs();\n      if (match(JsDocToken.COLON)) {\n        next();\n        skipEOLs();\n        Node typeName = parseTypeName(next());\n        if (typeName != null) {\n          functionTypeNode.addChildToFront(typeName);\n          skipEOLs();\n        }\n      }\n    }\n\n    if (match(JsDocToken.COMMA)) {\n      next();\n      skipEOLs();\n      Node parametersType = parseParametersType(next());\n      if (parametersType != null) {\n        functionTypeNode.addChildToFront(parametersType);\n        skipEOLs();\n      }\n    }\n\n    if (match(JsDocToken.RP)) {\n      next();\n      skipEOLs();\n}\n}\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  if (token == JsDocToken.STRING) {\n    String string = stream.getString();\n    if (\"function\".equals(string)) {\n      next();\n      skipEOLs();\n      Node typeParams = parseTypeParameters(next());\n      if (match(JsDocToken.LP)) {\n        next();\n        skipEOLs();\n        if (match(JsDocToken.THIS)) {\n          next();\n          skipEOLs();\n          if (match(JsDocToken.COLON)) {\n            next();\n            skipEOLs();\n            Node typeName = parseTypeName(next());\n            if (typeName != null) {\n              skipEOLs();\n              Node params = parseParametersType(next());\n              if (params != null) {\n                skipEOLs();\n                if (match(JsDocToken.RP)) {\n                  next();\n                  skipEOLs();\n                  Node resultType = parseResultType(next());\n                  if (resultType != null) {\n                    return newFunctionType(typeParams, typeName, params, resultType);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return reportGenericTypeSyntaxWarning();\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  if (token != JsDocToken.STRING || !\"function\".equals(stream.getString())) {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  next();\n  skipEOLs();\n\n  Node functionTypeNode = newNode(Token.FUNCTION);\n  Node functionSignatureTypeNode = newNode(Token.FUNCTION_SIGNATURE);\n  functionTypeNode.addChildToBack(functionSignatureTypeNode);\n\n  if (match(JsDocToken.LT)) {\n    next();\n    skipEOLs();\n    Node typeParameters = parseTypeExpressionList(next());\n    if (typeParameters != null) {\n      functionSignatureTypeNode.addChildToBack(typeParameters);\n      skipEOLs();\n      if (!match(JsDocToken.GT)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n      }\n\n      next();\n    }\n  }\n\n  if (!match(JsDocToken.LP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n\n  next();\n  skipEOLs();\n\n  if (!match(JsDocToken.STRING) || !\"this\".equals(stream.getString())) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n  }\n\n  next();\n  skipEOLs();\n\n  if (!match(JsDocToken.COLON)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n  }\n\n  next();\n  skipEOLs();\n\n  Node typeName = parseTypeName(next());\n  if (typeName == null) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.typename\");\n  }\n\n  functionSignatureTypeNode.addChildToBack(typeName);\n\n  skipEOLs();\n  if (!match(JsDocToken.COMMA)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.comma\");\n  }\n\n  next();\n  skipEOLs();\n\n  Node parametersType = parseParametersType(next());\n  if (parametersType == null) {\n}\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  if (token == JsDocToken.FUNCTION) {\n    next();\n    skipEOLs();\n    Node typeParams = parseTypeParameters(next());\n    if (match(JsDocToken.LP)) {\n      next();\n      skipEOLs();\n      Node thisType = parseContextTypeExpression(next());\n      if (match(JsDocToken.COMMA)) {\n        next();\n        skipEOLs();\n        Node paramTypes = parseParametersType(next());\n        if (match(JsDocToken.RP)) {\n          next();\n          skipEOLs();\n          Node resultType = parseResultType(next());\n          return wrapNode(Token.FUNCTION,\n              typeParams, thisType, paramTypes, resultType);\n        }\n      }\n    }\n  }\n  return reportGenericTypeSyntaxWarning();\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  if (token == JsDocToken.FUNCTION) {\n    next();\n    skipEOLs();\n    if (match(JsDocToken.LP)) {\n      next();\n      skipEOLs();\n      if (match(JsDocToken.THIS)) {\n        next();\n        skipEOLs();\n        if (match(JsDocToken.COLON)) {\n          next();\n          skipEOLs();\n          Node typeName = parseTypeName(next());\n          skipEOLs();\n          if (match(JsDocToken.COMMA)) {\n            next();\n            skipEOLs();\n            Node parametersType = parseParametersType(next());\n            skipEOLs();\n            if (match(JsDocToken.RP)) {\n              next();\n              skipEOLs();\n              Node resultType = parseResultType(next());\n              return wrapNode(Token.FUNCTION, typeName, parametersType, resultType);\n            }\n          }\n        }\n      }\n    }\n  }\n  return reportGenericTypeSyntaxWarning();\n}"
    ],
    [
      "public static String deleteWhitespace(final String str)  {\n    if (isEmpty(str)) {\n        return str;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    int sz = str.length();\n    // make a first pass to avoid StringBuffer\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (Character.isWhitespace(str.charAt(i))) {\n            count++;\n        }\n    }\n    if (count == 0) {\n        return str;\n    }\n    final StringBuffer buffer = new StringBuffer(sz - count);\n    for (int i = 0; i < sz; i++) {\n        char ch = str.charAt(i);\n        if (!Character.isWhitespace(ch)) {\n            buffer.append(ch);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (isEmpty(str)) {\n        return str;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (isEmpty(str)) {\n        return str;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (isEmpty(str)) {\n        return str;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (isEmpty(str)) {\n        return str;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (isEmpty(str)) {\n        return str;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (isEmpty(str)) {\n        return str;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}"
    ],
    [
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n        if (statistics == null || statistics.isEmpty()) {\n            return null;\n        }\n\n        double sum = 0.0;\n        double sumsq = 0.0;\n        double sumLogs = 0.0;\n        double min = Double.POSITIVE_INFINITY;\n        double max = Double.NEGATIVE_INFINITY;\n        long n = 0;\n\n        for (SummaryStatistics stat : statistics) {\n            sum += stat.getSum();\n            sumsq += stat.getSumsq();\n            sumLogs += stat.getSumOfLogs();\n            min = Math.min(min, stat.getMin());\n            max = Math.max(max, stat.getMax());\n            n += stat.getN();\n        }\n\n        double mean = sum / n;\n        double variance = sumsq / n - mean * mean;\n        double secondMoment = sumsq / n;\n        double geometricMean = Math.exp(sumLogs / n);\n\n        return new StatisticalSummaryValues(mean, variance, n, max, min, sum, secondMoment, geometricMean);\n    }",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n        if (statistics == null || statistics.isEmpty()) {\n            return null;\n        }\n        SummaryStatistics summaryStatistics = new SummaryStatistics();\n        for (SummaryStatistics stat : statistics) {\n            SummaryStatistics.add(summaryStatistics, stat);\n        }\n        return new StatisticalSummaryValues(summaryStatistics.getMean(),\n                summaryStatistics.getVariance(), summaryStatistics.getN(),\n                summaryStatistics.getMax(), summaryStatistics.getMin(),\n                summaryStatistics.getSum());\n    }",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    double sum = 0;\n    double sumsq = 0;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    double sumLogs = 0;\n    long n = 0;\n    for (SummaryStatistics s : statistics) {\n        sum += s.getSum();\n        sumsq += s.getSumsq();\n        min = Math.min(min, s.getMin());\n        max = Math.max(max, s.getMax());\n        sumLogs += s.getSumOfLogs();\n        n += s.getN();\n    }\n    return new StatisticalSummaryValues(sum / n,\n            sumsq / n - (sum / n) * (sum / n), n, min, max, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n        if (statistics == null || statistics.isEmpty()) {\n            return null;\n        }\n\n        SummaryStatistics combinedStatistics = new SummaryStatistics();\n        for (SummaryStatistics stat : statistics) {\n            SummaryStatistics.add(combinedStatistics, stat);\n        }\n\n        return new StatisticalSummaryValues(combinedStatistics.getMean(),\n                combinedStatistics.getVariance(), combinedStatistics.getN(),\n                combinedStatistics.getMax(), combinedStatistics.getMin(),\n                combinedStatistics.getSum());\n    }",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    SummaryStatistics aggregatedStatistics = new SummaryStatistics();\n\n    for (SummaryStatistics stat : statistics) {\n        SummaryStatistics.copy(stat, aggregatedStatistics);\n    }\n\n    return new StatisticalSummaryValues(aggregatedStatistics.getMean(),\n            aggregatedStatistics.getVariance(), aggregatedStatistics.getN(),\n            aggregatedStatistics.getMax(), aggregatedStatistics.getMin(),\n            aggregatedStatistics.getSum());\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n        if (statistics == null || statistics.isEmpty()) {\n            return null;\n        }\n\n        SummaryStatistics aggregatedStatistics = new AggregatingSummaryStatistics();\n\n        for (SummaryStatistics stat : statistics) {\n            SummaryStatistics.copy(stat, aggregatedStatistics);\n        }\n\n        return new StatisticalSummaryValues(aggregatedStatistics.getMean(),\n                aggregatedStatistics.getVariance(), aggregatedStatistics.getN(),\n                aggregatedStatistics.getMax(), aggregatedStatistics.getMin(),\n                aggregatedStatistics.getSum());\n    }",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n        if (statistics == null || statistics.isEmpty()) {\n            return null;\n        }\n\n        double sum = 0.0;\n        double sumsq = 0.0;\n        double sumLogs = 0.0;\n        double min = Double.POSITIVE_INFINITY;\n        double max = Double.NEGATIVE_INFINITY;\n        long n = 0;\n\n        for (SummaryStatistics s : statistics) {\n            sum += s.getSum();\n            sumsq += s.getSumsq();\n            sumLogs += s.getSumOfLogs();\n            min = Math.min(min, s.getMin());\n            max = Math.max(max, s.getMax());\n            n += s.getN();\n        }\n\n        return new StatisticalSummaryValues(sum / n, sumsq / n, n, min, max, sum);\n    }",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n        if (statistics == null || statistics.isEmpty()) {\n            return null;\n        }\n\n        SummaryStatistics prototype = statistics.iterator().next();\n        SummaryStatistics aggregatedStatistics = new AggregatingSummaryStatistics(prototype);\n\n        for (SummaryStatistics stat : statistics) {\n            SummaryStatistics.copy(stat, aggregatedStatistics);\n        }\n\n        return aggregatedStatistics.getSummary();\n    }",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    double sum = 0;\n    double sumsq = 0;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    double sumLogs = 0;\n    double sumSqLogs = 0;\n    long n = 0;\n\n    for (SummaryStatistics s : statistics) {\n        if (s == null) {\n            continue;\n        }\n        n += s.getN();\n        double mean = s.getMean();\n        double var = s.getVariance();\n        double sd = s.getStandardDeviation();\n        double[] quantiles = s.getQuantiles();\n        double[] meanLogs = s.getMeanLogs();\n\n        sum += mean * n;\n        sumsq += var * n + sd * sd * n * (n - 1);\n        min = Math.min(min, s.getMin());\n        max = Math.max(max, s.getMax());\n        sumLogs += meanLogs[0] * n;\n        sumSqLogs += meanLogs[1] * n;\n    }\n\n    return new StatisticalSummaryValues(sum / n, sumsq / n, n, min, max, sum, sumLogs, sumSqLogs);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    double sum = 0;\n    double sumsq = 0;\n    long n = 0;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    double sumLogs = 0;\n\n    for (SummaryStatistics stat : statistics) {\n        if (stat == null) {\n            continue;\n        }\n\n        sum += stat.getSum();\n        sumsq += stat.getSumsq();\n        n += stat.getN();\n        min = Math.min(min, stat.getMin());\n        max = Math.max(max, stat.getMax());\n        sumLogs += stat.getSumOfLogs();\n    }\n\n    return new StatisticalSummaryValues(sum / n,\n            sumsq / n - (sum / n) * (sum / n),\n            n,\n            min,\n            max,\n            sum);\n}"
    ],
    [
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION, n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += (sample1[i] - sample2[i] - meanDifference) * (sample1[i] - sample2[i] - meanDifference);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n <= 1) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += (sample1[i] - sample2[i] - meanDifference) * (sample1[i] - sample2[i] - meanDifference);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n <= 1) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += (sample1[i] - sample2[i] - meanDifference) * (sample1[i] - sample2[i] - meanDifference);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n <= 1) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += (sample1[i] - sample2[i] - meanDifference) * (sample1[i] - sample2[i] - meanDifference);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION, n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += (sample1[i] - sample2[i] - meanDifference) * (sample1[i] - sample2[i] - meanDifference);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION, n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += (sample1[i] - sample2[i] - meanDifference) * (sample1[i] - sample2[i] - meanDifference);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION, n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += (sample1[i] - sample2[i] - meanDifference) * (sample1[i] - sample2[i] - meanDifference);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION, n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += (sample1[i] - sample2[i] - meanDifference) * (sample1[i] - sample2[i] - meanDifference);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION, n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += (sample1[i] - sample2[i] - meanDifference) * (sample1[i] - sample2[i] - meanDifference);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n <= 1) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION, n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += (sample1[i] - sample2[i] - meanDifference) * (sample1[i] - sample2[i] - meanDifference);\n        }\n        return result / (n - 1);\n    }"
    ],
    [
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double result = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) {\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            double v = value.doubleValue();\n            if (v >= 0.0) {\n                result = result + v;\n            }\n        }\n    }\n    return result;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null) \n        {\n            double v = value.doubleValue();\n            if (v >= 0.0) \n            {\n                total += v;\n            }\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double result = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null) \n        {\n            double v = value.doubleValue();\n            if (v >= 0.0) \n            {\n                result += v;\n            }\n        }\n    }\n    return result;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) {\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            double v = value.doubleValue();\n            if (v >= 0.0) {\n                total = total + v;\n            }\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double result = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) {\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            double v = value.doubleValue();\n            if (v >= 0.0) {\n                result = result + v;\n            }\n        }\n    }\n    return result;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) {\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            double v = value.doubleValue();\n            if (v >= 0.0) {\n                total += v;\n            }\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null) \n        {\n            double v = value.doubleValue();\n            if (v >= 0.0) \n            {\n                total += v;\n            }\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double result = 0.0;\n    int seriesCount = dataset.getSeriesCount();\n    for (int series = 0; series < seriesCount; series++) \n    {\n        int itemCount = dataset.getItemCount(series);\n        for (int item = 0; item < itemCount; item++) \n        {\n            Number value = dataset.getValue(series, item);\n            if (value != null) \n            {\n                double v = value.doubleValue();\n                if (v >= 0.0) \n                {\n                    result += v;\n                }\n            }\n        }\n    }\n    return result;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) {\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            double v = value.doubleValue();\n            if (v >= 0.0) {\n                total += v;\n            }\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null) \n        {\n            double v = value.doubleValue();\n            if (v >= 0.0) \n            {\n                total += v;\n            }\n        }\n    }\n    return total;\n}"
    ],
    [
      "public String nextName() throws IOException  {\n    String name = nextString();\n    if (peeked != PEEKED_NONE) {\n        peeked = PEEKED_NONE;\n    }\n    return name;\n}",
      "public String nextName() throws IOException  {\n    String name = nextString();\n    if (name == null) {\n        throw new IOException(\"Expected a name but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n    }\n    return name;\n}",
      "public String nextName() throws IOException  {\n    String name = nextString();\n    if (peeked != PEEKED_NONE) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n    }\n    peekedString = name;\n    return name;\n  }",
      "public String nextName() throws IOException  {\n    //TODO: Implement this method\n    return null;\n}",
      "public String nextName() throws IOException  {\n    String name = nextString();\n    if (name == null)\n    {\n        throw new IOException(\"Expected a name but was \" + peek());\n    }\n    return name;\n}",
      "public String nextName() throws IOException  {\n    String result = peekedString;\n    if (result == null) {\n      if (peek() != PEEKED_NAME) {\n        throw new JsonDataException(\"Expected a name but was \" + peek() + \" at line \"\n            + getLineNumber() + \" column \" + getColumnNumber());\n      }\n      result = nextStringInternal();\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n  String name = nextString();\n  if (name == null) {\n    throw new IllegalStateException(\"Expected a name but was \" + peek());\n  }\n  return name;\n}",
      "public String nextName() throws IOException  {\n    String result = nextString();\n    if (result == null) {\n      throw new IOException(\"Expected a name but was \" + peek());\n    }\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    String name = nextString();\n    if (name == null) {\n        throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    return name;\n}",
      "public String nextName() throws IOException  {\n  String name = nextString();\n  if (peeked != PEEKED_NONE) {\n    peeked = PEEKED_NONE;\n  }\n  return name;\n}"
    ],
    [
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_INT_ARRAY;\n        }\n        final int[] result = new int[array.length];\n        for (int i = 0; i < array.length; i++) {\n            final Integer b = array[i];\n            result[i] = (b == null ? valueForNull : b.intValue());\n        }\n        return result;\n    }",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}"
    ],
    [
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (inUncompressedChunk) {\n            final int read = Math.min(uncompressedBytesRemaining, len);\n            final int actualRead = in.read(b, off, read);\n            uncompressedBytesRemaining -= actualRead;\n            return actualRead;\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.read(b, off, len);\n        }\n        return -1;\n    }",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (currentCompressedChunk == null) {\n            return -1;\n        }\n        int read = currentCompressedChunk.read(b, off, len);\n        if (read == -1) {\n            currentCompressedChunk.close();\n            currentCompressedChunk = null;\n            readNextBlock();\n            if (endReached) {\n                return -1;\n            }\n            read = currentCompressedChunk.read(b, off, len);\n        }\n        return read;\n    }",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (inUncompressedChunk) {\n            final int bytesToRead = Math.min(uncompressedBytesRemaining, len);\n            final int read = in.read(b, off, bytesToRead);\n            if (read != -1) {\n                uncompressedBytesRemaining -= read;\n            }\n            return read;\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.read(b, off, len);\n        }\n        return -1;\n    }",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        if (uncompressedBytesRemaining == 0) {\n            return -1;\n        }\n        final int read = in.read(b, off, Math.min(len, uncompressedBytesRemaining));\n        uncompressedBytesRemaining -= read;\n        return read;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) {\n        return -1;\n    }\n    final int read = currentCompressedChunk.read(b, off, len);\n    if (read == -1) {\n        currentCompressedChunk.close();\n        currentCompressedChunk = null;\n        if (uncompressedBytesRemaining == 0) {\n            endReached = true;\n        }\n    } else {\n        uncompressedBytesRemaining -= read;\n    }\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) {\n        return -1;\n    }\n    int read = currentCompressedChunk.read(b, off, len);\n    if (read == -1) {\n        currentCompressedChunk.close();\n        currentCompressedChunk = null;\n        if (inUncompressedChunk) {\n            readNextBlock();\n        }\n        if (currentCompressedChunk != null) {\n            read = currentCompressedChunk.read(b, off, len);\n        }\n    }\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        final int read = Math.min(uncompressedBytesRemaining, len);\n        in.read(b, off, read);\n        uncompressedBytesRemaining -= read;\n        return read;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        if (uncompressedBytesRemaining == 0) {\n            return -1;\n        }\n        final int read = in.read(b, off, Math.min(len, uncompressedBytesRemaining));\n        uncompressedBytesRemaining -= read;\n        return read;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) {\n        return -1;\n    }\n    int read = currentCompressedChunk.read(b, off, len);\n    if (read == -1) {\n        currentCompressedChunk.close();\n        currentCompressedChunk = null;\n        readNextBlock();\n        if (endReached) {\n            return -1;\n        }\n        read = currentCompressedChunk.read(b, off, len);\n    }\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (inUncompressedChunk) {\n            if (len == 0) {\n                return 0;\n            }\n            final int read = Math.min(uncompressedBytesRemaining, len);\n            in.readFully(b, off, read);\n            uncompressedBytesRemaining -= read;\n            if (uncompressedBytesRemaining == 0) {\n                inUncompressedChunk = false;\n            }\n            return read;\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.read(b, off, len);\n        }\n        return -1;\n    }"
    ],
    [
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node callNode = site.node;\n      if (callNode.isCall()) {\n        return callNode.getSecondChild().getChildAtIndex(argIndex);\n      } else if (callNode.isNew()) {\n        return callNode.getSecondChild().getChildAtIndex(argIndex);\n      } else if (callNode.isGetProp() && callNode.getLastChild().getString().equals(\"call\")) {\n        return callNode.getFirstChild().getNext().getChildAtIndex(argIndex);\n      }\n      return null;\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node callNode = site.node;\n      if (callNode.isCall()) {\n        return callNode.getChildAtIndex(argIndex + 1);\n      } else if (callNode.isNew()) {\n        return callNode.getSecondChild();\n      } else if (callNode.isGetProp()) {\n        return callNode.getNext();\n      }\n      return null;\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node callNode = site.node;\n      Node arg = null;\n      if (NodeUtil.isCallOrNew(callNode)) {\n        arg = callNode.getSecondChild().getChildAtIndex(argIndex);\n      } else if (callNode.isGetProp() && callNode.getLastChild().getString().equals(\"call\")) {\n        arg = callNode.getFirstChild().getNext().getChildAtIndex(argIndex);\n      }\n      return arg;\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node call = site.node;\n      if (call.isCall() || call.isNew()) {\n        return call.getChildAtIndex(argIndex + 1);\n      } else if (call.isGetProp() && call.getLastChild().getString().equals(\"call\")) {\n        return call.getSecondToLastChild();\n      } else {\n        return null;\n      }\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node call = site.node;\n      if (call.isCall() || call.isNew()) {\n        return call.getSecondChild().getChildAtIndex(argIndex);\n      } else if (call.isGetProp() && call.getLastChild().getString().equals(\"call\")) {\n        return call.getFirstChild().getNext().getChildAtIndex(argIndex);\n      }\n      return null;\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node call = site.node;\n      if (NodeUtil.isCallOrNew(call)) {\n        return call.getChildAtIndex(argIndex + 1);\n      } else {\n        return call.getLastChild().getChildAtIndex(argIndex);\n      }\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node call = site.node;\n      Node arg = call.getFirstChild().getNext();\n      while (argIndex > 0) {\n        arg = arg.getNext();\n        argIndex--;\n      }\n      return arg;\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node callNode = site.node;\n      Node arg = null;\n      if (callNode.isCall()) {\n        arg = callNode.getSecondChild();\n        for (int i = 0; i < argIndex && arg != null; i++) {\n          arg = arg.getNext();\n        }\n      } else if (callNode.isNew()) {\n        arg = callNode.getSecondChild();\n        for (int i = 0; i < argIndex && arg != null; i++) {\n          arg = arg.getNext();\n        }\n      } else if (callNode.isGetProp()) {\n        Node getProp = callNode.getFirstChild();\n        Node func = getProp.getNext();\n        arg = func.getNext();\n        for (int i = 0; i < argIndex && arg != null; i++) {\n          arg = arg.getNext();\n        }\n      }\n      return arg;\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node callNode = site.node;\n      if (callNode.isCall()) {\n        return callNode.getSecondChild().getNext().getChildAtIndex(argIndex);\n      } else if (callNode.isNew()) {\n        return callNode.getSecondChild().getChildAtIndex(argIndex);\n      } else if (callNode.isGetProp() && callNode.getLastChild().getString().equals(\"call\")) {\n        return callNode.getFirstChild().getNext().getChildAtIndex(argIndex);\n      } else {\n        return null;\n      }\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node call = site.node;\n      if (call.isCall() || call.isNew()) {\n        Node arg = call.getSecondChild();\n        for (int i = 0; i < argIndex; i++) {\n          arg = arg.getNext();\n        }\n        return arg;\n      } else if (call.isGetProp() && call.getLastChild().getString().equals(\"call\")) {\n        Node arg = call.getNext();\n        for (int i = 0; i < argIndex; i++) {\n          arg = arg.getNext();\n        }\n        return arg;\n      }\n      return null;\n    }"
    ],
    [
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type == null) {\n    return null;\n  }\n\n  if (type.isDeprecated()) {\n    String deprecationReason = type.getDeprecationReason();\n    return (deprecationReason == null) ? \"\" : deprecationReason;\n  }\n\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type != null && type.isDeprecated()) {\n      String deprecationReason = type.getDeprecationReason();\n      return (deprecationReason == null) ? \"\" : deprecationReason;\n    }\n    return null;\n  }",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type == null) {\n      return null;\n    }\n    JSDocInfo info = type.getJSDocInfo();\n    if (info == null) {\n      return null;\n    }\n    if (info.isDeprecated()) {\n      return info.getDeprecationReason();\n    }\n    return null;\n  }",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type == null) {\n      return null;\n    }\n\n    JSDocInfo info = type.getJSDocInfo();\n    if (info == null) {\n      return null;\n    }\n\n    String reason = info.getDeprecationReason();\n    if (reason == null) {\n      return null;\n    }\n\n    return reason;\n  }",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type != null) {\n    JSDocInfo jsdoc = type.getJSDocInfo();\n    if (jsdoc != null && jsdoc.isDeprecated()) {\n      return jsdoc.getDeprecationReason();\n    }\n  }\n\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type == null) {\n      return null;\n    }\n\n    if (type.isFunctionType()) {\n      return getTypeDeprecationInfo(type.toMaybeFunctionType().getInstanceType());\n    }\n\n    if (type.isClassType()) {\n      return getTypeDeprecationInfo(type.toMaybeClassType().getConstructor());\n    }\n\n    if (type.isConstructor()) {\n      return getTypeDeprecationInfo(type.toMaybeFunctionType().getPrototype());\n    }\n\n    if (type.isObjectType()) {\n      return getTypeDeprecationInfo(type.toMaybeObjectType().getImplicitPrototype());\n    }\n\n    return null;\n  }",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type == null) {\n      return null;\n    }\n\n    JSDocInfo info = type.getJSDocInfo();\n    if (info == null) {\n      return null;\n    }\n\n    if (info.isDeprecated()) {\n      return info.getDeprecationReason();\n    }\n\n    return null;\n  }",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type != null) {\n    JSDocInfo jsDoc = type.getJSDocInfo();\n    if (jsDoc != null) {\n      String deprecationReason = jsDoc.getDeprecationReason();\n      if (deprecationReason != null) {\n        return deprecationReason;\n      }\n    }\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type == null) {\n    return null;\n  }\n  JSDocInfo info = type.getJSDocInfo();\n  if (info != null && info.isDeprecated()) {\n    return info.getDeprecationReason();\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type == null) {\n      return null;\n    }\n    if (type.isDeprecated()) {\n      return type.getDeprecationReason();\n    }\n    return null;\n  }"
    ],
    [
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.putIfAbsent(key, value);\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.putIfAbsent(key, value);\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.putIfAbsent(key, value);\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.putIfAbsent(key, value);\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.putIfAbsent(key, value);\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.putIfAbsent(key, value);\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.putIfAbsent(key, value);\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.putIfAbsent(key, value);\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.putIfAbsent(key, value);\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.putIfAbsent(key, value);\n    }\n    return value;\n}"
    ],
    [
      "public int getColumnIndex(Comparable key)  {\n    int columnIndex = this.underlying.getColumnIndex(key);\n    if (columnIndex >= this.firstCategoryIndex && columnIndex <= this.lastCategoryIndex())\n    {\n        return columnIndex;\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int index = this.underlying.getColumnIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int index = this.underlying.getColumnIndex(key);\n    if (index >= this.firstCategoryIndex && index <= this.lastCategoryIndex()) {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    // TODO: Fill in the code here\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int index = this.underlying.getColumnIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int index = this.underlying.getColumnIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int columnIndex = this.underlying.getColumnIndex(key);\n    if (columnIndex >= this.firstCategoryIndex) \n    {\n        return columnIndex - this.firstCategoryIndex;\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int index = this.underlying.getColumnIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) \n    {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int index = this.underlying.getColumnIndex(key);\n    if (index >= this.firstCategoryIndex && index <= this.lastCategoryIndex()) {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int index = this.underlying.getColumnIndex(key);\n    if (index < this.firstCategoryIndex) {\n        return -1;\n    }\n    if (this.maximumCategoryCount > 0 && index > this.firstCategoryIndex + this.maximumCategoryCount - 1) {\n        return -1;\n    }\n    return index;\n}"
    ],
    [
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point < lower + tolerance && point > lower - tolerance) {\n        return Location.BOUNDARY;\n    } else if (point > upper - tolerance && point < upper + tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n\n    // check if the point is inside the interval\n    if (point > lower && point < upper) {\n        return Location.INSIDE;\n    }\n\n    // check if the point is outside the interval\n    if (point < lower || point > upper) {\n        return Location.OUTSIDE;\n    }\n\n    // check if the point is on the boundary of the interval\n    if (point <= lower + tolerance || point >= upper - tolerance) {\n        return Location.BOUNDARY;\n    }\n\n    // if none of the above conditions are met, the point is not considered\n    // to belong to the interval\n    return Location.OUTSIDE;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point < lower + tolerance && point > lower - tolerance) {\n        return Location.BOUNDARY;\n    } else if (point > upper - tolerance && point < upper + tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point < lower + tolerance) {\n        return Location.BOUNDARY;\n    } else if (point > upper - tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point <= lower + tolerance && point >= lower - tolerance) {\n        return Location.BOUNDARY;\n    } else if (point <= upper + tolerance && point >= upper - tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point < lower + tolerance) {\n        return Location.BOUNDARY;\n    } else if (point > upper - tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point < lower + tolerance && point > lower - tolerance) {\n        return Location.BOUNDARY;\n    } else if (point > upper - tolerance && point < upper + tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n\n    // Check if the point is inside the interval\n    if (point >= lower && point <= upper) {\n        return Location.INSIDE;\n    }\n\n    // Check if the point is outside the interval\n    if (point < lower || point > upper) {\n        return Location.OUTSIDE;\n    }\n\n    // Check if the point is on the boundary of the interval\n    if (Math.abs(point - lower) <= tolerance || Math.abs(point - upper) <= tolerance) {\n        return Location.BOUNDARY;\n    }\n\n    // If none of the above, then the point is not on the interval\n    return Location.OUTSIDE;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point <= lower + tolerance && point >= lower - tolerance) {\n        return Location.BOUNDARY;\n    } else if (point <= upper + tolerance && point >= upper - tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point < lower + tolerance) {\n        return Location.BOUNDARY;\n    } else if (point > upper - tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}"
    ],
    [
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new LogTickUnitSource(locale);\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new TickUnits();\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new LogTickUnitSource(locale);\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    // create the formatters\n    NumberFormat format = NumberFormat.getNumberInstance(locale);\n    format.setMaximumFractionDigits(1);\n    format.setMinimumFractionDigits(1);\n    format.setGroupingUsed(false);\n\n    // create the tick units\n    TickUnitSource units = new NumberTickUnitSource(format);\n\n    // return the collection of tick units\n    return units;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new TickUnits();\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new LogTickUnitSource(locale);\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new TickUnits();\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new LogTickUnitSource(locale);\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new LogTickUnitSource(locale);\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new TickUnits();\n}"
    ],
    [
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotColumn = 0;\n    double minValue = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getWidth(); i++) {\n        if (tableau.getEntry(0, i) < minValue) {\n            minValue = tableau.getEntry(0, i);\n            pivotColumn = i;\n        }\n    }\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minRatio = Double.POSITIVE_INFINITY;\n    Integer minRatioCol = null;\n    for (int i = 0; i < tableau.getWidth(); i++) {\n        double ratio = tableau.getEntry(0, i) / tableau.getEntry(0, i);\n        if (ratio < minRatio) {\n            minRatio = ratio;\n            minRatioCol = i;\n        }\n    }\n    return minRatioCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n\n    // Get the objective function row\n    final List<Double> objectiveFunctionRow = tableau.getRow(tableau.getObjectiveFunctionRow());\n\n    // Find the column with the most negative coefficient\n    int pivotColumn = 0;\n    double minValue = objectiveFunctionRow.get(pivotColumn);\n    for (int i = 1; i < objectiveFunctionRow.size(); i++) {\n        if (objectiveFunctionRow.get(i) < minValue) {\n            minValue = objectiveFunctionRow.get(i);\n            pivotColumn = i;\n        }\n    }\n\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotColumn = 0;\n    double minRatio = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getWidth(); i++) {\n        double ratio = tableau.getEntry(tableau.getHeight() - 1, i) / tableau.getEntry(tableau.getHeight() - 2, i);\n        if (ratio < minRatio) {\n            minRatio = ratio;\n            pivotColumn = i;\n        }\n    }\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n\n    // Find the column with the most negative coefficient in the objective function row.\n    int pivotColumn = 0;\n    double minValue = Double.POSITIVE_INFINITY;\n    for (int i = 0; i < tableau.getWidth(); i++) {\n        if (tableau.getEntry(0, i) < minValue) {\n            minValue = tableau.getEntry(0, i);\n            pivotColumn = i;\n        }\n    }\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    // TODO\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minRatio = Double.POSITIVE_INFINITY;\n    Integer minRatioCol = null;\n    for (int i = 0; i < tableau.getWidth(); i++) {\n        double ratio = tableau.getEntry(tableau.getHeight() - 1, i) / tableau.getEntry(tableau.getHeight() - 2, i);\n        if (ratio < minRatio) {\n            minRatio = ratio;\n            minRatioCol = i;\n        }\n    }\n    return minRatioCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minValue = Double.POSITIVE_INFINITY;\n    Integer minIndex = null;\n    for (int i = 0; i < tableau.getWidth(); i++) {\n        if (tableau.getCj(i) < minValue) {\n            minValue = tableau.getCj(i);\n            minIndex = i;\n        }\n    }\n    return minIndex;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minValue = Double.MAX_VALUE;\n    Integer minIndex = null;\n    for (int i = 0; i < tableau.getWidth(); i++) {\n        if (tableau.getEntry(0, i) < minValue) {\n            minValue = tableau.getEntry(0, i);\n            minIndex = i;\n        }\n    }\n    return minIndex;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int nCol = tableau.getWidth() - 1;\n    int pivotCol = 0;\n    double maxRatio = 0;\n    for (int i = 0; i < nCol; i++) {\n        double ratio = tableau.getEntry(0, i) / tableau.getEntry(0, pivotCol);\n        if (ratio < 0 && ratio > maxRatio) {\n            maxRatio = ratio;\n            pivotCol = i;\n        }\n    }\n    return pivotCol;\n}"
    ]
  ]
}