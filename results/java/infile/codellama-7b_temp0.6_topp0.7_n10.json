{
  "benchmark": "javaeval_if",
  "lastest_eval": {
    "compile@1": 0.5301507537688441,
    "pass@1": 0.30301507537688444,
    "compile@3": 0.6618927973199326,
    "pass@3": 0.3889447236180903,
    "compile@5": 0.7087620642897026,
    "pass@5": 0.4211733269522214
  },
  "n": 10,
  "k": [
    1,
    3,
    5
  ],
  "fn_codes": [
    [
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }"
    ],
    [
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            result = new Double(duration.getPercentComplete());\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            long start = duration.getStart().getTime();\n            long end = duration.getEnd().getTime();\n            long now = System.currentTimeMillis();\n            if (now < end) {\n                result = new Double(\n                    (double)(now - start) / (double)(end - start)\n                );\n            }\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            result = new Double(duration.getPercentComplete());\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        result = new Double(task.getPercentComplete());\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            result = new Double(duration.getPercentComplete());\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            TimePeriod complete = task.getComplete();\n            if (complete != null) {\n                result = new Double(complete.getLength() / duration.getLength());\n            }\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        result = new Double(task.getPercentComplete());\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            result = new Double(duration.getPercentComplete());\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        result = new Double(task.getPercentComplete());\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        result = new Double(task.getPercentComplete());\n    }\n    return result;\n}"
    ],
    [
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}"
    ],
    [
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator);\n}"
    ],
    [
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1)\n    {\n        final double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++)\n        {\n            for (int c = 0; c < m.getRowDimension(); c++)\n            {\n                d[r][c] = m.getEntry(r, 0);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n    else\n    {\n        final double[][] d = new double[m.getColumnDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getColumnDimension(); r++)\n        {\n            for (int c = 0; c < m.getColumnDimension(); c++)\n            {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    int rows = m.getRowDimension();\n    int cols = m.getColumnDimension();\n    if (rows == cols)\n    {\n        return m;\n    }\n    else if (rows > cols)\n    {\n        return selectColumns(m, new int[]{0});\n    }\n    else\n    {\n        return times(m, new Array2DRowRealMatrix(new double[][]{{1}}, false));\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    int n = m.getRowDimension();\n    if (m.getColumnDimension() == 1)\n    {\n        double[][] d = new double[n][n];\n        for (int i = 0; i < n; i++)\n        {\n            d[i][i] = m.getEntry(i, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n    else\n    {\n        double[][] d = new double[n][n];\n        for (int i = 0; i < n; i++)\n        {\n            d[i][i] = m.getEntry(i, i);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    int n = m.getColumnDimension();\n    if (m.getRowDimension() == 1)\n    {\n        return new Array2DRowRealMatrix(m.getData(), false);\n    }\n    else if (m.getColumnDimension() == 1)\n    {\n        double[][] d = new double[n][n];\n        for (int i = 0; i < n; i++)\n        {\n            d[i][i] = m.getEntry(i, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n    else\n    {\n        throw new IllegalArgumentException(\"Input matrix must be a column or row vector.\");\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    int rows = m.getRowDimension();\n    int cols = m.getColumnDimension();\n    if (rows > cols)\n    {\n        // m is a row matrix\n        double[][] d = new double[cols][cols];\n        for (int r = 0; r < rows; r++)\n        {\n            for (int c = 0; c < cols; c++)\n            {\n                d[c][c] = m.getEntry(r, c);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n    else\n    {\n        // m is a column matrix\n        double[][] d = new double[rows][rows];\n        for (int r = 0; r < rows; r++)\n        {\n            for (int c = 0; c < cols; c++)\n            {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    int rows = m.getRowDimension();\n    int cols = m.getColumnDimension();\n    double[][] d = new double[rows][cols];\n    for (int r = 0; r < rows; r++)\n    {\n        for (int c = 0; c < cols; c++)\n        {\n            if (r == c)\n            {\n                d[r][c] = m.getEntry(r, c);\n            }\n            else\n            {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1)\n    {\n        final double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++)\n        {\n            for (int c = 0; c < m.getRowDimension(); c++)\n            {\n                d[r][c] = r == c ? m.getEntry(r, 0) : 0;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n    else\n    {\n        final double[][] d = new double[m.getColumnDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getColumnDimension(); r++)\n        {\n            for (int c = 0; c < m.getColumnDimension(); c++)\n            {\n                d[r][c] = r == c ? m.getEntry(r, c) : 0;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) \n    {\n        final double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) \n        {\n            for (int c = 0; c < m.getRowDimension(); c++) \n            {\n                d[r][c] = m.getEntry(r, 0);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n    else \n    {\n        final double[][] d = new double[m.getColumnDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getColumnDimension(); r++) \n        {\n            for (int c = 0; c < m.getColumnDimension(); c++) \n            {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1)\n    {\n        final double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++)\n        {\n            for (int c = 0; c < m.getRowDimension(); c++)\n            {\n                d[r][c] = r == c ? m.getEntry(r, 0) : 0;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n    else\n    {\n        final double[][] d = new double[m.getColumnDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getColumnDimension(); r++)\n        {\n            for (int c = 0; c < m.getColumnDimension(); c++)\n            {\n                d[r][c] = r == c ? m.getEntry(r, c) : 0;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getRowDimension() == m.getColumnDimension())\n    {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++)\n        {\n            for (int c = 0; c < m.getColumnDimension(); c++)\n            {\n                if (r == c)\n                {\n                    d[r][c] = m.getEntry(r, c);\n                }\n                else\n                {\n                    d[r][c] = 0;\n                }\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n    else\n    {\n        final double[][] d = new double[m.getColumnDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getColumnDimension(); r++)\n        {\n            for (int c = 0; c < m.getColumnDimension(); c++)\n            {\n                if (r == c)\n                {\n                    d[r][c] = m.getEntry(r, c);\n                }\n                else\n                {\n                    d[r][c] = 0;\n                }\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}"
    ],
    [
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n            ++blockIndex;\n        }\n    }\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    final double[][] blocks = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            blocks[index] = new double[iHeight * blockWidth(jBlock)];\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    final double[][] blocks = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            blocks[index] = new double[iHeight * blockWidth(jBlock)];\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    final double[][] blocks = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            blocks[index] = new double[iHeight * blockWidth(jBlock)];\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    final double[][] blocks = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            final int jWidth = blockWidth(jBlock);\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[index] = block;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    final double[][] blocks = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            final int jWidth = blockWidth(jBlock);\n            blocks[index] = new double[iHeight * jWidth];\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    final double[][] blocks = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            blocks[index] = new double[iHeight * blockWidth(jBlock)];\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    final double[][] blocks = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            final int jWidth = blockWidth(jBlock);\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[index] = block;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}"
    ],
    [
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}"
    ],
    [
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        // try the cache\n        SoftReference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n        DateTimeZone zone = ref == null ? null : ref.get();\n        if (zone != null) {\n            return zone;\n        }\n        // parse the ID\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int offset = parseOffset(id);\n            zone = new FixedDateTimeZone(id, null, offset, offset);\n        } else {\n            zone = parseZoneInfo(id);\n        }\n        // cache the zone\n        iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n        return zone;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        // Check for fixed offset\n        if (id.length() > 3 && id.charAt(0) == '+' || id.charAt(0) == '-') {\n            return forOffsetHoursMinutes(Integer.parseInt(id.substring(1, 3)),\n                    Integer.parseInt(id.substring(4, 6)));\n        }\n        // Check for UTC\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        // Check for ID conversion\n        String converted = cZoneIdConversion.get(id);\n        if (converted != null) {\n            id = converted;\n        }\n        // Check the cache\n        SoftReference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n        DateTimeZone zone = ref == null ? null : ref.get();\n        if (zone == null) {\n            // Check the provider\n            zone = getProvider0().getZone(id);\n            if (zone == null) {\n                // Check the name provider\n                zone = getNameProvider0().getZone(id);\n            }\n            if (zone == null) {\n                // Check the available IDs\n                if (!cAvailableIDs.contains(id)) {\n                    throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n                }\n                // Create a fixed offset zone\n                zone = new FixedDateTimeZone(id, id, Integer.parseInt(id.substring(1, 3)),\n                        Integer.parseInt(id.substring(4, 6)));\n            }\n            // Cache the zone\n            iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n        }\n        return zone;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        // check the cache\n        SoftReference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n        DateTimeZone zone = ref == null ? null : ref.get();\n        if (zone == null) {\n            // create a new zone\n            zone = forIDImpl(id);\n            if (zone == null) {\n                throw new IllegalArgumentException(\"Invalid ID: \" + id);\n            }\n            // cache it\n            iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n        }\n        return zone;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        // parse offset\n        if (id.length() > 3 && id.charAt(0) == '+' || id.charAt(0) == '-') {\n            int offset = parseOffset(id);\n            return forOffsetMillis(offset);\n        }\n        // convert to old zone ID\n        String newId = cZoneIdConversion.get(id);\n        if (newId != null) {\n            id = newId;\n        }\n        // check cache\n        SoftReference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n        DateTimeZone zone = ref == null ? null : ref.get();\n        if (zone == null) {\n            // load zone\n            zone = new DateTimeZone(id);\n            iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n        }\n        return zone;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        DateTimeZone zone = cZoneIdConversion.get(id);\n        if (zone != null) {\n            return zone;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            return forOffsetHoursMinutes(Integer.parseInt(id.substring(0, 3)), Integer.parseInt(id.substring(3)));\n        }\n        if (id.startsWith(\"UTC+\") || id.startsWith(\"UTC-\")) {\n            return forOffsetHoursMinutes(Integer.parseInt(id.substring(4, 6)), Integer.parseInt(id.substring(6)));\n        }\n        if (id.startsWith(\"GMT+\") || id.startsWith(\"GMT-\")) {\n            return forOffsetHoursMinutes(Integer.parseInt(id.substring(4, 6)), Integer.parseInt(id.substring(6)));\n        }\n        if (id.startsWith(\"UT+\") || id.startsWith(\"UT-\")) {\n            return forOffsetHoursMinutes(Integer.parseInt(id.substring(3, 5)), Integer.parseInt(id.substring(5)));\n        }\n        if (id.startsWith(\"Etc/GMT+\") || id.startsWith(\"Etc/GMT-\")) {\n            return forOffsetHoursMinutes(Integer.parseInt(id.substring(10, 12)), Integer.parseInt(id.substring(12)));\n        }\n        if (id.startsWith(\"Etc/GMT0\") || id.startsWith(\"Etc/GMT\")) {\n            return forOffsetHours(Integer.parseInt(id.substring(9, 11)));\n        }\n        if (id.startsWith(\"Etc/GMT+\") || id.startsWith(\"Etc/GMT-\")) {\n            return forOffsetHoursMinutes(Integer.parseInt(id.substring(10, 12)), Integer.parseInt(id.substring(12)));\n        }\n}",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        // check the fixed offset cache\n        SoftReference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n        DateTimeZone zone = ref == null ? null : ref.get();\n        if (zone != null) {\n            return zone;\n        }\n        // check the zone id conversion cache\n        String conv = cZoneIdConversion.get(id);\n        if (conv != null) {\n            id = conv;\n        }\n        // check the available IDs\n        if (cAvailableIDs.contains(id)) {\n            zone = new DateTimeZone(id);\n            iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n            return zone;\n        }\n        // check the provider\n        if (cProvider != null) {\n            zone = cProvider.getZone(id);\n            if (zone != null) {\n                return zone;\n            }\n        }\n        // check the name provider\n        if (cNameProvider != null) {\n            zone = cNameProvider.getZone(id);\n            if (zone != null) {\n                return zone;\n            }\n        }\n        // check the offsets\n        int offset = parseOffset(id);\n        if (offset != Integer.MIN_VALUE) {\n            zone = new DateTimeZone(id, offset);\n            iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n            return zone;\n        }\n        // all failed\n        throw new IllegalArgumentException(\"Invalid ID: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            return forOffsetHoursMinutes(Integer.parseInt(id.substring(0, 3)), Integer.parseInt(id.substring(3)));\n        }\n        DateTimeZone zone = cZoneIdConversion.get(id);\n        if (zone == null) {\n            zone = cZoneIdConversion.get(id.toUpperCase(Locale.ENGLISH));\n        }\n        if (zone == null) {\n            zone = cZoneIdConversion.get(id.toLowerCase(Locale.ENGLISH));\n        }\n        if (zone == null) {\n            zone = cZoneIdConversion.get(id.replace(' ', '_'));\n        }\n        if (zone == null) {\n            zone = cZoneIdConversion.get(id.replace(' ', '-'));\n        }\n        if (zone == null) {\n            zone = cZoneIdConversion.get(id.replace(' ', '+'));\n        }\n        if (zone == null) {\n            zone = cZoneIdConversion.get(id.replace(' ', ':'));\n        }\n        if (zone == null) {\n            zone = cZoneIdConversion.get(id.replace(' ', '/'));\n        }\n        if (zone == null) {\n            zone = cZoneIdConversion.get(id.replace(' ', '.'));\n        }\n        if (zone == null) {\n            zone = cZoneIdConversion.get(id.replace(' ', ','));\n        }\n        if (zone == null) {\n            zone = cZoneIdConversion.get(id.replace(' ', '|'));\n        }\n        if (zone == null) {\n            zone = cZoneIdConversion.get(id.replace(' ', '\\\\'));\n        }\n        if (zone == null) {\n            zone = cZoneIdConversion.get(id.replace(' ', '^'));\n        }\n}",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        DateTimeZone zone = cZoneIdConversion.get(id);\n        if (zone == null) {\n            zone = cAvailableIDs.get(id);\n            if (zone == null) {\n                if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n                    zone = forOffsetHoursMinutes(Integer.parseInt(id.substring(0, 3)), Integer.parseInt(id.substring(3)));\n                } else {\n                    throw new IllegalArgumentException(\"Invalid ID: \" + id);\n                }\n            }\n        }\n        return zone;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        if (id.equals(\"Z\")) {\n            return UTC;\n        }\n        if (id.length() > 3 && id.charAt(0) == '+' && id.charAt(3) == ':') {\n            return forOffsetHoursMinutes(Integer.parseInt(id.substring(1, 3)), Integer.parseInt(id.substring(4, 6)));\n        }\n        if (id.length() > 3 && id.charAt(0) == '-' && id.charAt(3) == ':') {\n            return forOffsetHoursMinutes(Integer.parseInt(id.substring(1, 3)) * -1, Integer.parseInt(id.substring(4, 6)) * -1);\n        }\n        // check the cache\n        SoftReference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n        DateTimeZone zone = ref == null ? null : ref.get();\n        if (zone != null) {\n            return zone;\n        }\n        // parse the ID\n        int[] types = new int[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n        int[] values = new int[6];\n        int count = parseTimeZoneID(id, types, values);\n        if (count < 1) {\n            throw new IllegalArgumentException(\"Invalid ID: \" + id);\n        }\n        // create the zone\n        if (count == 1) {\n            zone = forOffsetHours(values[0]);\n        } else if (count == 2) {\n            zone = forOffsetHoursMinutes(values[0], values[1]);\n        } else {\n            zone = forID(id, values[0], values[1], values[2], values[3], values[4], values[5]);\n        }\n        // cache the zone\n        iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n        return zone;\n}",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        // try the fixed offset cache\n        if (id.length() > 3) {\n            int colon = id.indexOf(':');\n            if (colon >= 0 && id.charAt(0) == '+' || id.charAt(0) == '-') {\n                int offsetMillis = Integer.parseInt(id.substring(1, colon)) * 60 * 60 * 1000;\n                if (colon < id.length() - 3) {\n                    offsetMillis += Integer.parseInt(id.substring(colon + 1)) * 60 * 1000;\n                }\n                return forOffsetMillis(offsetMillis);\n            }\n        }\n        // try the zone ID conversion cache\n        String converted = cZoneIdConversion.get(id);\n        if (converted != null) {\n            return forID(converted);\n        }\n        // try the zone ID cache\n        SoftReference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n        DateTimeZone zone = ref == null ? null : ref.get();\n        if (zone == null) {\n            zone = loadZone(id);\n            if (zone != null) {\n                iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n            }\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"No DateTimeZone found for ID: \" + id);\n        }\n        return zone;\n    }"
    ],
    [
      "private Dfp multiplyFast(final int x)  {\n    Dfp result = newInstance(this);\n    int carry = 0;\n    for (int i = 0; i < mant.length; i++) {\n        int r = mant[i] * x + carry;\n        result.mant[i] = r % RADIX;\n        carry = r / RADIX;\n    }\n    result.mant[mant.length] = carry;\n    result.exp = exp + 1;\n    result.sign = (byte)((sign == 1)?1:-1);\n    result.nans = FINITE;\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n        Dfp result = newInstance(this);\n\n        if (x == 0) {\n            result.setZero();\n            return result;\n        }\n\n        if (x == 1) {\n            return result;\n        }\n\n        if (x == -1) {\n            result.sign = (byte) (sign * -1);\n            return result;\n        }\n\n        if (x == RADIX) {\n            result.sign = (byte) (sign * -1);\n            result.exp++;\n            return result;\n        }\n\n        if (x == -RADIX) {\n            result.exp++;\n            return result;\n        }\n\n        // Special case for powers of 2\n        if ((x & (x - 1)) == 0) {\n            result.exp += Integer.numberOfTrailingZeros(x);\n            return result;\n        }\n\n        // Special case for powers of 10\n        if ((x % 2) == 0) {\n            int exp = Integer.numberOfTrailingZeros(x);\n            result.exp += exp;\n            return result;\n        }\n\n        // General case\n        result.mant[mant.length - 1] = mant[mant.length - 1] * x;\n        for (int i = mant.length - 2; i >= 0; i--) {\n            int rh = 0;\n            for (int j = 0; j < mant.length; j++) {\n                int r = result.mant[i + j] + mant[i] * x;\n                r = r + rh;\n                rh = r / RADIX;\n                result.mant[i + j] = r - rh * RADIX;\n            }\n            result.mant[i] = rh;\n        }\n\n        // Find the most sig digit\n        int md = mant.length - 1;  // default, in case result is zero\n        for (int i = mant.length - 1; i >= 0; i--) {\n            if (result.mant[i] != 0) {\n                md = i;\n                break;\n}\n}\n}",
      "private Dfp multiplyFast(final int x)  {\n        // handle special cases\n        if (nans == INFINITE) {\n            if (x == 0) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, this, this);\n            }\n            if (x == 1) {\n                return newInstance(this);\n            }\n            if (x == RADIX-1) {\n                return newInstance(this);\n            }\n        }\n\n        if (x == 0) {\n            return getZero();\n        }\n\n        if (x == 1) {\n            return newInstance(this);\n        }\n\n        if (x == RADIX-1) {\n            return newInstance(this);\n        }\n\n        // handle special cases\n        if (nans == QNAN || x == 0) {\n            return newInstance(this);\n        }\n\n        if (x == 1) {\n            return newInstance(this);\n        }\n\n        if (x == RADIX-1) {\n            return newInstance(this);\n        }\n\n        // handle special cases\n        if (nans == INFINITE && x < RADIX) {\n            return newInstance(this);\n        }\n\n        if (x < RADIX && nans == INFINITE) {\n            return newInstance(this);\n        }\n\n        if (x == 0) {\n            return getZero();\n        }\n\n        if (x == 1) {\n            return newInstance(this);\n        }\n\n        if (x == RADIX-1) {\n            return newInstance(this);\n        }\n\n        // handle special cases\n        if (nans == QNAN || x == 0) {\n            return newInstance(this);\n        }\n\n        if (x == 1) {\n            return newInstance(this);\n        }\n\n        if (x == RADIX-1) {\n            return newInstance(this);\n        }\n\n        // handle special cases\n}",
      "private Dfp multiplyFast(final int x)  {\n        if (x == 0) {\n            return getZero();\n        }\n\n        if (x == 1) {\n            return newInstance(this);\n        }\n\n        if (x == -1) {\n            return newInstance(this).negate();\n        }\n\n        if (x == RADIX) {\n            return newInstance(this).add(newInstance(1));\n        }\n\n        if (x == -RADIX) {\n            return newInstance(this).subtract(newInstance(1));\n        }\n\n        // Special case for powers of two\n        if (x == 2) {\n            return newInstance(this).shiftLeft(1);\n        }\n\n        if (x == -2) {\n            return newInstance(this).shiftRight(1);\n        }\n\n        if (x == 4) {\n            return newInstance(this).shiftLeft(2);\n        }\n\n        if (x == -4) {\n            return newInstance(this).shiftRight(2);\n        }\n\n        if (x == 8) {\n            return newInstance(this).shiftLeft(3);\n        }\n\n        if (x == -8) {\n            return newInstance(this).shiftRight(3);\n        }\n\n        if (x == 16) {\n            return newInstance(this).shiftLeft(4);\n        }\n\n        if (x == -16) {\n            return newInstance(this).shiftRight(4);\n        }\n\n        if (x == 32) {\n            return newInstance(this).shiftLeft(5);\n        }\n\n        if (x == -32) {\n            return newInstance(this).shiftRight(5);\n        }\n\n        if (x == 64) {\n            return newInstance(this).shiftLeft(6);\n        }\n\n        if (x == -64) {\n            return newInstance(this).shiftRight(6);\n        }\n\n        if (x == 128) {\n            return newInstance(this).shiftLeft(7);\n        }\n\n}",
      "private Dfp multiplyFast(final int x)  {\n        if (x == 0) {\n            return getZero();\n        }\n\n        if (x == 1) {\n            return newInstance(this);\n        }\n\n        if (x == -1) {\n            return newInstance(this).negate();\n        }\n\n        if (x == RADIX) {\n            return newInstance(this).shiftLeft(1);\n        }\n\n        if (x == 10) {\n            return newInstance(this).shiftLeft(3);\n        }\n\n        if (x == 100) {\n            return newInstance(this).shiftLeft(6);\n        }\n\n        if (x == RADIX/2) {\n            return newInstance(this).shiftRight(1);\n        }\n\n        if (x == RADIX/10) {\n            return newInstance(this).shiftRight(3);\n        }\n\n        if (x == RADIX/100) {\n            return newInstance(this).shiftRight(6);\n        }\n\n        if (x == RADIX/2 + 1) {\n            return newInstance(this).shiftRight(1).add(1);\n        }\n\n        if (x == RADIX/10 + 1) {\n            return newInstance(this).shiftRight(3).add(1);\n        }\n\n        if (x == RADIX/100 + 1) {\n            return newInstance(this).shiftRight(6).add(1);\n        }\n\n        return multiplyFast0(x);\n    }",
      "private Dfp multiplyFast(final int x)  {\n    Dfp result = newInstance(this);\n    result.sign = (byte) (sign * x);\n    if (x == 0) {\n        result.nans = FINITE;\n        result.exp = 0;\n        result.mant[0] = 0;\n        return result;\n    }\n    int carry = 0;\n    for (int i = 0; i < mant.length; i++) {\n        int r = mant[i] * x + carry;\n        result.mant[i] = r % RADIX;\n        carry = r / RADIX;\n    }\n    result.mant[mant.length] = carry;\n    result.exp = exp + 1;\n    result.nans = FINITE;\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    Dfp result = newInstance(this);\n    int carry = 0;\n    for (int i = 0; i < mant.length; i++) {\n        int r = mant[i] * x + carry;\n        result.mant[i] = r % RADIX;\n        carry = r / RADIX;\n    }\n    result.mant[mant.length] = carry;\n    result.exp = exp + mant.length;\n    result.sign = (byte)((sign == x)?1:-1);\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n        Dfp result = newInstance(this);\n\n        if (x == 0) {\n            result.sign = 1;\n            result.exp = 0;\n            result.nans = FINITE;\n            return result;\n        }\n\n        if (x == 1) {\n            return this;\n        }\n\n        if (x == -1) {\n            result.sign = (byte) -sign;\n            return result;\n        }\n\n        if (x == RADIX) {\n            result.sign = (byte) sign;\n            result.exp = exp + 1;\n            result.nans = FINITE;\n            return result;\n        }\n\n        if (x == -RADIX) {\n            result.sign = (byte) -sign;\n            result.exp = exp + 1;\n            result.nans = FINITE;\n            return result;\n        }\n\n        if (nans == INFINITE) {\n            result.sign = (byte) (sign * x);\n            result.nans = INFINITE;\n            return result;\n        }\n\n        if (x == INFINITE) {\n            result.sign = (byte) (sign * x);\n            result.nans = INFINITE;\n            return result;\n        }\n\n        if (x == QNAN) {\n            result.nans = QNAN;\n            return result;\n        }\n\n        if (x == SNAN) {\n            result.nans = SNAN;\n            return result;\n        }\n\n        // x is finite\n        result.sign = (byte) (sign * x);\n        result.nans = FINITE;\n\n        if (x == 0) {\n            result.exp = 0;\n            result.mant[0] = 0;\n            return result;\n        }\n\n        if (x == 1) {\n            result.exp = exp;\n            System.arraycopy(mant, 0, result.mant, 0, mant.length);\n            return result;\n        }\n\n        if (x == -1) {\n}\n}",
      "private Dfp multiplyFast(final int x)  {\n        Dfp result = newInstance(this);\n        result.sign = (byte) (sign * x);\n\n        // Check for special cases\n        if (nans == INFINITE) {\n            if (x == 0) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n                return result;\n            }\n            if (x == 1) {\n                return result;\n            }\n            if (x == -1) {\n                result.sign = (byte) -sign;\n                return result;\n            }\n            if (x == RADIX-1) {\n                result.exp = exp + 1;\n                result.mant[0] = 1;\n                return result;\n            }\n            if (x == RADIX-2) {\n                result.exp = exp + 1;\n                result.mant[0] = 1;\n                result.mant[1] = 1;\n                return result;\n            }\n            if (x == RADIX-3) {\n                result.exp = exp + 1;\n                result.mant[0] = 1;\n                result.mant[1] = 2;\n                return result;\n            }\n            if (x == RADIX-4) {\n                result.exp = exp + 1;\n                result.mant[0] = 1;\n                result.mant[1] = 3;\n                return result;\n            }\n            if (x == RADIX-5) {\n                result.exp = exp + 1;\n                result.mant[0] = 1;\n                result.mant[1] = 4;\n                return result;\n            }\n            if (x == RADIX-6) {\n                result.exp = exp + 1;\n                result.mant[0] = 1;\n                result.mant[1] = 5;\n}\n}\n}",
      "private Dfp multiplyFast(final int x)  {\n    Dfp result = newInstance(this);\n    int carry = 0;\n    for (int i = 0; i < mant.length; i++) {\n        int r = mant[i] * x + carry;\n        result.mant[i] = r % RADIX;\n        carry = r / RADIX;\n    }\n    result.mant[mant.length] = carry;\n    result.exp = exp + 1;\n    result.sign = (byte)((sign == 1)?1:-1);\n    return result;\n}"
    ],
    [
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new HashMap<K, V>();\n        for (final Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = createMap(map.size());\n        for (final Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        final Map<K, V> result = (Map<K, V>) map;\n        final Transformer<? super K, ? extends K> keyTransformer = this.keyTransformer;\n        final Transformer<? super V, ? extends V> valueTransformer = this.valueTransformer;\n        if (keyTransformer != null || valueTransformer != null) {\n            for (final Iterator<? extends Map.Entry<? extends K, ? extends V>> it = map.entrySet().iterator(); it.hasNext(); ) {\n                final Map.Entry<? extends K, ? extends V> entry = it.next();\n                K key = entry.getKey();\n                V value = entry.getValue();\n                if (keyTransformer != null) {\n                    key = keyTransformer.transform(key);\n                }\n                if (valueTransformer != null) {\n                    value = valueTransformer.transform(value);\n                }\n                result.put(key, value);\n            }\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        final Map<K, V> transformed = new HashMap<K, V>();\n        for (final Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            transformed.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return transformed;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        final Map<K, V> transformed = (Map<K, V>) map;\n        final Transformer<? super K, ? extends K> keyTransformer = this.keyTransformer;\n        final Transformer<? super V, ? extends V> valueTransformer = this.valueTransformer;\n        if (keyTransformer != null || valueTransformer != null) {\n            final Map<K, V> result = new HashMap<K, V>();\n            for (final Map.Entry<? extends K, ? extends V> entry : transformed.entrySet()) {\n                final K key = transformKey(entry.getKey());\n                final V value = transformValue(entry.getValue());\n                result.put(key, value);\n            }\n            return result;\n        }\n        return transformed;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        final Map<K, V> result = (Map<K, V>) map;\n        if (keyTransformer != null || valueTransformer != null) {\n            final Set<Map.Entry<? extends K, ? extends V>> entrySet = map.entrySet();\n            for (final Map.Entry<? extends K, ? extends V> entry : entrySet) {\n                final K key = transformKey(entry.getKey());\n                final V value = transformValue(entry.getValue());\n                result.put(key, value);\n            }\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        final Map<K, V> result = new HashMap<K, V>();\n        for (final Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        final Map<K, V> result = (Map<K, V>) map;\n        if (keyTransformer != null) {\n            for (final Iterator<K> it = result.keySet().iterator(); it.hasNext(); ) {\n                final K key = it.next();\n                it.set(transformKey(key));\n            }\n        }\n        if (valueTransformer != null) {\n            for (final Iterator<V> it = result.values().iterator(); it.hasNext(); ) {\n                final V value = it.next();\n                it.set(transformValue(value));\n            }\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        final Map<K, V> result = new HashMap<K, V>();\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new HashMap<K, V>(map.size());\n        for (final Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            final K key = transformKey(entry.getKey());\n            final V value = transformValue(entry.getValue());\n            result.put(key, value);\n        }\n        return result;\n    }"
    ],
    [
      "private Node createExternFunction(Node exportedFunction)  {\n  Node function = NodeUtil.newFunctionNode(\n      exportedFunction.getFirstChild().cloneNode(),\n      exportedFunction.getLastChild().cloneNode());\n\n  NodeUtil.addFeatureToScript(\n      compiler.getScriptNode(), Feature.ES_NEXT_FUNCTIONS);\n\n  NodeUtil.markFunctionsDeleted(function, compiler);\n\n  return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node function = NodeUtil.newFunctionNode(exportedFunction.getFirstChild().cloneTree());\n  function.getFirstChild().setIsExtern(true);\n  NodeUtil.setFunctionLends(function, null);\n  NodeUtil.setFunctionTypeI(function, null);\n  return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Preconditions.checkState(exportedFunction.isFunction());\n\n  Node externFunction = IR.function(\n      IR.name(exportedFunction.getFirstChild().getString()),\n      IR.paramList(),\n      IR.block());\n\n  externFunction.setJSDocInfo(exportedFunction.getJSDocInfo());\n\n  return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node function = IR.function(exportedFunction.getFirstChild().cloneNode());\n  Node paramList = exportedFunction.getSecondChild();\n  if (paramList != null) {\n    function.addChildToFront(paramList.cloneNode());\n  }\n\n  Node returnType = exportedFunction.getLastChild();\n  if (returnType != null) {\n    function.addChildToBack(returnType.cloneNode());\n  }\n\n  NodeUtil.addFeatureToScript(\n      compiler, function, Feature.EXPORT_DEFAULT);\n\n  return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Preconditions.checkState(exportedFunction.isFunction());\n\n  Node externFunction = IR.function(exportedFunction.getFirstChild().cloneNode());\n\n  Node paramList = exportedFunction.getSecondChild();\n  for (Node param : paramList.children()) {\n    externFunction.getSecondChild().addChildToBack(param.cloneNode());\n  }\n\n  Node returnType = exportedFunction.getLastChild();\n  if (returnType.isEmpty()) {\n    compiler.report(JSError.make(exportedFunction,\n        RhinoErrorReporter.BAD_JSDOC_ANNOTATION));\n  } else {\n    externFunction.addChildToBack(returnType.cloneNode());\n  }\n\n  return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node externFunction = NodeUtil.newFunctionNode(\n      exportedFunction.getFirstChild().cloneTree());\n\n  // Make sure that the function has a return type.\n  if (externFunction.getJSDocInfo() == null\n      || externFunction.getJSDocInfo().getReturnType() == null) {\n    compiler.report(JSError.make(exportedFunction,\n        EXTERNS_MISSING_RETURN_TYPE));\n  }\n\n  // Make sure that the function has a parameter type.\n  Node paramList = externFunction.getSecondChild();\n  for (Node param : paramList.children()) {\n    if (param.getJSDocInfo() == null\n        || param.getJSDocInfo().getType() == null) {\n      compiler.report(JSError.make(exportedFunction,\n          EXTERNS_MISSING_PARAM_TYPE, param.getString()));\n    }\n  }\n\n  return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node externFunction = IR.function(exportedFunction.getFirstChild().cloneNode());\n  externFunction.setJSDocInfo(createExternFunctionJSDoc(exportedFunction));\n  return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node externFunction = IR.function(exportedFunction.getFirstChild().cloneNode());\n\n  // Copy over the parameter names\n  for (Node param : exportedFunction.getSecondChild().children()) {\n    externFunction.getSecondChild().addChildToBack(param.cloneNode());\n  }\n\n  // Copy over the return type\n  if (exportedFunction.getJSDocInfo() != null\n      && exportedFunction.getJSDocInfo().getReturnType() != null) {\n    externFunction.setJSDocInfo(\n        new JSDocInfo(exportedFunction.getJSDocInfo().getReturnType()));\n  } else {\n    compiler.report(\n        JSError.make(exportedFunction,\n            RhinoErrorReporter.MISSING_RETURN_TYPE));\n  }\n\n  return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Preconditions.checkState(exportedFunction.isFunction());\n  Node externFunction = NodeUtil.newFunctionNode(\n      exportedFunction.getFirstChild().cloneNode(),\n      exportedFunction.getSecondChild().cloneNode());\n\n  if (exportedFunction.getJSDocInfo() == null) {\n    compiler.report(\n        JSError.make(exportedFunction, EXTERNS_MISSING_PARAM_OR_RETURN));\n  }\n\n  return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node functionNode = NodeUtil.newFunctionNode(exportedFunction.getFirstChild().cloneTree());\n  functionNode.setJSDocInfo(NodeUtil.getBestJSDocInfo(exportedFunction));\n  NodeUtil.markFunctionsDeleted(functionNode, null);\n  return functionNode;\n}"
    ],
    [
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    // Compute the covariance matrix.\n    double[][] covariances = computeCovariances(params,\n                                                covarianceSingularityThreshold);\n\n    // Extract the square root of the diagonal coefficients.\n    double[] sigmas = new double[covariances.length];\n    for (int i = 0; i < covariances.length; i++) {\n        sigmas[i] = FastMath.sqrt(covariances[i][i]);\n    }\n\n    return sigmas;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    final double[][] covariances = computeCovariances(params,\n                                                      covarianceSingularityThreshold);\n    final double[] sigma = new double[covariances.length];\n    for (int i = 0; i < covariances.length; i++) {\n        sigma[i] = FastMath.sqrt(covariances[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    // Compute the covariances matrix.\n    final double[][] covariances = computeCovariances(params,\n            covarianceSingularityThreshold);\n\n    // Extract the diagonal coefficients.\n    final double[] sigma = new double[covariances.length];\n    for (int i = 0; i < covariances.length; i++) {\n        sigma[i] = FastMath.sqrt(covariances[i][i]);\n    }\n\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    // Compute the covariances matrix.\n    final double[][] covariances = computeCovariances(params,\n            covarianceSingularityThreshold);\n\n    // Extract the diagonal coefficients.\n    final double[] sigma = new double[params.length];\n    for (int i = 0; i < params.length; i++) {\n        sigma[i] = FastMath.sqrt(covariances[i][i]);\n    }\n\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    final double[][] covariances = computeCovariances(params,\n                                                      covarianceSingularityThreshold);\n    final double[] sigma = new double[covariances.length];\n    for (int i = 0; i < covariances.length; ++i) {\n        sigma[i] = FastMath.sqrt(covariances[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    // Compute the covariance matrix.\n    final double[][] covariances = computeCovariances(params,\n            covarianceSingularityThreshold);\n\n    // Extract the diagonal coefficients.\n    final double[] sigmas = new double[params.length];\n    for (int i = 0; i < sigmas.length; ++i) {\n        sigmas[i] = FastMath.sqrt(covariances[i][i]);\n    }\n\n    return sigmas;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    // Compute the covariance matrix.\n    final double[][] covariances = computeCovariances(params,\n                                                      covarianceSingularityThreshold);\n\n    // Extract the diagonal coefficients.\n    final double[] sigma = new double[covariances.length];\n    for (int i = 0; i < covariances.length; i++) {\n        sigma[i] = FastMath.sqrt(covariances[i][i]);\n    }\n\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    // Compute the covariance matrix.\n    final double[][] covariances = computeCovariances(params,\n            covarianceSingularityThreshold);\n\n    // Extract the square root of the diagonal coefficients.\n    final double[] sigmas = new double[covariances.length];\n    for (int i = 0; i < covariances.length; i++) {\n        sigmas[i] = FastMath.sqrt(covariances[i][i]);\n    }\n\n    return sigmas;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    // Compute the covariance matrix.\n    double[][] covariances = computeCovariances(params,\n                                                covarianceSingularityThreshold);\n\n    // Extract the square roots of the diagonal coefficients.\n    double[] sigmas = new double[covariances.length];\n    for (int i = 0; i < covariances.length; i++) {\n        sigmas[i] = FastMath.sqrt(covariances[i][i]);\n    }\n\n    return sigmas;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    // Compute the covariances matrix.\n    final double[][] covariances = computeCovariances(params,\n                                                      covarianceSingularityThreshold);\n\n    // Extract the diagonal coefficients.\n    final double[] sigma = new double[covariances.length];\n    for (int i = 0; i < covariances.length; ++i) {\n        sigma[i] = FastMath.sqrt(covariances[i][i]);\n    }\n\n    return sigma;\n}"
    ],
    [
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalStateException(\"Cyclic variable substitution for \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    for (int i = 0; i < priorVariables.size(); i++) \n    {\n        if (priorVariables.get(i).equals(varName)) \n        {\n            throw new IllegalStateException(\"Cyclic variable substitution\");\n        }\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    for (int i = 0; i < priorVariables.size(); i++) {\n        if (priorVariables.get(i).equals(varName)) {\n            throw new IllegalStateException(\"Cyclic substitution of variable \" + varName);\n        }\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalStateException(\"Cyclic variable substitution\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    for (final String priorVarName : priorVariables) {\n        if (priorVarName.equals(varName)) {\n            throw new IllegalStateException(\"Cyclic substitution of variable '\"\n                    + varName + \"'\");\n        }\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalStateException(\"Cyclic variable substitution detected: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalStateException(\"Cyclic variable substitution\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalStateException(\"Variable '\" + varName + \"' has been referenced before in the substitution chain\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    for (final String priorVar : priorVariables) {\n        if (priorVar.equals(varName)) {\n            throw new IllegalStateException(\"Cyclic variable substitution for \" + varName);\n        }\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    for (int i = priorVariables.size() - 1; i >= 0; i--) {\n        if (varName.equals(priorVariables.get(i))) {\n            throw new IllegalStateException(\"Cyclic variable substitution for \" + varName);\n        }\n    }\n}"
    ],
    [
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    // Step 1: Find all the inputs that are reachable from the roots.\n    Set<INPUT> reachable = Sets.newHashSet();\n    Queue<INPUT> toVisit = Queues.newArrayDeque();\n    toVisit.addAll(roots);\n    while (!toVisit.isEmpty()) {\n        INPUT current = toVisit.remove();\n        if (reachable.add(current)) {\n            for (INPUT dependency : deps.get(current)) {\n                toVisit.add(dependency);\n            }\n        }\n    }\n\n    // Step 2: Find all the inputs that are not reachable from the roots.\n    Set<INPUT> unreachable = Sets.newHashSet();\n    for (INPUT input : inputs) {\n        if (!reachable.contains(input)) {\n            unreachable.add(input);\n        }\n    }\n\n    // Step 3: If we want to get them in a stable order, sort them.\n    if (sorted) {\n        // Sort the inputs by their topological order.\n        List<INPUT> sorted = Lists.newArrayList();\n        for (INPUT input : inputs) {\n            if (reachable.contains(input)) {\n                sorted.add(input);\n            }\n        }\n        return sorted;\n    } else {\n        // Just return the inputs in the order they were passed to the compiler.\n        return Lists.newArrayList(inputs);\n    }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  // The set of inputs that are known to be dependencies of the roots.\n  Set<INPUT> deps = Sets.newHashSet();\n\n  // The set of inputs that are known to be dependencies of the roots, but\n  // have not yet been processed.\n  Set<INPUT> toProcess = Sets.newHashSet();\n\n  // The set of inputs that are known to be dependencies of the roots, but\n  // have not yet been processed.\n  Set<INPUT> processed = Sets.newHashSet();\n\n  // The list of inputs that are dependencies of the roots, in the order\n  // they were passed to the compiler.\n  List<INPUT> result = Lists.newArrayList();\n\n  // Add the roots to the set of inputs that are known to be dependencies\n  // of the roots.\n  toProcess.addAll(roots);\n\n  // While there are still inputs to process, keep processing them.\n  while (!toProcess.isEmpty()) \n  {\n    // Get the next input to process.\n    INPUT input = toProcess.iterator().next();\n\n    // Remove the input from the set of inputs that are known to be\n    // dependencies of the roots.\n    toProcess.remove(input);\n\n    // Add the input to the set of inputs that have been processed.\n    processed.add(input);\n\n    // Add the input to the list of inputs that are dependencies of the\n    // roots, in the order they were passed to the compiler.\n    result.add(input);\n\n    // Add the inputs that require the input to the set of inputs that\n    // are known to be dependencies of the roots.\n    for (INPUT require : input.getRequires()) \n    {\n      if (!processed.contains(require)) \n      {\n        toProcess.add(require);\n      }\n    }\n  }\n\n  // If the inputs are to be sorted, sort the list of inputs that are\n  // dependencies of the roots.\n  if (sorted) \n  {\n    Collections.sort(result, new Comparator<INPUT>() \n    {\n}\n}\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  // Get the list of all inputs.\n  Set<INPUT> inputs = Sets.newHashSet();\n  for (INPUT root : roots) \n  {\n    inputs.add(root);\n    inputs.addAll(getDependenciesOf(root));\n  }\n\n  // Get the list of all dependencies.\n  Multimap<INPUT, INPUT> deps = LinkedHashMultimap.create();\n  for (INPUT input : inputs) \n  {\n    for (String symbol : input.getRequires()) \n    {\n      INPUT provider = provideMap.get(symbol);\n      if (provider != null) \n      {\n        deps.put(input, provider);\n      }\n    }\n  }\n\n  // Get the list of all dependencies.\n  List<INPUT> dependencies = Lists.newArrayList();\n  for (INPUT input : inputs) \n  {\n    dependencies.addAll(getDependenciesOf(input, deps));\n  }\n\n  // Sort the dependencies.\n  if (sorted) \n  {\n    dependencies = Ordering.from(new Comparator<INPUT>() \n    {\n}\n}\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  // TODO: Implement this function\n  return null;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    // TODO: Implement this function\n    return null;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> inputs = Lists.newArrayList();\n    Set<INPUT> seen = Sets.newHashSet();\n    Queue<INPUT> queue = Lists.newLinkedList();\n    for (INPUT root : roots) {\n        queue.add(root);\n    }\n    while (!queue.isEmpty()) {\n        INPUT input = queue.poll();\n        if (seen.add(input)) {\n            inputs.add(input);\n            for (INPUT dep : deps.get(input)) {\n                queue.add(dep);\n            }\n        }\n    }\n    if (sorted) {\n        return topologicallySort(inputs);\n    } else {\n        return inputs;\n    }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    // Get the subgraph of the roots.\n    Set<INPUT> subGraph = Sets.newHashSet(roots);\n\n    // Get the subgraph of the dependencies of the roots.\n    Set<INPUT> subGraphDeps = Sets.newHashSet();\n    for (INPUT input : subGraph) \n    {\n        for (String symbol : input.getRequires()) \n        {\n            INPUT candidate = provideMap.get(symbol);\n            if (subGraph.contains(candidate)) \n            {\n                subGraphDeps.add(candidate);\n            }\n        }\n    }\n\n    // Get the dependencies of the subgraph of the dependencies of the roots.\n    Set<INPUT> deps = Sets.newHashSet();\n    for (INPUT input : subGraphDeps) \n    {\n        for (String symbol : input.getRequires()) \n        {\n            INPUT candidate = provideMap.get(symbol);\n            if (subGraph.contains(candidate)) \n            {\n                deps.add(candidate);\n            }\n        }\n    }\n\n    // Add the subgraph of the roots to the dependencies.\n    deps.addAll(subGraph);\n\n    // If we want to sort them, do so.\n    if (sorted) \n    {\n        // Create a list of the inputs.\n        List<INPUT> inputs = Lists.newArrayList(deps);\n\n        // Sort them.\n        Collections.sort(inputs, new Comparator<INPUT>() \n        {\n}\n}\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    // Get all the inputs that we need to traverse.\n    Set<INPUT> inputs = Sets.newHashSet();\n    for (INPUT root : roots) {\n        inputs.add(root);\n    }\n\n    // Get all the dependencies of the inputs.\n    Multimap<INPUT, INPUT> deps = ArrayListMultimap.create();\n    for (INPUT input : inputs) {\n        for (String symbol : input.getRequires()) {\n            INPUT provider = provideMap.get(symbol);\n            if (provider != null) {\n                deps.put(provider, input);\n            }\n        }\n    }\n\n    // Find the cycles.\n    List<List<INPUT>> cycles = Lists.newArrayList();\n    for (INPUT input : inputs) {\n        try {\n            List<INPUT> cycle = findCycle(inputs, deps);\n            if (cycle.size() > 0) {\n                cycles.add(cycle);\n            }\n        } catch (MissingProvideException e) {\n            // Ignore this input.\n        }\n    }\n\n    // If there are no cycles, we're done.\n    if (cycles.size() == 0) {\n        return sorted ? sortedList : Lists.newArrayList(inputs);\n    }\n\n    // Sort the cycles.\n    List<List<INPUT>> sortedCycles = Lists.newArrayList();\n    for (List<INPUT> cycle : cycles) {\n        sortedCycles.add(Lists.newArrayList(cycle));\n    }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> inputs = Lists.newArrayList();\n    Multimap<INPUT, INPUT> deps = HashMultimap.create();\n    for (INPUT input : roots) {\n        inputs.add(input);\n        for (String symbol : input.getProvides()) {\n            deps.put(provideMap.get(symbol), input);\n        }\n    }\n\n    // Build the list of all inputs in topological order.\n    List<INPUT> sortedList = Lists.newArrayList();\n    while (!inputs.isEmpty()) {\n        List<INPUT> cycle = findCycle(inputs, deps);\n        if (cycle != null) {\n            throw new IllegalStateException(\n                \"cycle found: \" + cycleToString(cycle));\n        }\n        sortedList.add(inputs.remove(0));\n    }\n\n    if (sorted) {\n        // Sort the list so that inputs that don't depend on each other come\n        // first.\n}\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    // Create a list of all the inputs.\n    List<INPUT> allInputs = Lists.newArrayList();\n    for (INPUT root : roots) \n    {\n        allInputs.add(root);\n    }\n\n    // Create a map of inputs to their dependencies.\n    Multimap<INPUT, INPUT> deps = HashMultimap.create();\n    for (INPUT input : allInputs) \n    {\n        for (String symbol : input.getRequires()) \n        {\n            INPUT dependency = provideMap.get(symbol);\n            deps.put(input, dependency);\n        }\n    }\n\n    // Create a list of inputs to return.\n    List<INPUT> inputsToReturn = Lists.newArrayList();\n\n    // Add all the roots to the list of inputs to return.\n    for (INPUT root : roots) \n    {\n        inputsToReturn.add(root);\n    }\n\n    // While there are still inputs that need to be added.\n    while (!inputsToReturn.isEmpty()) \n    {\n        // Get the next input to add.\n        INPUT nextInput = inputsToReturn.remove(0);\n\n        // Add all of its dependencies that haven't already been added.\n        for (INPUT dependency : deps.get(nextInput)) \n        {\n            if (!inputsToReturn.contains(dependency)) \n            {\n                inputsToReturn.add(dependency);\n            }\n        }\n    }\n\n    // If we want them in a stable order, sort them.\n    if (sorted) \n    {\n        Collections.sort(inputsToReturn, new Comparator<INPUT>() \n        {\n}\n}\n}"
    ],
    [
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    int index = 0;\n    while (index < buffer.length) \n    {\n        if (index == 0 || (delimLen != 0 && Character.isWhitespace(buffer[index - 1]) && !Character.isWhitespace(buffer[index]))) \n        {\n            buffer[index] = Character.toLowerCase(buffer[index]);\n        }\n        index++;\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (Character.isWhitespace(ch)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        } \n        else if (delimLen != 0 && isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    int index = 0;\n    while (index < buffer.length) \n    {\n        final char ch = buffer[index];\n        if (Character.isWhitespace(ch) || (delimLen > 0 && isDelimiter(ch, delimiters))) \n        {\n            index++;\n            continue;\n        }\n        if (Character.isUpperCase(ch)) \n        {\n            buffer[index] = Character.toLowerCase(ch);\n        }\n        index++;\n        while (index < buffer.length) \n        {\n            if (Character.isWhitespace(buffer[index]) || (delimLen > 0 && isDelimiter(buffer[index], delimiters))) \n            {\n                break;\n            }\n            index++;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    int index = 0;\n    while (index < buffer.length) \n    {\n        final char ch = buffer[index];\n        if (Character.isWhitespace(ch) || (delimLen > 0 && isDelimiter(ch, delimiters))) \n        {\n            index++;\n            continue;\n        }\n        if (Character.isUpperCase(ch)) \n        {\n            buffer[index] = Character.toLowerCase(ch);\n        }\n        index++;\n        while (index < buffer.length) \n        {\n            if (Character.isWhitespace(buffer[index]) || (delimLen > 0 && isDelimiter(buffer[index], delimiters))) \n            {\n                break;\n            }\n            index++;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    int index = 0;\n    while (index < buffer.length) \n    {\n        final char ch = buffer[index];\n        if (Character.isWhitespace(ch) || index == 0 && !Character.isWhitespace(ch)) \n        {\n            index++;\n            continue;\n        }\n        else \n        {\n            final int newIndex = index + 1;\n            if (index != 0 && newIndex < buffer.length) \n            {\n                final char c = buffer[newIndex];\n                if (Character.isWhitespace(c) || indexOf(delimiters, c, delimLen) >= 0) \n                {\n                    buffer[index] = Character.toLowerCase(ch);\n                    index = newIndex;\n                    continue;\n                }\n            }\n        }\n        index++;\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    int index = 0;\n    while (index < buffer.length) \n    {\n        final char ch = buffer[index];\n        if (Character.isWhitespace(ch) || index == 0 && !Character.isWhitespace(ch)) \n        {\n            index++;\n            continue;\n        }\n        else \n        {\n            if (index > 0 && delimLen != 0) \n            {\n                final int lastUnchanged = index - 1;\n                final int curr = index - 1;\n                while (lastUnchanged >= 0 && !Character.isWhitespace(buffer[lastUnchanged]) && !ArrayUtils.contains(delimiters, buffer[lastUnchanged])) \n                {\n                    lastUnchanged--;\n                }\n                if (lastUnchanged == -1) \n                {\n                    index = curr + 1;\n                    continue;\n                }\n            }\n            buffer[index] = Character.toLowerCase(ch);\n            index++;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    int index = 0;\n    while (index < buffer.length) \n    {\n        if (Character.isWhitespace(buffer[index])) \n        {\n            index++;\n        } \n        else \n        {\n            boolean capitalizeNext = true;\n            if (index > 0 && delimLen > 0) \n            {\n                for (int delimIndex = 0; delimIndex < delimLen; delimIndex++) \n                {\n                    if (buffer[index - 1] == delimiters[delimIndex]) \n                    {\n                        capitalizeNext = false;\n                        break;\n                    }\n                }\n            }\n            if (capitalizeNext) \n            {\n                buffer[index] = Character.toLowerCase(buffer[index]);\n            }\n            index++;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (Character.isWhitespace(ch)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        } \n        else if (delimLen != 0 && isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    int index = 0;\n    while (index < buffer.length) \n    {\n        if (index == 0 || isDelimiter(buffer, index - 1, delimiters)) \n        {\n            if (Character.isUpperCase(buffer[index])) \n            {\n                buffer[index] = Character.toLowerCase(buffer[index]);\n            }\n            index++;\n        } \n        else \n        {\n            index++;\n        }\n    }\n    return new String(buffer);\n}"
    ],
    [
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    char[] buf;\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    buf = new char[a.getUnscaledValue().toString().length()];\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.getUnscaledValue().toString().charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.getUnscaledValue().toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.getField().newDfp(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    int sp = 0;\n    int sig = 0;\n    char[] buf;\n    boolean leading = true;\n\n    buf = new char[a.getUnscaledValue().toString().length()];\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.getUnscaledValue().toString().charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    Dfp result[] = new Dfp[2];\n    result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.getUnscaledValue().toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.getField().newDfp(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    int radixDigits = a.getField().getRadixDigits();\n    int[] aParts = a.getUnscaledValue().getMantissa();\n    int aPrecision = a.getUnscaledValue().getScale();\n    int aLength = aParts.length;\n    int aLeading = 0;\n    int aTrailing = 0;\n    int aMiddle = 0;\n    int aMiddlePrecision = 0;\n    int aMiddleLength = 0;\n    int aMiddleTrailing = 0;\n    int aMiddleLeading = 0;\n    int aMiddlePrecisionLeading = 0;\n    int aMiddlePrecisionTrailing = 0;\n    int aMiddlePrecisionMiddle = 0;\n    int aMiddlePrecisionMiddleLength = 0;\n    int aMiddlePrecisionMiddleTrailing = 0;\n    int aMiddlePrecisionMiddleLeading = 0;\n    int aMiddlePrecisionMiddlePrecision = 0;\n    int aMiddlePrecisionMiddleLength = 0;\n    int aMiddlePrecisionMiddleTrailing = 0;\n    int aMiddlePrecisionMiddleLeading = 0;\n    int aMiddlePrecisionMiddlePrecision = 0;\n    int aMiddlePrecisionMiddleLength = 0;\n    int aMiddlePrecisionMiddleTrailing = 0;\n    int aMiddlePrecisionMiddleLeading = 0;\n    int aMiddlePrecisionMiddlePrecision = 0;\n    int aMiddlePrecisionMiddleLength = 0;\n    int aMiddlePrecisionMiddleTrailing = 0;\n    int aMiddlePrecisionMiddleLeading = 0;\n    int aMiddlePrecisionMiddlePrecision = 0;\n    int aMiddlePrecisionMiddleLength = 0;\n    int aMiddlePrecisionMiddleTrailing = 0;\n    int aMiddlePrecisionMiddleLeading = 0;\n    int aMiddlePrecisionMiddlePrecision = 0;\n    int aMiddlePrecisionMiddleLength = 0;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    char[] buf;\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    buf = new char[a.getUnscaledValue().toString().length()];\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.getUnscaledValue().toString().charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.getUnscaledValue().toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.getField().newDfp(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    int radixDigits = a.getField().getRadixDigits();\n    int[] intA = a.getUnscaledValue().getMantissa();\n    int[] intB = new int[intA.length];\n    int[] intC = new int[intA.length];\n    int[] intD = new int[intA.length];\n    int scale = a.getScale();\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int q = 0;\n    int r = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int carry = 0;\n    int digit = 0;\n    int remainder = 0;\n    int temp = 0;\n    int temp2 = 0;\n    int temp3 = 0;\n    int temp4 = 0;\n    int temp5 = 0;\n    int temp6 = 0;\n    int temp7 = 0;\n    int temp8 = 0;\n    int temp9 = 0;\n    int temp10 = 0;\n    int temp11 = 0;\n    int temp12 = 0;\n    int temp13 = 0;\n    int temp14 = 0;\n    int temp15 = 0;\n    int temp16 = 0;\n    int temp17 = 0;\n    int temp18 = 0;\n    int temp19 = 0;\n    int temp20 = 0;\n    int temp21 = 0;\n    int temp22 = 0;\n    int temp23 = 0;\n    int temp24 = 0;\n    int temp25 = 0;\n    int temp26 = 0;\n    int temp27 = 0;\n    int temp28 = 0;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    int sp = 0;\n    int sig = 0;\n\n    char[] buf = new char[a.getUnscaledValue().toString().length()];\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.getUnscaledValue().toString().charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.getUnscaledValue().toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.getField().newDfp(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    char[] buf;\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    buf = new char[a.getUnscaledValue().toString().length()];\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.getUnscaledValue().toString().charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.getUnscaledValue().toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.getField().newDfp(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    char[] buf;\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    buf = new char[a.getUnscaledValue().toString().length()];\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.getUnscaledValue().toString().charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.getUnscaledValue().toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.getField().newDfp(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    int sp = 0;\n    int sig = 0;\n\n    char[] buf = new char[a.getUnscaledValue().getDigits().length];\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.getUnscaledValue().getDigits()[i];\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.getUnscaledValue().getDigits()[i];\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.getField().newDfp(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    Dfp[] aSplit = a.split();\n    result[0] = aSplit[0];\n    result[1] = aSplit[1];\n    return result;\n}"
    ],
    [
      "public String cssSelector()  {\n    if (hasId())\n    {\n        return \"#\" + id();\n    }\n    else\n    {\n        StringBuilder sb = new StringBuilder();\n        if (parent() != null)\n        {\n            sb.append(parent().cssSelector());\n            sb.append(\" > \");\n        }\n        sb.append(tagName());\n        if (hasClass())\n        {\n            sb.append(\".\");\n            sb.append(String.join(\".\", classNames()));\n        }\n        if (hasAttribute(\"name\"))\n        {\n            sb.append(\"[name=\");\n            sb.append(attribute(\"name\"));\n            sb.append(\"]\");\n        }\n        if (parent() != null && parent().children().size() > 1)\n        {\n            sb.append(\":nth-child(\");\n            sb.append(siblingIndex() + 1);\n            sb.append(\")\");\n        }\n        return sb.toString();\n    }\n}",
      "public String cssSelector()  {\n    if (id() != null) \n    {\n        return \"#\" + id();\n    }\n    else \n    {\n        String selector = tagName();\n        if (hasClass()) \n        {\n            selector += \".\" + cssClass();\n        }\n        if (parent() != null) \n        {\n            selector = parent().cssSelector() + \" > \" + selector;\n        }\n        return selector + \":\" + siblingIndex();\n    }\n}",
      "public String cssSelector()  {\n    if (id() != null) \n    {\n        return \"#\" + id();\n    }\n    else \n    {\n        StringBuilder builder = new StringBuilder();\n        Element parent = parent();\n        if (parent != null) \n        {\n            builder.append(parent.cssSelector());\n            builder.append(\" > \");\n        }\n        builder.append(tagName());\n        if (hasClass()) \n        {\n            builder.append(\".\");\n            builder.append(classNames().stream().collect(Collectors.joining(\".\")));\n        }\n        if (parent != null && parent.children().size() > 1) \n        {\n            builder.append(\":nth-child(\");\n            builder.append(parent.children().indexOf(this) + 1);\n            builder.append(\")\");\n        }\n        return builder.toString();\n    }\n}",
      "public String cssSelector()  {\n    if (hasId()) \n    {\n        return \"#\" + id();\n    }\n    else \n    {\n        Element parent = parent();\n        if (parent == null) \n        {\n            return tagName();\n        }\n        else \n        {\n            String parentPath = parent.cssSelector();\n            return parentPath + \" > \" + tagName() + (classNames().size() > 0 ? \".\" + String.join(\".\", classNames()) : \"\") + \":nth-child(\" + siblingIndex() + \")\";\n        }\n    }\n}",
      "public String cssSelector()  {\n    if (id() != null)\n        return \"#\" + id();\n    else {\n        Element parent = parent();\n        if (parent == null)\n            return tagName();\n        else\n            return parent.cssSelector() + \" > \" + tagName() +\n                    (classNames().size() > 0 ? \".\" + classNames().get(0) : \"\") +\n                    (parent.children().size() > 1 ? \":\" + (siblingIndex() + 1) : \"\");\n    }\n}",
      "public String cssSelector()  {\n    if (hasId())\n        return \"#\" + id();\n    else\n    {\n        Element parent = parent();\n        if (parent == null)\n            return tagName();\n        else\n            return parent.cssSelector() + \" > \" + tagName() + \".\" + cssClass() + \".\" + Arrays.toString(cssClasses()).replace(\" \", \".\");\n    }\n}",
      "public String cssSelector()  {\n    if (id() != null) \n    {\n        return \"#\" + id();\n    }\n    else \n    {\n        String selector = tagName();\n        if (hasClass()) \n        {\n            selector += \".\" + cssClass();\n        }\n        if (parent() != null) \n        {\n            selector = parent().cssSelector() + \" > \" + selector;\n        }\n        return selector + \":\" + siblingIndex();\n    }\n}",
      "public String cssSelector()  {\n    if (hasId())\n    {\n        return \"#\" + id();\n    }\n    else\n    {\n        StringBuilder sb = new StringBuilder();\n        Element parent = parent();\n        if (parent != null)\n        {\n            sb.append(parent.cssSelector());\n            sb.append(\" > \");\n        }\n        sb.append(cssPath());\n        return sb.toString();\n    }\n}",
      "public String cssSelector()  {\n    if (hasId()) {\n        return \"#\" + id();\n    } else {\n        Element parent = parent();\n        if (parent == null) {\n            return tagName();\n        } else {\n            String parentPath = parent.cssSelector();\n            if (parentPath.equals(\"body\")) {\n                return tagName() + \":\" + className();\n            } else {\n                return parentPath + \" > \" + tagName() + \":\" + className();\n            }\n        }\n    }\n}",
      "public String cssSelector()  {\n    if (hasId()) {\n        return \"#\" + id();\n    }\n    StringBuilder sb = new StringBuilder();\n    Element parent = parent();\n    if (parent != null) {\n        sb.append(parent.cssSelector());\n        sb.append(\" > \");\n    }\n    sb.append(tagName());\n    sb.append(cssClassSelector());\n    sb.append(cssPseudoElementSelector());\n    sb.append(cssPseudoClassSelector());\n    sb.append(cssPseudoFunctionSelector());\n    return sb.toString();\n}"
    ],
    [
      "private static int estimateCostOneLevel(Node n)  {\n  int cost = 0;\n  switch (n.getType()) \n  {\n    case Token.NOT:\n      cost = 1;\n      break;\n    case Token.HOOK:\n      cost = 2;\n      break;\n    case Token.COMMA:\n      cost = 1;\n      break;\n    default:\n      break;\n  }\n  return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.getType() == Token.NOT) {\n        cost = 1;\n    } else if (n.getType() == Token.HOOK) {\n        cost = 1;\n    } else if (n.getType() == Token.COMMA) {\n        cost = 1;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  int cost = 0;\n  if (n.getType() == Token.NOT) {\n    cost++;\n  }\n  if (n.getFirstChild().getType() == Token.LP) {\n    cost++;\n  }\n  return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  int cost = 0;\n  switch (n.getType()) {\n    case Token.NOT:\n      cost = 1;\n      break;\n    case Token.HOOK:\n      cost = 2;\n      break;\n    case Token.COMMA:\n      cost = 1;\n      break;\n    default:\n      break;\n  }\n  return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  int cost = 0;\n  if (n.getType() == Token.NOT) {\n    cost += 3;\n  } else {\n    Node child = n.getFirstChild();\n    while (child != null) {\n      if (child.getType() == Token.OR || child.getType() == Token.AND) {\n        cost += 2;\n      }\n      child = child.getNext();\n    }\n  }\n  return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType()) {\n        case Token.NOT:\n            cost = 1;\n            break;\n        case Token.HOOK:\n        case Token.COMMA:\n            cost = 2;\n            break;\n        default:\n            break;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType()) {\n        case Token.NOT:\n            cost += 4;\n            break;\n        case Token.HOOK:\n            cost += 2;\n            break;\n        case Token.COMMA:\n            cost += 1;\n            break;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType())\n    {\n        case Token.NOT:\n            cost = 1;\n            break;\n        case Token.HOOK:\n            cost = 2;\n            break;\n        case Token.COMMA:\n            cost = 1;\n            break;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  int cost = 0;\n  switch (n.getType()) {\n    case Token.NOT:\n      cost = 1;\n      break;\n    case Token.HOOK:\n    case Token.COMMA:\n      cost = 2;\n      break;\n    default:\n      break;\n  }\n  for (Node child = n.getFirstChild(); child != null;\n       child = child.getNext()) {\n    cost += estimateCostOneLevel(child);\n  }\n  return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  int cost = 0;\n  if (n.getType() == Token.NOT) {\n    cost++;\n  } else if (n.getType() == Token.HOOK) {\n    cost += 2;\n  } else if (n.getType() == Token.COMMA) {\n    cost += 2;\n  }\n  return cost;\n}"
    ],
    [
      "public StrBuilder reverse()  {\n    if (size > 1) \n    {\n        int i = 0;\n        int j = size - 1;\n        while (i < j) \n        {\n            char tmp = buffer[i];\n            buffer[i] = buffer[j];\n            buffer[j] = tmp;\n            i++;\n            j--;\n        }\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size > 1) \n    {\n        int i = 0;\n        int j = size - 1;\n        char tmp;\n        while (i < j) \n        {\n            tmp = buffer[i];\n            buffer[i] = buffer[j];\n            buffer[j] = tmp;\n            i++;\n            j--;\n        }\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int j = this.size - 1;\n    for (int i = 0; i < this.size / 2; i++) \n    {\n        char temp = this.buffer[i];\n        this.buffer[i] = this.buffer[j];\n        this.buffer[j] = temp;\n        j--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int j = size - 1;\n    for (int i = 0; i < j; i++, j--) \n    {\n        char temp = buffer[i];\n        buffer[i] = buffer[j];\n        buffer[j] = temp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int mid = size / 2;\n    for (int i = 0; i < mid; i++) {\n        char c = buffer[i];\n        buffer[i] = buffer[size - i - 1];\n        buffer[size - i - 1] = c;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int i = 0;\n    int j = size - 1;\n    while (i < j) \n    {\n        char tmp = buffer[i];\n        buffer[i] = buffer[j];\n        buffer[j] = tmp;\n        i++;\n        j--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size > 1) \n    {\n        int half = size / 2;\n        for (int i = 0; i < half; i++) \n        {\n            char tmp = buffer[i];\n            buffer[i] = buffer[size - i - 1];\n            buffer[size - i - 1] = tmp;\n        }\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size > 1) {\n        int i = 0;\n        int j = size - 1;\n        while (i < j) {\n            char tmp = buffer[i];\n            buffer[i] = buffer[j];\n            buffer[j] = tmp;\n            i++;\n            j--;\n        }\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    // TODO: Implement this method\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int i = 0;\n    int j = size - 1;\n    while (i < j) \n    {\n        char temp = buffer[i];\n        buffer[i] = buffer[j];\n        buffer[j] = temp;\n        i++;\n        j--;\n    }\n    return this;\n}"
    ],
    [
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Split offset must be not negative number\");\n    Validate.isTrue(offset < wholeText.length(), \"Split offset must be less than node length\");\n    TextNode newNode = new TextNode(wholeText.substring(offset));\n    String head = wholeText.substring(0, offset);\n    coreValue(head);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Split offset must be not negative number\");\n    Validate.isTrue(offset < value.length(), \"Split offset must not be greater than node length\");\n\n    String newData = value.substring(offset);\n    value = value.substring(0, offset);\n\n    TextNode newNode = new TextNode(newData);\n    if (parent() != null)\n        parent().addChildren(siblingIndex() + 1, newNode);\n\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Split offset must be not negative number\");\n    Validate.isTrue(offset < value.length(), \"Split offset must not be greater than node length\");\n\n    String newData = value.substring(offset);\n    value = value.substring(0, offset);\n\n    TextNode newNode = new TextNode(newData);\n    if (parent() != null)\n        parent().addChildren(siblingIndex() + 1, newNode);\n\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0);\n    Validate.isTrue(offset <= value.length());\n\n    TextNode newNode = new TextNode(value.substring(offset));\n    String head = value.substring(0, offset);\n    this.value = head;\n    if (parent() != null)\n        parent().addChildren(index + 1, newNode);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0 && offset <= length(), \"split offset %s, but length is %s\", offset, length());\n    String head = getWholeText().substring(0, offset);\n    String tail = getWholeText().substring(offset);\n    TextNode newNode = new TextNode(tail);\n    parentNode.insertAfter(newNode, this);\n    this.text(head);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0);\n    Validate.isTrue(offset < getWholeText().length());\n    String pre = getWholeText().substring(0, offset);\n    String post = getWholeText().substring(offset);\n    TextNode postNode = new TextNode(post);\n    parentNode.insertAfter(postNode, this);\n    this.coreValue(pre);\n    return postNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Split offset must be not negative\");\n    Validate.isTrue(offset < wholeText().length(), \"Split offset must be less than node length\");\n\n    String newText = wholeText().substring(offset);\n    String remainingText = wholeText().substring(0, offset);\n\n    coreValue(remainingText);\n\n    TextNode newNode = new TextNode(newText);\n    parentNode().insertAfter(newNode, this);\n\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Split offset must be not negative number\");\n    Validate.isTrue(offset < wholeText.length(), \"Split offset must be less than node length\");\n    TextNode newNode = new TextNode(wholeText.substring(offset));\n    wholeText = wholeText.substring(0, offset);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Split offset must be not negative\");\n    Validate.isTrue(offset < wholeText.length(), \"Split offset must be before the end of the text\");\n\n    TextNode newNode = new TextNode(wholeText.substring(offset));\n    wholeText = wholeText.substring(0, offset);\n    parentNode.insertAfter(newNode, this);\n\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0 && offset <= value.length());\n    TextNode newNode = new TextNode(value.substring(offset));\n    if (parent() != null)\n    {\n        parent().addChildren(index + 1, newNode);\n    }\n    value = value.substring(0, offset);\n    return newNode;\n}"
    ],
    [
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        final int aCount = helper.count(obj, a);\n        final int bCount = helper.count(obj, b);\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj) + bCount - aCount);\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        final int aCount = helper.count(obj, a);\n        final int bCount = helper.count(obj, b);\n        helper.setCardinality(obj, Math.max(aCount, bCount) - Math.min(aCount, bCount));\n    }\n    return helper.list();\n}"
    ],
    [
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] bytes = new byte[8];\n    int i = 0;\n    while (value.signum() != 0) \n    {\n        bytes[i] = value.byteValue();\n        value = value.shiftRight(8);\n        i++;\n    }\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] bytes = new byte[8];\n    int i = 0;\n    while (value.signum() != 0) \n    {\n        bytes[i] = value.byteValue();\n        value = value.shiftRight(8);\n        i++;\n    }\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n        final byte[] bytes = new byte[8];\n        int i = 0;\n        for (; i < 8; i++) {\n            bytes[i] = value.byteValue();\n            value = value.shiftRight(BYTE_8);\n        }\n        return bytes;\n    }",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    for (int i = 0; i < 8; i++) \n    {\n        bytes[i] = (byte) ((value.shiftRight(BYTE_7 - i).and(LEFTMOST_BIT).longValue() == 1) ? LEFTMOST_BIT : 0);\n    }\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] bytes = new byte[8];\n    int i = 0;\n    while (value.signum() != 0) \n    {\n        bytes[i] = (byte) (value.and(BigInteger.valueOf(0xFFL)).longValue());\n        value = value.shiftRight(8);\n        i++;\n    }\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] bytes = new byte[8];\n    int i = 0;\n    while (value.signum() != 0) \n    {\n        bytes[i++] = value.byteValue();\n        value = value.shiftRight(8);\n    }\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n        final byte[] bytes = new byte[8];\n        int i = 0;\n        while (value.signum() != 0) {\n            bytes[i] = (byte) (value.and(BigInteger.valueOf(0xFF)).longValue());\n            value = value.shiftRight(8);\n            i++;\n        }\n        return bytes;\n    }",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] bytes = new byte[8];\n    int offset = 0;\n    while (value.signum() != 0) \n    {\n        final int byteValue = value.and(ZipEightByteInteger.BYTE_7_MASK).intValue();\n        bytes[offset] = (byte) (byteValue >>> ZipEightByteInteger.BYTE_7_SHIFT);\n        value = value.shiftRight(ZipEightByteInteger.BYTE_8_SHIFT);\n        offset++;\n    }\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] bytes = new byte[8];\n    int offset = 0;\n    while (value.signum() != 0) {\n        bytes[offset] = value.byteValue();\n        value = value.shiftRight(8);\n        offset++;\n    }\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] bytes = new byte[8];\n    int offset = 0;\n    for (int i = BYTE_7; i >= 0; i--) \n    {\n        bytes[offset] = (byte) (value.shiftRight(i * BYTE_2_SHIFT).and(BYTE_7_MASK).longValue());\n        offset++;\n    }\n    return bytes;\n}"
    ],
    [
      "public static String keep(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return StringUtils.EMPTY;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        final int sz = str.length();\n        final StringBuilder buffer = new StringBuilder(sz);\n        for (int i = 0; i < sz; i++) {\n            final char ch = str.charAt(i);\n            if (chars.contains(ch)) {\n                buffer.append(ch);\n            }\n        }\n        return buffer.toString();\n    }\n\n    // RemoveAny",
      "public static String keep(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return StringUtils.EMPTY;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        final StringBuilder buffer = new StringBuilder(str.length());\n        for (final char ch : str.toCharArray()) {\n            if (chars.contains(ch)) {\n                buffer.append(ch);\n            }\n        }\n        return buffer.toString();\n    }\n\n    //-----------------------------------------------------------------------",
      "public static String keep(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return StringUtils.EMPTY;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        final int sz = str.length();\n        final StringBuilder buffer = new StringBuilder(sz);\n        for (int i = 0; i < sz; i++) {\n            final char ch = str.charAt(i);\n            if (chars.contains(ch)) {\n                buffer.append(ch);\n            }\n        }\n        return buffer.toString();\n    }\n\n    // KeepAny",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return StringUtils.EMPTY;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final int sz = str.length();\n    final char[] chrs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        final char ch = str.charAt(i);\n        if (chars.contains(ch)) {\n            chrs[count++] = ch;\n        }\n    }\n    return new String(chrs, 0, count);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    for (final char ch : str.toCharArray()) {\n        if (chars.contains(ch)) {\n            buffer.append(ch);\n        }\n    }\n    return buffer.toString();\n}\n\n    // Remove",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return StringUtils.EMPTY;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    for (final char ch : str.toCharArray()) {\n        if (chars.contains(ch)) {\n            buffer.append(ch);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return StringUtils.EMPTY;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        final int sz = str.length();\n        final char[] chrs = new char[sz];\n        int count = 0;\n        for (int i = 0; i < sz; i++) {\n            final char ch = str.charAt(i);\n            if (chars.contains(ch)) {\n                chrs[count++] = ch;\n            }\n        }\n        return new String(chrs, 0, count);\n    }\n\n    // RemoveAny",
      "public static String keep(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return StringUtils.EMPTY;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        final StringBuilder buffer = new StringBuilder(str.length());\n        for (final char ch : str.toCharArray()) {\n            if (chars.contains(ch)) {\n                buffer.append(ch);\n            }\n        }\n        return buffer.toString();\n    }",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    for (final char ch : str.toCharArray()) {\n        if (chars.contains(ch)) {\n            buffer.append(ch);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return str;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        final int sz = str.length();\n        final StringBuilder buffer = new StringBuilder(sz);\n        for (int i = 0; i < sz; i++) {\n            final char ch = str.charAt(i);\n            if (chars.contains(ch)) {\n                buffer.append(ch);\n            }\n        }\n        return buffer.toString();\n    }"
    ],
    [
      "public RealMatrix getSquareRoot()  {\n    final int n = getRowDimension();\n    final double[][] s = new double[n][n];\n    final double[][] v = new double[n][n];\n    final double[] d = new double[n];\n    final double[] diag = new double[n];\n    final double[] diag2 = new double[n];\n    final double[] diag3 = new double[n];\n    final double[] diag4 = new double[n];\n    final double[] diag5 = new double[n];\n    final double[] diag6 = new double[n];\n    final double[] diag7 = new double[n];\n    final double[] diag8 = new double[n];\n    final double[] diag9 = new double[n];\n    final double[] diag10 = new double[n];\n    final double[] diag11 = new double[n];\n    final double[] diag12 = new double[n];\n    final double[] diag13 = new double[n];\n    final double[] diag14 = new double[n];\n    final double[] diag15 = new double[n];\n    final double[] diag16 = new double[n];\n    final double[] diag17 = new double[n];\n    final double[] diag18 = new double[n];\n    final double[] diag19 = new double[n];\n    final double[] diag20 = new double[n];\n    final double[] diag21 = new double[n];\n    final double[] diag22 = new double[n];\n    final double[] diag23 = new double[n];\n    final double[] diag24 = new double[n];\n    final double[] diag25 = new double[n];\n    final double[] diag26 = new double[n];\n    final double[] diag27 = new double[n];\n    final double[] diag28 = new double[n];\n    final double[] diag29 = new double[n];\n    final double[] diag30 = new double[n];\n    final double[] diag31 = new double[n];\n    final double[] diag32 = new double[n];\n    final double[] diag33 = new double[n];\n}",
      "public RealMatrix getSquareRoot()  {\n    // Check if the matrix is symmetric and positive definite\n    if (!isSymmetric())\n    {\n        throw new MathUnsupportedOperationException(\n                \"The matrix must be symmetric and positive definite\");\n    }\n\n    // Compute the eigenvalues and eigenvectors of the matrix\n    final EigenDecomposition eigen = new EigenDecomposition(this);\n    final double[] eigenvalues = eigen.getRealEigenvalues();\n    final RealMatrix eigenvectors = eigen.getV();\n\n    // Compute the square root of the matrix\n    final int n = eigenvalues.length;\n    final double[] squareRootEigenvalues = new double[n];\n    final RealMatrix squareRootEigenvectors = new Array2DRowRealMatrix(n, n);\n    for (int i = 0; i < n; i++)\n    {\n        squareRootEigenvalues[i] = Math.sqrt(eigenvalues[i]);\n        for (int j = 0; j < n; j++)\n        {\n            squareRootEigenvectors.setEntry(i, j, eigenvectors.getEntry(i, j) / Math.sqrt(eigenvalues[i]));\n        }\n    }\n\n    // Return the square root of the matrix\n    return new Array2DRowRealMatrix(squareRootEigenvectors, false, squareRootEigenvalues);\n}",
      "public RealMatrix getSquareRoot()  {\n    final int n = realEigenvalues.length;\n    final RealMatrix[] eigenvectors = new RealMatrix[n];\n    for (int i = 0; i < n; i++) {\n        eigenvectors[i] = new Array2DRowRealMatrix(getEigenvector(i).toArray(), false);\n    }\n    final RealMatrix[] squareRoots = new RealMatrix[n];\n    for (int i = 0; i < n; i++) {\n        squareRoots[i] = eigenvectors[i].multiply(Math.sqrt(realEigenvalues[i]));\n    }\n    return MatrixUtils.createRealMatrix(squareRoots);\n}",
      "public RealMatrix getSquareRoot()  {\n    // TODO: Implement this method\n    return null;\n}",
      "public RealMatrix getSquareRoot()  {\n    // check that the matrix is symmetric and positive definite\n    if (!isSymmetric())\n    {\n        throw new MathUnsupportedOperationException(LocalizedCoreFormats.NOT_SYMMETRIC);\n    }\n    if (!isPositiveDefinite())\n    {\n        throw new MathUnsupportedOperationException(LocalizedCoreFormats.NOT_POSITIVE_DEFINITE);\n    }\n\n    // compute the eigenvalues and eigenvectors of the matrix\n    EigenDecomposition eigen = new EigenDecomposition(this);\n    double[] eigenvalues = eigen.getRealEigenvalues();\n    RealMatrix eigenvectors = eigen.getV();\n\n    // compute the square root of the eigenvalues\n    double[] sqrtEigenvalues = new double[eigenvalues.length];\n    for (int i = 0; i < eigenvalues.length; i++)\n    {\n        sqrtEigenvalues[i] = Math.sqrt(eigenvalues[i]);\n    }\n\n    // compute the square root of the matrix\n    RealMatrix sqrtMatrix = new Array2DRowRealMatrix(eigenvectors.getRowDimension(), eigenvectors.getColumnDimension());\n    for (int i = 0; i < sqrtMatrix.getRowDimension(); i++)\n    {\n        for (int j = 0; j < sqrtMatrix.getColumnDimension(); j++)\n        {\n            sqrtMatrix.setEntry(i, j, sqrtEigenvalues[i] * eigenvectors.getEntry(i, j));\n        }\n    }\n\n    return sqrtMatrix;\n}",
      "public RealMatrix getSquareRoot()  {\n    // Check if the matrix is symmetric and positive definite\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(LocalizedCoreFormats.NOT_SYMMETRIC);\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(LocalizedCoreFormats.NOT_POSITIVE_DEFINITE);\n    }\n\n    // Compute the Cholesky decomposition of the matrix\n    final CholeskyDecomposition cholesky = new CholeskyDecomposition(this);\n\n    // Return the square-root of the matrix\n    return cholesky.getL();\n}",
      "public RealMatrix getSquareRoot()  {\n    // Check that the matrix is symmetric and positive definite\n    final double[] diag = getDiagonal();\n    for (int i = 0; i < diag.length; i++) {\n        if (diag[i] <= 0) {\n            throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SYMMETRIC_POSITIVE_DEFINITE);\n        }\n    }\n\n    // Compute the square root\n    final int n = getRowDimension();\n    final RealMatrix sqrt = new Array2DRowRealMatrix(n, n);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <= i; j++) {\n            final double value = getEntry(i, j);\n            final double sqrtValue = FastMath.sqrt(value);\n            sqrt.setEntry(i, j, sqrtValue);\n            if (i != j) {\n                sqrt.setEntry(j, i, sqrtValue);\n            }\n        }\n    }\n\n    return sqrt;\n}",
      "public RealMatrix getSquareRoot()  {\n    // TODO: Implement this method\n    return null;\n}",
      "public RealMatrix getSquareRoot()  {\n    final int n = getRowDimension();\n    if (n != getColumnDimension()) {\n        throw new MathIllegalArgumentException(LocalizedCoreFormats.DIMENSIONS_2X_MUST_AGREE, n, n);\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(LocalizedCoreFormats.NOT_POSITIVE_DEFINITE);\n    }\n    final double[][] sqrt = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            sqrt[i][j] = getEntry(i, j);\n        }\n    }\n    final EigenDecomposition eigen = new EigenDecompositionImpl(this);\n    final double[] evals = eigen.getRealEigenvalues();\n    for (int i = 0; i < n; i++) {\n        final double lambda = evals[i];\n        if (lambda < 0) {\n            throw new MathUnsupportedOperationException(LocalizedCoreFormats.NOT_POSITIVE_DEFINITE);\n        }\n        final double sqrtLambda = FastMath.sqrt(lambda);\n        final double[] eVec = eigen.getEigenvector(i).toArray();\n        for (int j = 0; j < n; j++) {\n            sqrt[i][j] = eVec[j] / sqrtLambda;\n        }\n    }\n    return new Array2DRowRealMatrix(sqrt, false);\n}",
      "public RealMatrix getSquareRoot()  {\n    // Check if the matrix is symmetric and positive definite\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SYMMETRIC);\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_POSITIVE_DEFINITE);\n    }\n\n    // Compute the eigenvalues and eigenvectors of the matrix\n    final EigenDecomposition eigen = new EigenDecomposition(this);\n    final double[] eigenvalues = eigen.getRealEigenvalues();\n    final RealMatrix eigenvectors = eigen.getV();\n\n    // Compute the square root of the eigenvalues\n    final double[] squareRoots = new double[eigenvalues.length];\n    for (int i = 0; i < eigenvalues.length; i++) {\n        squareRoots[i] = FastMath.sqrt(eigenvalues[i]);\n    }\n\n    // Compute the square root of the matrix\n    final RealMatrix squareRoot = new Array2DRowRealMatrix(eigenvectors.getRowDimension(), eigenvectors.getColumnDimension());\n    for (int i = 0; i < eigenvectors.getRowDimension(); i++) {\n        for (int j = 0; j < eigenvectors.getColumnDimension(); j++) {\n            squareRoot.setEntry(i, j, eigenvectors.getEntry(i, j) / squareRoots[i]);\n        }\n    }\n\n    return squareRoot;\n}"
    ],
    [
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \t\tif (t == JsonToken.VALUE_NUMBER_INT) {\n    \t\t\treturn deserializeFromNumber(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_NUMBER_FLOAT) {\n    \t\t\treturn deserializeFromDouble(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_STRING) {\n    \t\t\treturn deserializeFromString(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n    \t\t\treturn deserializeFromEmbedded(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_TRUE) {\n    \t\t\treturn deserializeFromBoolean(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_FALSE) {\n    \t\t\treturn deserializeFromBoolean(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_NULL) {\n    \t\t\treturn deserializeFromNull(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.START_ARRAY) {\n    \t\t\treturn deserializeFromArray(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.START_OBJECT) {\n    \t\t\treturn deserializeFromObject(p, ctxt);\n    \t\t}\n    \t\treturn ctxt.handleUnexpectedToken(handledType(), p);\n    \t}",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \t\tswitch (t) {\n    \t\tcase VALUE_STRING:\n    \t\t\treturn deserializeFromString(p, ctxt);\n    \t\tcase VALUE_NUMBER_INT:\n    \t\t\treturn deserializeFromNumber(p, ctxt);\n    \t\tcase VALUE_NUMBER_FLOAT:\n    \t\t\treturn deserializeFromDouble(p, ctxt);\n    \t\tcase VALUE_EMBEDDED_OBJECT:\n    \t\t\treturn deserializeFromEmbedded(p, ctxt);\n    \t\tcase VALUE_TRUE:\n    \t\tcase VALUE_FALSE:\n    \t\t\treturn deserializeFromBoolean(p, ctxt);\n    \t\tcase VALUE_NULL:\n    \t\t\treturn deserializeFromNull(p, ctxt);\n    \t\tcase START_ARRAY:\n    \t\t\t// these only work if there's a (delegating) creator...\n    \t\t\treturn deserializeFromArray(p, ctxt);\n    \t\tcase FIELD_NAME:\n    \t\tcase END_OBJECT: // added to resolve [JACKSON-319], possible related issues\n    \t\t\treturn vanillaDeserialize(p, ctxt, t);\n    \t\tdefault:\n    \t\t}\n    \t\treturn ctxt.handleUnexpectedToken(handledType(), p);\n    \t}",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t) {\n        case VALUE_STRING:\n            return deserializeFromString(p, ctxt);\n        case VALUE_NUMBER_INT:\n            return deserializeFromNumber(p, ctxt);\n        case VALUE_NUMBER_FLOAT:\n            return deserializeFromDouble(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT:\n            return deserializeFromEmbedded(p, ctxt);\n        case VALUE_TRUE:\n        case VALUE_FALSE:\n            return deserializeFromBoolean(p, ctxt);\n        case VALUE_NULL:\n            return deserializeFromNull(p, ctxt);\n        case START_ARRAY:\n            // these only work if there's a (delegating) creator...\n            return deserializeFromArray(p, ctxt);\n        case FIELD_NAME:\n        case END_OBJECT: // added to resolve [JACKSON-319], possible related issues\n            if (_vanillaProcessing) {\n                return vanillaDeserialize(p, ctxt, t);\n            }\n            if (_objectIdReader != null) {\n                return deserializeWithObjectId(p, ctxt);\n            }\n            return deserializeFromObject(p, ctxt);\n        default:\n        }\n        return ctxt.handleUnexpectedToken(handledType(), p);\n    }\n\n    @Deprecated // since 2.8; remove unless getting used\n    protected Object _missingToken(JsonParser p, DeserializationContext ctxt) throws IOException {\n        throw ctxt.endOfInputException(handledType());\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \t\tswitch (t) {\n    \t\tcase VALUE_STRING:\n    \t\t\treturn deserializeFromString(p, ctxt);\n    \t\tcase VALUE_NUMBER_INT:\n    \t\t\treturn deserializeFromNumber(p, ctxt);\n    \t\tcase VALUE_NUMBER_FLOAT:\n    \t\t\treturn deserializeFromDouble(p, ctxt);\n    \t\tcase VALUE_EMBEDDED_OBJECT:\n    \t\t\treturn deserializeFromEmbedded(p, ctxt);\n    \t\tcase VALUE_TRUE:\n    \t\tcase VALUE_FALSE:\n    \t\t\treturn deserializeFromBoolean(p, ctxt);\n    \t\tcase VALUE_NULL:\n    \t\t\treturn deserializeFromNull(p, ctxt);\n    \t\tcase START_ARRAY:\n    \t\t\t// these only work if there's a (delegating) creator...\n    \t\t\treturn deserializeFromArray(p, ctxt);\n    \t\tcase FIELD_NAME:\n    \t\tcase END_OBJECT: // added to resolve [JACKSON-319], possible related issues\n    \t\t\treturn deserializeFromObject(p, ctxt);\n    \t\tdefault:\n    \t\t}\n    \t\treturn ctxt.handleUnexpectedToken(handledType(), p);\n    \t}",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.VALUE_STRING) {\n            return deserializeFromString(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return deserializeFromNumber(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return deserializeFromDouble(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            return deserializeFromEmbedded(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_TRUE) {\n            return Boolean.TRUE;\n        }\n        if (t == JsonToken.VALUE_FALSE) {\n            return Boolean.FALSE;\n        }\n        if (t == JsonToken.VALUE_NULL) {\n            return null;\n        }\n        if (t == JsonToken.START_ARRAY) {\n            return deserializeFromArray(p, ctxt);\n        }\n        if (t == JsonToken.FIELD_NAME) {\n            return deserializeFromObject(p, ctxt);\n        }\n        if (t == JsonToken.START_OBJECT) {\n            return deserializeFromObject(p, ctxt);\n        }\n        return ctxt.handleUnexpectedToken(handledType(), p);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \t\tif (t == JsonToken.VALUE_STRING) {\n    \t\t\treturn deserializeFromString(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_NUMBER_INT) {\n    \t\t\treturn deserializeFromNumber(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_NUMBER_FLOAT) {\n    \t\t\treturn deserializeFromDouble(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n    \t\t\treturn deserializeFromEmbedded(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_TRUE) {\n    \t\t\treturn deserializeFromBoolean(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_FALSE) {\n    \t\t\treturn deserializeFromBoolean(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_NULL) {\n    \t\t\treturn deserializeFromNull(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.START_ARRAY) {\n    \t\t\treturn deserializeFromArray(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.FIELD_NAME) {\n    \t\t\treturn deserializeFromObject(p, ctxt);\n    \t\t}\n    \t\treturn ctxt.handleUnexpectedToken(handledType(), p);\n    \t}",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \t\tif (t == JsonToken.VALUE_STRING) {\n    \t\t\treturn p.getText();\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_NUMBER_INT) {\n    \t\t\treturn p.getNumberValue();\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_NUMBER_FLOAT) {\n    \t\t\treturn p.getDecimalValue();\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_TRUE) {\n    \t\t\treturn Boolean.TRUE;\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_FALSE) {\n    \t\t\treturn Boolean.FALSE;\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_NULL) {\n    \t\t\treturn getNullValue(ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.START_ARRAY) {\n    \t\t\treturn deserializeFromArray(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.START_OBJECT) {\n    \t\t\treturn deserializeFromObject(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.FIELD_NAME) {\n    \t\t\treturn deserializeFromObject(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.END_OBJECT) {\n    \t\t\treturn getNullValue(ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.END_ARRAY) {\n    \t\t\treturn getNullValue(ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n    \t\t\treturn deserializeEmbeddedBean(p, ctxt);\n    \t\t}\n    \t\treturn ctxt.handleUnexpectedToken(getValueType(ctxt), p);\n    \t}",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t) {\n        case VALUE_STRING:\n            return deserializeFromString(p, ctxt);\n        case VALUE_NUMBER_INT:\n            return deserializeFromNumber(p, ctxt);\n        case VALUE_NUMBER_FLOAT:\n            return deserializeFromDouble(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT:\n            return deserializeFromEmbedded(p, ctxt);\n        case VALUE_TRUE:\n        case VALUE_FALSE:\n            return deserializeFromBoolean(p, ctxt);\n        case VALUE_NULL:\n            return deserializeFromNull(p, ctxt);\n        case START_ARRAY:\n            // these only work if there's a (delegating) creator...\n            return deserializeFromArray(p, ctxt);\n        case FIELD_NAME:\n        case END_OBJECT: // added to resolve [JACKSON-319], possible related issues\n            if (_vanillaProcessing) {\n                return vanillaDeserialize(p, ctxt, t);\n            }\n            if (_objectIdReader != null) {\n                return deserializeWithObjectId(p, ctxt);\n            }\n            return deserializeFromObject(p, ctxt);\n        default:\n        }\n        return ctxt.handleUnexpectedToken(handledType(), p);\n    }\n\n    @Deprecated // since 2.8; remove unless getting used\n    protected Object _missingToken(JsonParser p, DeserializationContext ctxt) throws IOException {\n        throw ctxt.endOfInputException(handledType());\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \t\tif (t == JsonToken.VALUE_STRING) {\n    \t\t\treturn deserializeFromString(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_NUMBER_INT) {\n    \t\t\treturn deserializeFromNumber(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_NUMBER_FLOAT) {\n    \t\t\treturn deserializeFromDouble(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n    \t\t\treturn deserializeFromEmbedded(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_TRUE) {\n    \t\t\treturn deserializeFromBoolean(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_FALSE) {\n    \t\t\treturn deserializeFromBoolean(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_NULL) {\n    \t\t\treturn deserializeFromNull(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.START_ARRAY) {\n    \t\t\t// these only work if there's a (delegating) creator...\n    \t\t\treturn deserializeFromArray(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.FIELD_NAME) {\n    \t\t\treturn deserializeFromObject(p, ctxt);\n    \t\t}\n    \t\treturn ctxt.handleUnexpectedToken(handledType(), p);\n    \t}",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return deserializeFromNumber(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return deserializeFromDouble(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_STRING) {\n            return deserializeFromString(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            return deserializeFromEmbedded(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_TRUE) {\n            return Boolean.TRUE;\n        }\n        if (t == JsonToken.VALUE_FALSE) {\n            return Boolean.FALSE;\n        }\n        if (t == JsonToken.VALUE_NULL) {\n            return deserializeFromNull(p, ctxt);\n        }\n        if (t == JsonToken.START_ARRAY) {\n            // these only work if there's a (delegating) creator...\n            return deserializeFromArray(p, ctxt);\n        }\n        if (t == JsonToken.START_OBJECT) {\n            return deserializeFromObject(p, ctxt);\n        }\n        return ctxt.handleUnexpectedToken(handledType(), p);\n    }"
    ],
    [
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        double sum = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += (sample1[i] - sample2[i]);\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        double sum = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        MathUtils.checkNotNull(sample1);\n        MathUtils.checkNotNull(sample2);\n        MathUtils.checkEqualLength(sample1, sample2);\n        double sum = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        MathUtils.checkNotNull(sample1);\n        MathUtils.checkNotNull(sample2);\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        double sum = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        MathUtils.checkNotNull(sample1);\n        MathUtils.checkNotNull(sample2);\n        MathUtils.checkEquals(sample1.length, sample2.length, LocalizedFormats.DIMENSIONS_MISMATCH, true);\n        if (sample1.length == 0) {\n            throw new NoDataException(LocalizedFormats.NO_DATA_POINTS);\n        }\n        double sum = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        double sum = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        MathUtils.checkNotNull(sample1);\n        MathUtils.checkNotNull(sample2);\n        MathUtils.checkEquals(sample1.length, sample2.length, LocalizedCoreFormats.DIMENSIONS_MISMATCH);\n        if (sample1.length == 0) {\n            throw new NoDataException(LocalizedCoreFormats.SAMPLE_SIZE);\n        }\n        double sum = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        double sum = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        MathUtils.checkNotNull(sample1);\n        MathUtils.checkNotNull(sample2);\n        MathUtils.checkEquals(sample1.length, sample2.length,\n                LocalizedFormats.DIMENSIONS_MISMATCH);\n        if (sample1.length == 0) {\n            throw new NoDataException(LocalizedFormats.EMPTY_ARRAY);\n        }\n        double sum = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += (sample1[i] - sample2[i]);\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        MathUtils.checkNotNull(sample1);\n        MathUtils.checkNotNull(sample2);\n        MathUtils.checkEqualLength(sample1, sample2);\n        if (sample1.length == 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_VALUE_REQUIRED);\n        }\n        double sum = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }"
    ],
    [
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        int len = fullChunk.length;\n        int newLen = len + (len >> 1);\n\n        // Let's double up until 64k chunks\n        if (newLen < SMALL_CHUNK) {\n            newLen = SMALL_CHUNK;\n        }\n\n        // Let's limit maximum size of chunks we use; helps avoid excessive allocation\n        // overhead for huge data sets.\n        if (newLen > MAX_CHUNK) {\n            newLen = MAX_CHUNK;\n        }\n\n        // If we have a free buffer, we can use that; otherwise, create new one\n        Object[] result;\n        if (_freeBuffer != null) {\n            result = _freeBuffer;\n            _freeBuffer = null;\n        } else {\n            result = new Object[newLen];\n        }\n\n        // And then copy in contents, and append to linked list\n        System.arraycopy(fullChunk, 0, result, 0, len);\n        _size += len;\n        if (_tail == null) {\n            _head = new LinkedNode<Object[]>(result);\n            _tail = _head;\n        } else {\n            _tail.next = new LinkedNode<Object[]>(result);\n            _tail = _tail.next;\n        }\n\n        return result;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         // First, let's see if we can just append to existing buffer:\n         if (_tail != null) {\n             int len = fullChunk.length;\n             Object[] curr = _tail.value;\n             int currLen = curr.length;\n             if (currLen + len <= MAX_CHUNK) {\n                 System.arraycopy(fullChunk, 0, curr, currLen, len);\n                 _tail.value = curr;\n                 _size += len;\n                 return fullChunk;\n             }\n         }\n         // Nope, need to add new chunk:\n         LinkedNode<Object[]> newNode = new LinkedNode<Object[]>(fullChunk);\n         if (_tail == null) {\n             _head = _tail = newNode;\n         } else {\n             _tail = _tail.next = newNode;\n         }\n         _size += fullChunk.length;\n         return fullChunk;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         // First: let's just add the chunk to the end of the list\n         LinkedNode<Object[]> node = new LinkedNode<Object[]>(fullChunk);\n         if (_tail == null) {\n             _head = node;\n         } else {\n             _tail.next = node;\n         }\n         _tail = node;\n         _size += fullChunk.length;\n\n         // And then: if we have enough entries, let's just return null\n         if (_size >= MAX_CHUNK) {\n             _freeBuffer = fullChunk;\n             return null;\n         }\n\n         // Otherwise: let's just return a new chunk\n         int chunkSize = Math.min(SMALL_CHUNK, MAX_CHUNK - _size);\n         Object[] newChunk = new Object[chunkSize];\n         _freeBuffer = newChunk;\n         return newChunk;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         // First, let's add it to the end of list\n         LinkedNode<Object[]> node = new LinkedNode<Object[]>(fullChunk);\n         if (_tail == null) {\n             _head = node;\n         } else {\n             _tail.next = node;\n         }\n         _tail = node;\n         _size += fullChunk.length;\n\n         // Then let's check if we need to expand\n         if (_size > MAX_CHUNK) {\n             // 16k chunks for now; but let's double up\n             int newChunkSize = Math.min(_size, 2 * SMALL_CHUNK);\n             Object[] newChunk = new Object[newChunkSize];\n             // And let's add it to head of list\n             node = new LinkedNode<Object[]>(newChunk);\n             node.next = _head;\n             _head = node;\n             _tail = node;\n             _size = newChunkSize;\n         }\n\n         // And finally, let's return a new buffer\n         if (_freeBuffer == null) {\n             return (_freeBuffer = new Object[12]);\n         }\n         return _freeBuffer;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        int chunkLen = fullChunk.length;\n        // If we have a free buffer, and it's big enough, let's use it\n        if (_freeBuffer != null) {\n            int freeLen = _freeBuffer.length;\n            if (chunkLen < freeLen) {\n                // Yup, we can use it\n                System.arraycopy(fullChunk, 0, _freeBuffer, 0, chunkLen);\n                return _freeBuffer;\n            }\n        }\n        // Otherwise, let's add it to list\n        LinkedNode<Object[]> node = new LinkedNode<Object[]>(fullChunk);\n        if (_head == null) {\n            _head = node;\n        } else {\n            _tail.next = node;\n        }\n        _tail = node;\n        _size += chunkLen;\n        // And let's check if we need to expand\n        if (_size > MAX_CHUNK) {\n            _expand();\n        }\n        return new Object[SMALL_CHUNK];\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        // Let's first see if we can just add it to existing tail\n        if (_tail == null) { // no chunks yet\n            _tail = new LinkedNode<Object[]>(fullChunk);\n            _head = _tail;\n        } else { // append to existing tail\n            _tail.next = new LinkedNode<Object[]>(fullChunk);\n            _tail = _tail.next;\n        }\n        _size += fullChunk.length;\n        if (_size > MAX_CHUNK) {\n            throw new IllegalStateException(\"Buffer overflow: too many entries buffered\");\n        }\n        // And then let's see if we can reuse old buffer\n        if (_freeBuffer != null) {\n            _freeBuffer = null;\n        }\n        // And then let's return new buffer\n        if (_size < SMALL_CHUNK) {\n            return new Object[12];\n        }\n        int chunkSize = Math.min(SMALL_CHUNK, _size);\n        return new Object[chunkSize];\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        // Let's add chunk to list\n        LinkedNode<Object[]> node = new LinkedNode<Object[]>(fullChunk);\n        if (_tail == null) {\n            _head = node;\n        } else {\n            _tail.next = node;\n        }\n        _tail = node;\n        _size += fullChunk.length;\n\n        // And then return new buffer\n        if (_size < MAX_CHUNK) {\n            return _freeBuffer;\n        }\n        return null;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        int len = fullChunk.length;\n        if (len == 0) {\n            return fullChunk;\n        }\n        if (_head == null) {\n            _head = new LinkedNode<Object[]>(fullChunk);\n            _tail = _head;\n        } else {\n            _tail.next = new LinkedNode<Object[]>(fullChunk);\n            _tail = _tail.next;\n        }\n        _size += len;\n        // let's double up until 64k chunks\n        if (_size < SMALL_CHUNK) {\n            return new Object[len];\n        }\n        // let's limit maximum size of chunks we use; helps avoid excessive allocation\n        // overhead for huge data sets.\n        if (_size < MAX_CHUNK) {\n            return new Object[len];\n        }\n        // let's limit to quarter million entries, 1 meg chunks for 32-bit machines\n        return new Object[Math.min(len, MAX_CHUNK)];\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         // First: if we have a free buffer, let's use it\n         if (_freeBuffer != null) {\n             Object[] result = _freeBuffer;\n             _freeBuffer = null;\n             return result;\n         }\n\n         // Otherwise, let's expand by doubling up\n         int len = fullChunk.length;\n         if (len < SMALL_CHUNK) {\n             len = SMALL_CHUNK;\n         } else if (len < MAX_CHUNK) {\n             len = len + (len >> 1);\n         } else {\n             len = MAX_CHUNK;\n         }\n         return new Object[len];\n     }\n\n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         int len = fullChunk.length;\n         if (len == 0) {\n             return fullChunk;\n         }\n         if (_size == 0) {\n             _head = _tail = new LinkedNode<Object[]>(fullChunk);\n         } else {\n             _tail.next = new LinkedNode<Object[]>(fullChunk);\n             _tail = _tail.next;\n         }\n         _size += len;\n         return _tail.value;\n     }"
    ],
    [
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n        // Validate arguments\n        if (pattern == null)\n        {\n            throw new IllegalArgumentException(\"The pattern must not be null\");\n        }\n\n        // Build the formatter\n        DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n        int[] indexRef = new int[1];\n        for (int i = 0; i < pattern.length(); i++)\n        {\n            char c = pattern.charAt(i);\n            if (c == '\\'')\n            {\n                i = appendLiteral(pattern, builder, i);\n            }\n            else if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')\n            {\n                i = appendText(pattern, builder, i);\n            }\n            else\n            {\n                throw new IllegalArgumentException(\"Illegal pattern character: \" + c);\n            }\n        }\n\n        return builder.toFormatter();\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    // TODO\n    return null;\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n        StringBuilder buf = new StringBuilder();\n        int[] indexRef = new int[1];\n        indexRef[0] = 0;\n\n        while (indexRef[0] < pattern.length()) {\n            String token = parseToken(pattern, indexRef);\n            if (token.length() == 0) {\n                break;\n            }\n\n            if (isNumericToken(token)) {\n                // This will identify token as numeric field.\n                buf.append('\\'');\n                buf.append(token);\n                buf.append('\\'');\n            } else {\n                // This will identify token as text.\n                buf.append('\\'');\n                buf.append(token);\n                buf.append('\\'');\n            }\n        }\n\n        return new DateTimeFormatterBuilder().appendPattern(buf.toString()).toFormatter();\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    // TODO\n    return null;\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    // TODO\n    return null;\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    int[] indexRef = new int[1];\n    indexRef[0] = 0;\n    while (indexRef[0] < pattern.length()) {\n        String token = parseToken(pattern, indexRef);\n        if (token.length() == 0) {\n            break;\n        }\n        if (isNumericToken(token)) {\n            // Handle numeric field\n            int fieldType = -1;\n            int fieldValue = -1;\n            int fieldCount = 1;\n            if (token.length() > 1) {\n                fieldCount = Integer.parseInt(token.substring(1));\n            }\n            switch (token.charAt(0)) {\n            case 'y': // year\n                fieldType = DateTimeFieldType.year();\n                break;\n            case 'M': // month\n                fieldType = DateTimeFieldType.monthOfYear();\n                break;\n            case 'd': // day of month\n                fieldType = DateTimeFieldType.dayOfMonth();\n                break;\n            case 'h': // hour of day\n                fieldType = DateTimeFieldType.clockhourOfDay();\n                break;\n            case 'H': // hour of day\n                fieldType = DateTimeFieldType.hourOfDay();\n                break;\n            case 'm': // minute of hour\n                fieldType = DateTimeFieldType.minuteOfHour();\n                break;\n            case 's': // second of minute\n                fieldType = DateTimeFieldType.secondOfMinute();\n                break;\n            case 'S': // fraction of second\n                fieldType = DateTimeFieldType.millisOfSecond();\n                break;\n            case 'e': // day of week\n                fieldType = DateTimeFieldType.dayOfWeek();\n                break;\n            case 'D': // day of year\n                fieldType = DateTimeFieldType.dayOfYear();\n                break;\n            case 'F': // day of week in month\n                fieldType = DateTimeFieldType.dayOfWeek();\n                break;\n            case 'w': // week of year\n                fieldType = DateTimeFieldType.weekOfWeekyear();\n                break;\n            case 'W': // week of month\n}\n}\n}\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n        int[] indexRef = new int[1];\n        List<DateTimeFormatter> formatters = new ArrayList<>();\n        while (indexRef[0] < pattern.length()) {\n            String token = parseToken(pattern, indexRef);\n            if (isNumericToken(token)) {\n                formatters.add(DateTimeFormat.forPattern(token));\n            } else {\n                formatters.add(new DateTimeFormatterBuilder().appendLiteral(token).toFormatter());\n            }\n        }\n\n        return new DateTimeFormatterBuilder().append(formatters.toArray(new DateTimeFormatter[0])).toFormatter();\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    StringBuilder buf = new StringBuilder();\n    int[] indexRef = new int[1];\n    indexRef[0] = 0;\n    while (indexRef[0] < pattern.length()) {\n        String token = parseToken(pattern, indexRef);\n        if (isNumericToken(token)) {\n            buf.append(\"'\").append(token).append(\"'\");\n        } else {\n            buf.append(token);\n        }\n    }\n    return new DateTimeFormatterBuilder().appendPattern(buf.toString()).toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    int[] indexRef = new int[1];\n    List<DateTimeFormatter> formatters = new ArrayList<DateTimeFormatter>();\n    while (indexRef[0] < pattern.length()) {\n        String token = parseToken(pattern, indexRef);\n        if (isNumericToken(token)) {\n            formatters.add(DateTimeFormat.forPattern(token));\n        } else {\n            formatters.add(new DateTimeFormatterBuilder().appendLiteral(token).toFormatter());\n        }\n    }\n    return new DateTimeFormatterBuilder().append(formatters.toArray(new DateTimeFormatter[formatters.size()])).toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    int[] indexRef = new int[1];\n    while (indexRef[0] < pattern.length()) {\n        String token = parseToken(pattern, indexRef);\n        if (isNumericToken(token)) {\n            // Number\n            builder.appendValue(DateTimeFieldType.year(), 4, 4, SignStyle.EXCEEDS_PAD);\n        } else {\n            // Text\n            builder.appendText(DateTimeFieldType.year(), TextStyle.FULL);\n        }\n    }\n    return builder.toFormatter();\n}"
    ],
    [
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.VOID) {\n    return newNode(Token.VOID);\n  } else if (token == JsDocToken.TYPE_NAME) {\n    return parseTypeName(token);\n  } else if (token == JsDocToken.LP) {\n    return parseFunctionType(token);\n  } else if (token == JsDocToken.LC) {\n    return parseRecordType(token);\n  } else if (token == JsDocToken.LB) {\n    return parseArrayType(token);\n  } else if (token == JsDocToken.PIPE) {\n    return parseUnionType(token);\n  }\n\n  return null;\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL) {\n      return newNode(Token.NULL);\n    } else if (token == JsDocToken.VOID) {\n      return newNode(Token.VOID);\n    } else if (token == JsDocToken.IDENT) {\n      return parseTypeName(token);\n    } else if (token == JsDocToken.FUNCTION) {\n      return parseFunctionType(token);\n    } else if (token == JsDocToken.PIPE) {\n      return parseUnionType(token);\n    } else if (token == JsDocToken.LC) {\n      return parseRecordType(token);\n    } else if (token == JsDocToken.LS) {\n      return parseArrayType(token);\n    }\n\n    return null;\n  }",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  switch (token) \n  {\n    case ASTERISK:\n      return newNode(Token.STAR);\n    case NULL:\n      return newNode(Token.NULL);\n    case UNDEFINED:\n      return newNode(Token.VOID);\n    case NAME:\n      return newNode(Token.NAME, token.stringValue());\n    case LB:\n      return parseArrayType(token);\n    case LC:\n      return parseRecordType(token);\n    case LT:\n      return parseFunctionType(token);\n    case PIPE:\n      return parseUnionType(token);\n    default:\n      return null;\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  switch (token) {\n    case STAR:\n      return newNode(Token.STAR);\n    case NULL:\n      return newNode(Token.NULL);\n    case UNDEFINED:\n      return newNode(Token.UNDEFINED);\n    case NAME:\n      return parseTypeName(token);\n    case LB:\n      return parseArrayType(token);\n    case LC:\n      return parseRecordType(token);\n    case LP:\n      return parseFunctionType(token);\n    case PIPE:\n      return parseUnionType(token);\n    default:\n      return null;\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) \n    {\n        return newNode(Token.STAR);\n    } \n    else if (token == JsDocToken.NULL) \n    {\n        return newNode(Token.NULL);\n    } \n    else if (token == JsDocToken.VOID) \n    {\n        return newNode(Token.VOID);\n    } \n    else if (token == JsDocToken.TYPE_NAME) \n    {\n        return newNode(Token.TYPE_NAME);\n    } \n    else if (token == JsDocToken.FUNCTION) \n    {\n        return parseFunctionType(next());\n    } \n    else if (token == JsDocToken.PIPE) \n    {\n        return parseUnionType(next());\n    } \n    else if (token == JsDocToken.LC) \n    {\n        return parseRecordType(next());\n    } \n    else if (token == JsDocToken.LB) \n    {\n        return parseArrayType(next());\n    } \n    else \n    {\n        return null;\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.VOID) {\n    return newNode(Token.VOID);\n  } else if (token == JsDocToken.TYPE_NAME) {\n    return parseTypeName(next());\n  } else if (token == JsDocToken.FUNCTION) {\n    return parseFunctionType(next());\n  } else if (token == JsDocToken.PIPE) {\n    return parseUnionType(next());\n  } else if (token == JsDocToken.LB) {\n    return parseRecordType(next());\n  } else if (token == JsDocToken.LB) {\n    return parseArrayType(next());\n  } else {\n    return null;\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) \n  {\n    return newNode(Token.STAR);\n  } \n  else if (token == JsDocToken.NULL) \n  {\n    return newNode(Token.NULL);\n  } \n  else if (token == JsDocToken.VOID) \n  {\n    return newNode(Token.VOID);\n  } \n  else if (token == JsDocToken.STRING) \n  {\n    return newNode(Token.STRING);\n  } \n  else if (token == JsDocToken.NUMBER) \n  {\n    return newNode(Token.NUMBER);\n  } \n  else if (token == JsDocToken.BOOLEAN) \n  {\n    return newNode(Token.BOOLEAN);\n  } \n  else if (token == JsDocToken.FUNCTION) \n  {\n    return parseFunctionType(next());\n  } \n  else if (token == JsDocToken.UNION) \n  {\n    return parseUnionType(next());\n  } \n  else if (token == JsDocToken.RECORD) \n  {\n    return parseRecordType(next());\n  } \n  else if (token == JsDocToken.ARRAY) \n  {\n    return parseArrayType(next());\n  } \n  else \n  {\n    return parseTypeName(token);\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.UNDEFINED) {\n    return newNode(Token.VOID);\n  } else if (token == JsDocToken.IDENTIFIER) {\n    return parseTypeName(token);\n  } else if (token == JsDocToken.FUNCTION) {\n    return parseFunctionType(token);\n  } else if (token == JsDocToken.UNION) {\n    return parseUnionType(token);\n  } else if (token == JsDocToken.RECORD) {\n    return parseRecordType(token);\n  } else if (token == JsDocToken.ARRAY) {\n    return parseArrayType(token);\n  }\n\n  return null;\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL) {\n      return newNode(Token.NULL);\n    } else if (token == JsDocToken.VOID) {\n      return newNode(Token.VOID);\n    } else if (token == JsDocToken.TYPE_NAME) {\n      return parseTypeName(next());\n    } else if (token == JsDocToken.FUNCTION) {\n      return parseFunctionType(next());\n    } else if (token == JsDocToken.PIPE) {\n      return parseUnionType(next());\n    } else if (token == JsDocToken.LC) {\n      return parseRecordType(next());\n    } else if (token == JsDocToken.LB) {\n      return parseArrayType(next());\n    }\n\n    return null;\n  }",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n        return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL) {\n        return newNode(Token.NULL);\n    } else if (token == JsDocToken.VOID) {\n        return newNode(Token.VOID);\n    } else if (token == JsDocToken.TYPE_NAME) {\n        return parseTypeName(next());\n    } else if (token == JsDocToken.FUNCTION) {\n        return parseFunctionType(next());\n    } else if (token == JsDocToken.PIPE) {\n        return parseUnionType(next());\n    } else if (token == JsDocToken.LC) {\n        return parseRecordType(next());\n    } else if (token == JsDocToken.LS) {\n        return parseArrayType(next());\n    }\n\n    return null;\n}"
    ],
    [
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (stackSize == 0) {\n      throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n\n    beforeValue();\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (stackSize == 0) {\n        throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    if (deferredName != null) {\n        throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n\n    // if the next token is not a name, the parser may accept a null name.\n    // this is especially true for the first name in an object or in a\n    // first array. in these cases, the parser will accept a null name.\n    // we can avoid this problem by deferring the name until we know if\n    // it is required.\n    deferredName = name;\n    deferredNameForNull = true;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) \n    {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) \n    {\n        throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n\n    if (stackSize == 0) \n    {\n        throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    int context = peek();\n    if (context != NONEMPTY_OBJECT) \n    {\n        if (context == EMPTY_OBJECT) \n        {\n            replaceTop(NONEMPTY_OBJECT);\n        } \n        else \n        {\n            throw new IllegalStateException(\"Nesting problem.\");\n        }\n    }\n    beforeName();\n    string(name);\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) \n    {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (stackSize == 1) \n    {\n        throw new IllegalStateException(\"Dangling name: \" + name);\n    }\n\n    // add new deferred name\n    if (deferredName != null) \n    {\n        throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n    deferredName = name;\n\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) \n    {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (stackSize == 0) \n    {\n        throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    if (deferredName != null) \n    {\n        throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n    beforeValue();\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (stackSize == 0) {\n      throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n\n    beforeValue();\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (stackSize == 0) {\n        throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    if (deferredName != null) {\n        throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n\n    // If the next token is NOT a name, the parser will synthesize a name token\n    // after the next call to nextToken(). We want to keep the original string\n    // so that this name can be re-used.\n    deferredName = name;\n\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (stackSize == 1) {\n      throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n\n    beforeValue();\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (stackSize == 0) {\n        throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    if (deferredName != null) {\n        throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n\n    // Optimization to avoid inlining toString().equals()\n    if (name.equals(\"value\")) {\n        writeDeferredName();\n        return this;\n    }\n\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (stackSize == 1) {\n        throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    if (deferredName != null) {\n        throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n\n    beforeValue();\n    deferredName = name;\n    return this;\n}"
    ],
    [
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    // check arguments\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    // get the group count\n    int groupCount = dataset.getColumnCount();\n    // get the series count\n    int seriesCount = dataset.getRowCount();\n    // result\n    Number result = null;\n    // minimum and maximum for each group...\n    double[] minimum = new double[groupCount];\n    double[] maximum = new double[groupCount];\n    // initialise the arrays\n    for (int g = 0; g < groupCount; g++) {\n        minimum[g] = Double.MAX_VALUE;\n        maximum[g] = -Double.MAX_VALUE;\n    }\n    // find the minimum and maximum for each group...\n    for (int item = 0; item < groupCount; item++) {\n        double[] positive = new double[seriesCount];\n        double[] negative = new double[seriesCount];\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    positive[series] = positive[series] + value;\n                }\n                if (value < 0.0) {\n                    negative[series] = negative[series] + value;\n                    // '+', remember value is negative\n                }\n            }\n        }\n        for (int g = 0; g < groupCount; g++) {\n            minimum[g] = Math.min(minimum[g], negative[g]);\n            maximum[g] = Math.max(maximum[g], positive[g]);\n        }\n    }\n    // find the minimum value\n    for (int g = 0; g < groupCount; g++) {\n        if (minimum[g] < maximum[g]) {\n            result = minimum[g];\n            break;\n        }\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    // create an array holding the group indices for each series...\n    int[] groupIndex = new int[dataset.getRowCount()];\n    for (int i = 0; i < dataset.getRowCount(); i++) {\n        groupIndex[i] = dataset.getRowKey(i);\n    }\n\n    // minimum and maximum for each group...\n    int groupCount = dataset.getRowCount();\n    double[] minimum = new double[groupCount];\n\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double[] positive = new double[groupCount];\n        double[] negative = new double[groupCount];\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    positive[groupIndex[series]]\n                                 = positive[groupIndex[series]] + value;\n                }\n                if (value < 0.0) {\n                    negative[groupIndex[series]]\n                                 = negative[groupIndex[series]] + value;\n                                 // '+', remember value is negative\n                }\n            }\n        }\n        for (int g = 0; g < groupCount; g++) {\n            minimum[g] = Math.min(minimum[g], negative[g]);\n        }\n    }\n    double result = Double.MAX_VALUE;\n    for (int g = 0; g < groupCount; g++) {\n        result = Math.min(result, minimum[g]);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    boolean hasValidData = false;\n    Number result = null;\n\n    // create an array holding the group indices for each series...\n    int[] groupIndex = new int[dataset.getRowCount()];\n    for (int i = 0; i < dataset.getRowCount(); i++) {\n        groupIndex[i] = map.getGroupIndex(map.getGroup(\n                dataset.getRowKey(i)));\n    }\n\n    // minimum and maximum for each group...\n    int groupCount = map.getGroupCount();\n    double[] minimum = new double[groupCount];\n    double[] maximum = new double[groupCount];\n\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double[] positive = new double[groupCount];\n        double[] negative = new double[groupCount];\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    positive[groupIndex[series]]\n                             = positive[groupIndex[series]] + value;\n                }\n                if (value < 0.0) {\n                    negative[groupIndex[series]]\n                             = negative[groupIndex[series]] + value;\n                    // '+', remember value is negative\n                }\n            }\n        }\n        for (int g = 0; g < groupCount; g++) {\n            minimum[g] = Math.min(minimum[g], negative[g]);\n            maximum[g] = Math.max(maximum[g], positive[g]);\n        }\n    }\n    if (hasValidData) {\n        for (int j = 0; j < groupCount; j++) {\n            result = Range.combine(result, new Range(minimum[j],\n}\n}\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    boolean hasValidData = false;\n    Number result = null;\n\n    // create an array holding the group indices for each series...\n    int[] groupIndex = new int[dataset.getRowCount()];\n    for (int i = 0; i < dataset.getRowCount(); i++) {\n        groupIndex[i] = map.getGroupIndex(map.getGroup(\n                dataset.getRowKey(i)));\n    }\n\n    // minimum and maximum for each group...\n    int groupCount = map.getGroupCount();\n    double[] minimum = new double[groupCount];\n    double[] maximum = new double[groupCount];\n\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double[] positive = new double[groupCount];\n        double[] negative = new double[groupCount];\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    positive[groupIndex[series]]\n                             = positive[groupIndex[series]] + value;\n                }\n                if (value < 0.0) {\n                    negative[groupIndex[series]]\n                             = negative[groupIndex[series]] + value;\n                             // '+', remember value is negative\n                }\n            }\n        }\n        for (int g = 0; g < groupCount; g++) {\n            minimum[g] = Math.min(minimum[g], negative[g]);\n            maximum[g] = Math.max(maximum[g], positive[g]);\n        }\n    }\n    if (hasValidData) {\n        for (int j = 0; j < groupCount; j++) {\n            result = Math.min(result, new Double(minimum[j]));\n        }\n}\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    // check arguments\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    // find the minimum value\n    int categoryCount = dataset.getColumnCount();\n    double minimum = Double.POSITIVE_INFINITY;\n    for (int item = 0; item < categoryCount; item++) {\n        double value = findStackedRangeValue(dataset, item, true);\n        if (value < minimum) {\n            minimum = value;\n        }\n    }\n\n    // return the result\n    if (minimum == Double.POSITIVE_INFINITY) {\n        return null;\n    } else {\n        return new Double(minimum);\n    }\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    // check arguments\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    // find the minimum value in the dataset\n    double result = Double.POSITIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double minimum = Double.POSITIVE_INFINITY;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                double value = number.doubleValue();\n                if (value < minimum) {\n                    minimum = value;\n                }\n            }\n        }\n        result = Math.min(result, minimum);\n    }\n    return new Double(result);\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    // check arguments...\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    // find the minimum value...\n    int seriesCount = dataset.getRowCount();\n    int categoryCount = dataset.getColumnCount();\n    double result = Double.POSITIVE_INFINITY;\n    for (int item = 0; item < categoryCount; item++) {\n        double minimum = Double.POSITIVE_INFINITY;\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    minimum = Math.min(minimum, value);\n                }\n            }\n        }\n        result = Math.min(result, minimum);\n    }\n\n    // return the result...\n    if (result == Double.POSITIVE_INFINITY) {\n        return null;\n    } else {\n        return new Double(result);\n    }\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    boolean hasValidData = false;\n    Number result = null;\n\n    // create an array holding the group indices for each series...\n    int[] groupIndex = new int[dataset.getRowCount()];\n    for (int i = 0; i < dataset.getRowCount(); i++) {\n        groupIndex[i] = map.getGroupIndex(map.getGroup(\n                dataset.getRowKey(i)));\n    }\n\n    // minimum and maximum for each group...\n    int groupCount = map.getGroupCount();\n    double[] minimum = new double[groupCount];\n    double[] maximum = new double[groupCount];\n\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double[] positive = new double[groupCount];\n        double[] negative = new double[groupCount];\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    positive[groupIndex[series]]\n                             = positive[groupIndex[series]] + value;\n                }\n                if (value < 0.0) {\n                    negative[groupIndex[series]]\n                             = negative[groupIndex[series]] + value;\n                    // '+', remember value is negative\n                }\n            }\n        }\n        for (int g = 0; g < groupCount; g++) {\n            minimum[g] = Math.min(minimum[g], negative[g]);\n            maximum[g] = Math.max(maximum[g], positive[g]);\n        }\n    }\n    if (hasValidData) {\n        for (int j = 0; j < groupCount; j++) {\n            result = Range.combine(result, new Range(minimum[j],\n}\n}\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range range = findStackedRangeBounds(dataset, null);\n    return (range == null ? null : new Double(range.getLowerBound()));\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range range = findStackedRangeBounds(dataset, new KeyToGroupMap());\n    return (range == null ? null : new Double(range.getLowerBound()));\n}"
    ],
    [
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}"
    ],
    [
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) {\n        return StringUtils.swapCase(str.substring(0, 1)) + StringUtils.swapCase(str.substring(1));\n    }\n    final Set<Character> delimiterSet = new HashSet<>();\n    for (final char delimiter : delimiters) {\n        delimiterSet.add(delimiter);\n    }\n    final char[] buffer = str.toCharArray();\n    boolean whitespace = true;\n    int count = 0;\n    for (final char ch : buffer) {\n        if (delimiterSet.contains(ch)) {\n            whitespace = true;\n        } else if (Character.isLetter(ch)) {\n            if (whitespace) {\n                buffer[count++] = ch;\n                whitespace = false;\n            }\n        } else {\n            whitespace = true;\n        }\n    }\n    return new String(buffer, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) {\n        return initials(str);\n    }\n    final Set<Character> delimiterSet = new HashSet<>();\n    for (final char delimiter : delimiters) {\n        delimiterSet.add(delimiter);\n    }\n    final char[] buffer = str.toCharArray();\n    boolean whitespace = true;\n    int count = 0;\n\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (delimiterSet.contains(ch)) {\n            whitespace = true;\n        } else if (Character.isLetter(ch)) {\n            if (whitespace) {\n                buffer[count++] = ch;\n                whitespace = false;\n            }\n        } else {\n            whitespace = true;\n        }\n    }\n    return new String(buffer, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) {\n        return initials(str);\n    }\n    final Set<Character> delimiterSet = new HashSet<>();\n    for (final char delimiter : delimiters) {\n        delimiterSet.add(delimiter);\n    }\n    final char[] buffer = str.toCharArray();\n    final StringBuilder initials = new StringBuilder();\n    boolean whitespace = true;\n    for (final char ch : buffer) {\n        if (delimiterSet.contains(ch)) {\n            whitespace = true;\n        } else if (whitespace) {\n            initials.append(ch);\n            whitespace = false;\n        }\n    }\n    return initials.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) {\n        return initials(str);\n    }\n    final char[] buffer = str.toCharArray();\n    final Set<Character> delimitersSet = new HashSet<>(delimiters.length);\n    for (final char delimiter : delimiters) {\n        delimitersSet.add(delimiter);\n    }\n    final StringBuilder initials = new StringBuilder((int) (buffer.length * 1.3));\n    boolean whitespace = true;\n    for (final char ch : buffer) {\n        if (delimitersSet.contains(ch)) {\n            whitespace = true;\n        } else if (whitespace) {\n            initials.append(Character.toUpperCase(ch));\n            whitespace = false;\n        }\n    }\n    return initials.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) {\n        return initials(str);\n    }\n    final Set<Character> delimiterSet = new HashSet<Character>(delimiters.length);\n    for (final char delimiter : delimiters) {\n        delimiterSet.add(delimiter);\n    }\n    final String[] words = StringUtils.split(str, delimiterSet);\n    final StringBuilder initials = new StringBuilder(str.length());\n    for (final String word : words) {\n        if (initials.length() == 0) {\n            initials.append(Character.toUpperCase(word.charAt(0)));\n        } else {\n            initials.append(Character.toUpperCase(word.charAt(0)));\n        }\n    }\n    return initials.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) {\n        return initials(str);\n    }\n    final Set<Character> delimiterSet = new HashSet<>(delimiters.length);\n    for (final char delimiter : delimiters) {\n        delimiterSet.add(delimiter);\n    }\n    final char[] buffer = str.toCharArray();\n    boolean isInDelimiter = false;\n    final StringBuilder initials = new StringBuilder(buffer.length);\n    for (final char ch : buffer) {\n        if (delimiterSet.contains(ch)) {\n            isInDelimiter = true;\n        } else if (Character.isLetter(ch)) {\n            if (isInDelimiter) {\n                initials.append(ch);\n                isInDelimiter = false;\n            }\n        }\n    }\n    return initials.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) \n    {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) \n    {\n        return initials(str);\n    }\n    final char[] buffer = str.toCharArray();\n    boolean whitespace = true;\n    int count = 0;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            whitespace = true;\n        } \n        else if (whitespace) \n        {\n            buffer[count++] = ch;\n            whitespace = false;\n        }\n    }\n    return new String(buffer, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) \n    {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) \n    {\n        return initials(str);\n    }\n    final Set<Character> delimiterSet = new HashSet<Character>();\n    for (final char delimiter : delimiters) \n    {\n        delimiterSet.add(delimiter);\n    }\n    final char[] buffer = str.toCharArray();\n    boolean isInDelimiter = false;\n    final StringBuilder initials = new StringBuilder();\n    for (final char ch : buffer) \n    {\n        if (isInDelimiter) \n        {\n            if (delimiterSet.contains(ch)) \n            {\n                // currently in a delimiter, so do nothing\n            } \n            else \n            {\n                initials.append(ch);\n                isInDelimiter = false;\n            }\n        } \n        else \n        {\n            if (delimiterSet.contains(ch)) \n            {\n                isInDelimiter = true;\n            } \n            else \n            {\n                initials.append(ch);\n            }\n        }\n    }\n    return initials.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) {\n        return StringUtils.swapCase(str.substring(0, 1)) + StringUtils.swapCase(str).substring(1);\n    }\n    final Set<Character> delimiterSet = new HashSet<Character>();\n    for (final char delimiter : delimiters) {\n        delimiterSet.add(delimiter);\n    }\n    final char[] buffer = str.toCharArray();\n    boolean whitespace = true;\n    int count = 0;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (delimiterSet.contains(ch)) {\n            whitespace = true;\n        } else if (Character.isLetter(ch)) {\n            if (whitespace) {\n                buffer[count++] = Character.toUpperCase(ch);\n                whitespace = false;\n            } else {\n                buffer[count++] = Character.toLowerCase(ch);\n            }\n        } else {\n            whitespace = Character.isWhitespace(ch);\n        }\n    }\n    return new String(buffer, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) {\n        return StringUtils.swapCase(str.substring(0, 1));\n    }\n    final Set<Character> delimiterSet = new HashSet<>();\n    for (final char delimiter : delimiters) {\n        delimiterSet.add(delimiter);\n    }\n    final char[] buffer = str.toCharArray();\n    boolean whitespace = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (delimiterSet.contains(ch)) {\n            whitespace = true;\n        } else if (whitespace) {\n            buffer[i] = Character.toTitleCase(ch);\n            whitespace = false;\n        }\n    }\n    return new String(buffer);\n}"
    ],
    [
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0.0;\n    for (int i = 0; i < data.getRowCount(); i++) {\n        total += data.getValue(i, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    int rowCount = data.getRowCount();\n    double total = 0.0;\n    for (int row = 0; row < rowCount; row++) {\n        total += data.getValue(row, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    for (int row = 0; row < data.getRowCount(); row++) {\n        total += data.getValue(row, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0.0;\n    for (int row = 0; row < data.getRowCount(); row++) {\n        total += data.getValue(row, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    for (int row = 0; row < data.getRowCount(); row++) {\n        total += data.getValue(row, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    int rowCount = data.getRowCount();\n    double total = 0.0;\n    for (int row = 0; row < rowCount; row++) {\n        total += data.getValue(row, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0.0;\n    int rows = data.getRowCount();\n    for (int r = 0; r < rows; r++) {\n        total += data.getValue(r, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0.0;\n    for (int row = 0; row < data.getRowCount(); row++) \n    {\n        total += data.getValue(row, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    int rowCount = data.getRowCount();\n    double total = 0.0;\n    for (int row = 0; row < rowCount; row++) \n    {\n        total += data.getValue(row, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int row = 0; row < rowCount; row++) \n    {\n        total += data.getValue(row, column);\n    }\n    return total;\n}"
    ],
    [
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    // perform some checks\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    // get the chart area\n    Rectangle2D chartArea = getChartArea();\n    // convert the screen point to a Java2D point\n    double x = screenPoint.x - chartArea.getX();\n    double y = screenPoint.y - chartArea.getY();\n    // scale the point\n    x /= this.scaleX;\n    y /= this.scaleY;\n    // return the result\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    // perform argument checking\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    // translate the point\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / this.scaleX;\n    double y = (screenPoint.y - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / this.scaleX;\n    double y = (screenPoint.y - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / this.scaleX;\n    double y = (screenPoint.y - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / this.scaleX;\n    double y = (screenPoint.y - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    // perform argument checking\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n\n    // translate the screen point to Java2D coordinates\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / this.scaleX;\n    double y = (screenPoint.y - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / this.scaleX;\n    double y = (screenPoint.y - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / this.scaleX;\n    double y = (screenPoint.y - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    // perform some simple checks\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    int x = screenPoint.x - insets.left;\n    int y = screenPoint.y - insets.top;\n    return new Point2D.Double(x / this.scaleX, y / this.scaleY);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    // perform argument checking\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    // get the insets\n    Insets insets = getInsets();\n    // calculate the Java2D coordinates\n    double x = (screenPoint.x - insets.left) / this.scaleX;\n    double y = (screenPoint.y - insets.top) / this.scaleY;\n    // return the result\n    return new Point2D.Double(x, y);\n}"
    ],
    [
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final String[] parts = source.split(\" / \");\n        if (parts.length != 2) {\n            throw new MathParseException(LocalizedFormats.IMPROPER_FRACTION_FORMAT, source);\n        }\n\n        final BigInteger numerator;\n        final BigInteger denominator;\n        try {\n            numerator = getNumeratorFormat().parse(parts[0]);\n            denominator = getDenominatorFormat().parse(parts[1]);\n        } catch (final MathParseException e) {\n            throw new MathParseException(LocalizedFormats.IMPROPER_FRACTION_FORMAT, source, e);\n        }\n\n        return new BigFraction(numerator, denominator);\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        return parse(source, 0);\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final int slashIndex = source.indexOf('/');\n        if (slashIndex == -1) {\n            throw new MathParseException(LocalizedFormats.UNABLE_TO_PARSE_FRACTION, source);\n        }\n\n        final BigInteger numerator;\n        final BigInteger denominator;\n        try {\n            numerator = getNumeratorFormat().parse(source.substring(0, slashIndex));\n            denominator = getDenominatorFormat().parse(source.substring(slashIndex + 1));\n        } catch (final ParseException ex) {\n            throw new MathParseException(LocalizedFormats.UNABLE_TO_PARSE_FRACTION, source, ex);\n        }\n\n        return new BigFraction(numerator, denominator);\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final String[] parts = source.split(\"/\");\n        if (parts.length != 2) {\n            throw new MathParseException(LocalizedFormats.CANNOT_PARSE_FRACTION, source);\n        }\n        final BigInteger numerator = new BigInteger(parts[0]);\n        final BigInteger denominator = new BigInteger(parts[1]);\n        return new BigFraction(numerator, denominator);\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final String[] parts = source.split(\"\\\\s*/\\\\s*\");\n        if (parts.length != 2) {\n            throw new MathParseException(LocalizedFormats.CANNOT_PARSE_FRACTION, source);\n        }\n\n        final BigInteger numerator;\n        try {\n            numerator = getNumeratorFormat().parse(parts[0]);\n        } catch (final MathParseException ex) {\n            throw new MathParseException(LocalizedFormats.CANNOT_PARSE_FRACTION, source, ex);\n        }\n\n        final BigInteger denominator;\n        try {\n            denominator = getDenominatorFormat().parse(parts[1]);\n        } catch (final MathParseException ex) {\n            throw new MathParseException(LocalizedFormats.CANNOT_PARSE_FRACTION, source, ex);\n        }\n\n        return new BigFraction(numerator, denominator);\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final String[] split = source.split(\" / \");\n        if (split.length != 2) {\n            throw new MathParseException(LocalizedFormats.CANNOT_PARSE_FRACTION, source);\n        }\n        try {\n            return new BigFraction(getNumeratorFormat().parse(split[0]),\n                                   getDenominatorFormat().parse(split[1]));\n        } catch (final ParseException ex) {\n            throw new MathParseException(LocalizedFormats.CANNOT_PARSE_FRACTION, source, ex);\n        }\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final String[] fractionParts = source.split(\"/\");\n        if (fractionParts.length != 2) {\n            throw new MathParseException(LocalizedFormats.CANNOT_PARSE_FRACTION, source);\n        }\n\n        final BigInteger numerator;\n        final BigInteger denominator;\n        try {\n            numerator = new BigInteger(fractionParts[0]);\n            denominator = new BigInteger(fractionParts[1]);\n        } catch (NumberFormatException nfe) {\n            throw new MathParseException(LocalizedFormats.CANNOT_PARSE_FRACTION, source);\n        }\n\n        return new BigFraction(numerator, denominator);\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final String[] parts = source.split(\" / \");\n        if (parts.length != 2) {\n            throw new MathParseException(LocalizedFormats.IMPROPER_FRACTION_FORMAT, source);\n        }\n        try {\n            return new BigFraction(getNumeratorFormat().parse(parts[0]),\n                                   getDenominatorFormat().parse(parts[1]));\n        } catch (final ParseException e) {\n            throw new MathParseException(LocalizedFormats.IMPROPER_FRACTION_FORMAT, source, e);\n        }\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final String[] split = source.split(\" / \");\n        if (split.length != 2) {\n            throw new MathParseException(LocalizedFormats.CANNOT_PARSE_FRACTION, source);\n        }\n\n        final BigInteger numerator = getNumeratorFormat().parse(split[0]);\n        final BigInteger denominator = getDenominatorFormat().parse(split[1]);\n\n        return new BigFraction(numerator, denominator);\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final String[] numDen = source.split(\"/\");\n        if (numDen.length != 2) {\n            throw new MathParseException(LocalizedFormats.CANNOT_PARSE_FRACTION, source);\n        }\n\n        final BigInteger numerator = getNumeratorFormat().parse(numDen[0]);\n        final BigInteger denominator = getDenominatorFormat().parse(numDen[1]);\n\n        return new BigFraction(numerator, denominator);\n    }"
    ],
    [
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return new ListOrderedSet<E>(new HashSet<E>(), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return listOrderedSet(new HashSet<E>(), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return listOrderedSet(new HashSet<E>(), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return listOrderedSet(new HashSet<E>(), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return listOrderedSet(new HashSet<E>(), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    return new ListOrderedSet<E>(new HashSet<E>(), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    final Set<E> set = new HashSet<E>(list);\n    list.clear();\n    return new ListOrderedSet<E>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    return new ListOrderedSet<E>(new HashSet<E>(), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return new ListOrderedSet<E>(new HashSet<E>(), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return listOrderedSet(new HashSet<E>(), list);\n}"
    ],
    [
      "public Range getDataRange(ValueAxis axis)  {\n    // if the axis is not the range axis, return null\n    if (axis != getRangeAxis()) {\n        return null;\n    }\n\n    // get the range for all the subplots\n    Range result = null;\n    for (int i = 0; i < this.subplots.size(); i++) {\n        CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n        Range range = plot.getDataRange(axis);\n        if (result == null) {\n            result = range;\n        }\n        else {\n            result = result.combine(range);\n        }\n    }\n\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    for (int i = 0; i < this.subplots.size(); i++) {\n        CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n        Range subplotRange = plot.getDataRange(axis);\n        if (result == null) {\n            result = subplotRange;\n        }\n        else {\n            result = result.combineRange(subplotRange);\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    Iterator iterator = this.subplots.iterator();\n    while (iterator.hasNext()) {\n        CategoryPlot plot = (CategoryPlot) iterator.next();\n        Range range = plot.getDataRange(axis);\n        if (result == null) {\n            result = range;\n        }\n        else {\n            result = result.combine(range);\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    Iterator iterator = this.subplots.iterator();\n    while (iterator.hasNext()) {\n        CategoryPlot plot = (CategoryPlot) iterator.next();\n        Range range = plot.getDataRange(axis);\n        if (result == null) {\n            result = range;\n        }\n        else {\n            result = result.combine(range);\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    Iterator iterator = this.subplots.iterator();\n    while (iterator.hasNext()) {\n        CategoryPlot plot = (CategoryPlot) iterator.next();\n        Range range = plot.getDataRange(axis);\n        if (result == null) {\n            result = range;\n        }\n        else {\n            result = result.combine(range);\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    // calculate the data range...\n    Range result = null;\n    for (int i = 0; i < this.subplots.size(); i++) {\n        CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n        Range range = plot.getDataRange(axis);\n        if (result == null) {\n            result = range;\n        }\n        else {\n            result = result.combineRange(range);\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    for (int i = 0; i < this.subplots.size(); i++) {\n        CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n        Range range = plot.getDataRange(axis);\n        if (result == null) {\n            result = range;\n        }\n        else {\n            result = result.combine(range);\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    Iterator iterator = this.subplots.iterator();\n    while (iterator.hasNext()) {\n        CategoryPlot plot = (CategoryPlot) iterator.next();\n        Range range = plot.getDataRange(axis);\n        if (result == null) {\n            result = range;\n        }\n        else {\n            result = result.combine(range);\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    // find the subplot that uses the axis\n    CategoryPlot subplot = null;\n    for (int i = 0; i < this.subplots.size(); i++) {\n        CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n        if (plot.getRangeAxis() == axis) {\n            subplot = plot;\n            break;\n        }\n    }\n    if (subplot == null) {\n        return null;\n    }\n    // ask the subplot for its data range\n    Range range = subplot.getDataRange(axis);\n    return range;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    for (int i = 0; i < this.subplots.size(); i++) {\n        CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n        Range range = plot.getDataRange(axis);\n        if (result == null) {\n            result = range;\n        }\n        else {\n            result = result.combine(range);\n        }\n    }\n    return result;\n}"
    ],
    [
      "public double adjustedLog10(double val)  {\n    // adjust negative values to positive:\n    double adjustedVal = (val < 0.0) ? -val : val;\n    // calculate log10 of adjusted value:\n    double log10Val = Math.log(adjustedVal) / LOG10_VALUE;\n    // if value is less than 10, add scaling factor:\n    if (adjustedVal < 10.0) {\n        log10Val += (1.0 - adjustedVal) / 9.0;\n    }\n    // return negated answer:\n    return -log10Val;\n}",
      "public double adjustedLog10(double val)  {\n    // adjust negative values to positive\n    if (val < 0.0) {\n        val = -val;\n    }\n\n    // adjust for values less than 10\n    double result = Math.log(val) / LOG10_VALUE;\n    if (val < 10.0) {\n        result += (1.0 - val / 10.0);\n    }\n\n    // negate result if original value was negative\n    if (val < 0.0) {\n        result = -result;\n    }\n\n    return result;\n}",
      "public double adjustedLog10(double val)  {\n    // adjust negative values to positive:\n    double adjustedVal = Math.abs(val);\n    // add scaling factor to adjust for values less than 10:\n    double scalingFactor = Math.min(1.0, adjustedVal / 10.0);\n    return -Math.log10(adjustedVal * (1.0 - scalingFactor)) * scalingFactor;\n}",
      "public double adjustedLog10(double val)  {\n    double adjustedVal = val;\n    if (val < 0.0) {\n        adjustedVal = -val;\n    }\n    double log10 = Math.log(adjustedVal) / LOG10_VALUE;\n    if (val < 10.0) {\n        log10 += (1.0 - adjustedVal) / 9.0;\n    }\n    return -log10;\n}",
      "public double adjustedLog10(double val)  {\n    // first, adjust negative values to positive:\n    double adjustedVal = Math.abs(val);\n    // now, adjust for values less than 10:\n    double scaleFactor = (adjustedVal < 10.0) ? (11.0 - adjustedVal) / 10.0 : 1.0;\n    return -Math.log10(adjustedVal) * scaleFactor;\n}",
      "public double adjustedLog10(double val)  {\n    // change negative values to positive:\n    double adjustedVal = Math.abs(val);\n\n    // add scaling factor for values less than 10:\n    double scalingFactor = 1.0;\n    if (adjustedVal < 10.0) {\n        scalingFactor = (10.0 - adjustedVal) / 9.0;\n    }\n    adjustedVal += scalingFactor;\n\n    // calculate log10:\n    double log10Val = Math.log(adjustedVal) / LOG10_VALUE;\n\n    // negate answer if necessary:\n    if (val < 0.0) {\n        log10Val = -log10Val;\n    }\n\n    return log10Val;\n}",
      "public double adjustedLog10(double val)  {\n    // make sure val is positive:\n    double result = Math.log10(Math.abs(val));\n    if (val < 10.0) {\n        // adjust for values less than 10:\n        result -= (10.0 - val) / 10.0;\n    }\n    return -result;\n}",
      "public double adjustedLog10(double val)  {\n    // make negative values positive for calculations:\n    double adjustedVal = Math.abs(val);\n    // adjust for values less than 10:\n    double scalingFactor = (adjustedVal < 10.0)\n            ? 10.0 / adjustedVal\n            : 1.0;\n    return -Math.log10(adjustedVal * scalingFactor);\n}",
      "public double adjustedLog10(double val)  {\n    // adjust negative values:\n    double result = Math.log10(Math.abs(val));\n    // adjust for values less than 10:\n    if (val < 10.0) {\n        result -= (10.0 - val) / 10.0;\n    }\n    // return negative answer:\n    return -result;\n}",
      "public double adjustedLog10(double val)  {\n    // adjust negative values to positive\n    double adjustedVal = (val < 0.0) ? -val : val;\n\n    // if the value is less than 10, add a scaling factor\n    // to make it so that at 0 the value is adjusted to 1\n    double scalingFactor = (adjustedVal < 10.0) ?\n            (10.0 - adjustedVal) / 9.0 : 1.0;\n\n    // calculate the log10 value\n    double log10Val = Math.log(adjustedVal) / LOG10_VALUE;\n\n    // negate the answer if the original value was negative\n    return (val < 0.0) ? -log10Val : log10Val;\n}"
    ],
    [
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  if (cfg.getImplicitReturn() == null) {\n    return false;\n  }\n\n  Node entry = cfg.getEntry();\n  if (entry == null) {\n    return false;\n  }\n\n  Node exit = cfg.getImplicitReturn();\n  if (exit == null) {\n    return false;\n  }\n\n  // If the entry node has no successors, then it must be a return statement\n  // and we can return true.\n  if (cfg.getSuccNodes(entry).isEmpty()) {\n    return true;\n  }\n\n  // If the exit node has no predecessors, then it must be a return statement\n  // and we can return true.\n  if (cfg.getPredNodes(exit).isEmpty()) {\n    return true;\n  }\n\n  // If the entry node has a single successor and the exit node has a single\n  // predecessor, then we can fast-path the check.\n  if (cfg.getSuccNodes(entry).size() == 1\n      && cfg.getPredNodes(exit).size() == 1) {\n    Node entrySucc = cfg.getSuccNodes(entry).get(0);\n    Node exitPred = cfg.getPredNodes(exit).get(0);\n    if (entrySucc == exitPred) {\n      return true;\n    }\n  }\n\n  return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  if (cfg.getImplicitReturn() == null) {\n    return false;\n  }\n\n  // If there are no conditional branches, we can skip the more expensive\n  // check.\n  if (cfg.getEntry().getOutEdges().size() > 1) {\n    return false;\n  }\n\n  // If the only out edge is to the implicit return, then all paths return.\n  Node exit = cfg.getImplicitReturn();\n  if (exit == null) {\n    return false;\n  }\n\n  for (DiGraphEdge<Node, ControlFlowGraph.Branch> edge :\n      cfg.getEntry().getOutEdges()) {\n    if (edge.getDestination() != exit) {\n      return false;\n    }\n  }\n\n  return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  Node entry = cfg.getEntry();\n  Node implicitReturn = cfg.getImplicitReturn();\n\n  if (entry == null || implicitReturn == null) {\n    return false;\n  }\n\n  // Check if there is a path from the entry node to the implicit return node\n  // that does not contain a return statement.\n  return cfg.getReversePostOrder().contains(implicitReturn) &&\n      !cfg.getReversePostOrder().contains(entry);\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  // If the graph has no entry, then it's a function that never returns.\n  if (cfg.getEntry() == null) {\n    return true;\n  }\n\n  // If the graph has no return node, then it's a function that always returns.\n  if (cfg.getImplicitReturn() == null) {\n    return false;\n  }\n\n  // If the graph has only one path, then it must be a return path.\n  if (cfg.getEntry().getOutEdges().size() == 1) {\n    return true;\n  }\n\n  // If the graph has more than one path, then it must have a return path.\n  return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  // Fast path for functions that have no control flow statements.\n  if (cfg.getEntry().getOutEdges().size() == 1) {\n    Node entry = cfg.getEntry().getOutEdges().get(0).getValue().getValue();\n    if (entry.isReturn()) {\n      return true;\n    }\n  }\n\n  // Fast path for functions that have no loops.\n  if (cfg.getLoops().isEmpty()) {\n    Node implicitReturn = cfg.getImplicitReturn();\n    if (implicitReturn != null) {\n      return cfg.getExit().getInEdges().contains(implicitReturn);\n    }\n  }\n\n  return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  // We are looking for a path from the entry node to the implicit return\n  // node that does not contain a return statement.\n  //\n  // If we find such a path, we know that a return statement is missing.\n  //\n  // We can skip the implicit return node because it is always reachable.\n  //\n  // We can skip the entry node because it is the starting point of all\n  // execution paths.\n  //\n  // We can skip nodes that are not reachable because they are not on any\n  // execution path.\n  //\n  // We can skip nodes that are not reachable from the entry node because\n  // they are not on any execution path.\n  //\n  // We can skip nodes that are not reachable from the implicit return node\n  // because they are not on any execution path.\n  //\n  // We can skip nodes that are not reachable from the implicit return node\n  // because they are not on any execution path.\n  //\n  // We can skip nodes that are not reachable from the implicit return node\n  // because they are not on any execution path.\n  //\n  // We can skip nodes that are not reachable from the implicit return node\n  // because they are not on any execution path.\n  //\n  // We can skip nodes that are not reachable from the implicit return node\n  // because they are not on any execution path.\n  //\n  // We can skip nodes that are not reachable from the implicit return node\n  // because they are not on any execution path.\n  //\n  // We can skip nodes that are not reachable from the implicit return node\n  // because they are not on any execution path.\n  //\n  // We can skip nodes that are not reachable from the implicit return node\n  // because they are not on any execution path.\n  //\n  // We can skip nodes that are not reachable from the implicit return node\n  // because they are not on any execution path.\n  //\n  // We can skip nodes that are not reachable from the implicit return node\n  // because they are not on any execution path.\n  //\n  // We can skip nodes that are not reachable from the implicit return node\n  // because they are not on any execution path.\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  Node entry = cfg.getEntry();\n  Node exit = cfg.getImplicitReturn();\n  if (entry == exit) {\n    return true;\n  }\n\n  // If the entry node is a return, then all paths return.\n  if (entry.isReturn()) {\n    return true;\n  }\n\n  // If the exit node is not a return, then all paths return.\n  if (!exit.isReturn()) {\n    return true;\n  }\n\n  // If there are no edges between the entry and exit, then all paths return.\n  if (cfg.getEdgesConnecting(entry, exit).isEmpty()) {\n    return true;\n  }\n\n  // If the entry node is a function, and the exit node is a return, then all\n  // paths return.\n  if (entry.isFunction() && exit.isReturn()) {\n    return true;\n  }\n\n  // If the entry node is a conditional, and the exit node is a return, then\n  // all paths return.\n  if (entry.isConditional() && exit.isReturn()) {\n    return true;\n  }\n\n  // If the entry node is a loop, and the exit node is a return, then all\n  // paths return.\n  if (entry.isLoop() && exit.isReturn()) {\n    return true;\n  }\n\n  // If the entry node is a switch, and the exit node is a return, then all\n  // paths return.\n  if (entry.isSwitch() && exit.isReturn()) {\n    return true;\n  }\n\n  // If the entry node is a try, and the exit node is a return, then all\n  // paths return.\n  if (entry.isTry() && exit.isReturn()) {\n    return true;\n  }\n\n  // If the entry node is a throw, and the exit node is a return, then all\n  // paths return.\n  if (entry.isThrow() && exit.isReturn()) {\n    return true;\n  }\n\n  // If the entry node is a case, and the exit node is a return, then all\n  // paths return.\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  // TODO(user): This is a fast path check. It is possible that the return\n  // statement is missing.\n  // We could do a more thorough check, but it is not necessary for now.\n  return cfg.getImplicitReturn().getInEdges().size() == 1;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  // TODO(user): This is a fast check that is not always correct.\n  // The problem is that we don't know if the function is a constructor.\n  // If it is, then we don't know if it is supposed to return an object.\n  // This is not a problem for the compiler, but it is a problem for\n  // the type checker.\n  //\n  // We should be able to do better than this, but this is a start.\n  //\n  // We will only check the first block of the function.\n  // If the function has no return statement, then the first block\n  // will be the only block.\n  //\n  // If the function has a return statement, then the first block\n  // will be the only block if the function has no fall through.\n  //\n  // If the function has a fall through, then the first block will\n  // have a fall through to the second block.\n  //\n  // If the function has a return statement and a fall through, then\n  // the first block will have a fall through to the second block\n  // if and only if the fall through is not the implicit return.\n  //\n  // If the function has a return statement and a fall through, then\n  // the first block will have a fall through to the second block\n  // if and only if the fall through is not the implicit return.\n  //\n  // We will also ignore any code after a return statement.\n  //\n  // We will also ignore any code after a throw statement.\n  //\n  // We will also ignore any code after a break statement.\n  //\n  // We will also ignore any code after a continue statement.\n  //\n  // We will also ignore any code after a return statement.\n  //\n  // We will also ignore any code after a throw statement.\n  //\n  // We will also ignore any code after a break statement.\n  //\n  // We will also ignore any code after a continue statement.\n  //\n  // We will also ignore any code after a return statement.\n  //\n  // We will also ignore any code after a throw statement.\n  //\n  // We will also ignore any code after a break statement.\n  //\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  // Check for a function with no return statement.\n  if (cfg.getImplicitReturn() == null) {\n    return true;\n  }\n\n  // Check for a function with no conditional branches.\n  if (cfg.getEntry().getOutEdges().size() == 1) {\n    return true;\n  }\n\n  // Check for a function with no loops.\n  if (cfg.getLoops().isEmpty()) {\n    return true;\n  }\n\n  return false;\n}"
    ],
    [
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    final Dfp x = a[0];\n    final Dfp y = a[1];\n\n    final Dfp x1 = x.subtract(1);\n    final Dfp y1 = y.subtract(1);\n\n    final Dfp x2 = x1.divide(x.add(1));\n    final Dfp y2 = y1.divide(y.add(1));\n\n    final Dfp x3 = x2.divide(x.add(1));\n    final Dfp y3 = y2.divide(y.add(1));\n\n    final Dfp x4 = x3.divide(x.add(1));\n    final Dfp y4 = y3.divide(y.add(1));\n\n    final Dfp x5 = x4.divide(x.add(1));\n    final Dfp y5 = y4.divide(y.add(1));\n\n    final Dfp x6 = x5.divide(x.add(1));\n    final Dfp y6 = y5.divide(y.add(1));\n\n    final Dfp x7 = x6.divide(x.add(1));\n    final Dfp y7 = y6.divide(y.add(1));\n\n    final Dfp x8 = x7.divide(x.add(1));\n    final Dfp y8 = y7.divide(y.add(1));\n\n    final Dfp x9 = x8.divide(x.add(1));\n    final Dfp y9 = y8.divide(y.add(1));\n\n    final Dfp x10 = x9.divide(x.add(1));\n    final Dfp y10 = y9.divide(y.add(1));\n\n    final Dfp x11 = x10.divide(x.add(1));\n    final Dfp y11 = y10.divide(y.add(1));\n\n    final Dfp x12 = x11.divide(x.add(1));\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        // We want to find the value of x such that a = (x+1)/(x-1).\n        // This is easily solved to find that x = (a-1)/(a+1).\n        // We use the fact that a is in the range 0 < a < 2, so\n        // we can solve for x by solving the equation:\n        //\n        //   x + 1 = a * x - 1\n        //\n        // We know that a is in the range 0 < a < 2, so we can solve for x\n        // by solving the equation:\n        //\n        //   x + 1 = a * x - 1\n        //\n        // We know that a is in the range 0 < a < 2, so we can solve for x\n        // by solving the equation:\n        //\n        //   x + 1 = a * x - 1\n        //\n        // We know that a is in the range 0 < a < 2, so we can solve for x\n        // by solving the equation:\n        //\n        //   x + 1 = a * x - 1\n        //\n        // We know that a is in the range 0 < a < 2, so we can solve for x\n        // by solving the equation:\n        //\n        //   x + 1 = a * x - 1\n        //\n        // We know that a is in the range 0 < a < 2, so we can solve for x\n        // by solving the equation:\n        //\n        //   x + 1 = a * x - 1\n        //\n        // We know that a is in the range 0 < a < 2, so we can solve for x\n        // by solving the equation:\n        //\n        //   x + 1 = a * x - 1\n        //\n        // We know that a is in the range 0 < a < 2, so we can solve for x\n        // by solving the equation:\n        //\n        //   x + 1 = a * x - 1\n        //\n        // We know that a is in the range 0 < a < 2, so we can solve for x\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    final Dfp[] result = new Dfp[2];\n    final Dfp[] spx = a;\n    final Dfp[] spy = new Dfp[2];\n    final Dfp[] spz = new Dfp[2];\n    final Dfp[] spw = new Dfp[2];\n    final Dfp[] spv = new Dfp[2];\n    final Dfp[] spu = new Dfp[2];\n    final Dfp[] spq = new Dfp[2];\n    final Dfp[] spl = new Dfp[2];\n    final Dfp[] spr = new Dfp[2];\n    final Dfp[] spm = new Dfp[2];\n    final Dfp[] spn = new Dfp[2];\n    final Dfp[] spo = new Dfp[2];\n    final Dfp[] spj = new Dfp[2];\n    final Dfp[] spi = new Dfp[2];\n    final Dfp[] sph = new Dfp[2];\n    final Dfp[] spg = new Dfp[2];\n    final Dfp[] spf = new Dfp[2];\n    final Dfp[] spa = new Dfp[2];\n    final Dfp[] sp9 = new Dfp[2];\n    final Dfp[] sp8 = new Dfp[2];\n    final Dfp[] sp7 = new Dfp[2];\n    final Dfp[] sp6 = new Dfp[2];\n    final Dfp[] sp5 = new Dfp[2];\n    final Dfp[] sp4 = new Dfp[2];\n    final Dfp[] sp3 = new Dfp[2];\n    final Dfp[] sp2 = new Dfp[2];\n    final Dfp[] sp1 = new Dfp[2];\n    final Dfp[] sp0 = new Dfp[2];\n    final Dfp[] spx2 = new Dfp[2];\n    final Dfp[] spx3 = new Dfp[2];\n    final Dfp[] spx4 = new Dfp[2];\n    final Dfp[] spx5 = new Dfp[2];\n    final Dfp[] spx6 = new Dfp[2];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] result = new Dfp[2];\n    Dfp[] x = new Dfp[2];\n    Dfp[] y = new Dfp[2];\n    Dfp[] z = new Dfp[2];\n    Dfp[] t = new Dfp[2];\n    Dfp[] u = new Dfp[2];\n    Dfp[] v = new Dfp[2];\n    Dfp[] w = new Dfp[2];\n    Dfp[] r = new Dfp[2];\n    Dfp[] s = new Dfp[2];\n    Dfp[] q = new Dfp[2];\n    Dfp[] p = new Dfp[2];\n    Dfp[] o = new Dfp[2];\n    Dfp[] n = new Dfp[2];\n    Dfp[] m = new Dfp[2];\n    Dfp[] l = new Dfp[2];\n    Dfp[] k = new Dfp[2];\n    Dfp[] j = new Dfp[2];\n    Dfp[] i = new Dfp[2];\n    Dfp[] h = new Dfp[2];\n    Dfp[] g = new Dfp[2];\n    Dfp[] f = new Dfp[2];\n    Dfp[] e = new Dfp[2];\n    Dfp[] d = new Dfp[2];\n    Dfp[] c = new Dfp[2];\n    Dfp[] b = new Dfp[2];\n    Dfp[] a2 = new Dfp[2];\n    Dfp[] a1 = new Dfp[2];\n    Dfp[] a0 = new Dfp[2];\n\n    x[0] = a[0];\n    x[1] = a[1];\n\n    y[0] = a[0].add(a[0]);\n    y[1] = a[1].add(a[1]);\n\n    z[0] = a[0].add(a[0]);\n    z[1] = a[1].add(a[1]);\n\n    t[0] = a[0].add(a[0]);\n    t[1] = a[1].add(a[1]);\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        final int n = a.length;\n        final Dfp[] ln = new Dfp[n];\n        final Dfp[] one = new Dfp[n];\n        final Dfp[] minusOne = new Dfp[n];\n        final Dfp[] two = new Dfp[n];\n        final Dfp[] three = new Dfp[n];\n        final Dfp[] five = new Dfp[n];\n        final Dfp[] seven = new Dfp[n];\n        final Dfp[] x = new Dfp[n];\n        final Dfp[] x2 = new Dfp[n];\n        final Dfp[] x3 = new Dfp[n];\n        final Dfp[] x4 = new Dfp[n];\n        final Dfp[] x5 = new Dfp[n];\n        final Dfp[] x6 = new Dfp[n];\n        final Dfp[] x7 = new Dfp[n];\n        final Dfp[] x8 = new Dfp[n];\n        final Dfp[] x9 = new Dfp[n];\n        final Dfp[] x10 = new Dfp[n];\n        final Dfp[] x11 = new Dfp[n];\n        final Dfp[] x12 = new Dfp[n];\n        final Dfp[] x13 = new Dfp[n];\n        final Dfp[] x14 = new Dfp[n];\n        final Dfp[] x15 = new Dfp[n];\n        final Dfp[] x16 = new Dfp[n];\n        final Dfp[] x17 = new Dfp[n];\n        final Dfp[] x18 = new Dfp[n];\n        final Dfp[] x19 = new Dfp[n];\n        final Dfp[] x20 = new Dfp[n];\n        final Dfp[] x21 = new Dfp[n];\n        final Dfp[] x22 = new Dfp[n];\n        final Dfp[] x23 = new Dfp[n];\n        final Dfp[] x24 = new Dfp[n];\n        final Dfp[] x25 = new Dfp[n];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    // We want to compute ln(a), so we need to find the value of x\n    // such that a = (x+1)/(x-1).   This is easily solved to find that\n    // x = (a-1)/(a+1).\n    Dfp[] spx = new Dfp[2];\n    spx[0] = a[0].subtract(a[1]);\n    spx[1] = a[0].add(a[1]);\n    return spx;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] ret = new Dfp[2];\n    Dfp x = a[0].subtract(a[1]);\n    Dfp x1 = a[0].add(a[1]);\n    Dfp x2 = a[0].subtract(a[1]);\n    Dfp x3 = a[0].add(a[1]);\n    Dfp x4 = a[0].subtract(a[1]);\n    Dfp x5 = a[0].add(a[1]);\n    Dfp x6 = a[0].subtract(a[1]);\n    Dfp x7 = a[0].add(a[1]);\n    Dfp x8 = a[0].subtract(a[1]);\n    Dfp x9 = a[0].add(a[1]);\n    Dfp x10 = a[0].subtract(a[1]);\n    Dfp x11 = a[0].add(a[1]);\n    Dfp x12 = a[0].subtract(a[1]);\n    Dfp x13 = a[0].add(a[1]);\n    Dfp x14 = a[0].subtract(a[1]);\n    Dfp x15 = a[0].add(a[1]);\n    Dfp x16 = a[0].subtract(a[1]);\n    Dfp x17 = a[0].add(a[1]);\n    Dfp x18 = a[0].subtract(a[1]);\n    Dfp x19 = a[0].add(a[1]);\n    Dfp x20 = a[0].subtract(a[1]);\n    Dfp x21 = a[0].add(a[1]);\n    Dfp x22 = a[0].subtract(a[1]);\n    Dfp x23 = a[0].add(a[1]);\n    Dfp x24 = a[0].subtract(a[1]);\n    Dfp x25 = a[0].add(a[1]);\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp x = a[0].subtract(a[1]);\n    Dfp x1 = a[0].add(a[1]);\n    Dfp[] spx = split(x);\n    Dfp[] spx1 = split(x1);\n    Dfp[] spy = new Dfp[2];\n    spy[0] = spx[0].divide(spx1[0]);\n    spy[1] = spx[1].divide(spx1[0]);\n    spx = logInternal(spy);\n    spx1 = logInternal(spx1);\n    spy[0] = a.getField().getTwo();\n    spy[1] = a.getField().getZero();\n    spx = splitMult(spx, spy);\n    spx1 = splitMult(spx1, spy);\n    spy[0] = a.getField().getTwo();\n    spy[1] = a.getField().getZero();\n    spx = splitAdd(spx, spx1);\n    spy[0] = a.getField().getTwo();\n    spy[1] = a.getField().getZero();\n    spx = splitMult(spx, spy);\n    spx1 = split(x);\n    spx = splitAdd(spx, spx1);\n    spx1 = split(x1);\n    spx = splitSubtract(spx, spx1);\n    return spx;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        // If a is already less than 2, then we are done\n        if (a[0].greaterThan(a[1])) {\n            return a;\n        }\n\n        // If a is greater than 2, then we need to compute ln(a) - ln(2)\n        Dfp[] spx = split(a[0]);\n        Dfp[] spy = split(a[1]);\n        Dfp[] spz = new Dfp[2];\n\n        spx[0] = spx[0].divide(spy[0]);\n        spx[1] = spx[1].divide(spy[0]);\n\n        spy[0] = a.getField().getLn2Split()[0];\n        spy[1] = a.getField().getLn2Split()[1];\n\n        spz[0] = spx[0].subtract(spy[0]);\n        spz[1] = spx[1].subtract(spy[1]);\n\n        return spz;\n    }",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    // Let f(x) = ln(x),\n    //\n    // We know that f'(x) = 1/x, thus from Taylor's theorum we have:\n    //\n    //           -----          n+1         n\n    //  f(x) =   \\           (-1)    (x - 1)\n    //           /          ----------------    for 1 <= n <= infinity\n    //           -----             n\n    //\n    // or\n    //                       2        3       4\n    //                   (x-1)   (x-1)    (x-1)\n    //  ln(x) =  (x-1) - ----- + ------ - ------ + ...\n    //                     2       3        4\n    //\n    // alternatively,\n    //\n    //                  2    3   4\n    //                 x    x   x\n    //  ln(x+1) =  x - -  + - - - + ...\n    //                 2    3   4\n    //\n    // This series can be used to compute ln(x), but it converges too slowly.\n    //\n    // If we substitute -x for x above, we get\n    //\n    //                   2    3    4\n    //                  x    x    x\n    //  ln(1-x) =  -x - -  - -  - - + ...\n    //                  2    3    4\n    //\n    // Note that all terms are now negative.  Because the even powered ones\n    // absorbed the sign.  Now, subtract the series above from the previous\n    // one to get ln(x+1) - ln(1-x).  Note the even terms cancel out leaving\n    // only the odd ones\n    //\n    //                             3     5      7\n    //                           2x    2x     2x\n    //  ln(x+1) - ln(x-1) = 2x + --- + --- + ---- + ...\n    //                            3     5      7\n    //\n}"
    ],
    [
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection coll = decorated().get(key);\n        if (coll == null) {\n            return false;\n        }\n        return coll.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection coll = getCollection(key);\n        return coll.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection coll = getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n        return coll.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection coll = getCollection(key);\n        return coll.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection coll = getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n        return coll.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection coll = getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n        return coll.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection coll = getCollection(key);\n        if (coll.remove(value)) {\n            if (coll.isEmpty()) {\n                decorated().remove(key);\n            }\n            return true;\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) {\n            return false;\n        }\n        final Collection<V> coll = decorated().get(key);\n        if (coll == null) {\n            return false;\n        }\n        return coll.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection coll = getCollection(key);\n        return coll.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection coll = decorated().get(key);\n        if (coll == null) {\n            return false;\n        }\n        final boolean removed = coll.remove(value);\n        if (coll.isEmpty()) {\n            decorated().remove(key);\n        }\n        return removed;\n    }"
    ],
    [
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n    } else if (node.getType() == Token.STRING) {\n        node.setQuotedString();\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) {\n    node.setType(Token.STRING);\n  } else if (node.getType() == Token.STRING) {\n    node.setQuotedString();\n  }\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) \n    {\n        node.setType(Token.STRING);\n    } \n    else if (node.getType() == Token.STRING) \n    {\n        node.setString(node.getString().quote());\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) \n    {\n        node.setType(Token.STRING);\n    }\n    else if (node.getType() == Token.STRING) \n    {\n        node.setType(Token.STRING);\n        node.setQuotedString(true);\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME)\n    {\n        node.setType(Token.STRING);\n    }\n    else if (node.getType() == Token.STRING)\n    {\n        node.setString(\"'\" + node.getString() + \"'\");\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) \n    {\n        node.setType(Token.STRING);\n    }\n    else if (node.getType() == Token.STRING) \n    {\n        node.setString(node.getString().quote());\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) {\n    node.setType(Token.STRING);\n  } else if (node.getType() == Token.STRING) {\n    node.setQuotedString();\n  }\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) {\n    node.setType(Token.STRING);\n  } else if (node.getType() == Token.STRING) {\n    node.setQuotedString();\n  }\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) {\n    node.setType(Token.STRING);\n  } else if (node.getType() == Token.STRING) {\n    node.setQuotedString();\n  }\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) \n    {\n        node.setType(Token.STRING);\n    }\n    else if (node.getType() == Token.STRING) \n    {\n        node.setString(node.getString() + \"\\\"\");\n    }\n    return node;\n}"
    ],
    [
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n\n    int seriesCount = dataset.getRowCount();\n    List list = new ArrayList(seriesCount);\n    double total = 0.0;\n    for (int i = 0; i < seriesCount; i++) {\n        if (this.ignoreZeroValues && dataset.getValue(i, category) == 0.0) {\n            list.add(new Double(0.0));\n        }\n        else {\n            double value = dataset.getValue(i, category).doubleValue();\n            if (asPercentages) {\n                value = value / base;\n            }\n            list.add(new Double(value));\n            total += value;\n        }\n    }\n    for (int i = 0; i < seriesCount; i++) {\n        double value = ((Double) list.get(i)).doubleValue();\n        if (asPercentages) {\n            value = value * total;\n        }\n        list.set(i, new Double(value));\n    }\n    return list;\n\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    int seriesCount = dataset.getRowCount();\n    List list = new ArrayList(seriesCount);\n    double total = base;\n    for (int i = 0; i < seriesCount; i++) {\n        if (includedRows != null && !Arrays.contains(includedRows, i)) {\n            continue;\n        }\n        double value = dataset.getValue(i, category).doubleValue();\n        if (value != DatasetUtilities.missingValueIndicator()) {\n            total += value;\n            list.add(new Double(value));\n        }\n    }\n    if (asPercentages) {\n        total = 100.0 / total;\n        for (int i = 0; i < list.size(); i++) {\n            Double d = (Double) list.get(i);\n            list.set(i, new Double(d.doubleValue() * total));\n        }\n    }\n    return list;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n\n    int rowCount = dataset.getRowCount();\n    int columnCount = dataset.getColumnCount();\n    List result = new ArrayList();\n    double total = 0.0;\n    for (int row = 0; row < rowCount; row++) {\n        if (isSeriesVisible(row, dataset, includedRows)) {\n            double value = dataset.getValue(row, category).doubleValue();\n            if (asPercentages) {\n                total += value;\n            }\n            result.add(new Double(value));\n        }\n        else {\n            result.add(new Double(0.0));\n        }\n    }\n    if (asPercentages) {\n        for (int item = 0; item < columnCount; item++) {\n            Double d = (Double) result.get(item);\n            double value = d.doubleValue();\n            result.set(item, new Double(value / total));\n        }\n    }\n    return result;\n\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n\n    int rowCount = dataset.getRowCount();\n    List result = new ArrayList();\n    result.add(new Double(base));\n    for (int row = 0; row < rowCount; row++) {\n        if (includedRows == null || ArrayUtils.contains(includedRows, row)) {\n            double value = dataset.getValue(row, category).doubleValue();\n            if (asPercentages) {\n                value = value / dataset.getColumnCount();\n            }\n            result.add(new Double(value));\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    int seriesCount = dataset.getRowCount();\n    List result = new ArrayList();\n    double total = 0.0;\n    for (int i = 0; i < seriesCount; i++) {\n        if (this.ignoreZeroValues && (dataset.getValue(i, category) == 0.0)) {\n            continue;\n        }\n        if (includedRows != null) {\n            if (!ArrayUtils.contains(includedRows, i)) {\n                continue;\n            }\n        }\n        double value = dataset.getValue(i, category).doubleValue();\n        if (asPercentages) {\n            value = value / 100.0;\n        }\n        result.add(new Double(base + value));\n        total += value;\n    }\n    if (asPercentages) {\n        total = total / 100.0;\n    }\n    result.add(new Double(total));\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n\n    List list = new ArrayList();\n    list.add(new Double(base));\n    int rowCount = dataset.getRowCount();\n    for (int row = 0; row < rowCount; row++) {\n        if (includedRows == null || ArrayUtils.contains(includedRows, row)) {\n            double value = dataset.getValue(row, category).doubleValue();\n            if (asPercentages) {\n                value = value / dataset.getColumnCount();\n            }\n            list.add(new Double(value));\n        }\n    }\n    return list;\n\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List list = new ArrayList();\n    list.add(new Double(base));\n    int rowCount = dataset.getRowCount();\n    for (int row = 0; row < rowCount; row++) {\n        if (Arrays.binarySearch(includedRows, row) >= 0) {\n            double value = dataset.getValue(row, category).doubleValue();\n            list.add(new Double(value));\n        }\n    }\n    if (asPercentages) {\n        double total = this.calculateTotal(list);\n        for (int i = 0; i < list.size(); i++) {\n            Double d = (Double) list.get(i);\n            double v = d.doubleValue();\n            list.set(i, new Double(v / total));\n        }\n    }\n    return list;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n\n    List list = new ArrayList();\n    list.add(new Double(base));\n    int rowCount = dataset.getRowCount();\n    for (int row = 0; row < rowCount; row++) {\n        if (ArrayUtils.contains(includedRows, row)) {\n            double value = dataset.getValue(row, category).doubleValue();\n            list.add(new Double(value));\n        }\n    }\n    if (asPercentages) {\n        double total = StatUtils.sum(list);\n        for (int i = 0; i < list.size(); i++) {\n            Double d = (Double) list.get(i);\n            list.set(i, new Double(d.doubleValue() / total));\n        }\n    }\n    return list;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n\n    int seriesCount = dataset.getRowCount();\n    List list = new ArrayList();\n    list.add(new Double(base));\n    for (int i = 0; i < seriesCount; i++) {\n        if (includedRows == null || ArrayUtils.contains(includedRows, i)) {\n            double value = dataset.getValue(i, category).doubleValue();\n            list.add(new Double(value));\n        }\n        else {\n            list.add(new Double(0.0));\n        }\n    }\n    if (asPercentages) {\n        double total = 0.0;\n        for (int i = 1; i < list.size(); i++) {\n            total += ((Double) list.get(i)).doubleValue();\n        }\n        for (int i = 1; i < list.size(); i++) {\n            double v = ((Double) list.get(i)).doubleValue();\n            list.set(i, new Double(v / total));\n        }\n    }\n    return list;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    int rowCount = dataset.getRowCount();\n    List list = new ArrayList();\n    double total = 0.0;\n    for (int row = 0; row < rowCount; row++) {\n        if (this.ignoreZeroValues && dataset.getValue(row, category) == 0.0) {\n            continue;\n        }\n        if (includedRows != null && !Arrays.contains(includedRows, row)) {\n            continue;\n        }\n        double value = dataset.getValue(row, category).doubleValue();\n        if (asPercentages) {\n            value = value / 100.0;\n        }\n        total = total + value;\n        list.add(new Double(base + total));\n    }\n    return list;\n}"
    ],
    [
      "private List<Element> childElementsList()  {\n    if (childElements == null) {\n        childElements = new ArrayList<Element>();\n        for (Node node : childNodes) {\n            if (node instanceof Element) {\n                childElements.add((Element) node);\n            }\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    if (childElements == null) {\n        childElements = new ArrayList<Element>();\n        for (Node node : childNodes) {\n            if (node instanceof Element) {\n                childElements.add((Element) node);\n            }\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    if (childElements == null) {\n        childElements = new ArrayList<Element>();\n        for (Node node : childNodes) {\n            if (node instanceof Element) {\n                childElements.add((Element) node);\n            }\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    if (childElements == null) {\n        childElements = new ArrayList<Element>();\n        for (Node node : childNodes) {\n            if (node instanceof Element) {\n                childElements.add((Element) node);\n            }\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    if (childElementsCache == null) {\n        childElementsCache = new ArrayList<Element>();\n        for (Node node : childNodes) {\n            if (node instanceof Element) {\n                childElementsCache.add((Element) node);\n            }\n        }\n    }\n    return childElementsCache;\n}",
      "private List<Element> childElementsList()  {\n    if (childElementsCache == null) {\n        childElementsCache = new ArrayList<Element>();\n        for (Node child : childNodes) {\n            if (child instanceof Element) {\n                childElementsCache.add((Element) child);\n            }\n        }\n    }\n    return childElementsCache;\n}",
      "private List<Element> childElementsList()  {\n    if (childElementsCache == null) {\n        childElementsCache = new ArrayList<Element>();\n        for (Node child : childNodes) {\n            if (child instanceof Element) {\n                childElementsCache.add((Element) child);\n            }\n        }\n    }\n    return childElementsCache;\n}",
      "private List<Element> childElementsList()  {\n    if (childElements == null) {\n        childElements = new ArrayList<Element>();\n        for (Node node : childNodes) {\n            if (node instanceof Element) {\n                childElements.add((Element) node);\n            }\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    if (childElementsCache == null) {\n        childElementsCache = new ArrayList<Element>();\n        for (Node node : childNodes) {\n            if (node instanceof Element) {\n                childElementsCache.add((Element) node);\n            }\n        }\n    }\n    return childElementsCache;\n}",
      "private List<Element> childElementsList()  {\n    if (childElements == null) {\n        childElements = new ArrayList<Element>();\n        for (Node node : childNodes) {\n            if (node instanceof Element) {\n                childElements.add((Element) node);\n            }\n        }\n    }\n    return childElements;\n}"
    ],
    [
      "private int getHash(final Object key)  {\n    final int hash = key.hashCode();\n    return Math.abs(hash % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    int n = buckets.length;\n    return Math.abs(hash % n);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    int n = buckets.length;\n    return (Math.abs(hash) % n);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    int n = buckets.length;\n    return Math.abs(hash % n);\n}",
      "private int getHash(final Object key)  {\n    final int hash = key.hashCode();\n    final int size = buckets.length;\n    return Math.abs(hash % size);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    int n = buckets.length;\n    return (Math.abs(hash) % n);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    int n = buckets.length;\n    return Math.abs(hash % n);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    int n = buckets.length;\n    return (hash % n + n) % n;\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    int n = buckets.length;\n    return (hash < 0 ? hash * -1 : hash) % n;\n}",
      "private int getHash(final Object key)  {\n    final int hash = key.hashCode();\n    return Math.abs(hash % buckets.length);\n}"
    ],
    [
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    if (k < 0) {\n        k = 0;\n    }\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r > c - k) {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r >= c - k) {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    if (k < 0) {\n        throw new IllegalArgumentException(\"k must be non-negative\");\n    }\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r > c - k) {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r >= c + k) {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) \n    {\n        for (int c = 0; c < m.getColumnDimension(); c++) \n        {\n            if (r > c) \n            {\n                d[r][c] = m.getEntry(r, c);\n            }\n            else if (r == c && k > 0) \n            {\n                d[r][c] = m.getEntry(r, c) * k;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    if (k < 0) \n    {\n        throw new IllegalArgumentException(\"k must be non-negative\");\n    }\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) \n    {\n        for (int c = 0; c < m.getColumnDimension(); c++) \n        {\n            if (r > c + k) \n            {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r >= c + k) {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r > c + k) {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    if (k < 0) {\n        k = 0;\n    }\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r > c && c >= k) {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r >= c + k) {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}"
    ],
    [
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        case RIGHT_HIGH:\n            if (left.skew == Skew.LEFT_HIGH) {\n                rotateCW();\n                skew      = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            } else {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch (s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.LEFT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.RIGHT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n            }\n            return false;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return true;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (left.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCW();\n                skew      = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (left.skew == Skew.BALANCED) \n            {\n                rotateCW();\n                skew      = Skew.RIGHT_HIGH;\n                right.skew = Skew.LEFT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        right.skew  = Skew.BALANCED;\n                        left.skew   = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        right.skew  = Skew.LEFT_HIGH;\n                        left.skew   = Skew.BALANCED;\n                        break;\n                    default:\n                        right.skew  = Skew.BALANCED;\n                        left.skew   = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (left.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCW();\n                skew      = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (left.skew == Skew.BALANCED) \n            {\n                rotateCW();\n                skew      = Skew.RIGHT_HIGH;\n                right.skew = Skew.LEFT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (left.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCW();\n                skew = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (left.skew == Skew.BALANCED) \n            {\n                rotateCW();\n                skew = Skew.RIGHT_HIGH;\n                right.skew = Skew.LEFT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        right.skew = Skew.BALANCED;\n                        left.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        right.skew = Skew.LEFT_HIGH;\n                        left.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        right.skew = Skew.BALANCED;\n                        left.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (left.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCW();\n                skew      = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (left.skew == Skew.BALANCED) \n            {\n                rotateCW();\n                skew      = Skew.RIGHT_HIGH;\n                right.skew = Skew.LEFT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        right.skew  = Skew.BALANCED;\n                        left.skew   = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        right.skew  = Skew.LEFT_HIGH;\n                        left.skew   = Skew.BALANCED;\n                        break;\n                    default:\n                        right.skew  = Skew.BALANCED;\n                        left.skew   = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (left.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCW();\n                skew      = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (left.skew == Skew.BALANCED) \n            {\n                rotateCW();\n                skew      = Skew.RIGHT_HIGH;\n                right.skew = Skew.LEFT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (left.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCW();\n                skew      = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (left.skew == Skew.BALANCED) \n            {\n                rotateCW();\n                skew      = Skew.RIGHT_HIGH;\n                right.skew = Skew.LEFT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        case RIGHT_HIGH:\n            if (left.skew == Skew.LEFT_HIGH) {\n                rotateCW();\n                skew      = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            } else {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch (s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.LEFT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.RIGHT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n            }\n            return false;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return true;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (left.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCW();\n                skew      = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (left.skew == Skew.BALANCED) \n            {\n                rotateCW();\n                skew      = Skew.RIGHT_HIGH;\n                right.skew = Skew.LEFT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        right.skew  = Skew.BALANCED;\n                        left.skew   = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        right.skew  = Skew.LEFT_HIGH;\n                        left.skew   = Skew.BALANCED;\n                        break;\n                    default:\n                        right.skew  = Skew.BALANCED;\n                        left.skew   = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (left.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCW();\n                skew = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (left.skew == Skew.BALANCED) \n            {\n                rotateCW();\n                skew = Skew.RIGHT_HIGH;\n                right.skew = Skew.LEFT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        right.skew = Skew.BALANCED;\n                        left.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        right.skew = Skew.LEFT_HIGH;\n                        left.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        right.skew = Skew.BALANCED;\n                        left.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}"
    ],
    [
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    // This is the \"innermost loop\" of the implicit shift QR iteration.\n    // It has been carefully optimized for execution on modern processors.\n    //\n    // The loop looks for a small sub-diagonal element.\n    // for (int i = startIdx; i >= 0; i--) {\n    //     final double x = matrixT[i][i];\n    //     final double y = matrixT[i + 1][i];\n    //     final double z = matrixT[i + 1][i + 1];\n    //     final double s = x - z;\n    //     final double p = (y - x) / s;\n    //     final double e = p * p + 1.0;\n    //     if (e >= 0.0) {\n    //         final double f = FastMath.sqrt(e);\n    //         matrixT[i][i] = x - f * s;\n    //         matrixT[i + 1][i + 1] = z + f * s;\n    //         p = p / (f * FastMath.sqrt(x * z - y * y));\n    //         break;\n    //     }\n    // }\n    //\n    // The variable \"e\" is the shift, and \"f\" is its square root.\n    // The \"is\" statement terminates the innermost loop.\n    // The case of non-positive \"e\" found here is a little different\n    // from the EISPACK algorithm, but it makes the same\n    // mathematical sense.  Because of the \"break\" statement, this\n    // case occurs when there are multiple roots.\n    //\n    // We will use a modified form of the QR step to avoid\n    // the costly \"break\".  This is a good trade-off, because\n    // the QR step is already a very well tuned loop.\n    //\n    // The variable \"p\" is the \"shift\", which makes the\n    // sub-diagonal element zero.  The variable \"s\" is the\n    // truncation of the matrix T to a 2x2 matrix.\n    //\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int i = startIdx; i >= 0; i--) {\n        final double abs = FastMath.abs(matrixT[i][i - 1]);\n        if (abs <= EPS * norm) {\n            return i;\n        }\n    }\n    return 0;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    // the size of the matrix\n    final int n = matrixT.length;\n\n    // the threshold for the sub-diagonal element\n    final double threshold = norm * EPS;\n\n    // the index of the first small sub-diagonal element\n    int idx = n - 1;\n\n    // look for the first small sub-diagonal element\n    for (int i = startIdx; i < n; i++) {\n        if (FastMath.abs(matrixT[i][i - 1]) <= threshold) {\n            idx = i;\n            break;\n        }\n    }\n\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int i = startIdx; i >= 0; i--) {\n        if (FastMath.abs(matrixT[i][i - 1]) <= EPS * norm) {\n            return i;\n        }\n    }\n    return 0;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int i = startIdx;\n    while (i < matrixT.length) {\n        final double t = FastMath.abs(matrixT[i][i - 1]);\n        if (t == 0.0) {\n            i++;\n        } else {\n            final double x = FastMath.abs(matrixT[i - 1][i - 1]) + FastMath.abs(matrixT[i][i]);\n            if (t <= Math.max(eps * x, norm * eps)) {\n                return i;\n            } else {\n                return i - 1;\n            }\n        }\n    }\n    return i;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    // This is the \"modified\" LU-decomposition as described in the paper\n    // \"Implicit QL Algorithms for LU Decomposition and Eigenvalue Problems\"\n    // by Martin et al.\n    // The \"modifications\" are:\n    // 1. The diagonal element is not accessed\n    // 2. The sub-diagonal element is not accessed\n    // 3. The diagonal element is not modified\n    // 4. The sub-diagonal element is not modified\n    // 5. The diagonal element is not used in the computation of the\n    //    sub-diagonal element\n    // 6. The sub-diagonal element is not used in the computation of the\n    //    diagonal element\n    // 7. The diagonal element is not used in the computation of the\n    //    sub-diagonal element\n    // 8. The sub-diagonal element is not used in the computation of the\n    //    diagonal element\n    // 9. The diagonal element is not used in the computation of the\n    //    sub-diagonal element\n    // 10. The sub-diagonal element is not used in the computation of the\n    //     diagonal element\n    // 11. The diagonal element is not used in the computation of the\n    //     sub-diagonal element\n    // 12. The sub-diagonal element is not used in the computation of the\n    //     diagonal element\n    // 13. The diagonal element is not used in the computation of the\n    //     sub-diagonal element\n    // 14. The sub-diagonal element is not used in the computation of the\n    //     diagonal element\n    // 15. The diagonal element is not used in the computation of the\n    //     sub-diagonal element\n    // 16. The sub-diagonal element is not used in the computation of the\n    //     diagonal element\n    // 17. The diagonal element is not used in the computation of the\n    //     sub-diagonal element\n    // 18. The sub-diagonal element is not used in the computation of the\n    //     diagonal element\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int i = startIdx;\n    while (i < matrixT.length) {\n        final double t = FastMath.abs(matrixT[i][i - 1]);\n        if (t == 0.0) {\n            i++;\n        } else {\n            final double x = matrixT[i - 1][i - 1] / t;\n            final double y = matrixT[i][i] / t;\n            final double s = x * y;\n            final double c = 1.0 / FastMath.sqrt(1.0 + s * s);\n            if (s < 0.0) {\n                c = -c;\n            }\n            t = t * c;\n            matrixT[i - 1][i - 1] = t * x;\n            matrixT[i][i] = t * y;\n            for (int j = i + 1; j < matrixT.length; j++) {\n                matrixT[i - 1][j] = matrixT[i][j] / t;\n                matrixT[i][j] = 0.0;\n            }\n            for (int j = 0; j < matrixP.length; j++) {\n                matrixP[j][i - 1] = matrixP[j][i] / t;\n                matrixP[j][i] = 0.0;\n            }\n            i++;\n        }\n    }\n    return i - 1;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int i = startIdx; i >= 0; i--) {\n        if (FastMath.abs(matrixT[i][i - 1]) <= EPS * norm) {\n            return i;\n        }\n    }\n    return -1;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int i = startIdx;\n    while (i < matrixT.length) {\n        final double absTii = FastMath.abs(matrixT[i][i]);\n        final double absTii1 = FastMath.abs(matrixT[i][i + 1]);\n        if (absTii1 <= EPSILON * (absTii + norm)) {\n            return i;\n        }\n        i++;\n    }\n    return i;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    // Find first small sub-diagonal element\n    for (int i = startIdx; i >= 0; i--) {\n        final double x = matrixT[i][i];\n        final double y = matrixT[i + 1][i];\n        if (FastMath.abs(x) + FastMath.abs(y) == FastMath.abs(x) + FastMath.abs(y)) {\n            return i;\n        }\n    }\n    return -1;\n}"
    ],
    [
      "public Node getNotSmaller(final T reference)  {\n    if (top == null) {\n        return null;\n    } else {\n        Node node = top.getSmallest();\n        while (node != null && node.element.compareTo(reference) < 0) {\n            node = node.getNext();\n        }\n        return node;\n    }\n}",
      "public Node getNotSmaller(final T reference)  {\n    // TODO: Implement this method\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    if (top == null) {\n        return null;\n    }\n    Node node = top;\n    while (node.getPrevious() != null) {\n        node = node.getPrevious();\n        if (node.element.compareTo(reference) >= 0) {\n            return node;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    if (top == null) {\n        return null;\n    }\n    // loop over all elements neither smaller nor larger\n    // than the specified one\n    for (Node node = top; node != null; node = node.getNext()) {\n        if (node.element.compareTo(reference) > 0) {\n            // all the remaining elements are known to be larger,\n            // the element is not in the tree\n            return null;\n        } else if (node.element.compareTo(reference) == 0) {\n            // the element is in the tree\n            return node;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node node = top;\n    while (node != null && node.element.compareTo(reference) < 0) {\n        node = node.getNext();\n    }\n    return node;\n}",
      "public Node getNotSmaller(final T reference)  {\n    if (top == null)\n        return null;\n    else\n        return top.getNotSmaller(reference);\n}",
      "public Node getNotSmaller(final T reference)  {\n    // TODO: Implement this method\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    // TODO: Implement this method\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node node = top;\n    while (node != null && node.element.compareTo(reference) < 0) {\n        node = node.getNext();\n    }\n    return node;\n}",
      "public Node getNotSmaller(final T reference)  {\n    if (top == null) {\n        return null;\n    }\n    Node node = top;\n    while (node.getPrevious() != null && node.getPrevious().element.compareTo(reference) < 0) {\n        node = node.getPrevious();\n    }\n    return node;\n}"
    ],
    [
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int i = 0;\n    while (i < size) {\n        final int start = i;\n        i = indexOf(str, i);\n        if (i < 0) {\n            break;\n        }\n        final int len = str.length();\n        deleteImpl(start, i + len, len);\n        i -= len;\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) \n    {\n        return this;\n    }\n    int pos = 0;\n    while (pos < size) \n    {\n        int found = indexOf(str, pos);\n        if (found < 0) \n        {\n            break;\n        }\n        deleteImpl(found, found + str.length(), str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int i = 0;\n    while (i < size) {\n        final int start = i;\n        i = indexOf(str, i);\n        if (i < 0) {\n            break;\n        }\n        final int len = str.length();\n        deleteImpl(start, i + len, len);\n        i -= len;\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int found = 0;\n    while ((found = indexOf(str, found)) >= 0) {\n        delete(found, found + str.length());\n        found += str.length();\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int i = 0;\n    while (i < size) {\n        final int start = i;\n        i = indexOf(str, i);\n        if (i < 0) {\n            break;\n        }\n        final int len = str.length();\n        deleteImpl(start, i + len, len);\n        i -= len;\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int found = 0;\n    while ((found = indexOf(str, found)) >= 0) {\n        deleteImpl(found, found + str.length(), str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int i = 0;\n    while (i < size) {\n        final int start = i;\n        i = indexOf(str, i);\n        if (i < 0) {\n            break;\n        }\n        final int len = str.length();\n        deleteImpl(start, i + len, len);\n        i -= len;\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int i = 0;\n    while (i < size) {\n        final int start = i;\n        i = indexOf(str, i);\n        if (i < 0) {\n            break;\n        }\n        final int len = str.length();\n        deleteImpl(start, i + len, len);\n        i -= len;\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int i = 0;\n    while ((i = indexOf(str, i)) >= 0) {\n        deleteImpl(i, i + str.length(), str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int i = 0;\n    while (i < size) {\n        final int start = i;\n        i = indexOf(str, i);\n        if (i < 0) {\n            break;\n        }\n        final int len = str.length();\n        deleteImpl(start, i + len, len);\n        i -= len;\n    }\n    return this;\n}"
    ],
    [
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    // TODO: Implement this function\n    return null;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  // Get the JSDocInfo from the node\n  JSDocInfo jsDocInfo = node.getJSDocInfo();\n  \n  // If there is no JSDocInfo, or it doesn't have a type, return the node\n  if (jsDocInfo == null || !jsDocInfo.hasType())\n  {\n    return transform(node);\n  }\n  \n  // If the node is a NAME, and it is in a parameter list or a variable\n  // declaration, we need to create a new node with the type information\n  // attached.\n  if (node.getType() == Token.NAME\n      && (node.getParent().getType() == Token.PARAM_LIST\n          || node.getParent().getType() == Token.VAR))\n  {\n    // Create a new node with the type information attached\n    Node newNode = newNode(Token.CAST, transform(node));\n    newNode.setJSDocInfo(jsDocInfo);\n    return newNode;\n  }\n  \n  // If the node is a GETPROP or GETELEM, and it is in a parameter list or a\n  // variable declaration, we need to create a new node with the type\n  // information attached.\n  if (node.getType() == Token.GETPROP\n      || node.getType() == Token.GETELEM\n      && (node.getParent().getType() == Token.PARAM_LIST\n          || node.getParent().getType() == Token.VAR))\n  {\n    // Create a new node with the type information attached\n    Node newNode = newNode(Token.CAST, transform(node));\n    newNode.setJSDocInfo(jsDocInfo);\n    return newNode;\n  }\n  \n  // If the node is a GETPROP or GETELEM, and it is in a parameter list or a\n  // variable declaration, we need to create a new node with the type\n  // information attached.\n  if (node.getType() == Token.CALL\n      && (node.getParent().getType() == Token.PARAM_LIST\n          || node.getParent().getType() == Token.VAR))\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    // TODO: Implement this function\n    return null;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    // TODO: implement this method\n    return null;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info != null && info.hasType()) {\n    // Casts are valid\n    if (node.getType() == Token.LP && node instanceof ParenthesizedExpression) {\n      return newNode(Token.CAST, transform(node));\n    }\n    // Variable declarations are valid\n    if (node.getType() == Token.VAR) {\n      return transform(node);\n    }\n    // Function declarations are valid\n    if (node.getType() == Token.FUNCTION) {\n      FunctionNode fnNode = (FunctionNode) node;\n      if (fnNode.getFunctionType() == FunctionNode.FUNCTION_STATEMENT) {\n        return transform(node);\n      }\n    }\n    // Object literal properties, catch declarations and variable\n    // initializers are valid.\n    if (node.getType() == Token.NAME) {\n      AstNode parent = node.getParent();\n      if (parent instanceof ObjectProperty\n          || parent instanceof CatchClause\n          || parent instanceof FunctionNode\n          || (parent instanceof VariableInitializer &&\n              node == ((VariableInitializer) parent).getTarget())) {\n        return transform(node);\n      }\n    }\n    // Object literal properties are valid\n    if (node.getType() == Token.GET || node.getType() == Token.SET\n        || node.getType() == Token.NUMBER || node.getType() == Token.STRING) {\n      if (node.getParent() instanceof ObjectProperty) {\n        return transform(node);\n      }\n    }\n    // Property assignments are valid, if at the root of an expression.\n    if (node.getType() == Token.ASSIGN) {\n      if (node instanceof Assignment && isExprStmt(node.getParent())\n          && isPropAccess(((Assignment) node).getLeft())) {\n        return transform(node);\n      }\n    }\n    // Property definitions are valid, if at the root of an expression.\n    if (node.getType() == Token.GETPROP || node.getType() == Token.GETELEM) {\n}\n}\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = justTransform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) {\n      irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n  }",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) \n  {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = justTransform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) {\n        irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n        irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}"
    ],
    [
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list);\n}"
    ],
    [
      "private Node parseArrayType(JsDocToken token)  {\n    skipEOLs();\n    if (!match(JsDocToken.LB)) {\n      return null;\n    }\n    next();\n    skipEOLs();\n    if (match(JsDocToken.RB)) {\n      next();\n      return newNode(Token.EMPTY);\n    }\n    Node array = newNode(Token.ARRAY);\n    Node elementType = parseTypeExpression(next());\n    if (elementType == null) {\n      return null;\n    }\n    array.addChildToBack(elementType);\n    do {\n      skipEOLs();\n      token = next();\n      Preconditions.checkState(token == JsDocToken.COMMA || token == JsDocToken.RB);\n      if (token == JsDocToken.COMMA) {\n        skipEOLs();\n        token = next();\n        if (token == JsDocToken.ELLIPSIS) {\n          next();\n          skipEOLs();\n          token = next();\n          if (token == JsDocToken.RB) {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.array.trailing.ellipsis\");\n          }\n          Node ellipsis = newNode(Token.ELLIPSIS);\n          Node type = parseTypeExpression(token);\n          if (type == null) {\n            return null;\n          }\n          ellipsis.addChildToBack(type);\n          array.addChildToBack(ellipsis);\n          break;\n        }\n        Node type = parseTypeExpression(token);\n        if (type == null) {\n          return null;\n        }\n        array.addChildToBack(type);\n      }\n    } while (match(JsDocToken.COMMA));\n    skipEOLs();\n    if (!match(JsDocToken.RB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n    return array;\n  }",
      "private Node parseArrayType(JsDocToken token)  {\n    // The left bracket will be checked by parseTypeExpression\n    Node array = newNode(Token.BRACKET);\n    Node elementType = null;\n    do {\n        if (elementType != null) {\n            skipEOLs();\n            token = next();\n            Preconditions.checkState(token == JsDocToken.COMMA);\n            skipEOLs();\n            token = next();\n        }\n        elementType = parseTypeExpression(token);\n        if (elementType == null) {\n            return null;\n        }\n\n        array.addChildToBack(elementType);\n        // We support commas for backwards compatibility.\n    } while (match(JsDocToken.COMMA));\n\n    if (elementType == null) {\n        skipEOLs();\n        if (!match(JsDocToken.RB)) {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n        }\n        next();\n    }\n    return array;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node array = newNode(Token.ARRAY);\n  Node expr = null;\n  do {\n    if (expr != null) {\n      skipEOLs();\n      token = next();\n      Preconditions.checkState(token == JsDocToken.COMMA || token == JsDocToken.RP);\n\n      if (token == JsDocToken.COMMA) {\n        array.addChildToBack(expr);\n      }\n    }\n    expr = parseTypeExpression(next());\n    if (expr == null) {\n      return null;\n    }\n\n    array.addChildToBack(expr);\n  } while (match(JsDocToken.COMMA));\n\n  skipEOLs();\n  if (!match(JsDocToken.RP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n  next();\n  return array;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    // We've removed the empty array type.\n    Node array = newNode(Token.BRACKET);\n    Node expr = parseTypeExpression(next());\n    if (expr == null) {\n      return null;\n    }\n    array.addChildToBack(expr);\n\n    // We support commas for backwards compatibility.\n    while (match(JsDocToken.COMMA)) {\n      next();\n      skipEOLs();\n      token = next();\n      if (token == JsDocToken.ELLIPSIS) {\n        next();\n        skipEOLs();\n        token = next();\n      }\n      expr = parseTypeExpression(token);\n      if (expr == null) {\n        return null;\n      }\n      array.addChildToBack(expr);\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n    return array;\n  }",
      "private Node parseArrayType(JsDocToken token)  {\n    Node array = newNode(Token.BRACKET);\n    if (match(JsDocToken.RB)) \n    {\n        return array;\n    }\n\n    Node expr = parseTypeExpression(next());\n    if (expr == null) \n    {\n        return null;\n    }\n\n    array.addChildToBack(expr);\n\n    while (match(JsDocToken.COMMA)) \n    {\n        skipEOLs();\n        token = next();\n        if (token == JsDocToken.ELLIPSIS) \n        {\n            array.addChildToBack(newNode(Token.ELLIPSIS));\n            next();\n        } \n        else \n        {\n            expr = parseTypeExpression(token);\n            if (expr == null) \n            {\n                return null;\n            }\n            array.addChildToBack(expr);\n        }\n    }\n\n    if (!match(JsDocToken.RB)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n\n    return array;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  // The left bracket will be checked by parseTypeExpression\n  Node array = newNode(Token.ARRAY);\n  Node expr = parseTypeExpression(next());\n  if (expr == null) \n  {\n    return null;\n  }\n  array.addChildToBack(expr);\n  skipEOLs();\n  if (match(JsDocToken.RB)) \n  {\n    next();\n    return array;\n  }\n  if (match(JsDocToken.COMMA)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.array.comma\");\n  }\n  if (match(JsDocToken.ELLIPSIS)) \n  {\n    next();\n    expr = parseTypeExpression(next());\n    if (expr == null) \n    {\n      return null;\n    }\n    array.addChildToBack(expr);\n    skipEOLs();\n    if (!match(JsDocToken.RB)) \n    {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n    return array;\n  }\n  return reportTypeSyntaxWarning(\"msg.jsdoc.array.comma\");\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node array = newNode(Token.BRACKET);\n  if (match(JsDocToken.RP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.type\");\n  }\n  Node elementType = parseTypeExpression(next());\n  if (elementType == null) {\n    return null;\n  }\n  array.addChildToBack(elementType);\n  while (match(JsDocToken.COMMA)) {\n    skipEOLs();\n    token = next();\n    if (match(JsDocToken.ELLIPSIS)) {\n      next();\n      skipEOLs();\n      if (match(JsDocToken.RP)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.type\");\n      }\n      elementType = parseTypeExpression(next());\n      if (elementType == null) {\n        return null;\n      }\n      array.addChildToBack(elementType);\n    } else {\n      Node type = parseTypeExpression(token);\n      if (type == null) {\n        return null;\n      }\n      array.addChildToBack(type);\n    }\n  }\n  skipEOLs();\n  if (!match(JsDocToken.RP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n  next();\n  return array;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node array = newNode(Token.BRACKET);\n    Node elementType = parseElementTypeList(next());\n    if (elementType == null) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.type\");\n    }\n    array.addChildToBack(elementType);\n    return array;\n  }",
      "private Node parseArrayType(JsDocToken token)  {\n    skipEOLs();\n    if (!match(JsDocToken.LB)) {\n      return null;\n    }\n    next();\n    skipEOLs();\n    Node elementType = parseTypeExpression(next());\n    if (elementType == null) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.type\");\n    }\n    skipEOLs();\n    if (!match(JsDocToken.RB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n    return elementType;\n  }",
      "private Node parseArrayType(JsDocToken token)  {\n  Node array = newNode(Token.ARRAY);\n  if (match(JsDocToken.LB)) \n  {\n    next();\n    skipEOLs();\n    token = next();\n    if (token == JsDocToken.ELLIPSIS) \n    {\n      next();\n      skipEOLs();\n      token = next();\n    }\n    if (token == JsDocToken.RB) \n    {\n      next();\n      return array;\n    }\n    Node expr = parseTypeExpression(token);\n    if (expr == null) \n    {\n      return null;\n    }\n    array.addChildToBack(expr);\n    while (match(JsDocToken.COMMA)) \n    {\n      next();\n      skipEOLs();\n      token = next();\n      if (token == JsDocToken.ELLIPSIS) \n      {\n        next();\n        skipEOLs();\n        token = next();\n      }\n      if (token == JsDocToken.RB) \n      {\n        next();\n        return array;\n      }\n      expr = parseTypeExpression(token);\n      if (expr == null) \n      {\n        return null;\n      }\n      array.addChildToBack(expr);\n    }\n    if (token != JsDocToken.RB) \n    {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n  }\n  return array;\n}"
    ],
    [
      "public Vector3D getAxis()  {\n    double norm = FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n}",
      "public Vector3D getAxis()  {\n    double inv = 1.0 / FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);\n    return new Vector3D(q1 * inv, q2 * inv, q3 * inv);\n}",
      "public Vector3D getAxis()  {\n    double norm = FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    if (norm == 0) {\n        return Vector3D.PLUS_K;\n    }\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n}",
      "public Vector3D getAxis()  {\n    return new Vector3D(q1, q2, q3);\n}",
      "public Vector3D getAxis()  {\n    return new Vector3D(q1, q2, q3).normalize();\n}",
      "public Vector3D getAxis()  {\n    return new Vector3D(q1, q2, q3);\n}",
      "public Vector3D getAxis()  {\n    return new Vector3D(q1, q2, q3);\n}",
      "public Vector3D getAxis()  {\n    double inv = 1.0 / FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);\n    return new Vector3D(q1 * inv, q2 * inv, q3 * inv);\n}",
      "public Vector3D getAxis()  {\n    final double norm = FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n}",
      "public Vector3D getAxis()  {\n    return new Vector3D(q1, q2, q3);\n}"
    ],
    [
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int pos = 0;  // position in byte array\n\n    while (pos < bytes.length) {\n        final int b = bytes[pos++] & 0xff;\n        if (b == '+') {\n            buffer.write(' ');\n        } else if (b == '%') {\n            final int u = Character.digit((char) bytes[pos++], RADIX);\n            final int l = Character.digit((char) bytes[pos++], RADIX);\n            if (u == -1 || l == -1) {\n                throw new DecoderException(\"Invalid URL encoding: \");\n            }\n            buffer.write((char) ((u << 4) + l));\n        } else {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        int b = bytes[i];\n        // Convert plus to space.\n        if (b == '+') {\n            b = ' ';\n        } else if (b == '%') {\n            // Convert hexidecimal %XX to byte value.\n            final int uc = Character.digit((char) bytes[++i], RADIX);\n            final int lc = Character.digit((char) bytes[++i], RADIX);\n            if (uc == -1 || lc == -1) {\n                throw new DecoderException(\"Invalid URL encoding: \" + new String(bytes, i - 2, 3));\n            }\n            b = (uc << 4) + lc;\n        }\n        buffer.write(b);\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        int b = bytes[i];\n\n        // Convert plus to space\n        if (b == '+') {\n            b = ' ';\n        }\n\n        // Convert % to original character\n        else if (b == '%') {\n            final int c1 = bytes[++i];\n            final int c2 = bytes[++i];\n\n            if (!isHexDigit(c1) || !isHexDigit(c2)) {\n                throw new DecoderException(\"Invalid URL encoding: \" + '%' + (char) c1 + (char) c2);\n            }\n\n            b = (decodeHexDigit(c1) << 4) + decodeHexDigit(c2);\n        }\n\n        buffer.write(b);\n    }\n\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        int b = bytes[i];\n\n        // Convert plus to space.\n        if (b == '+') {\n            b = ' ';\n        } else if (b == ESCAPE_CHAR) {\n            // Convert %xx to original byte.\n            final int u = Character.digit((char) bytes[++i], RADIX);\n            final int l = Character.digit((char) bytes[++i], RADIX);\n            if (u == -1 || l == -1) {\n                throw new DecoderException(\"Invalid URL encoding: \");\n            }\n            b = (u << 4) + l;\n\n            // Convert %u0000 to %u0020.\n            if (b < 0x20) {\n                b += 0x20;\n            }\n        }\n        buffer.write(b);\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        int b = bytes[i];\n        // Convert plus to space.\n        if (b == '+') {\n            b = ' ';\n        } else if (b == '%') {\n            // Convert hex characters to a nibble\n            final byte hex1 = bytes[++i];\n            final byte hex2 = bytes[++i];\n            b = (byte) ((Character.digit(hex1, RADIX) << 4) + Character.digit(hex2, RADIX));\n        }\n        buffer.write(b);\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        int b = bytes[i];\n\n        // Convert plus to space\n        if (b == '+') {\n            b = ' ';\n        }\n\n        // Convert % to original character\n        else if (b == '%') {\n            final int h1 = decodeHexByte(bytes[++i]);\n            final int h2 = decodeHexByte(bytes[++i]);\n\n            if ((h1 | h2) < 0) {\n                throw new DecoderException(\"Invalid URL encoding: \");\n            }\n            b = (h1 << 4) | h2;\n        }\n\n        buffer.write(b);\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        int b = bytes[i];\n\n        // Convert plus to space.\n        if (b == '+') {\n            b = ' ';\n        }\n\n        // Convert % to original character\n        else if (b == ESCAPE_CHAR) {\n            final byte[] hex = new byte[2];\n            if ((bytes.length - i) < hex.length) {\n                throw new DecoderException(\"Invalid URL encoding: \" + new String(bytes));\n            }\n            System.arraycopy(bytes, i + 1, hex, 0, 2);\n            b = (byte) Integer.parseInt(new String(hex), RADIX);\n            i += 2;\n        }\n\n        buffer.write(b);\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        int b = bytes[i];\n\n        // Convert plus to space\n        if (b == '+') {\n            b = ' ';\n        } else if (b == '%') {\n            // Convert hex characters to a nibble\n            final byte hi = (byte) Character.digit( (char) bytes[++i], RADIX );\n            final byte lo = (byte) Character.digit( (char) bytes[++i], RADIX );\n            b = (byte) ((hi << 4) + lo);\n        }\n\n        buffer.write(b);\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        int b = bytes[i];\n\n        // Convert plus to space\n        if (b == '+') {\n            b = ' ';\n        } else if (b == ESCAPE_CHAR) {\n            try {\n                b = (Character.digit((char) bytes[++i], RADIX) << 4)\n                        + Character.digit((char) bytes[++i], RADIX);\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding: \", e);\n            }\n        }\n        buffer.write(b);\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        int b = bytes[i];\n        // Convert plus to space.\n        if (b == '+') {\n            b = ' ';\n        } else if (b == '%') {\n            // Convert hexidecimal %XX to byte value.\n            final int uc = Character.digit((char) bytes[++i], RADIX);\n            final int lc = Character.digit((char) bytes[++i], RADIX);\n            if (uc == -1 || lc == -1) {\n                throw new DecoderException(\"Invalid URL encoding: \" + new String(bytes, \"US-ASCII\"));\n            }\n            b = (uc << 4) + lc;\n        }\n        buffer.write(b);\n    }\n    return buffer.toByteArray();\n}"
    ],
    [
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}"
    ],
    [
      "public static final boolean isContiguous(ReadablePartial partial)  {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"Partial must not be null\");\n        }\n        List<DateTimeFieldType> list = partial.getFields();\n        for (int i = 0; i < list.size() - 1; i++) {\n            DateTimeFieldType current = list.get(i);\n            DateTimeFieldType next = list.get(i + 1);\n            if (current.getDurationField() != next.getRangeUnit()) {\n                return false;\n            }\n        }\n        return true;\n    }",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    if (partial.size() < 2) {\n        return true;\n    }\n    int i = 0;\n    while (i < partial.size() - 1) {\n        if (partial.getFieldType(i) != partial.getFieldType(i + 1).getRangeType()) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"Partial must not be null\");\n        }\n        int size = partial.size();\n        for (int i = 0; i < size; i++) {\n            if (i + 1 < size) {\n                if (!partial.getFieldType(i).equals(partial.getFieldType(i + 1))) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    Iterator<DateTimeFieldType> it = partial.getFieldTypes().iterator();\n    while (it.hasNext()) {\n        DateTimeFieldType current = it.next();\n        DateTimeFieldType next = it.hasNext() ? it.next() : null;\n        if (next == null) {\n            return true;\n        }\n        if (!current.getDurationType().equals(next.getDurationType())) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    for (int i = 0; i < size; i++) {\n        if (i + 1 < size) {\n            if (partial.getFieldType(i) != partial.getFieldType(i + 1)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"Partial must not be null\");\n        }\n        int size = partial.size();\n        for (int i = 0; i < size; i++) {\n            if (i + 1 < size && !partial.getFieldType(i).getRangeType().equals(partial.getFieldType(i + 1))) {\n                return false;\n            }\n        }\n        return true;\n    }",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size == 0) {\n        return false;\n    }\n    int i = 0;\n    while (i < size - 1) {\n        if (partial.getFieldType(i) != partial.getFieldType(i + 1).getRangeType()) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    if (partial.size() < 2) {\n        return true;\n    }\n    for (int i = 0; i < partial.size() - 1; i++) {\n        if (partial.getFieldType(i) != partial.getFieldType(i + 1)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size == 0) {\n        return false;\n    }\n    int i = 0;\n    while (i < size - 1) {\n        if (partial.getFieldType(i).getDurationType() != partial.getFieldType(i + 1).getDurationType()) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size == 0) {\n        return true;\n    }\n    int i = 0;\n    while (i < size - 1) {\n        if (partial.getFieldType(i) != partial.getFieldType(i + 1)) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}"
    ],
    [
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> collection = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O element : a) \n    {\n        collection.setCardinality(element, 1);\n    }\n    for (final O element : b) \n    {\n        if (!collection.contains(element)) \n        {\n            collection.setCardinality(element, 1);\n        }\n    }\n    return collection.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final Iterator<? extends O> it = a.iterator(); it.hasNext();) {\n        final O obj = it.next();\n        helper.setCardinality(obj, 1);\n    }\n    for (final Iterator<? extends O> it = b.iterator(); it.hasNext();) {\n        final O obj = it.next();\n        helper.setCardinality(obj, 1);\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return SetOperationCardinalityHelper.union(a, b);\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O element : a) \n    {\n        helper.setCardinality(element, 1);\n    }\n    for (final O element : b) \n    {\n        if (!helper.elements.contains(element)) \n        {\n            helper.setCardinality(element, 1);\n        }\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    if (a == null || b == null) {\n        throw new IllegalArgumentException(\"Collections must not be null\");\n    }\n    return new SetOperationCardinalityHelper<O>(a, b).list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : a) \n    {\n        helper.setCardinality(obj, 1);\n    }\n    for (final O obj : b) \n    {\n        if (!helper.contains(obj)) \n        {\n            helper.setCardinality(obj, 1);\n        }\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O element : a) {\n        helper.setCardinality(element, 1);\n    }\n    for (final O element : b) {\n        if (!helper.elements.contains(element)) {\n            helper.setCardinality(element, 1);\n        }\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return SetOperationCardinalityHelper.union(a, b);\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> setOp = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O element : a) \n    {\n        setOp.setCardinality(element, 1);\n    }\n    for (final O element : b) \n    {\n        setOp.setCardinality(element, 1);\n    }\n    return setOp.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return SetOperationCardinalityHelper.union(a, b);\n}"
    ],
    [
      "private static List<Node> createStringsFromParamList(Node params)  {\n  Preconditions.checkArgument(params.isParamList());\n  List<Node> strings = new ArrayList<>();\n  for (Node param : params.children()) {\n    strings.add(IR.string(param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  Preconditions.checkArgument(params.isParamList());\n  List<Node> result = Lists.newArrayList();\n  for (Node param : params.children()) {\n    result.add(IR.string(param.getString()));\n  }\n  return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  Preconditions.checkArgument(params.isParamList());\n  List<Node> strings = Lists.newArrayList();\n  for (Node param : params.children()) {\n    strings.add(IR.string(param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  Preconditions.checkArgument(params.isParamList());\n  List<Node> strings = Lists.newArrayList();\n  for (Node param : params.children()) {\n    strings.add(IR.string(param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  Preconditions.checkArgument(params.isParamList());\n  List<Node> strings = new ArrayList<>();\n  for (Node param : params.children()) {\n    strings.add(IR.string(param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  Preconditions.checkArgument(params.isParamList());\n  List<Node> result = new ArrayList<Node>();\n  for (Node child : params.children()) {\n    result.add(IR.string(child.getString()));\n  }\n  return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  Preconditions.checkArgument(params.isParamList());\n  List<Node> result = Lists.newArrayList();\n  for (Node child = params.getFirstChild(); child != null;\n       child = child.getNext()) {\n    result.add(IR.string(child.getString()));\n  }\n  return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  Preconditions.checkArgument(params.isParamList());\n  List<Node> result = Lists.newArrayList();\n  for (Node child : params.children()) {\n    result.add(IR.string(child.getString()));\n  }\n  return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  Preconditions.checkArgument(params.isParamList());\n  List<Node> result = Lists.newArrayList();\n  for (Node param : params.children()) {\n    result.add(IR.string(param.getString()));\n  }\n  return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  Preconditions.checkArgument(params.isParamList());\n  List<Node> result = new ArrayList<>();\n  for (Node param : params.children()) {\n    result.add(IR.string(param.getString()));\n  }\n  return result;\n}"
    ],
    [
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            str.getChars(0, strLen, buffer, size);\n            for (int i = strLen; i < width; i++) \n            {\n                buffer[size + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            str.getChars(0, strLen, buffer, size);\n            for (int i = strLen; i < width; i++) \n            {\n                buffer[size + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            str.getChars(0, strLen, buffer, size);\n            for (int i = strLen; i < width; i++) \n            {\n                buffer[size + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            str.getChars(0, strLen, buffer, size);\n            for (int i = strLen; i < width; i++) \n            {\n                buffer[size + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            str.getChars(0, strLen, buffer, size);\n            for (int i = strLen; i < width; i++) \n            {\n                buffer[size + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            str.getChars(0, strLen, buffer, size);\n            for (int i = strLen; i < width; i++) \n            {\n                buffer[size + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}"
    ],
    [
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    // handle any leading delimiters\n    str = StringUtils.deleteAny(str, delimiters);\n    str = StringUtils.capitalize(str, delimiters);\n    // handle any remaining delimiters\n    int strLen = str.length();\n    int current = 0;\n    int index = 0;\n    while (index < strLen) \n    {\n        if (isDelimiter(str.charAt(index), delimiters)) \n        {\n            index++;\n            continue;\n        }\n        final int bufferIndex = index++;\n        if (index == strLen) \n        {\n            str = str.substring(0, bufferIndex) + StringUtils.capitalize(str.substring(bufferIndex), delimiters);\n            break;\n        }\n        while (index < strLen) \n        {\n            if (isDelimiter(str.charAt(index), delimiters)) \n            {\n                str = str.substring(0, bufferIndex) + StringUtils.capitalize(str.substring(bufferIndex, index), delimiters) + str.substring(index);\n                index++;\n                break;\n            }\n            index++;\n        }\n        if (index > strLen) \n        {\n            index = strLen;\n        }\n        current = index;\n    }\n    return str;\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    str = str.toLowerCase();\n    return capitalize(str, delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    str = str.toLowerCase();\n    return capitalize(str, delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    // account for null str and empty delimiters\n    final String[] words = str.split(\"(?![^\\\\s,]+[']s$)[\\\\s,]+\", -1);\n    final StringBuilder sb = new StringBuilder(str.length());\n    boolean capitalizeNext = true;\n    for (String word : words) \n    {\n        if (capitalizeNext && StringUtils.isNotEmpty(word)) \n        {\n            word = capitalize(word, delimiters);\n            capitalizeNext = false;\n        }\n        sb.append(word);\n        if (delimLen > 0) \n        {\n            final int textIndex = word.length() - 1;\n            for (int i = 0; i < delimLen; i++) \n            {\n                if (delimiters[i] == word.charAt(textIndex)) \n                {\n                    capitalizeNext = true;\n                }\n            }\n        }\n    }\n    return sb.toString();\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    str = capitalize(str, delimiters);\n    str = uncapitalize(str, delimiters);\n    return str;\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    str = capitalize(str, delimiters);\n    str = uncapitalize(str, delimiters);\n    return str;\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    // handle any leading delimiters\n    str = StringUtils.deleteAny(str, delimiters);\n    str = StringUtils.capitalize(str, delimiters);\n    // handle any remaining delimiters\n    int strLen = str.length();\n    int current = 0;\n    int after = 0;\n    while (after < strLen) \n    {\n        current = after;\n        after = StringUtils.indexOfAny(str, delimiters, current);\n        if (after > -1) \n        {\n            str = str.substring(0, after) + StringUtils.capitalize(str.substring(after), delimiters);\n            after += current + 1;\n        }\n    }\n    return str;\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    str = capitalize(str, delimiters);\n    str = uncapitalize(str, delimiters);\n    return str;\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    str = capitalize(str, delimiters);\n    str = uncapitalize(str, delimiters);\n    return str;\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    str = capitalize(str, delimiters);\n    str = uncapitalize(str, delimiters);\n    return str;\n}"
    ],
    [
      "private static synchronized String getConvertedId(String id)  {\n        if (id.equals(\"GMT\")) {\n            return \"Etc/GMT\";\n        } else if (id.equals(\"GMT+0\")) {\n            return \"Etc/GMT-0\";\n        } else if (id.equals(\"GMT-0\")) {\n            return \"Etc/GMT+0\";\n        } else if (id.equals(\"GMT0\")) {\n            return \"Etc/GMT0\";\n        } else if (id.equals(\"UT\")) {\n            return \"Etc/UTC\";\n        } else if (id.equals(\"UTC\")) {\n            return \"Etc/UTC\";\n        } else if (id.equals(\"Z\")) {\n            return \"Etc/UTC\";\n        } else if (id.equals(\"Universal\")) {\n            return \"Etc/UTC\";\n        } else if (id.equals(\"Greenwich\")) {\n            return \"Etc/UTC\";\n        } else if (id.equals(\"WET\")) {\n            return \"Etc/UTC\";\n        } else if (id.equals(\"WEST\")) {\n            return \"Etc/UTC\";\n        } else if (id.equals(\"WAT\")) {\n            return \"Etc/UTC\";\n        } else if (id.equals(\"AST\")) {\n            return \"Etc/UTC\";\n        } else if (id.equals(\"ADT\")) {\n            return \"Etc/UTC\";\n        } else if (id.equals(\"EST\")) {\n            return \"Etc/UTC\";\n        } else if (id.equals(\"EDT\")) {\n            return \"Etc/UTC\";\n        } else if (id.equals(\"CST\")) {\n            return \"Etc/UTC\";\n        } else if (id.equals(\"CDT\")) {\n            return \"Etc/UTC\";\n        } else if (id.equals(\"MST\")) {\n            return \"Etc/UTC\";\n        } else if (id.equals(\"MDT\")) {\n            return \"Etc/UTC\";\n        } else if (id.equals(\"PST\")) {\n            return \"Etc/UTC\";\n        } else if (id.equals(\"PDT\")) {\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n        if (id.startsWith(\"Etc/GMT\")) {\n            if (id.equals(\"Etc/GMT+12\")) {\n                return \"Etc/GMT-12\";\n            }\n            if (id.equals(\"Etc/GMT+11\")) {\n                return \"Etc/GMT-11\";\n            }\n            if (id.equals(\"Etc/GMT+10\")) {\n                return \"Etc/GMT-10\";\n            }\n            if (id.equals(\"Etc/GMT+9\")) {\n                return \"Etc/GMT-9\";\n            }\n            if (id.equals(\"Etc/GMT+8\")) {\n                return \"Etc/GMT-8\";\n            }\n            if (id.equals(\"Etc/GMT+7\")) {\n                return \"Etc/GMT-7\";\n            }\n            if (id.equals(\"Etc/GMT+6\")) {\n                return \"Etc/GMT-6\";\n            }\n            if (id.equals(\"Etc/GMT+5\")) {\n                return \"Etc/GMT-5\";\n            }\n            if (id.equals(\"Etc/GMT+4\")) {\n                return \"Etc/GMT-4\";\n            }\n            if (id.equals(\"Etc/GMT+3\")) {\n                return \"Etc/GMT-3\";\n            }\n            if (id.equals(\"Etc/GMT+2\")) {\n                return \"Etc/GMT-2\";\n            }\n            if (id.equals(\"Etc/GMT+1\")) {\n                return \"Etc/GMT-1\";\n            }\n            if (id.equals(\"Etc/GMT0\")) {\n                return \"Etc/GMT0\";\n            }\n            if (id.equals(\"Etc/GMT-1\")) {\n                return \"Etc/GMT+1\";\n            }\n            if (id.equals(\"Etc/GMT-2\")) {\n                return \"Etc/GMT+2\";\n            }\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id.startsWith(\"Etc/GMT\") || id.startsWith(\"GMT\") || id.startsWith(\"UTC\")) {\n        id = \"Etc/UTC\";\n    } else if (id.startsWith(\"Etc/UCT\")) {\n        id = \"Etc/UTC\";\n    } else if (id.startsWith(\"Etc/Universal\")) {\n        id = \"Etc/UTC\";\n    } else if (id.startsWith(\"Etc/Zulu\")) {\n        id = \"Etc/UTC\";\n    } else if (id.startsWith(\"Etc/GMT+12\")) {\n        id = \"Etc/GMT-12\";\n    } else if (id.startsWith(\"Etc/GMT-12\")) {\n        id = \"Etc/GMT+12\";\n    } else if (id.startsWith(\"Etc/GMT+11\")) {\n        id = \"Etc/GMT-11\";\n    } else if (id.startsWith(\"Etc/GMT-11\")) {\n        id = \"Etc/GMT+11\";\n    } else if (id.startsWith(\"Etc/GMT+10\")) {\n        id = \"Etc/GMT-10\";\n    } else if (id.startsWith(\"Etc/GMT-10\")) {\n        id = \"Etc/GMT+10\";\n    } else if (id.startsWith(\"Etc/GMT+9\")) {\n        id = \"Etc/GMT-9\";\n    } else if (id.startsWith(\"Etc/GMT-9\")) {\n        id = \"Etc/GMT+9\";\n    } else if (id.startsWith(\"Etc/GMT+8\")) {\n        id = \"Etc/GMT-8\";\n    } else if (id.startsWith(\"Etc/GMT-8\")) {\n        id = \"Etc/GMT+8\";\n    } else if (id.startsWith(\"Etc/GMT+7\")) {\n        id = \"Etc/GMT-7\";\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n        if (id.length() == 3) {\n            if (id.startsWith(\"E\")) {\n                id = \"Etc/\" + id;\n            } else if (id.startsWith(\"A\")) {\n                id = \"Antarctica/\" + id;\n            } else if (id.startsWith(\"N\")) {\n                id = \"America/\" + id;\n            } else if (id.startsWith(\"O\")) {\n                id = \"Arctic/\" + id;\n            } else if (id.startsWith(\"P\")) {\n                id = \"Pacific/\" + id;\n            } else if (id.startsWith(\"R\")) {\n                id = \"Atlantic/\" + id;\n            } else if (id.startsWith(\"S\")) {\n                id = \"SouthAmerica/\" + id;\n            } else if (id.startsWith(\"U\")) {\n                id = \"US/\" + id;\n            } else if (id.startsWith(\"W\")) {\n                id = \"WET/\" + id;\n            } else if (id.startsWith(\"Z\")) {\n                id = \"Zulu/\" + id;\n            }\n        }\n        return id;\n    }",
      "private static synchronized String getConvertedId(String id)  {\n        if (id.equals(\"Etc/GMT+12\")) {\n            return \"Etc/GMT-12\";\n        }\n        if (id.equals(\"Etc/GMT-12\")) {\n            return \"Etc/GMT+12\";\n        }\n        if (id.equals(\"Etc/GMT+11\")) {\n            return \"Etc/GMT-11\";\n        }\n        if (id.equals(\"Etc/GMT-11\")) {\n            return \"Etc/GMT+11\";\n        }\n        if (id.equals(\"Etc/GMT+10\")) {\n            return \"Etc/GMT-10\";\n        }\n        if (id.equals(\"Etc/GMT-10\")) {\n            return \"Etc/GMT+10\";\n        }\n        if (id.equals(\"Etc/GMT+9\")) {\n            return \"Etc/GMT-9\";\n        }\n        if (id.equals(\"Etc/GMT-9\")) {\n            return \"Etc/GMT+9\";\n        }\n        if (id.equals(\"Etc/GMT+8\")) {\n            return \"Etc/GMT-8\";\n        }\n        if (id.equals(\"Etc/GMT-8\")) {\n            return \"Etc/GMT+8\";\n        }\n        if (id.equals(\"Etc/GMT+7\")) {\n            return \"Etc/GMT-7\";\n        }\n        if (id.equals(\"Etc/GMT-7\")) {\n            return \"Etc/GMT+7\";\n        }\n        if (id.equals(\"Etc/GMT+6\")) {\n            return \"Etc/GMT-6\";\n        }\n        if (id.equals(\"Etc/GMT-6\")) {\n            return \"Etc/GMT+6\";\n        }\n        if (id.equals(\"Etc/GMT+5\")) {\n            return \"Etc/GMT-5\";\n        }\n}",
      "private static synchronized String getConvertedId(String id)  {\n        if (id.startsWith(\"Etc/GMT\")) {\n            id = \"Etc/UTC\";\n        } else if (id.startsWith(\"Etc/GMT+\") || id.startsWith(\"Etc/GMT-\")) {\n            id = \"Etc/UTC\";\n        } else if (id.startsWith(\"Etc/\")) {\n            id = \"Etc/\" + id.substring(4);\n        } else if (id.startsWith(\"SystemV/\")) {\n            id = \"SystemV/\" + id.substring(8);\n        } else if (id.startsWith(\"ROC/\")) {\n            id = \"ROC/\" + id.substring(4);\n        } else if (id.startsWith(\"SystemV/CST\")) {\n            id = \"Asia/Shanghai\";\n        } else if (id.startsWith(\"SystemV/EST\")) {\n            id = \"America/New_York\";\n        } else if (id.startsWith(\"SystemV/HST\")) {\n            id = \"Pacific/Honolulu\";\n        } else if (id.startsWith(\"SystemV/MST\")) {\n            id = \"America/Phoenix\";\n        } else if (id.startsWith(\"SystemV/PST\")) {\n            id = \"America/Los_Angeles\";\n        } else if (id.startsWith(\"SystemV/YST\")) {\n            id = \"Asia/Tashkent\";\n        } else if (id.startsWith(\"SystemV/YDT\")) {\n            id = \"Asia/Chongqing\";\n        } else if (id.startsWith(\"SystemV/CCT\")) {\n            id = \"Asia/Kuala_Lumpur\";\n        } else if (id.startsWith(\"SystemV/JST\")) {\n            id = \"Asia/Tokyo\";\n        } else if (id.startsWith(\"SystemV/EET\")) {\n            id = \"Europe/Paris\";\n        } else if (id.startsWith(\"SystemV/EST5EDT\")) {\n            id = \"America/New_York\";\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id.startsWith(\"Etc/GMT\") && id.length() == 9) {\n        if (id.charAt(7) == '+') {\n            return \"Etc/GMT-\" + id.substring(8);\n        } else if (id.charAt(7) == '-') {\n            return \"Etc/GMT+\" + id.substring(8);\n        }\n    }\n    return null;\n}",
      "private static synchronized String getConvertedId(String id)  {\n        if (id.equals(\"EST\") || id.equals(\"EDT\")) {\n            return \"America/New_York\";\n        } else if (id.equals(\"CST\") || id.equals(\"CDT\")) {\n            return \"America/Chicago\";\n        } else if (id.equals(\"MST\") || id.equals(\"MDT\")) {\n            return \"America/Denver\";\n        } else if (id.equals(\"PST\") || id.equals(\"PDT\")) {\n            return \"America/Los_Angeles\";\n        } else if (id.equals(\"GMT\")) {\n            return \"Etc/GMT\";\n        } else if (id.equals(\"UTC\")) {\n            return \"Etc/UTC\";\n        } else if (id.equals(\"Z\")) {\n            return \"Etc/UTC\";\n        } else if (id.equals(\"A\")) {\n            return \"America/Anchorage\";\n        } else if (id.equals(\"N\")) {\n            return \"America/New_York\";\n        } else if (id.equals(\"D\")) {\n            return \"America/Denver\";\n        } else if (id.equals(\"M\")) {\n            return \"America/Chicago\";\n        } else if (id.equals(\"P\")) {\n            return \"America/Los_Angeles\";\n        } else if (id.equals(\"Y\")) {\n            return \"America/Halifax\";\n        } else if (id.equals(\"ZZ\")) {\n            return \"Etc/Unknown\";\n        }\n        return null;\n    }",
      "private static synchronized String getConvertedId(String id)  {\n        if (id.startsWith(\"Etc/\")) {\n            id = id.substring(4);\n        }\n        if (id.startsWith(\"GMT\") && id.length() > 3) {\n            id = \"Etc/\" + id.substring(3);\n        }\n        if (id.startsWith(\"SystemV/\")) {\n            id = id.substring(8);\n        }\n        if (id.startsWith(\"ROC/\")) {\n            id = id.substring(4);\n        }\n        if (id.startsWith(\"Japan/\")) {\n            id = id.substring(6);\n        }\n        if (id.startsWith(\"PRC/\")) {\n            id = id.substring(4);\n        }\n        if (id.startsWith(\"MSK/\")) {\n            id = id.substring(4);\n        }\n        if (id.startsWith(\"Libya/\")) {\n            id = id.substring(6);\n        }\n        if (id.startsWith(\"Turkey/\")) {\n            id = id.substring(7);\n        }\n        if (id.startsWith(\"Belarus/\")) {\n            id = id.substring(8);\n        }\n        if (id.startsWith(\"Russia/\")) {\n            id = id.substring(7);\n        }\n        if (id.startsWith(\"Libya/\")) {\n            id = id.substring(6);\n        }\n        if (id.startsWith(\"Turkey/\")) {\n            id = id.substring(7);\n        }\n        if (id.startsWith(\"Belarus/\")) {\n            id = id.substring(8);\n        }\n        if (id.startsWith(\"Russia/\")) {\n            id = id.substring(7);\n        }\n        if (id.startsWith(\"Libya/\")) {\n            id = id.substring(6);\n        }\n        if (id.startsWith(\"Turkey/\")) {\n            id = id.substring(7);\n        }\n        if (id.startsWith(\"Belarus/\")) {\n            id = id.substring(8);\n        }\n}",
      "private static synchronized String getConvertedId(String id)  {\n        if (id.length() == 3) {\n            // try the map\n            String newId = cIdMap.get(id);\n            if (newId != null) {\n                return newId;\n            }\n            // try the list\n            for (String[] data : cIdList) {\n                if (data[0].equals(id)) {\n                    return data[1];\n                }\n            }\n        }\n        return id;\n    }"
    ],
    [
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final int n = params.length;\n    final int m = jF.getDimensionOfDomain();\n    final double[][] jacobian = new double[m][n];\n    for (int i = 0; i < m; ++i) {\n        final double[] gradient = jF.gradient(params, i);\n        for (int j = 0; j < n; ++j) {\n            jacobian[i][j] = gradient[j];\n        }\n    }\n    return weightMatrixSqrt.multiply(MatrixUtils.createRealMatrix(jacobian));\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final double[][] jacobian = jF.computeDerivatives(params);\n    final double[][] weightedJacobian = new double[jacobian.length][jacobian[0].length];\n    for (int i = 0; i < jacobian.length; ++i) {\n        for (int j = 0; j < jacobian[0].length; ++j) {\n            weightedJacobian[i][j] = jacobian[i][j] * weightMatrixSqrt.getEntry(i, j);\n        }\n    }\n    return MatrixUtils.createRealMatrix(weightedJacobian);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final RealMatrix jacobian = jF.computeDerivatives(params);\n    return weightMatrixSqrt.multiply(jacobian);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final int n = params.length;\n    final int m = getNumberOfObservations();\n    final double[][] jacobian = new double[m][n];\n    final double[] residuals = new double[m];\n    for (int i = 0; i < m; i++) {\n        final double[] point = getPoint(i);\n        final double[] weight = getWeight(i);\n        final double[] residual = getResidual(point, params);\n        final double weightedResidual = weightedResidual(residual, weight);\n        residuals[i] = weightedResidual;\n        final double[] weightedResidualJacobian = getWeightedResidualJacobian(residual, weight, point, params);\n        for (int j = 0; j < n; j++) {\n            jacobian[i][j] = weightedResidualJacobian[j];\n        }\n    }\n    return new Array2DRowRealMatrix(jacobian, false).scalarMultiply(1 / weightMatrixSqrt.getEntry(0, 0));\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final int n = params.length;\n    final int m = jF.getDimensionOfDomain();\n    if (n != m) {\n        throw new DimensionMismatchException(n, m);\n    }\n    final RealMatrix jacobian =\n        new Array2DRowRealMatrix(m, n, false);\n    final double[] gradient = new double[n];\n    for (int i = 0; i < n; ++i) {\n        jF.gradient(params, gradient);\n        final double[] weightedGradient =\n            weightMatrixSqrt.operate(gradient);\n        for (int j = 0; j < m; ++j) {\n            jacobian.setEntry(j, i, weightedGradient[j]);\n        }\n        params[i] += getStep();\n    }\n    return jacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    // Compute the Jacobian matrix.\n    final RealMatrix jacobian = jF.computeGradient(params);\n\n    // Compute the square root of the weight matrix.\n    final RealMatrix weightMatrixSqrt = getWeightMatrixSqrt();\n\n    // Compute the weighted Jacobian: W<sup>1/2</sup> J.\n    return weightMatrixSqrt.multiply(jacobian);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final RealMatrix jacobian = jF.computeJacobianMatrix(params);\n    final RealMatrix weightedJacobian = weightMatrixSqrt.multiply(jacobian);\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    // compute the Jacobian matrix\n    final RealMatrix jacobian = jF.computeGradient(params);\n    // compute the square-root of the weight matrix\n    final RealMatrix weightMatrixSqrt = this.weightMatrixSqrt;\n    // compute the weighted Jacobian\n    return jacobian.multiply(weightMatrixSqrt);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final double[] residuals = computeResiduals(params);\n    final double[][] jacobian = jF.computeDerivatives(params);\n    final RealMatrix weightedJacobian = new Array2DRowRealMatrix(jacobian);\n    return weightMatrixSqrt.multiply(weightedJacobian).scalarMultiply(1.0 / weightMatrixSqrt.getEntry(0, 0));\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    // Compute the Jacobian matrix\n    final RealMatrix jacobian = jF.computeJacobianMatrix(params);\n\n    // Multiply by the square-root of the weight matrix\n    return weightMatrixSqrt.multiply(jacobian);\n}"
    ],
    [
      "private int least()  {\n    if (comparator == null) \n    {\n        throw new NullPointerException(\"Comparator has not been set\");\n    }\n    int leastIndex = -1;\n    for (int i = 0; i < values.size(); i++) \n    {\n        if (valueSet.get(i)) \n        {\n            if (leastIndex == -1) \n            {\n                leastIndex = i;\n            }\n            else if (comparator.compare(values.get(i), values.get(leastIndex)) < 0) \n            {\n                leastIndex = i;\n            }\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    // TODO: Implement this method\n    return -1;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int leastIndex = -1;\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i)) {\n            if (leastIndex == -1) {\n                leastIndex = i;\n            } else {\n                final int cmp = comparator.compare(values.get(i), values.get(leastIndex));\n                if (cmp < 0) {\n                    leastIndex = i;\n                }\n            }\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int leastIndex = -1;\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i)) {\n            if (leastIndex == -1) {\n                leastIndex = i;\n            } else {\n                if (comparator.compare(values.get(i), values.get(leastIndex)) < 0) {\n                    leastIndex = i;\n                }\n            }\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    if (comparator == null) \n    {\n        throw new NullPointerException(\"No comparator set\");\n    }\n\n    // Find the least element\n    int leastIndex = -1;\n    for (int i = 0; i < values.size(); i++) \n    {\n        if (valueSet.get(i)) \n        {\n            if (leastIndex == -1 || comparator.compare(values.get(i), values.get(leastIndex)) < 0) \n            {\n                leastIndex = i;\n            }\n        }\n    }\n\n    return leastIndex;\n}",
      "private int least()  {\n    // TODO: Complete this method\n    return 0;\n}",
      "private int least()  {\n    int leastIndex = -1;\n    for (int i = 0; i < iterators.size(); i++) {\n        if (valueSet.get(i)) {\n            if (leastIndex == -1 || comparator.compare(values.get(i), values.get(leastIndex)) < 0) {\n                leastIndex = i;\n            }\n        } else if (!set(i)) {\n            throw new NoSuchElementException();\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    if (comparator == null) \n    {\n        throw new NullPointerException(\"No comparator set\");\n    }\n\n    // If there is no value at position i, set it to the next value of the\n    // iterator at position i, or clear it if the iterator has no next value.\n    for (int i = 0; i < iterators.size(); i++) \n    {\n        if (!valueSet.get(i)) \n        {\n            if (!set(i)) \n            {\n                continue;\n            }\n        }\n\n        // If there is no value at position j, set it to the next value of the\n        // iterator at position j, or clear it if the iterator has no next value.\n        for (int j = i + 1; j < iterators.size(); j++) \n        {\n            if (!valueSet.get(j)) \n            {\n                if (!set(j)) \n                {\n                    continue;\n                }\n            }\n\n            // Compare the values at positions i and j.\n            final int compare = comparator.compare(values.get(i), values.get(j));\n            if (compare < 0) \n            {\n                // The value at position i is less than the value at position j.\n                // Clear the value at position j.\n                clear(j);\n            }\n            else if (compare > 0) \n            {\n                // The value at position i is greater than the value at position j.\n                // Clear the value at position i.\n                clear(i);\n                break;\n            }\n        }\n    }\n\n    // Find the index of the first value.\n    int leastIndex = -1;\n    for (int i = 0; i < values.size(); i++) \n    {\n        if (valueSet.get(i)) \n        {\n            if (leastIndex == -1) \n            {\n                leastIndex = i;\n            }\n            else \n            {\n                // Compare the values at positions i and leastIndex.\n                final int compare = comparator.compare(values.get(i), values.get(leastIndex));\n}\n}\n}\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator not set\");\n    }\n    int leastIndex = -1;\n    for (int i = 0; i < iterators.size(); i++) {\n        if (valueSet.get(i)) {\n            if (leastIndex == -1 || comparator.compare(values.get(i), values.get(leastIndex)) < 0) {\n                leastIndex = i;\n            }\n        } else if (set(i)) {\n            if (leastIndex == -1 || comparator.compare(values.get(i), values.get(leastIndex)) < 0) {\n                leastIndex = i;\n            }\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator not set\");\n    }\n    int leastIndex = -1;\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i)) {\n            if (leastIndex == -1 || comparator.compare(values.get(i), values.get(leastIndex)) < 0) {\n                leastIndex = i;\n            }\n        } else {\n            if (set(i)) {\n                if (leastIndex == -1 || comparator.compare(values.get(i), values.get(leastIndex)) < 0) {\n                    leastIndex = i;\n                }\n            }\n        }\n    }\n    return leastIndex;\n}"
    ],
    [
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    NodePointer childPointer = null;\n    if (step.getAxis() == Compiler.AXIS_CHILD) {\n        childPointer = parentPointer.getChildPointer();\n    } else if (step.getAxis() == Compiler.AXIS_ATTRIBUTE) {\n        childPointer = parentPointer.getAttributePointer();\n    } else if (step.getAxis() == Compiler.AXIS_DESCENDANT) {\n        childPointer = parentPointer.getDescendantPointer();\n    } else if (step.getAxis() == Compiler.AXIS_DESCENDANT_OR_SELF) {\n        childPointer = parentPointer.getDescendantOrSelfPointer();\n    } else if (step.getAxis() == Compiler.AXIS_FOLLOWING_SIBLING) {\n        childPointer = parentPointer.getFollowingSiblingPointer();\n    } else if (step.getAxis() == Compiler.AXIS_PARENT) {\n        childPointer = parentPointer.getParentPointer();\n    } else if (step.getAxis() == Compiler.AXIS_PRECEDING_SIBLING) {\n        childPointer = parentPointer.getPrecedingSiblingPointer();\n    } else if (step.getAxis() == Compiler.AXIS_SELF) {\n        childPointer = parentPointer.getSelfPointer();\n    }\n    return childPointer;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    // Get the property name\n    String propertyName = step.getNodeTest().getStringValue();\n\n    // Get the property value\n    Object propertyValue = parentPointer.getProperty(propertyName);\n\n    // Create a child pointer\n    return new PropertyPointer(\n        parentPointer,\n        propertyValue,\n        propertyName);\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    // Create a child pointer\n    NodePointer childPointer = (NodePointer) parentPointer.clone();\n    childPointer.setProperty(step.getLocalName());\n    return childPointer;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    NodePointer childPointer = null;\n    if (step.getAxis() == Compiler.AXIS_CHILD) {\n        childPointer = createChildPointer(parentPointer, step);\n    } else if (step.getAxis() == Compiler.AXIS_ATTRIBUTE) {\n        childPointer = createAttributePointer(parentPointer, step);\n    } else if (step.getAxis() == Compiler.AXIS_DESCENDANT) {\n        childPointer = createDescendantPointer(parentPointer, step);\n    } else if (step.getAxis() == Compiler.AXIS_DESCENDANT_OR_SELF) {\n        childPointer = createDescendantOrSelfPointer(parentPointer, step);\n    } else if (step.getAxis() == Compiler.AXIS_FOLLOWING) {\n        childPointer = createFollowingPointer(parentPointer, step);\n    } else if (step.getAxis() == Compiler.AXIS_FOLLOWING_SIBLING) {\n        childPointer = createFollowingSiblingPointer(parentPointer, step);\n    } else if (step.getAxis() == Compiler.AXIS_NAMESPACE) {\n        childPointer = createNamespacePointer(parentPointer, step);\n    } else if (step.getAxis() == Compiler.AXIS_PARENT) {\n        childPointer = createParentPointer(parentPointer, step);\n    } else if (step.getAxis() == Compiler.AXIS_PRECEDING) {\n        childPointer = createPrecedingPointer(parentPointer, step);\n    } else if (step.getAxis() == Compiler.AXIS_PRECEDING_SIBLING) {\n        childPointer = createPrecedingSiblingPointer(parentPointer, step);\n    } else if (step.getAxis() == Compiler.AXIS_SELF) {\n        childPointer = createSelfPointer(parentPointer, step);\n    }\n    return childPointer;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    // Get the property name\n    String propertyName = step.getNodeTest().getLocalName();\n\n    // Get the property value\n    Object propertyValue = parentPointer.getProperty(propertyName);\n\n    // Create the child pointer\n    return createChildPointer(parentPointer, propertyValue, step);\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    // Get the property name\n    String propertyName = step.getNodeTest().getNodeName();\n    // Get the property value\n    Object propertyValue = parentPointer.getProperty(propertyName);\n    // Create the child pointer\n    return createChildPointer(parentPointer, step, propertyValue);\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    NodePointer childPointer = null;\n    switch (step.getAxis()) {\n        case Compiler.AXIS_CHILD:\n            childPointer = parentPointer.getFirstChildPointer();\n            break;\n        case Compiler.AXIS_ATTRIBUTE:\n            childPointer = parentPointer.getFirstAttributePointer();\n            break;\n        case Compiler.AXIS_DESCENDANT:\n            childPointer = parentPointer.getFirstDescendantPointer();\n            break;\n        case Compiler.AXIS_DESCENDANT_OR_SELF:\n            childPointer = parentPointer.getFirstDescendantOrSelfPointer();\n            break;\n        case Compiler.AXIS_FOLLOWING_SIBLING:\n            childPointer = parentPointer.getFirstFollowingSiblingPointer();\n            break;\n        case Compiler.AXIS_FOLLOWING:\n            childPointer = parentPointer.getFirstFollowingPointer();\n            break;\n        case Compiler.AXIS_PARENT:\n            childPointer = parentPointer.getParentPointer();\n            break;\n        case Compiler.AXIS_ANCESTOR:\n            childPointer = parentPointer.getFirstAncestorPointer();\n            break;\n        case Compiler.AXIS_ANCESTOR_OR_SELF:\n            childPointer = parentPointer.getFirstAncestorOrSelfPointer();\n            break;\n        case Compiler.AXIS_PRECEDING_SIBLING:\n            childPointer = parentPointer.getFirstPrecedingSiblingPointer();\n            break;\n        case Compiler.AXIS_PRECEDING:\n            childPointer = parentPointer.getFirstPrecedingPointer();\n            break;\n        case Compiler.AXIS_NAMESPACE:\n            childPointer = parentPointer.getFirstNamespacePointer();\n            break;\n        case Compiler.AXIS_SELF:\n            childPointer = parentPointer.getSelfPointer();\n            break;\n        case Compiler.AXIS_DESCENDANT_ATTRIBUTE:\n            childPointer = parentPointer.getFirstDescendantAttributePointer();\n            break;\n        default:\n}\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    // Get the property name\n    String propertyName = step.getNodeTest().getNodeName();\n    // Get the property value\n    NodePointer propertyValue = parentPointer.getProperty(propertyName);\n    // Create the child pointer\n    return propertyValue != null ? propertyValue : createNullPointer(parentPointer, step);\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    String axis = step.getAxis();\n    if (axis.equals(Compiler.AXIS_CHILD)) {\n        return parentPointer.getChildPointer();\n    } else if (axis.equals(Compiler.AXIS_ATTRIBUTE)) {\n        return parentPointer.getAttributePointer();\n    } else if (axis.equals(Compiler.AXIS_DESCENDANT)) {\n        return parentPointer.getDescendantPointer();\n    } else if (axis.equals(Compiler.AXIS_DESCENDANT_OR_SELF)) {\n        return parentPointer.getDescendantOrSelfPointer();\n    } else if (axis.equals(Compiler.AXIS_FOLLOWING)) {\n        return parentPointer.getFollowingPointer();\n    } else if (axis.equals(Compiler.AXIS_FOLLOWING_SIBLING)) {\n        return parentPointer.getFollowingSiblingPointer();\n    } else if (axis.equals(Compiler.AXIS_NAMESPACE)) {\n        return parentPointer.getNamespacePointer();\n    } else if (axis.equals(Compiler.AXIS_PARENT)) {\n        return parentPointer.getParentPointer();\n    } else if (axis.equals(Compiler.AXIS_PRECEDING)) {\n        return parentPointer.getPrecedingPointer();\n    } else if (axis.equals(Compiler.AXIS_PRECEDING_SIBLING)) {\n        return parentPointer.getPrecedingSiblingPointer();\n    } else if (axis.equals(Compiler.AXIS_SELF)) {\n        return parentPointer.getSelfPointer();\n    } else {\n        throw new IllegalArgumentException(\"Unknown axis: \" + axis);\n    }\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    // Get the property name\n    String propertyName = step.getNodeTest();\n\n    // Get the property value\n    Object propertyValue = parentPointer.getProperty(propertyName);\n\n    // Create the child pointer\n    return createChildPointer(parentPointer, propertyValue, step);\n}"
    ],
    [
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    return ((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation().getX();\n}",
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    if (getTree(false).getCut().getHyperplane().getOffset() == 0) {\n        return Double.POSITIVE_INFINITY;\n    }\n    return ((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation().getX();\n}",
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    if (getTree(false).getCut().getHyperplane().getOffset() < 0) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    return ((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation().getX();\n}",
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    return ((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation().getX();\n}",
      "public double getInf()  {\n    // TODO: implement this method\n    return Double.NEGATIVE_INFINITY;\n}",
      "public double getInf()  {\n    // TODO: implement this method\n    return 0.0;\n}",
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    return ((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation().getX();\n}",
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    final OrientedPoint cut = (OrientedPoint) getTree(false).getCut().getHyperplane();\n    if (cut.getOffset() == 0.0) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    return cut.getLocation().getX();\n}",
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    if (getTree(false).getCut().getHyperplane().getOffset() == 0) {\n        return ((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation().getX();\n    }\n    return Double.POSITIVE_INFINITY;\n}",
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    if (getTree(false).getCut().getHyperplane().getOffset() < 0) {\n        return ((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation().getX();\n    }\n    return Double.POSITIVE_INFINITY;\n}"
    ],
    [
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    Locale locale= definingCalendar.getLocale();\n    Strategy strategy= cache.get(locale);\n    if(strategy==null) {\n        strategy= new TextStrategy(field, definingCalendar);\n        final Strategy oldStrategy= cache.putIfAbsent(locale, strategy);\n        if(oldStrategy!=null) {\n            strategy= oldStrategy;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar.getDisplayNames(field, Calendar.ALL_STYLES, locale));\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar.getDisplayNames(field, Calendar.ALL_STYLES, locale));\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar.getLocale());\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar.getDisplayNames(field, Calendar.ALL_STYLES, locale));\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar);\n}"
    ],
    [
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        nextObject = iterator.next();\n        if (predicate.evaluate(nextObject)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        final E next = iterator.next();\n        if (predicate.evaluate(next)) {\n            nextObject = next;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        nextObject = iterator.next();\n        if (predicate.evaluate(nextObject)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        final E next = iterator.next();\n        if (predicate.evaluate(next)) {\n            nextObject = next;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        nextObject = iterator.next();\n        if (predicate.evaluate(nextObject)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        final E next = iterator.next();\n        if (predicate.evaluate(next)) {\n            nextObject = next;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        nextObject = iterator.next();\n        if (predicate.evaluate(nextObject)) {\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        nextObject = iterator.next();\n        if (predicate.evaluate(nextObject)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        nextObject = iterator.next();\n        if (predicate.evaluate(nextObject)) {\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        nextObject = iterator.next();\n        if (predicate.evaluate(nextObject)) {\n            return true;\n        }\n    }\n    return false;\n}"
    ],
    [
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    final double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            x[i] = lB[i];\n        }\n        if (x[i] > uB[i]) {\n            x[i] = uB[i];\n        }\n    }\n    return x;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    for (int i = 0; i < x.length; i++) \n    {\n        if (x[i] < lB[i]) \n        {\n            x[i] = lB[i];\n        }\n        if (x[i] > uB[i]) \n        {\n            x[i] = uB[i];\n        }\n    }\n    return x;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    final double[] repaired = new double[x.length];\n\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] repaired = new double[x.length];\n\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    final double[] repaired = new double[x.length];\n\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            x[i] = lB[i];\n        }\n        if (x[i] > uB[i]) {\n            x[i] = uB[i];\n        }\n    }\n    return x;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    final double[] repaired = new double[x.length];\n\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    final double[] xRepaired = new double[x.length];\n\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            xRepaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            xRepaired[i] = uB[i];\n        } else {\n            xRepaired[i] = x[i];\n        }\n    }\n\n    return xRepaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            x[i] = lB[i];\n        }\n        if (x[i] > uB[i]) {\n            x[i] = uB[i];\n        }\n    }\n    return x;\n}"
    ],
    [
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // TODO: Implement this method\n    return null;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    transformer.transform();\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final SchurTransformer transformer = new SchurTransformer(matrix);\n    transformer.transform();\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // Transform the matrix to Schur form\n    final SchurTransformer schurTransformer = new SchurTransformer(matrix);\n    final RealMatrix t = schurTransformer.getT();\n    final RealMatrix z = schurTransformer.getZ();\n    final int n = t.getRowDimension();\n    // Calculate the eigenvalues\n    final double[] realEigenvalues = new double[n];\n    final double[] imagEigenvalues = new double[n];\n    for (int i = 0; i < n; i++) {\n        realEigenvalues[i] = t.getEntry(i, i);\n        imagEigenvalues[i] = 0;\n    }\n    return new SchurTransformer(t, z, realEigenvalues, imagEigenvalues);\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    SchurTransformer schurTransformer = new SchurTransformer(matrix);\n    schurTransformer.transform();\n    return schurTransformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    SchurTransformer schurTransformer = new SchurTransformer(matrix);\n    schurTransformer.transform();\n    return schurTransformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    SchurTransformer schurTransformer = new SchurTransformer(matrix);\n    schurTransformer.transform();\n    return schurTransformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // Transform to Schur form\n    final SchurTransformer transformer = new SchurTransformer(matrix);\n    final RealMatrix schurForm = transformer.getT();\n\n    // Calculate eigenvalues\n    final EigenDecomposition eigen = new EigenDecomposition(schurForm);\n    realEigenvalues = eigen.getRealEigenvalues();\n\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    //Transform the matrix to Schur form\n    SchurTransformer schurTransformer = new SchurTransformer(matrix);\n    schurTransformer.transform();\n    return schurTransformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // TODO: Implement this method\n    return null;\n}"
    ],
    [
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    checkBitVectorable(enumClass).getEnumConstants();\n    Validate.noNullElements(values);\n    ArrayUtils.reverse(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final E constant : enumClass.getEnumConstants()) {\n        if ((values[constant.ordinal() / Long.SIZE] & (1L << (constant.ordinal() % Long.SIZE))) != 0) {\n            result.add(constant);\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    checkBitVectorable(enumClass).getEnumConstants();\n    Validate.noNullElements(values);\n    ArrayUtils.reverse(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((values[i] & (1L << j)) != 0) {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    checkBitVectorable(enumClass).getEnumConstants();\n    Validate.notNull(values, \"values\");\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = values.length - 1; i >= 0; i--) {\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((values[i] & (1L << j)) != 0) {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    checkBitVectorable(enumClass).getEnumConstants();\n    Validate.noNullElements(values);\n    ArrayUtils.reverse(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((values[i] & (1L << j)) != 0) {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    ArrayUtils.reverse(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((values[i] & (1 << j)) != 0) {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    ArrayUtils.reverse(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final E constant : enumClass.getEnumConstants()) {\n        if ((values[constant.ordinal() / Long.SIZE] & (1 << (constant.ordinal() % Long.SIZE))) != 0) {\n            result.add(constant);\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = values.length - 1; i >= 0; i--) {\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((values[i] & (1 << j)) != 0) {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    ArrayUtils.reverse(values);\n    for (final E value : enumClass.getEnumConstants()) {\n        if ((values[value.ordinal() / Long.SIZE] & (1L << (value.ordinal() % Long.SIZE))) != 0) {\n            result.add(value);\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    checkBitVectorable(enumClass).getEnumConstants();\n    Validate.notNull(values);\n    ArrayUtils.reverse(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final E value : enumClass.getEnumConstants()) {\n        if ((values[value.ordinal() / Long.SIZE] & (1L << (value.ordinal() % Long.SIZE))) != 0) {\n            result.add(value);\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values, \"values\");\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = values.length; i-- > 0; ) {\n        for (int j = Long.SIZE; j-- > 0; ) {\n            if ((values[i] & (1L << j)) != 0) {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}"
    ],
    [
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    long localInstant = convertUTCToLocal(oldInstant);\n    long newLocalInstant = newZone.convertUTCToLocal(oldInstant);\n    return newZone.convertLocalToUTC(newLocalInstant, false);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    // Convert to local millis in this zone\n    long localMillis = convertUTCToLocal(oldInstant);\n    // Convert back to UTC millis in the new zone\n    return newZone.convertLocalToUTC(localMillis, false);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    long localMillis = convertUTCToLocal(oldInstant);\n    long newMillis = newZone.convertLocalToUTC(localMillis, false);\n    return newMillis;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    long localInstant = convertUTCToLocal(oldInstant);\n    long newInstant = newZone.convertLocalToUTC(localInstant, false);\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    return newZone.convertUTCToLocal(convertLocalToUTC(oldInstant, true));\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = DateTimeZone.getDefault();\n    }\n    // convert to local millis\n    long localMillis = convertUTCToLocal(oldInstant);\n    // convert back to UTC millis\n    return newZone.convertLocalToUTC(localMillis, false);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    // convert oldInstant to local millis\n    long localMillis = convertUTCToLocal(oldInstant);\n    // convert local millis to new zone millis\n    return convertLocalToUTC(localMillis, true, newZone);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    // Convert to local millis\n    long localMillis = convertUTCToLocal(oldInstant);\n    // Convert back to UTC millis\n    return newZone.convertLocalToUTC(localMillis, false);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    // convert to local millis\n    long localMillis = convertUTCToLocal(oldInstant);\n    // convert back to UTC millis\n    return convertLocalToUTC(localMillis, false, newZone.convertUTCToLocal(oldInstant));\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    // convert oldInstant to local millis in this zone\n    long localMillis = convertUTCToLocal(oldInstant);\n    // convert local millis to UTC millis in new zone\n    return convertLocalToUTC(localMillis, false, newZone == null ? DateTimeZone.getDefault() : newZone);\n}"
    ],
    [
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    // TODO: implement this method\n    return null;\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    // TODO: implement this method\n    return null;\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int years = calendar.get(Calendar.YEAR);\n    int months = calendar.get(Calendar.MONTH);\n    int days = calendar.get(Calendar.DATE);\n    int hours = calendar.get(Calendar.HOUR_OF_DAY);\n    int minutes = calendar.get(Calendar.MINUTE);\n    int seconds = calendar.get(Calendar.SECOND);\n    if (unit.equals(DateTickUnitType.SECOND)) {\n        if (this.tickMarkPosition == DateTickMarkPosition.START) {\n            seconds = 0;\n        }\n        else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {\n            seconds = 30;\n        }\n        else {\n            seconds = 59;\n        }\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, months, days, hours, minutes, seconds);\n        Date d1 = calendar.getTime();\n        if (d1.getTime() >= date.getTime()) {\n            calendar.set(Calendar.SECOND, seconds - 1);\n            d1 = calendar.getTime();\n        }\n        return d1;\n    }\n    else if (unit.equals(DateTickUnitType.MINUTE)) {\n        if (this.tickMarkPosition == DateTickMarkPosition.START) {\n            seconds = 0;\n        }\n        else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {\n            seconds = 30;\n        }\n        else {\n            seconds = 59;\n        }\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, months, days, hours, minutes, seconds);\n        Date d2 = calendar.getTime();\n        if (d2.getTime() >= date.getTime()) {\n            calendar.set(Calendar.MINUTE, minutes - 1);\n            d2 = calendar.getTime();\n        }\n        return d2;\n    }\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    // TODO: implement this method\n    return null;\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int years = calendar.get(Calendar.YEAR);\n    int months = calendar.get(Calendar.MONTH);\n    int days = calendar.get(Calendar.DATE);\n    int hours = calendar.get(Calendar.HOUR_OF_DAY);\n    int minutes = calendar.get(Calendar.MINUTE);\n    int seconds = calendar.get(Calendar.SECOND);\n    if (unit.equals(DateTickUnitType.SECOND)) {\n        if (this.tickMarkPosition == DateTickMarkPosition.START) {\n            seconds = 0;\n        }\n        else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {\n            seconds = 30;\n        }\n        else {\n            seconds = 59;\n        }\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, months, days, hours, minutes, seconds);\n        Date d1 = calendar.getTime();\n        if (d1.getTime() >= date.getTime()) {\n            calendar.set(Calendar.SECOND, seconds - 1);\n            d1 = calendar.getTime();\n        }\n        return d1;\n    }\n    else if (unit.equals(DateTickUnitType.MINUTE)) {\n        if (this.tickMarkPosition == DateTickMarkPosition.START) {\n            minutes = 0;\n        }\n        else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {\n            minutes = 30;\n        }\n        else {\n            minutes = 59;\n        }\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, months, days, hours, minutes, 0);\n        Date d2 = calendar.getTime();\n        if (d2.getTime() >= date.getTime()) {\n            calendar.set(Calendar.MINUTE, minutes - 1);\n            d2 = calendar.getTime();\n        }\n        return d2;\n    }\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int years = calendar.get(Calendar.YEAR);\n    int months = calendar.get(Calendar.MONTH);\n    int days = calendar.get(Calendar.DATE);\n    int hours = calendar.get(Calendar.HOUR_OF_DAY);\n    int minutes = calendar.get(Calendar.MINUTE);\n    int seconds = calendar.get(Calendar.SECOND);\n    if (unit.equals(DateTickUnitType.SECOND)) {\n        if (this.tickMarkPosition == DateTickMarkPosition.START) {\n            seconds = 0;\n        }\n        else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {\n            seconds = 30;\n        }\n        else {\n            seconds = 59;\n        }\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, months, days, hours, minutes, seconds);\n        Date d = calendar.getTime();\n        if (d.getTime() >= date.getTime()) {\n            calendar.set(Calendar.SECOND, seconds - 1);\n            d = calendar.getTime();\n        }\n        return d;\n    }\n    else if (unit.equals(DateTickUnitType.MINUTE)) {\n        if (this.tickMarkPosition == DateTickMarkPosition.START) {\n            seconds = 0;\n        }\n        else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {\n            seconds = 30;\n        }\n        else {\n            seconds = 59;\n        }\n        minutes = calendar.get(Calendar.MINUTE);\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, months, days, hours, minutes, seconds);\n        Date d1 = calendar.getTime();\n        if (d1.getTime() >= date.getTime()) {\n            calendar.set(Calendar.MINUTE, minutes - 1);\n            d1 = calendar.getTime();\n        }\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int years = calendar.get(Calendar.YEAR);\n    int months = calendar.get(Calendar.MONTH);\n    int days = calendar.get(Calendar.DATE);\n    int hours = calendar.get(Calendar.HOUR_OF_DAY);\n    int minutes = calendar.get(Calendar.MINUTE);\n    int seconds = calendar.get(Calendar.SECOND);\n    if (unit.equals(DateTickUnitType.SECOND)) {\n        if (this.tickMarkPosition == DateTickMarkPosition.START) {\n            seconds = 0;\n        }\n        else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {\n            seconds = 30;\n        }\n        else {\n            seconds = 59;\n        }\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, months, days, hours, minutes, seconds);\n        Date d = calendar.getTime();\n        if (d.getTime() >= date.getTime()) {\n            calendar.set(Calendar.SECOND, seconds - 1);\n            d = calendar.getTime();\n        }\n        return d;\n    }\n    else if (unit.equals(DateTickUnitType.MINUTE)) {\n        if (this.tickMarkPosition == DateTickMarkPosition.START) {\n            seconds = 0;\n        }\n        else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {\n            seconds = 30;\n        }\n        else {\n            seconds = 59;\n        }\n        minutes = 0;\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, months, days, hours, minutes, seconds);\n        Date d = calendar.getTime();\n        if (d.getTime() >= date.getTime()) {\n            calendar.set(Calendar.MINUTE, minutes - 1);\n            d = calendar.getTime();\n        }\n        return d;\n    }\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    // TODO: implement this method\n    return null;\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int years = calendar.get(Calendar.YEAR);\n    int months = calendar.get(Calendar.MONTH);\n    int days = calendar.get(Calendar.DATE);\n    int hours = calendar.get(Calendar.HOUR_OF_DAY);\n    int minutes = calendar.get(Calendar.MINUTE);\n    int seconds = calendar.get(Calendar.SECOND);\n    if (unit.equals(DateTickUnitType.SECOND)) {\n        if (this.tickMarkPosition == DateTickMarkPosition.START) {\n            seconds = 0;\n        }\n        else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {\n            seconds = 30;\n        }\n        else {\n            seconds = 59;\n        }\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, months, days, hours, minutes, seconds);\n        Date d1 = calendar.getTime();\n        if (d1.getTime() >= date.getTime()) {\n            calendar.set(Calendar.SECOND, seconds - 1);\n            d1 = calendar.getTime();\n        }\n        return d1;\n    }\n    else if (unit.equals(DateTickUnitType.MINUTE)) {\n        if (this.tickMarkPosition == DateTickMarkPosition.START) {\n            seconds = 0;\n        }\n        else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {\n            seconds = 30;\n        }\n        else {\n            seconds = 59;\n        }\n        minutes = 0;\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, months, days, hours, minutes, seconds);\n        Date d2 = calendar.getTime();\n        if (d2.getTime() >= date.getTime()) {\n            calendar.set(Calendar.MINUTE, minutes - 1);\n            d2 = calendar.getTime();\n        }\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int years = calendar.get(Calendar.YEAR);\n    int months = calendar.get(Calendar.MONTH);\n    int days = calendar.get(Calendar.DATE);\n    int hours = calendar.get(Calendar.HOUR_OF_DAY);\n    int minutes = calendar.get(Calendar.MINUTE);\n    int seconds = calendar.get(Calendar.SECOND);\n    int millis = calendar.get(Calendar.MILLISECOND);\n    calendar.clear(Calendar.MILLISECOND);\n    if (unit.equals(DateTickUnitType.SECOND)) {\n        if (this.tickMarkPosition == DateTickMarkPosition.START) {\n            calendar.set(years, months, days, hours, minutes, seconds);\n            Date d = calendar.getTime();\n            if (d.getTime() >= date.getTime()) {\n                calendar.set(Calendar.SECOND, seconds - 1);\n                d = calendar.getTime();\n            }\n            return d;\n        }\n        else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {\n            calendar.set(years, months, days, hours, minutes, seconds);\n            Date d = calendar.getTime();\n            if (d.getTime() >= date.getTime()) {\n                calendar.set(Calendar.SECOND, seconds - 1);\n                d = calendar.getTime();\n            }\n            return d;\n        }\n        else {\n            calendar.set(years, months, days, hours, minutes, seconds);\n            Date d = calendar.getTime();\n            if (d.getTime() >= date.getTime()) {\n                calendar.set(Calendar.SECOND, seconds - 1);\n                d = calendar.getTime();\n            }\n            return d;\n        }\n    }\n    else if (unit.equals(DateTickUnitType.MINUTE)) {\n        if (this.tickMarkPosition == DateTickMarkPosition.START) {\n}\n}\n}"
    ],
    [
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableResolver == null) {\n        return null;\n    }\n    final Object value = variableResolver.resolveVariable(variableName);\n    if (value == null) {\n        return null;\n    }\n    return value.toString();\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final VariableResolver resolver = getVariableResolver();\n    if (resolver == null) {\n        return null;\n    }\n    final String value = resolver.resolveVariable(variableName);\n    if (value == null) {\n        return null;\n    }\n    if (isEnableSubstitutionInVariables()) {\n        final StrBuilder bufValue = new StrBuilder(value);\n        substitute(bufValue, 0, bufValue.length());\n        return bufValue.toString();\n    }\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n        final VariableResolver<String> resolver = getVariableResolver();\n        if (resolver != null) {\n            final String value = resolver.resolveVariable(variableName);\n            if (value != null) {\n                return value;\n            }\n        }\n        return null;\n    }",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n        final VariableResolver<Object> resolver = getVariableResolver();\n        if (resolver == null) {\n            return null;\n        }\n        final Object value = resolver.resolveVariable(variableName);\n        if (value == null) {\n            return null;\n        }\n        if (isEnableSubstitutionInVariables()) {\n            final StrBuilder bufValue = new StrBuilder(value.toString());\n            substitute(bufValue, 0, bufValue.length());\n            return bufValue.toString();\n        }\n        return value.toString();\n    }",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final VariableResolver<Object> resolver = getVariableResolver();\n    if (resolver == null) {\n        return null;\n    }\n    final Object value = resolver.resolveVariable(variableName);\n    if (value == null) {\n        return null;\n    }\n    if (value instanceof String) {\n        return (String) value;\n    }\n    return value.toString();\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    return getVariableResolver().resolveVariable(variableName);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n        if (getVariableResolver() != null) {\n            final String value = getVariableResolver().resolveVariable(variableName);\n            if (value != null) {\n                return value;\n            }\n        }\n        return null;\n    }",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    return getVariableResolver().resolveVariable(variableName);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final StrBuilder bufName = new StrBuilder(variableName);\n    substitute(bufName, 0, bufName.length());\n    variableName = bufName.toString();\n    if (getVariableResolver() != null) {\n        final String value = getVariableResolver().resolveVariable(variableName);\n        if (value != null) {\n            return value;\n        }\n    }\n    if (isStrict()) {\n        throw new IllegalStateException(\"Cannot resolve variable \" + variableName);\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    return getVariableResolver().resolveVariable(variableName);\n}"
    ],
    [
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = str.trim();\n    if (str.length() == 0) {\n        return str;\n    }\n    str = str.toUpperCase();\n    char[] code = new char[4];\n    code[0] = this.map(str.charAt(0));\n    for (int i = 0, j = 1; i < str.length() && j < code.length; i++) {\n        char ch = str.charAt(i);\n        if (ch != 'H' && ch != 'W' && ch != 'X') {\n            if (code[j] != this.map(ch)) {\n                code[j] = this.map(ch);\n                j++;\n            }\n        }\n    }\n    return new String(code, 0, j);\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = str.trim();\n    if (str.length() == 0) {\n        return str;\n    }\n    final StringBuilder sb = new StringBuilder();\n    char ch = Character.toUpperCase(str.charAt(0));\n    sb.append(map(ch));\n    for (int i = 1; i < str.length(); i++) {\n        ch = Character.toUpperCase(str.charAt(i));\n        if (ch != 'H' && ch != 'W' && ch != 'Y') {\n            final char soundex = map(ch);\n            if (soundex != sb.charAt(sb.length() - 1)) {\n                sb.append(soundex);\n            }\n        }\n    }\n    sb.setLength(Math.min(sb.length(), getMaxLength()));\n    return sb.toString();\n}",
      "public String soundex(String str)  {\n    // Check for null input\n    if (str == null) {\n        return null;\n    }\n\n    // Strip all non-alpha characters from the input string\n    str = str.replaceAll(\"[^A-Za-z]\", \"\");\n\n    // Initialize the soundex string\n    String soundex = \"\";\n\n    // Get the first character of the string\n    char ch = str.charAt(0);\n\n    // Map the first character to its Soundex code\n    char soundexCode = map(ch);\n\n    // Check for a non-mapped character\n    if (soundexCode == 0) {\n        return null;\n    }\n\n    // Add the initial character's Soundex code to the soundex string\n    soundex += String.valueOf(soundexCode);\n\n    // Iterate over the remaining characters in the string\n    for (int i = 1; i < str.length(); i++) {\n        // Get the current character\n        ch = str.charAt(i);\n\n        // Map the current character to its Soundex code\n        soundexCode = map(ch);\n\n        // Check for a non-mapped character\n        if (soundexCode == 0) {\n            continue;\n        }\n\n        // Check for a duplicate character\n        if (i > 1 && soundexCode == soundex.charAt(i - 1)) {\n            continue;\n        }\n\n        // Add the current character's Soundex code to the soundex string\n        soundex += String.valueOf(soundexCode);\n    }\n\n    // Return the soundex string\n    return soundex.substring(0, Math.min(soundex.length(), this.getMaxLength()));\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = str.trim();\n    if (str.length() == 0) {\n        return str;\n    }\n    // Mapping\n    char[] soundexMapping = getSoundexMapping();\n    // Encoding\n    char[] result = new char[str.length()];\n    int size = 0;\n    char previous = '0';\n    for (int i = 0; i < str.length(); i++) {\n        char ch = Character.toUpperCase(str.charAt(i));\n        if (ch == 'H' || ch == 'W' || ch == 'X') {\n            if (previous != 'H') {\n                result[size++] = ch;\n                previous = ch;\n            }\n        } else if (ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U' || ch == 'Y') {\n            if (previous != ch) {\n                result[size++] = ch;\n                previous = ch;\n            }\n        } else {\n            char soundex = map(ch);\n            if (soundex != previous) {\n                result[size++] = soundex;\n                previous = soundex;\n            }\n        }\n    }\n    // Truncate\n    if (size == 0) {\n        return str.substring(0, 1);\n    }\n    if (size == 1) {\n        return str.substring(0, 1) + result[0];\n    }\n    if (size > getMaxLength()) {\n        size = getMaxLength();\n    }\n    return str.substring(0, 1) + new String(result, 0, size);\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = str.trim();\n    if (str.length() == 0) {\n        return str;\n    }\n    str = str.toUpperCase();\n    final StringBuilder buffer = new StringBuilder(str.substring(0, 1));\n    char prev = '0';\n    for (int i = 0; i < str.length(); i++) {\n        final char ch = this.map(str.charAt(i));\n        if (ch != '0' && ch != prev) {\n            buffer.append(ch);\n            if (buffer.length() == this.getMaxLength()) {\n                break;\n            }\n        }\n        prev = ch;\n    }\n    while (buffer.length() < this.getMaxLength()) {\n        buffer.append('0');\n    }\n    return buffer.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = str.trim();\n    if (str.length() == 0) {\n        return \"\";\n    }\n    str = str.toUpperCase();\n    final char[] s = new char[4];\n    s[0] = this.map(str.charAt(0));\n    s[1] = '0';\n    s[2] = '0';\n    s[3] = '0';\n    int i = 1;\n    int previous = 0;\n    for (int j = 1; j < str.length(); j++) {\n        final char c = this.map(str.charAt(j));\n        if (c != '0') {\n            if (previous == 0 || previous != c) {\n                s[i++] = c;\n                previous = c;\n            }\n        }\n    }\n    return new String(s, 0, Math.min(i, 4));\n}",
      "public String soundex(String str)  {\n    // Initialize the soundex code\n    String soundexCode = \"\";\n\n    // Check if the string is empty\n    if (str.length() == 0) {\n        return soundexCode;\n    }\n\n    // Convert the first character to uppercase\n    char firstChar = Character.toUpperCase(str.charAt(0));\n\n    // Get the soundex code for the first character\n    char soundexChar = map(firstChar);\n\n    // Add the first character's soundex code to the soundex code\n    soundexCode += soundexChar;\n\n    // Loop through each character in the string\n    for (int i = 1; i < str.length(); i++) {\n        // Get the current character\n        char currentChar = str.charAt(i);\n\n        // Convert the current character to uppercase\n        currentChar = Character.toUpperCase(currentChar);\n\n        // Get the soundex code for the current character\n        char currentSoundexChar = map(currentChar);\n\n        // Check if the current character's soundex code is the same as the first character's\n        if (currentSoundexChar != soundexChar) {\n            // Add the current character's soundex code to the soundex code\n            soundexCode += currentSoundexChar;\n        }\n    }\n\n    // Return the soundex code\n    return soundexCode;\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = str.trim();\n    if (str.length() == 0) {\n        return \"\";\n    }\n    final char[] sarr = str.toUpperCase().toCharArray();\n    final StringBuilder sb = new StringBuilder();\n    char prev = '0';\n    for (int i = 0; i < sarr.length; i++) {\n        final char ch = map(sarr[i]);\n        if (ch != '0') {\n            if (ch != prev) {\n                sb.append(ch);\n            }\n            prev = ch;\n        }\n    }\n    final String result = sb.toString();\n    if (result.length() > this.getMaxLength()) {\n        return result.substring(0, this.getMaxLength());\n    }\n    return result;\n}",
      "public String soundex(String str)  {\n    // Initialize the soundex string\n    String soundex = \"\";\n\n    // Check if the string is empty\n    if (str.isEmpty()) {\n        return soundex;\n    }\n\n    // Convert the first character to uppercase\n    char firstChar = Character.toUpperCase(str.charAt(0));\n\n    // Get the mapping for the first character\n    char mapping = map(firstChar);\n\n    // Add the mapping for the first character to the soundex string\n    soundex += mapping;\n\n    // Iterate over the remaining characters\n    for (int i = 1; i < str.length(); i++) {\n        // Get the current character\n        char currentChar = str.charAt(i);\n\n        // Convert the current character to uppercase\n        currentChar = Character.toUpperCase(currentChar);\n\n        // Get the mapping for the current character\n        char currentMapping = map(currentChar);\n\n        // Check if the current mapping is the same as the previous mapping\n        if (currentMapping == mapping) {\n            continue;\n        }\n\n        // Add the current mapping to the soundex string\n        soundex += currentMapping;\n\n        // Set the mapping to the current mapping\n        mapping = currentMapping;\n    }\n\n    // Return the soundex string\n    return soundex;\n}",
      "public String soundex(String str)  {\n    // TODO: Implement the soundex algorithm\n    // Hint: You may find it useful to create a mapping of characters to their corresponding Soundex codes\n    //       using the getSoundexMapping() method.\n    //       You may also find it useful to use the map() method to map characters to their corresponding Soundex codes.\n    //       The standard Soundex code should have a length of 4 characters.\n    //       You may need to truncate the soundex code if it is longer than 4 characters.\n    //       You should uppercase the first character of the soundex code.\n    //       You should pad the soundex code with '0' characters if it is shorter than 4 characters.\n    //       You should return a String object containing the soundex code.\n    return null;\n}"
    ],
    [
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == Integer.class || clz == int.class) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == Boolean.class || clz == boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    }\n    if (clz == Long.class || clz == long.class) {\n        return CORE_TYPE_LONG;\n    }\n    if (clz == Double.class || clz == double.class) {\n        return CORE_TYPE_DOUBLE;\n    }\n    if (clz == Float.class || clz == float.class) {\n        return CORE_TYPE_FLOAT;\n    }\n    if (clz == Short.class || clz == short.class) {\n        return CORE_TYPE_SHORT;\n    }\n    if (clz == Byte.class || clz == byte.class) {\n        return CORE_TYPE_BYTE;\n    }\n    if (clz == Character.class || clz == char.class) {\n        return CORE_TYPE_CHAR;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // 15-Sep-2015, tatu: Let's see if we can do better here...\n    if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == int.class || clz == Integer.class) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == long.class || clz == Long.class) {\n        return CORE_TYPE_LONG;\n    }\n    if (clz == boolean.class || clz == Boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    }\n    if (clz == float.class || clz == Float.class) {\n        return CORE_TYPE_FLOAT;\n    }\n    if (clz == double.class || clz == Double.class) {\n        return CORE_TYPE_DOUBLE;\n    }\n    if (clz == byte.class || clz == Byte.class) {\n        return CORE_TYPE_BYTE;\n    }\n    if (clz == short.class || clz == Short.class) {\n        return CORE_TYPE_SHORT;\n    }\n    if (clz == char.class || clz == Character.class) {\n        return CORE_TYPE_CHAR;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == Integer.class || clz == int.class) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == Long.class || clz == long.class) {\n        return CORE_TYPE_LONG;\n    }\n    if (clz == Boolean.class || clz == boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    }\n    if (clz == Double.class || clz == double.class) {\n        return CORE_TYPE_DOUBLE;\n    }\n    if (clz == Float.class || clz == float.class) {\n        return CORE_TYPE_FLOAT;\n    }\n    if (clz == Short.class || clz == short.class) {\n        return CORE_TYPE_SHORT;\n    }\n    if (clz == Byte.class || clz == byte.class) {\n        return CORE_TYPE_BYTE;\n    }\n    if (clz == Character.class || clz == char.class) {\n        return CORE_TYPE_CHAR;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == Integer.class || clz == int.class) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == Boolean.class || clz == boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    }\n    if (clz == Long.class || clz == long.class) {\n        return CORE_TYPE_LONG;\n    }\n    if (clz == Double.class || clz == double.class) {\n        return CORE_TYPE_DOUBLE;\n    }\n    if (clz == Float.class || clz == float.class) {\n        return CORE_TYPE_FLOAT;\n    }\n    if (clz == Short.class || clz == short.class) {\n        return CORE_TYPE_SHORT;\n    }\n    if (clz == Byte.class || clz == byte.class) {\n        return CORE_TYPE_BYTE;\n    }\n    if (clz == Character.class || clz == char.class) {\n        return CORE_TYPE_CHAR;\n    }\n    if (clz == Void.class || clz == void.class) {\n        return CORE_TYPE_VOID;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // 15-Sep-2015, tatu: Prior to 2.7, we did not have any \"well-known\" types\n    //    so this method was essentially no-op. With 2.7, we have a few\n    //    and we can use them to optimize things a bit\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == Integer.class || clz == int.class) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == Long.class || clz == long.class) {\n        return CORE_TYPE_LONG;\n    }\n    if (clz == Boolean.class || clz == boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    }\n    if (clz == Double.class || clz == double.class) {\n        return CORE_TYPE_DOUBLE;\n    }\n    if (clz == Float.class || clz == float.class) {\n        return CORE_TYPE_FLOAT;\n    }\n    if (clz == Short.class || clz == short.class) {\n        return CORE_TYPE_SHORT;\n    }\n    if (clz == Byte.class || clz == byte.class) {\n        return CORE_TYPE_BYTE;\n    }\n    if (clz == Character.class || clz == char.class) {\n        return CORE_TYPE_CHAR;\n    }\n    if (clz == Void.class || clz == void.class) {\n        return CORE_TYPE_VOID;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // First: primitive types\n    if (clz.isPrimitive()) {\n        if (clz == Integer.TYPE) {\n            return CORE_TYPE_INT;\n        }\n        if (clz == Boolean.TYPE) {\n            return CORE_TYPE_BOOLEAN;\n        }\n        if (clz == Long.TYPE) {\n            return CORE_TYPE_LONG;\n        }\n        if (clz == Double.TYPE) {\n            return CORE_TYPE_DOUBLE;\n        }\n        if (clz == Float.TYPE) {\n            return CORE_TYPE_FLOAT;\n        }\n        if (clz == Short.TYPE) {\n            return CORE_TYPE_SHORT;\n        }\n        if (clz == Byte.TYPE) {\n            return CORE_TYPE_BYTE;\n        }\n        if (clz == Character.TYPE) {\n            return CORE_TYPE_CHAR;\n        }\n    }\n    // Second: well-known core types\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == Void.class) {\n        return CORE_TYPE_VOID;\n    }\n    if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    }\n    // Third: well-known collection types\n    if (clz == List.class) {\n        return CORE_TYPE_JAVA_UTIL_LIST;\n    }\n    if (clz == Set.class) {\n        return CORE_TYPE_JAVA_UTIL_SET;\n    }\n    if (clz == Map.class) {\n        return CORE_TYPE_JAVA_UTIL_MAP;\n    }\n    if (clz == Collection.class) {\n        return CORE_TYPE_JAVA_UTIL_COLLECTION;\n    }\n    if (clz == Iterator.class) {\n        return CORE_TYPE_JAVA_UTIL_ITERATOR;\n    }\n    if (clz == Iterable.class) {\n}\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == int.class) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == long.class) {\n        return CORE_TYPE_LONG;\n    }\n    if (clz == double.class) {\n        return CORE_TYPE_DOUBLE;\n    }\n    if (clz == float.class) {\n        return CORE_TYPE_FLOAT;\n    }\n    if (clz == boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    }\n    if (clz == byte.class) {\n        return CORE_TYPE_BYTE;\n    }\n    if (clz == short.class) {\n        return CORE_TYPE_SHORT;\n    }\n    if (clz == char.class) {\n        return CORE_TYPE_CHAR;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == Integer.class) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    }\n    if (clz == Boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    }\n    if (clz == Double.class) {\n        return CORE_TYPE_DOUBLE;\n    }\n    if (clz == Float.class) {\n        return CORE_TYPE_FLOAT;\n    }\n    if (clz == Byte.class) {\n        return CORE_TYPE_BYTE;\n    }\n    if (clz == Short.class) {\n        return CORE_TYPE_SHORT;\n    }\n    if (clz == Character.class) {\n        return CORE_TYPE_CHAR;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == Integer.class) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    }\n    if (clz == Boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    }\n    if (clz == Double.class) {\n        return CORE_TYPE_DOUBLE;\n    }\n    if (clz == Float.class) {\n        return CORE_TYPE_FLOAT;\n    }\n    if (clz == Short.class) {\n        return CORE_TYPE_SHORT;\n    }\n    if (clz == Byte.class) {\n        return CORE_TYPE_BYTE;\n    }\n    if (clz == Character.class) {\n        return CORE_TYPE_CHAR;\n    }\n    if (clz == Void.class) {\n        return CORE_TYPE_VOID;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == Integer.class || clz == int.class) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == Boolean.class || clz == boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    }\n    if (clz == Long.class || clz == long.class) {\n        return CORE_TYPE_LONG;\n    }\n    if (clz == Double.class || clz == double.class) {\n        return CORE_TYPE_DOUBLE;\n    }\n    if (clz == Float.class || clz == float.class) {\n        return CORE_TYPE_FLOAT;\n    }\n    if (clz == Short.class || clz == short.class) {\n        return CORE_TYPE_SHORT;\n    }\n    if (clz == Byte.class || clz == byte.class) {\n        return CORE_TYPE_BYTE;\n    }\n    if (clz == Character.class || clz == char.class) {\n        return CORE_TYPE_CHAR;\n    }\n    if (clz == Void.class || clz == void.class) {\n        return CORE_TYPE_VOID;\n    }\n    if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    }\n    return null;\n}"
    ],
    [
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (NodeUtil.isGet(n) && n.getFirstChild().isQualifiedName())\n  {\n    Node lhs = n.getFirstChild();\n    Node rhs = n.getLastChild();\n\n    if (NodeUtil.isPrototypeProperty(lhs))\n    {\n      return new PrototypeMemberDeclaration(lhs, rhs);\n    }\n  }\n\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.isGetProp() && NodeUtil.isPrototypeProperty(n)) {\n    return new PrototypeMemberDeclaration(n.getFirstChild(), n);\n  }\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isGetProp() && n.getLastChild().getString().equals(\"prototype\")) \n    {\n        return new PrototypeMemberDeclaration(n.getFirstChild(), n);\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.isGetProp() && n.getLastChild().getString().equals(\"prototype\")) {\n    Node lhs = n.getFirstChild();\n    if (lhs.isQualifiedName()) {\n      return new PrototypeMemberDeclaration(lhs, n);\n    }\n  }\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isGetProp() && NodeUtil.isPrototypeProperty(n)) \n    {\n        return new PrototypeMemberDeclaration(n.getFirstChild(), n);\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.isGetProp() && n.getFirstChild().isThis()) \n  {\n    Node lhs = n.getFirstChild();\n    Node rhs = n.getLastChild();\n    if (rhs.isFunction()) \n    {\n      return new PrototypeMemberDeclaration(lhs, rhs);\n    }\n  }\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (NodeUtil.isGet(n) && n.getFirstChild().isQualifiedName())\n    {\n        Node lhs = n.getFirstChild();\n        Node rhs = n.getLastChild();\n        if (rhs.isFunction() && NodeUtil.isPrototypeProperty(lhs))\n        {\n            return new PrototypeMemberDeclaration(lhs, rhs);\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (NodeUtil.isGet(n) && n.getFirstChild().isQualifiedName()) \n  {\n    Node lhs = n.getFirstChild();\n    Node rhs = n.getLastChild();\n    if (rhs.isFunction()) \n    {\n      return new PrototypeMemberDeclaration(lhs, rhs);\n    }\n  }\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.isGetProp()) \n  {\n    Node lhs = n.getFirstChild();\n    if (lhs.isGetProp()) \n    {\n      return new PrototypeMemberDeclaration(lhs, n);\n    }\n  }\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.isGetProp()) {\n    Node lhs = n.getFirstChild();\n    if (lhs.isGetProp() && lhs.getLastChild().getString().equals(\"prototype\")) {\n      return new PrototypeMemberDeclaration(lhs, n);\n    }\n  }\n  return null;\n}"
    ],
    [
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[n * mat.getRowDimension()][m * mat.getColumnDimension()];\n    for (int r = 0; r < n; r++) {\n        for (int c = 0; c < m; c++) {\n            for (int i = 0; i < mat.getRowDimension(); i++) {\n                for (int j = 0; j < mat.getColumnDimension(); j++) {\n                    d[r * mat.getRowDimension() + i][c * mat.getColumnDimension() + j] = mat.getEntry(i, j);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    // TODO: Implement this method\n    return null;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    int rows = mat.getRowDimension();\n    int cols = mat.getColumnDimension();\n    int newRows = rows * n;\n    int newCols = cols * m;\n    double[][] newData = new double[newRows][newCols];\n    for (int i = 0; i < newRows; i++) {\n        for (int j = 0; j < newCols; j++) {\n            int row = i % rows;\n            int col = j % cols;\n            newData[i][j] = mat.getEntry(row, col);\n        }\n    }\n    return new Array2DRowRealMatrix(newData, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    // TODO: Implement the repmat function.\n    // Hint: Use the ones, zeros, and eye functions to create the necessary matrices.\n    // Hint: Use the multiply function to combine the matrices.\n    // Hint: Use the sumRows function to add the rows of the matrices.\n    // Hint: Use the diag function to create a diagonal matrix.\n    // Hint: Use the copyColumn function to copy a column from one matrix to another.\n    // Hint: Use the sumRows function to add the rows of the matrices.\n    // Hint: Use the sumRows function to add the rows of the matrices.\n    // Hint: Use the sumRows function to add the rows of the matrices.\n    // Hint: Use the sumRows function to add the rows of the matrices.\n    // Hint: Use the sumRows function to add the rows of the matrices.\n    // Hint: Use the sumRows function to add the rows of the matrices.\n    // Hint: Use the sumRows function to add the rows of the matrices.\n    // Hint: Use the sumRows function to add the rows of the matrices.\n    // Hint: Use the sumRows function to add the rows of the matrices.\n    // Hint: Use the sumRows function to add the rows of the matrices.\n    // Hint: Use the sumRows function to add the rows of the matrices.\n    // Hint: Use the sumRows function to add the rows of the matrices.\n    // Hint: Use the sumRows function to add the rows of the matrices.\n    // Hint: Use the sumRows function to add the rows of the matrices.\n    // Hint: Use the sumRows function to add the rows of the matrices.\n    // Hint: Use the sumRows function to add the rows of the matrices.\n    // Hint: Use the sumRows function to add the rows of the matrices.\n    // Hint: Use the sumRows function to add the rows of the matrices.\n    // Hint: Use the sumRows function to add the rows of the matrices.\n    // Hint: Use the sumRows function to add the rows of the matrices.\n    // Hint: Use the sumRows function to add the rows of the matrices.\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    // TODO: Implement this method\n    // Hint: Use the appropriate methods from the RealMatrix class to perform the replication.\n    // Hint: You may need to use the getRowDimension() and getColumnDimension() methods to determine the size of the input matrix.\n    // Hint: You may need to use the getEntry() method to retrieve individual elements of the input matrix.\n    // Hint: You may need to use the setEntry() method to set individual elements of the output matrix.\n    // Hint: You may need to use the copy() method to create a copy of the input matrix.\n    // Hint: You may need to use the create() method to create a new matrix.\n    // Hint: You may need to use the add() method to add elements of the input matrix to the output matrix.\n    // Hint: You may need to use the multiply() method to multiply elements of the input matrix by a scalar.\n    // Hint: You may need to use the multiply() method to multiply elements of the input matrix by a scalar.\n    // Hint: You may need to use the transpose() method to transpose the input matrix.\n    // Hint: You may need to use the getColumnDimension() method to determine the number of columns in the input matrix.\n    // Hint: You may need to use the getRowDimension() method to determine the number of rows in the input matrix.\n    // Hint: You may need to use the getEntry() method to retrieve individual elements of the input matrix.\n    // Hint: You may need to use the setEntry() method to set individual elements of the output matrix.\n    // Hint: You may need to use the create() method to create a new matrix.\n    // Hint: You may need to use the add() method to add elements of the input matrix to the output matrix.\n    // Hint: You may need to use the multiply() method to multiply elements of the input matrix by a scalar.\n    // Hint: You may need to use the transpose() method to transpose the input matrix.\n    // Hint: You may need to use the getColumnDimension() method to determine the number of columns in the input matrix.\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    // Write your code here\n    return null;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    int rows = mat.getRowDimension() * n;\n    int cols = mat.getColumnDimension() * m;\n    RealMatrix out = zeros(rows, cols);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            copyColumn(mat, 0, out, i * mat.getColumnDimension() + j);\n        }\n    }\n    return out;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    int rows = mat.getRowDimension() * n;\n    int cols = mat.getColumnDimension() * m;\n    double[][] d = new double[rows][cols];\n    for (int r = 0; r < rows; r++) {\n        for (int c = 0; c < cols; c++) {\n            d[r][c] = mat.getEntry(r % mat.getRowDimension(), c % mat.getColumnDimension());\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[n * mat.getRowDimension()][m * mat.getColumnDimension()];\n    for (int r = 0; r < n; r++) {\n        for (int c = 0; c < m; c++) {\n            for (int i = 0; i < mat.getRowDimension(); i++) {\n                for (int j = 0; j < mat.getColumnDimension(); j++) {\n                    d[r * mat.getRowDimension() + i][c * mat.getColumnDimension() + j] = mat.getEntry(i, j);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    // TODO: Implement this method\n    // Hint: Use the ones() and kron() methods\n    return null;\n}"
    ],
    [
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}"
    ],
    [
      "private long getBytesInflated()  {\n    final long bytesRead = current.bytesReadFromStream;\n    final long bytesInflated = inf.getBytesWritten();\n    if (bytesInflated >= bytesRead) {\n        return bytesInflated;\n    }\n    final long bytesRemaining = current.entry.getCompressedSize() - bytesInflated;\n    if (bytesRemaining > Integer.MAX_VALUE) {\n        throw new IllegalStateException(\"Inflater consumed too many bytes: \" + bytesInflated\n                                        + \" vs. \" + bytesRead);\n    }\n    return bytesInflated + bytesRemaining;\n}",
      "private long getBytesInflated()  {\n    final long bytesRead = current.bytesReadFromStream;\n    final long bytesInflated = inf.getBytesRead();\n    if (bytesInflated <= bytesRead) {\n        return bytesInflated;\n    }\n    final long bytesReadUnsigned = bytesRead & 0xffffffffL;\n    final long bytesInflatedUnsigned = bytesInflated & 0xffffffffL;\n    final long diff = bytesInflatedUnsigned - bytesReadUnsigned;\n    if (diff < 0 || diff > 0xffffffffL) {\n        throw new RuntimeException(\"Inflater consumed too many bytes: \" + bytesInflated\n                                   + \" vs \" + bytesRead);\n    }\n    return bytesReadUnsigned + diff;\n}",
      "private long getBytesInflated()  {\n    final long bytesRead = current.bytesReadFromStream;\n    final long bytesInflated = inf.getBytesRead();\n    return bytesInflated < bytesRead ? bytesInflated : bytesRead;\n}",
      "private long getBytesInflated()  {\n    long bytesRead = current.bytesReadFromStream;\n    long bytesInflated = inf.getBytesRead();\n    if (bytesInflated > bytesRead) {\n        // this should never happen\n        throw new IllegalStateException(\"Inflater read more bytes than it should have\");\n    }\n    if (bytesInflated < bytesRead) {\n        // this can happen if the compressed size is incorrect\n        bytesInflated = bytesRead;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesRead();\n    long bytesRead = current.bytesReadFromStream;\n    if (bytesInflated > bytesRead) {\n        bytesInflated = bytesRead;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    final long bytesRead = current.bytesReadFromStream;\n    final long bytesInflated = inf.getBytesWritten();\n    if (bytesInflated >= bytesRead) {\n        return bytesInflated;\n    }\n    final long bytesRemaining = current.entry.getCompressedSize() - bytesInflated;\n    final long bytesReadFromStream = bytesRead - bytesInflated;\n    if (bytesReadFromStream > bytesRemaining) {\n        return bytesInflated + bytesRemaining;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    final long bytesRead = current.bytesReadFromStream;\n    final long bytesInflated = inf.getBytesRead();\n    if (bytesInflated < bytesRead) {\n        return bytesInflated;\n    }\n    return bytesRead;\n}",
      "private long getBytesInflated()  {\n    final long bytesRead = current.bytesReadFromStream;\n    final long bytesInflated = inf.getBytesWritten();\n    if (bytesInflated >= bytesRead) {\n        return bytesInflated;\n    }\n    final long bytesReadMinus = bytesRead - bytesInflated;\n    if (bytesReadMinus > Integer.MAX_VALUE) {\n        return bytesInflated;\n    }\n    return bytesInflated + bytesReadMinus;\n}",
      "private long getBytesInflated()  {\n    long bytesRead = current.bytesReadFromStream;\n    long bytesInflated = inf.getBytesWritten();\n    if (bytesInflated > bytesRead) {\n        // deflated data is larger than the compressed data,\n        // so assume the Inflater has consumed all the data\n        bytesInflated = bytesRead;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesWritten();\n    long bytesRead = current.bytesReadFromStream;\n    if (bytesInflated > bytesRead) {\n        bytesInflated = bytesRead;\n    }\n    return bytesInflated;\n}"
    ],
    [
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.sizeIsEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    }\n    else if (object instanceof Collection<?>) \n    {\n        return ((Collection<?>) object).isEmpty();\n    }\n    else if (object instanceof Map<?, ?>) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    else if (object instanceof Object[]) \n    {\n        return ((Object[]) object).length == 0;\n    }\n    else if (object instanceof Iterator<?>) \n    {\n        return !((Iterator<?>) object).hasNext();\n    }\n    else if (object instanceof Enumeration<?>) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    else \n    {\n        try \n        {\n            return Array.getLength(object) == 0;\n        }\n        catch (final IllegalArgumentException ex) \n        {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.sizeIsEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n        if (object == null) {\n            return true;\n        }\n        boolean isEmpty = false;\n        if (object instanceof Map<?,?>) {\n            isEmpty = ((Map<?, ?>) object).isEmpty();\n        } else if (object instanceof Collection<?>) {\n            isEmpty = ((Collection<?>) object).isEmpty();\n        } else if (object instanceof Iterable<?>) {\n            isEmpty = IterableUtils.sizeIsEmpty((Iterable<?>) object);\n        } else if (object instanceof Object[]) {\n            isEmpty = ((Object[]) object).length == 0;\n        } else if (object instanceof Iterator<?>) {\n            isEmpty = !((Iterator<?>) object).hasNext();\n        } else if (object instanceof Enumeration<?>) {\n            isEmpty = !((Enumeration<?>) object).hasMoreElements();\n        } else {\n            try {\n                isEmpty = Array.getLength(object) == 0;\n            } catch (final IllegalArgumentException ex) {\n                throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n            }\n        }\n        return isEmpty;\n    }",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.sizeIsEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.sizeIsEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    }\n    if (object instanceof Map<?,?>) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    else if (object instanceof Collection<?>) \n    {\n        return ((Collection<?>) object).isEmpty();\n    }\n    else if (object instanceof Iterable<?>) \n    {\n        return IterableUtils.sizeIsEmpty((Iterable<?>) object);\n    }\n    else if (object instanceof Object[]) \n    {\n        return ((Object[]) object).length == 0;\n    }\n    else if (object instanceof Iterator<?>) \n    {\n        return !((Iterator<?>) object).hasNext();\n    }\n    else if (object instanceof Enumeration<?>) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    else \n    {\n        try \n        {\n            return Array.getLength(object) == 0;\n        } \n        catch (final IllegalArgumentException ex) \n        {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n        if (object == null) {\n            return true;\n        }\n        boolean isEmpty = true;\n        if (object instanceof Map<?,?>) {\n            isEmpty = ((Map<?, ?>) object).isEmpty();\n        } else if (object instanceof Collection<?>) {\n            isEmpty = ((Collection<?>) object).isEmpty();\n        } else if (object instanceof Iterable<?>) {\n            isEmpty = IterableUtils.sizeIsEmpty((Iterable<?>) object);\n        } else if (object instanceof Object[]) {\n            isEmpty = ((Object[]) object).length == 0;\n        } else if (object instanceof Iterator<?>) {\n            isEmpty = !((Iterator<?>) object).hasNext();\n        } else if (object instanceof Enumeration<?>) {\n            isEmpty = !((Enumeration<?>) object).hasMoreElements();\n        } else {\n            try {\n                isEmpty = Array.getLength(object) == 0;\n            } catch (final IllegalArgumentException ex) {\n                throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n            }\n        }\n        return isEmpty;\n    }",
      "public static boolean sizeIsEmpty(final Object object)  {\n        if (object == null) {\n            return true;\n        }\n        boolean total = false;\n        if (object instanceof Map<?,?>) {\n            total = ((Map<?, ?>) object).isEmpty();\n        } else if (object instanceof Collection<?>) {\n            total = ((Collection<?>) object).isEmpty();\n        } else if (object instanceof Iterable<?>) {\n            total = IterableUtils.sizeIsEmpty((Iterable<?>) object);\n        } else if (object instanceof Object[]) {\n            total = ((Object[]) object).length == 0;\n        } else if (object instanceof Iterator<?>) {\n            total = !((Iterator<?>) object).hasNext();\n        } else if (object instanceof Enumeration<?>) {\n            final Enumeration<?> it = (Enumeration<?>) object;\n            total = !it.hasMoreElements();\n        } else {\n            try {\n                total = Array.getLength(object) == 0;\n            } catch (final IllegalArgumentException ex) {\n                throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n            }\n        }\n        return total;\n    }",
      "public static boolean sizeIsEmpty(final Object object)  {\n        if (object == null) {\n            return true;\n        }\n        if (object instanceof Collection<?>) {\n            return ((Collection<?>) object).isEmpty();\n        } else if (object instanceof Map<?,?>) {\n            return ((Map<?, ?>) object).isEmpty();\n        } else if (object instanceof Iterable<?>) {\n            return IterableUtils.sizeIsEmpty((Iterable<?>) object);\n        } else if (object instanceof Object[]) {\n            return ((Object[]) object).length == 0;\n        } else if (object instanceof Iterator<?>) {\n            return !((Iterator<?>) object).hasNext();\n        } else if (object instanceof Enumeration<?>) {\n            return !((Enumeration<?>) object).hasMoreElements();\n        } else {\n            try {\n                return Array.getLength(object) == 0;\n            } catch (final IllegalArgumentException ex) {\n                throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n            }\n        }\n    }"
    ],
    [
      "public static boolean isValidQualifiedName(String name)  {\n    if (!isValidSimpleName(name)) {\n      return false;\n    }\n    int dotIndex = name.indexOf('.');\n    while (dotIndex != -1) {\n      if (!isValidSimpleName(name.substring(dotIndex + 1))) {\n        return false;\n      }\n      dotIndex = name.indexOf('.', dotIndex + 1);\n    }\n    return true;\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    int lastDot = name.lastIndexOf('.');\n    if (lastDot == -1) {\n      return isValidSimpleName(name);\n    }\n\n    String firstPart = name.substring(0, lastDot);\n    String secondPart = name.substring(lastDot + 1);\n\n    return isValidQualifiedName(firstPart) &&\n        isValidSimpleName(secondPart);\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    if (name == null || name.length() == 0) {\n      return false;\n    }\n\n    int lastDot = name.lastIndexOf('.');\n    if (lastDot == -1) {\n      return isValidSimpleName(name);\n    }\n\n    if (lastDot == 0 || lastDot == name.length() - 1) {\n      return false;\n    }\n\n    String firstPart = name.substring(0, lastDot);\n    String secondPart = name.substring(lastDot + 1);\n\n    return isValidSimpleName(firstPart) && isValidSimpleName(secondPart);\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n  if (!isValidSimpleName(name)) {\n    return false;\n  }\n\n  int dotIndex = name.indexOf('.');\n  while (dotIndex != -1) {\n    String subName = name.substring(0, dotIndex);\n    if (!isValidSimpleName(subName)) {\n      return false;\n    }\n\n    dotIndex = name.indexOf('.', dotIndex + 1);\n  }\n\n  return true;\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  if (!isValidSimpleName(name)) {\n    return false;\n  }\n\n  int dotIndex = name.indexOf('.');\n  while (dotIndex != -1) {\n    String subName = name.substring(0, dotIndex);\n    if (!isValidSimpleName(subName)) {\n      return false;\n    }\n\n    dotIndex = name.indexOf('.', dotIndex + 1);\n  }\n\n  return true;\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    int dotIndex = name.indexOf('.');\n    if (dotIndex == -1) {\n        return isValidSimpleName(name);\n    }\n\n    if (!isValidSimpleName(name.substring(0, dotIndex))) {\n        return false;\n    }\n\n    return isValidQualifiedName(name.substring(dotIndex + 1));\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    int len = name.length();\n    for (int index = 0; index < len; index++) {\n      char c = name.charAt(index);\n      if (c == '.') {\n        if (index == 0 || index == len - 1) {\n          return false;\n        }\n      } else if (!isValidSimpleName(name.substring(index))) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    if (name.indexOf('.') == -1) {\n      return false;\n    }\n    String[] parts = name.split(\"\\\\.\");\n    for (String part : parts) {\n      if (!isValidSimpleName(part)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // so that the results are different for es5 and es3.\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // so that the results are different for es5 and es3.\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // so that the results are different for es5 and es3.\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // so that the results are different for es5 and es3.\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // so that the results are different for es5 and es3.\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // so that the results are different for es5 and es3.\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // so that the results are different for es5 and es3.\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // so that the results are different for es5 and es3.\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // so that the results are different for es5 and es3.\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // so that the results are different for es5 and es3.\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // so that the results are different for es5 and es3.\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // so that the results are different for es5 and es3.\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // so that the results are different for es5 and es3.\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // so that the results are different for es5 and es3.\n  if (name.length() == 0) {\n    return false;\n  }\n  int dotIndex = name.indexOf('.');\n  if (dotIndex == -1) {\n    return isValidSimpleName(name);\n  }\n  if (dotIndex == 0) {\n    return false;\n  }\n  if (dotIndex == name.length() - 1) {\n    return isValidSimpleName(name.substring(0, name.length() - 1));\n  }\n  return isValidQualifiedName(name.substring(0, dotIndex)) &&\n      isValidSimpleName(name.substring(dotIndex + 1));\n}"
    ],
    [
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // Initialize the vectors for the QR step\n    for (int i = il; i <= iu; i++) {\n        hVec[i] = matrixT[i][i + 1];\n    }\n    if (iu < matrixT.length) {\n        hVec[iu + 1] = 0.0;\n    }\n    for (int j = il; j <= iu; j++) {\n        double s = 0.0;\n        for (int i = j; i <= iu; i++) {\n            s += matrixT[i][j] * hVec[i];\n        }\n        s = -s / matrixT[j][j];\n        for (int i = j; i <= iu; i++) {\n            hVec[i] += s * matrixT[i][j];\n        }\n    }\n    for (int i = 0; i <= iu; i++) {\n        hVec[i] *= scale;\n    }\n    hVec[iu + 1] *= scale;\n    if (shift.y != 0.0) {\n        final double s = hVec[iu] * hVec[iu] + shift.w * hVec[iu + 1] * hVec[iu + 1];\n        final double b = shift.x * hVec[iu] + shift.w * hVec[iu + 1];\n        final double c = shift.x * shift.w * hVec[iu + 1] * hVec[iu + 1];\n        double shift1 = 0.0;\n        double shift2 = 0.0;\n        if (c != 0.0) {\n            shift1 = b / c;\n            shift2 = (s - b * shift1) / c;\n        }\n        if (shift1 != 0.0) {\n            if (FastMath.abs(shift1) > FastMath.abs(shift2)) {\n                shift1 /= FastMath.abs(shift1);\n                shift2 /= FastMath.abs(shift1);\n            } else {\n                final double t = FastMath.abs(shift2);\n                shift1 /= t;\n}\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // Initialize the vectors hVec and gVec\n    hVec[0] = 1.0;\n    for (int i = 1; i <= iu; i++) {\n        hVec[i] = matrixT[i][i - 1];\n    }\n    double g = 0.0;\n    for (int i = il; i <= iu; i++) {\n        double s = 0.0;\n        for (int j = i; j <= iu; j++) {\n            s += hVec[j] * matrixT[j][i];\n        }\n        final double f = s / hVec[i];\n        g += s * f;\n        hVec[i] = f;\n    }\n    for (int i = il; i <= iu; i++) {\n        hVec[i] /= matrixT[i][i];\n    }\n    g = (g > 0.0) ? -Math.sqrt(g) : Math.sqrt(g);\n    if (hVec[iu] * g < 0.0) {\n        hVec[iu] = hVec[iu] * (-1.0);\n    }\n    hVec[iu + 1] = g;\n    return il;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // Initialize vectors\n    final double scale = FastMath.max(FastMath.abs(matrixT[iu][iu - 1]), FastMath.abs(matrixT[iu][iu]));\n    if (scale == 0.0) {\n        hVec[iu] = 1.0;\n    } else {\n        hVec[iu] = matrixT[iu][iu] / scale * matrixT[iu][iu - 1] + matrixT[iu - 1][iu];\n    }\n    hVec[iu - 1] = scale * (hVec[iu] * matrixT[iu][iu - 1] + matrixT[iu - 1][iu]);\n    hVec[iu - 1] = hVec[iu - 1] / FastMath.abs(hVec[iu - 1]);\n\n    // Initialize the start index for the QR step\n    int startIdx = il;\n\n    // Initialize the householder vectors for the QR step\n    for (int i = il; i < iu; i++) {\n        hVec[i] = matrixT[i][i];\n        if (i < iu - 1) {\n            hVec[i + 1] = matrixT[i + 1][i];\n        }\n    }\n\n    return startIdx;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // Initialize the vectors that define the elementary reflectors\n    // for the QR step.\n    for (int i = 0; i < iu - 1; i++) {\n        hVec[i] = 0.0;\n    }\n    hVec[iu - 1] = matrixT[iu - 1][iu - 1];\n    if (il < iu - 1) {\n        hVec[iu - 2] = matrixT[iu - 2][iu - 1];\n    }\n\n    // Initialize the shift\n    shift.x = matrixT[iu - 1][iu - 1];\n    shift.y = shift.w = 0.0;\n    if (il < iu - 2) {\n        shift.y = matrixT[iu - 2][iu - 2];\n        shift.w = matrixT[iu - 1][iu - 2] * matrixT[iu - 2][iu - 1];\n    }\n\n    // Wilkinson's original ad hoc shift\n    if (iteration == 10) {\n        shift.exShift += shift.x;\n        for (int i = 0; i <= iu - 1; i++) {\n            matrixT[i][i] -= shift.x;\n        }\n        final double s = FastMath.abs(matrixT[iu - 1][iu - 2]) + FastMath.abs(matrixT[iu - 2][iu - 3]);\n        shift.x = 0.75 * s;\n        shift.y = 0.75 * s;\n        shift.w = -0.4375 * s * s;\n    }\n\n    // MATLAB's new ad hoc shift\n    if (iteration == 30) {\n        double s = (shift.y - shift.x) / 2.0;\n        s = s * s + shift.w;\n        if (s > 0.0) {\n            s = FastMath.sqrt(s);\n            if (shift.y < shift.x) {\n                s = -s;\n            }\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // Initialize the householder vectors\n    for (int i = il; i <= iu; i++) {\n        hVec[i] = matrixT[i][i + 1];\n    }\n    if (iu < matrixT.length) {\n        hVec[iu + 1] = 0.0;\n    }\n    for (int j = il; j <= iu; j++) {\n        final double f = hVec[j];\n        hVec[j] = 1.0;\n        for (int i = j + 1; i <= iu; i++) {\n            hVec[i] -= f * matrixT[i][j];\n        }\n    }\n    for (int i = il; i <= iu; i++) {\n        hVec[i] *= 2.0 / (hVec[i] * hVec[i] + shift.w);\n    }\n    return il;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // Initialize the vectors\n    for (int i = 0; i < iu - il + 1; i++) {\n        hVec[i] = matrixT[il + i][iu];\n    }\n    hVec[iu - il] = 0.0;\n    hVec[iu - il + 1] = 0.0;\n\n    // Calculate the norm of the vector\n    double hNorm = 0.0;\n    for (int i = 0; i < iu - il + 1; i++) {\n        hNorm += hVec[i] * hVec[i];\n    }\n    hNorm = FastMath.sqrt(hNorm);\n\n    // Initialize the householder vector\n    hVec[iu - il] = hNorm;\n    if (hNorm != 0.0) {\n        if (hVec[iu - il + 1] < 0.0) {\n            hNorm = -hNorm;\n        }\n        for (int i = 0; i < iu - il + 1; i++) {\n            hVec[i] /= hNorm;\n        }\n    }\n\n    // Calculate the shift\n    shift.x = matrixT[iu][iu];\n    shift.y = 0.0;\n    shift.w = 0.0;\n    if (il < iu) {\n        shift.y = matrixT[iu - 1][iu - 1];\n        shift.w = matrixT[iu][iu - 1] * matrixT[iu - 1][iu];\n    }\n\n    // Wilkinson's original ad hoc shift\n    if (iteration == 10) {\n        shift.exShift += shift.x;\n        for (int i = 0; i <= iu; i++) {\n            matrixT[i][i] -= shift.x;\n        }\n        final double s = FastMath.abs(matrixT[iu][iu - 1]) + FastMath.abs(matrixT[iu - 1][iu - 2]);\n        shift.x = 0.75 * s;\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // Initialize the householder vectors\n    for (int i = il; i <= iu; i++) {\n        hVec[i] = matrixT[i][i + 1];\n    }\n    if (iu < matrixT.length) {\n        hVec[iu + 1] = 0.0;\n    }\n    for (int j = il; j <= iu; j++) {\n        final double f = hVec[j];\n        hVec[j] = 1.0;\n        for (int i = j; i <= iu; i++) {\n            hVec[i] -= f * matrixT[i][j];\n        }\n    }\n    hVec[iu + 1] = 0.0;\n    return il;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // Initialize the vectors\n    for (int i = 0; i < iu - il + 1; i++) \n    {\n        hVec[i] = matrixT[il + i][iu];\n    }\n\n    // Initialize the shift\n    shift.x = matrixT[iu][iu];\n    shift.y = 0.0;\n    shift.w = 0.0;\n\n    // Initialize the start index for the QR step\n    int startIdx = il;\n\n    return startIdx;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // Initialize vectors for the QR step\n    for (int i = il; i <= iu; i++) {\n        hVec[i] = matrixT[i][i + 1];\n    }\n    if (iu < matrixT.length) {\n        hVec[iu + 1] = 0.0;\n    }\n    return il;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int startIdx = iu - 1;\n    if (il == iu) {\n        hVec[startIdx] = 1.0;\n    } else {\n        hVec[startIdx] = matrixT[iu][iu - 1];\n        for (int i = il; i < iu; i++) {\n            hVec[i] = matrixT[i][i];\n        }\n        hVec[iu] = 0.0;\n    }\n    return startIdx;\n}"
    ],
    [
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node childNode : childNodes) {\n        if (childNode instanceof TextNode) {\n            textNodes.add((TextNode) childNode);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node childNode : childNodes) {\n        if (childNode instanceof TextNode) {\n            textNodes.add((TextNode) childNode);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node childNode : childNodes) \n    {\n        if (childNode instanceof TextNode) \n        {\n            textNodes.add((TextNode) childNode);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode) {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode) {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node childNode : childNodes) {\n        if (childNode instanceof TextNode) {\n            textNodes.add((TextNode) childNode);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node childNode : childNodes)\n    {\n        if (childNode instanceof TextNode)\n        {\n            textNodes.add((TextNode) childNode);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node child : childNodes) {\n        if (child instanceof TextNode) {\n            textNodes.add((TextNode) child);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes)\n    {\n        if (node instanceof TextNode)\n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}"
    ],
    [
      "public boolean inIncludeSegments()  {\n    for (int i = 0; i < getSegmentCount(); i++) {\n        Segment segment = getSegment(i);\n        if (!segment.isIncluded() || segment.isException()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (long i = this.segmentStart; i <= this.segmentEnd; i++) {\n        if (!getSegment(i).isIncluded()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    return this.segmentStart == this.millisecond && this.segmentEnd == this.millisecond;\n}",
      "public boolean inIncludeSegments()  {\n    for (long i = this.segmentStart; i <= this.segmentEnd; i++) {\n        if (!getSegment(i).isIncluded()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (long i = this.segmentStart; i <= this.segmentEnd; i++) {\n        if (!getSegment(i).isIncluded()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (int i = 0; i < getSegmentCount(); i++) {\n        Segment segment = getSegment(i);\n        if (!segment.isIncluded() || segment.isException()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (long i = this.segmentStart; i <= this.segmentEnd; i++) {\n        Segment segment = getSegment(i);\n        if (segment.isException()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (int i = 0; i < this.segmentCount; i++)\n    {\n        Segment segment = getSegment(this.millisecond + i);\n        if (segment.isException())\n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    return this.segmentStart == this.millisecond\n        && this.segmentEnd == this.millisecond + this.segmentCount - 1;\n}"
    ],
    [
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"Zero instance must not be null\");\n    }\n    if (!start.getFieldTypes().equals(end.getFieldTypes())) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same fields\");\n    }\n    if (!start.getFieldTypes().equals(zeroInstance.getFieldTypes())) {\n        throw new IllegalArgumentException(\"Zero instance must have the same fields\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start);\n    int[] values1 = start.getValues(chrono.getZone());\n    int[] values2 = end.getValues(chrono.getZone());\n    int[] values0 = zeroInstance.getValues();\n    int[] amounts = new int[values0.length];\n    for (int i = 0; i < amounts.length; i++) {\n        amounts[i] = values2[i] - values1[i];\n    }\n    return chrono.get(amounts, zeroInstance.getPeriodType());\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) \n    {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) \n    {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have same number of fields\");\n    }\n    int size = start.size();\n    int[] values1 = new int[size];\n    int[] values2 = new int[size];\n    for (int i = 0; i < size; i++) \n    {\n        DurationFieldType fieldType = start.getFieldType(i);\n        values1[i] = start.get(fieldType);\n        values2[i] = end.get(fieldType);\n    }\n    int amount = zeroInstance.get(values1, values2);\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have same amount of fields\");\n    }\n    int[] startValues = new int[start.size()];\n    int[] endValues = new int[end.size()];\n    for (int i = 0; i < start.size(); i++) {\n        DurationFieldType fieldType = start.getFieldType(i);\n        startValues[i] = start.getValue(fieldType);\n        endValues[i] = end.getValue(fieldType);\n    }\n    return zeroInstance.get(startValues, endValues);\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) \n    {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size() || start.size() != zeroInstance.size()) \n    {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same number of fields\");\n    }\n    int[] values1 = start.getValues();\n    int[] values2 = end.getValues();\n    int[] values0 = zeroInstance.getValues();\n    int[] durations = new int[values0.length];\n    for (int i = 0; i < values0.length; i++) \n    {\n        durations[i] = values0[i] - values1[i];\n    }\n    return zeroInstance.getFieldType(0).getField(DateTimeUtils.getChronology(start)).getDurationField().getUnitMillis() * FieldUtils.safeMultiply(durations);\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  throws IllegalArgumentException {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have same number of fields\");\n    }\n    int[] startValues = new int[start.size()];\n    int[] endValues = new int[end.size()];\n    for (int i = 0; i < start.size(); i++) {\n        DurationFieldType fieldType = start.getFieldType(i);\n        startValues[i] = start.getValue(fieldType);\n        endValues[i] = end.getValue(fieldType);\n    }\n    int[] minValues = new int[start.size()];\n    int[] maxValues = new int[start.size()];\n    for (int i = 0; i < start.size(); i++) {\n        minValues[i] = zeroInstance.getValue(start.getFieldType(i));\n        maxValues[i] = zeroInstance.getValue(start.getFieldType(i));\n    }\n    int amount = 0;\n    for (int i = 0; i < start.size(); i++) {\n        int min = minValues[i];\n        int max = maxValues[i];\n        int startValue = startValues[i];\n        int endValue = endValues[i];\n        if (startValue < min) {\n            amount -= (min - startValue);\n        } else if (startValue > max) {\n            amount += (startValue - max);\n        }\n        if (endValue < min) {\n            amount -= (min - endValue);\n        } else if (endValue > max) {\n            amount += (endValue - max);\n        }\n    }\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  throws IllegalArgumentException {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have same number of fields\");\n    }\n    int size = start.size();\n    int[] startValues = new int[size];\n    int[] endValues = new int[size];\n    for (int i = 0; i < size; i++) {\n        DurationFieldType fieldType = start.getFieldType(i);\n        startValues[i] = start.getValue(fieldType);\n        endValues[i] = end.getValue(fieldType);\n    }\n    return zeroInstance.get(startValues, endValues);\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) \n    {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (zeroInstance == null) \n    {\n        throw new IllegalArgumentException(\"ReadablePeriod zeroInstance must not be null\");\n    }\n    if (start.size() != end.size() || start.size() != zeroInstance.size()) \n    {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same number of fields\");\n    }\n    if (start.getChronology() != end.getChronology() || start.getChronology() != zeroInstance.getChronology()) \n    {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same chronology\");\n    }\n    Chronology chrono = start.getChronology();\n    int[] values1 = start.getValues(chrono.getZone());\n    int[] values2 = end.getValues(chrono.getZone());\n    int[] values0 = zeroInstance.getValues(chrono.getZone());\n    int[] isLeap = chrono.getLeapAmounts();\n    int[] fields = chrono.getFieldTypes();\n    int size = values1.length;\n    int amount = 0;\n    for (int i = 0; i < size; i++) \n    {\n        int value1 = values1[i];\n        int value2 = values2[i];\n        int value0 = values0[i];\n        if (value1 != value0) \n        {\n            int fieldIndex = fields[i].getField(chrono).getUnitMillis();\n            int leap = isLeap[i];\n            if (leap != 0) \n            {\n                if (value1 > value0) \n                {\n                    value1 -= leap;\n                }\n                if (value2 > value0) \n                {\n                    value2 -= leap;\n                }\n            }\n            amount += (value2 - value1) / fieldIndex;\n        }\n    }\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) \n    {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) \n    {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same number of fields\");\n    }\n    int[] startValues = new int[start.size()];\n    int[] endValues = new int[end.size()];\n    for (int i = 0; i < start.size(); i++) \n    {\n        DurationFieldType fieldType = start.getFieldType(i);\n        startValues[i] = start.getValue(fieldType);\n        endValues[i] = end.getValue(fieldType);\n    }\n    int[] amounts = zeroInstance.getValues();\n    for (int i = 0; i < start.size(); i++) \n    {\n        int amount = FieldUtils.safeSubtract(endValues[i], startValues[i]);\n        amounts[i] = amount;\n    }\n    return amounts[0];\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) \n    {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (zeroInstance == null) \n    {\n        throw new IllegalArgumentException(\"Zero instance must not be null\");\n    }\n    if (!start.getFieldTypes().equals(end.getFieldTypes())) \n    {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same fields\");\n    }\n    if (!start.getFieldTypes().equals(zeroInstance.getFieldTypes())) \n    {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same fields\");\n    }\n    int[] values1 = start.getValues(start.getFieldTypes());\n    int[] values2 = end.getValues(end.getFieldTypes());\n    int[] values0 = zeroInstance.getValues(zeroInstance.getFieldTypes());\n    int size = values0.length;\n    int amount = 0;\n    for (int i = 0; i < size; i++) \n    {\n        amount += FieldUtils.safeSubtract(values2[i], values1[i]);\n    }\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size() || !start.getFieldTypes().equals(end.getFieldTypes())) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have same fields\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start);\n    int[] values1 = start.getValues(chrono.getZone());\n    int[] values2 = end.getValues(chrono.getZone());\n    int[] isoValues1 = zeroInstance.getValues(ISOChronology.getInstance(chrono.getZone()));\n    int[] isoValues2 = zeroInstance.getValues(ISOChronology.getInstance(chrono.getZone()));\n    int[] values = new int[values1.length];\n    for (int i = 0; i < values1.length; i++) {\n        values[i] = values1[i] - values2[i] + isoValues1[i] - isoValues2[i];\n    }\n    return chrono.get(values, 0, values.length);\n}"
    ],
    [
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= this.subtitles.size()) {\n        return null;\n    }\n    else {\n        return (LegendTitle) this.subtitles.get(index);\n    }\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= this.subtitles.size()) {\n        return null;\n    }\n    else {\n        return (LegendTitle) this.subtitles.get(index);\n    }\n}",
      "public LegendTitle getLegend(int index)  {\n    // check arguments...\n    if (index < 0) \n    {\n        throw new IllegalArgumentException(\"Requires 'index' argument >= 0.\");\n    }\n\n    // search for the legend...\n    LegendTitle result = null;\n    int count = 0;\n    for (int i = 0; i < this.subtitles.size(); i++) \n    {\n        Title title = this.subtitles.get(i);\n        if (title instanceof LegendTitle) \n        {\n            if (count == index) \n            {\n                result = (LegendTitle) title;\n                break;\n            }\n            count++;\n        }\n    }\n\n    // return the result...\n    return result;\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0) {\n        throw new IllegalArgumentException(\"Negative 'index' argument.\");\n    }\n    List subtitles = getSubtitles();\n    if (index >= subtitles.size()) {\n        return null;\n    }\n    else {\n        return (LegendTitle) subtitles.get(index);\n    }\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= this.subtitles.size()) {\n        return null;\n    }\n    else {\n        return (LegendTitle) this.subtitles.get(index);\n    }\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= this.subtitles.size()) {\n        return null;\n    }\n    else {\n        return (LegendTitle) this.subtitles.get(index);\n    }\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= this.subtitles.size()) {\n        return null;\n    }\n    return (LegendTitle) this.subtitles.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    LegendTitle result = null;\n    int count = 0;\n    for (int i = 0; i < this.subtitles.size(); i++) {\n        Title title = (Title) this.subtitles.get(i);\n        if (title instanceof LegendTitle) {\n            if (count == index) {\n                result = (LegendTitle) title;\n                break;\n            }\n            count++;\n        }\n    }\n    return result;\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0) \n    {\n        throw new IllegalArgumentException(\"Negative 'index' argument.\");\n    }\n    if (this.subtitles == null) \n    {\n        return null;\n    }\n    int count = 0;\n    for (int i = 0; i < this.subtitles.size(); i++) \n    {\n        Title title = this.subtitles.get(i);\n        if (title instanceof LegendTitle) \n        {\n            if (count == index) \n            {\n                return (LegendTitle) title;\n            }\n            count++;\n        }\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= this.subtitles.size()) {\n        return null;\n    }\n    else {\n        return (LegendTitle) this.subtitles.get(index);\n    }\n}"
    ],
    [
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entriesInPhysicalOrder);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entriesInPhysicalOrder);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entriesInPhysicalOrder);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entriesInPhysicalOrder);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entriesInPhysicalOrder);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entriesInPhysicalOrder);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entriesInPhysicalOrder);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entriesInPhysicalOrder);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entriesInPhysicalOrder);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entriesInPhysicalOrder);\n}"
    ],
    [
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = parseOptionalParameterType(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  } else {\n    return parseTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseOptionalParameterType(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n\n        return typeNode;\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) {\n        skipEOLs();\n        Node typeNode = parseOptionalParameterType(next());\n        if (typeNode != null) {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } else {\n                next();\n            }\n        }\n\n        return typeNode;\n    } else {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) \n  {\n    skipEOLs();\n    Node typeNode = parseOptionalParameterType(next());\n    if (typeNode != null) \n    {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) \n      {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } \n      else \n      {\n        next();\n      }\n    }\n    return typeNode;\n  } \n  else \n  {\n    return parseTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) \n  {\n    skipEOLs();\n    Node typeNode = parseOptionalParameterType(next());\n    if (typeNode != null) \n    {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) \n      {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } \n      else \n      {\n        next();\n      }\n    }\n    return typeNode;\n  } \n  else \n  {\n    return parseTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = parseOptionalParameterType(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  } else {\n    return parseTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseOptionalParameterType(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n        return typeNode;\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = parseOptionalParameterType(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  } else {\n    return parseTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseOptionalParameterType(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n        return typeNode;\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = parseOptionalParameterType(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  } else {\n    return parseTypeExpression(token);\n  }\n}"
    ],
    [
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String[] frames = getStackFrames(getStackTrace(t));\n    final List<String> list = new ArrayList<String>();\n    for (int i = 0; i < frames.length; i++) {\n        final String frame = frames[i];\n        final int at = frame.indexOf(\"at\");\n        if (at != -1) {\n            list.add(frame.substring(at));\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> list = new ArrayList<String>();\n    final String[] frames = getStackFrames(getStackTrace(t));\n    for (int i = 0; i < frames.length; i++) {\n        final String frame = frames[i];\n        final int space = frame.indexOf(' ');\n        final String className = frame.substring(space + 1);\n        if (!isClass(className)) {\n            list.add(className);\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> list = new ArrayList<String>();\n    final String[] frames = getStackFrames(getStackTrace(t));\n    for (int i = 0; i < frames.length; i++) \n    {\n        final String frame = frames[i];\n        if (frame.indexOf(\"at \") != 0) \n        {\n            list.add(frame);\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String[] frames = getStackFrames(getStackTrace(t));\n    final List<String> list = new ArrayList<String>();\n    for (String frame : frames) \n    {\n        final int at = frame.indexOf(\"at\");\n        if (at != -1) \n        {\n            list.add(frame.substring(at));\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String[] frames = getStackFrames(getStackTrace(t));\n    final List<String> list = new ArrayList<String>();\n    for (String frame : frames) \n    {\n        final int space = frame.indexOf(' ');\n        if (space < 0) \n        {\n            list.add(frame);\n        } \n        else \n        {\n            final String typeName = frame.substring(0, space);\n            final String methodName = frame.substring(space + 1);\n            if (typeName.startsWith(\"sun.reflect.\") || typeName.startsWith(\"java.lang.reflect.\")) \n            {\n                list.add(methodName);\n            } \n            else \n            {\n                list.add(frame);\n            }\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String[] frames = getStackFrames(getStackTrace(t));\n    final List<String> list = new ArrayList<String>();\n    for (int i = 0; i < frames.length; i++) {\n        final String frame = frames[i];\n        if (frame.indexOf(\"at\") != 0) {\n            list.add(frame);\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String[] frames = getStackFrames(getStackTrace(t));\n    final List<String> list = new ArrayList<String>();\n    for (int i = 0; i < frames.length; i++) \n    {\n        final String frame = frames[i];\n        if (frame.indexOf(\"at \") != 0) \n        {\n            list.add(frame);\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> list = new ArrayList<String>();\n    final String[] frames = getStackFrames(getStackTrace(t));\n    for (int i = 0; i < frames.length; i++) \n    {\n        final String frame = frames[i];\n        if (frame.startsWith(\"at \")) \n        {\n            list.add(frame);\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String[] frames = getStackFrames(getStackTrace(t));\n    final List<String> list = new ArrayList<String>();\n    for (int i = 0; i < frames.length; i++) \n    {\n        final String frame = frames[i];\n        final int at = frame.indexOf(\"at\");\n        if (at != -1) \n        {\n            final StringTokenizer st = new StringTokenizer(frame.substring(at + 2), \" \");\n            while (st.hasMoreTokens()) \n            {\n                final String token = st.nextToken();\n                if (token.length() > 0) \n                {\n                    list.add(token);\n                    break;\n                }\n            }\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> frames = new ArrayList<String>();\n    for (StackTraceElement frame : t.getStackTrace())\n    {\n        frames.add(frame.toString());\n    }\n    return frames;\n}"
    ],
    [
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  } else if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  }\n  throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  } else if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  }\n  throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  } else if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  }\n  throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  } else if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  }\n  throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  } else if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  }\n  throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  } else if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  }\n  throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  } else if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  }\n  throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  } else if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  }\n  throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  } else if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  }\n  throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  } else if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  }\n  throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}"
    ],
    [
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n        if (str == null || size <= 0) {\n            return str;\n        }\n        final int strLen = str.length();\n        final int pads = size - strLen;\n        if (pads <= 0) {\n            return str;\n        }\n        str = leftPad(str, strLen + pads / 2, padChar);\n        str = rightPad(str, size, padChar);\n        return str;\n    }",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n        if (str == null || size <= 0) {\n            return str;\n        }\n        final int strLen = str.length();\n        final int pads = size - strLen;\n        if (pads <= 0) {\n            return str;\n        }\n        str = leftPad(str, strLen + pads / 2, padChar);\n        str = rightPad(str, size, padChar);\n        return str;\n    }",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n        if (str == null || size <= 0) {\n            return str;\n        }\n        final int strLen = str.length();\n        final int pads = size - strLen;\n        if (pads <= 0) {\n            return str;\n        }\n        str = leftPad(str, strLen + pads / 2, padChar);\n        str = rightPad(str, size, padChar);\n        return str;\n    }",
      "public static String center(String str, final int size, final char padChar)  {\n        if (str == null || size <= 0) {\n            return str;\n        }\n        final int strLen = str.length();\n        final int pads = size - strLen;\n        if (pads <= 0) {\n            return str;\n        }\n        str = leftPad(str, strLen + pads / 2, padChar);\n        str = rightPad(str, size, padChar);\n        return str;\n    }",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n        if (str == null || size <= 0) {\n            return str;\n        }\n        final int strLen = str.length();\n        final int pads = size - strLen;\n        if (pads <= 0) {\n            return str;\n        }\n        str = leftPad(str, strLen + pads / 2, padChar);\n        str = rightPad(str, size, padChar);\n        return str;\n    }",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}"
    ],
    [
      "private boolean argsMayHaveSideEffects(Node call)  {\n    for (Node arg : call.children()) \n    {\n        if (mayHaveSideEffects(arg)) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  Node argList = call.getSecondChild();\n  for (Node arg = argList.getFirstChild(); arg != null; arg = arg.getNext()) {\n    if (mayHaveSideEffects(arg)) {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  Node arg = call.getFirstChild().getNext();\n  while (arg != null)\n  {\n    if (NodeUtil.mayHaveSideEffects(arg))\n    {\n      return true;\n    }\n    arg = arg.getNext();\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  for (Node arg = call.getFirstChild().getNext();\n       arg != null; arg = arg.getNext()) {\n    if (NodeUtil.mayHaveSideEffects(arg)) {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  for (Node arg = call.getSecondChild(); arg != null;\n       arg = arg.getNext()) {\n    if (mayHaveSideEffects(arg)) {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  Node arg = call.getFirstChild().getNext();\n  while (arg != null) {\n    if (NodeUtil.mayHaveSideEffects(arg)) {\n      return true;\n    }\n    arg = arg.getNext();\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  // If the method call has no arguments, it can't have side effects.\n  if (call.getChildCount() <= 1) {\n    return false;\n  }\n\n  // Check whether any of the arguments have side effects.\n  for (Node arg = call.getSecondChild(); arg != null;\n       arg = arg.getNext()) {\n    if (NodeUtil.mayHaveSideEffects(arg)) {\n      return true;\n    }\n  }\n\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  Node arg = call.getSecondChild();\n  while (arg != null) {\n    if (NodeUtil.mayHaveSideEffects(arg)) {\n      return true;\n    }\n    arg = arg.getNext();\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  Node arg = call.getFirstChild().getNext();\n  while (arg != null)\n  {\n    if (NodeUtil.mayHaveSideEffects(arg))\n    {\n      return true;\n    }\n    arg = arg.getNext();\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  for (Node arg = call.getFirstChild().getNext(); arg != null; arg = arg.getNext()) {\n    if (mayHaveSideEffects(arg)) {\n      return true;\n    }\n  }\n  return false;\n}"
    ],
    [
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}"
    ],
    [
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    int size = 0;\n    for (final ZipExtraField extraField : data) \n    {\n        size += extraField.getLocalFileDataLength();\n    }\n\n    final byte[] result = new byte[size];\n    int offset = 0;\n    for (final ZipExtraField extraField : data) \n    {\n        final byte[] extraFieldData = extraField.getLocalFileDataData();\n        System.arraycopy(extraFieldData, 0, result, offset, extraFieldData.length);\n        offset += extraFieldData.length;\n    }\n\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    int length = 0;\n    for (final ZipExtraField extraField : data) {\n        length += extraField.getLocalFileDataLength();\n    }\n    final byte[] buffer = new byte[length];\n    int currentOffset = 0;\n    for (final ZipExtraField extraField : data) {\n        final byte[] extraFieldData = extraField.getLocalFileDataData();\n        System.arraycopy(extraFieldData, 0, buffer, currentOffset, extraFieldData.length);\n        currentOffset += extraFieldData.length;\n    }\n    return buffer;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    int length = 0;\n    for (final ZipExtraField ze : data) {\n        length += WORD + ze.getLocalFileDataLength();\n    }\n    final byte[] buffer = new byte[length];\n    int pos = 0;\n    for (final ZipExtraField ze : data) {\n        final ZipShort headerId = ze.getHeaderId();\n        final byte[] header = headerId.getBytes();\n        System.arraycopy(header, 0, buffer, pos, header.length);\n        pos += header.length;\n        final ZipShort length = new ZipShort(ze.getLocalFileDataLength());\n        final byte[] data = length.getBytes();\n        System.arraycopy(data, 0, buffer, pos, data.length);\n        pos += data.length;\n        final byte[] zeData = ze.getLocalFileDataData();\n        System.arraycopy(zeData, 0, buffer, pos, zeData.length);\n        pos += zeData.length;\n    }\n    return buffer;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    int length = 0;\n    for (final ZipExtraField ze : data) {\n        length += ze.getLocalFileDataLength();\n    }\n    final byte[] result = new byte[length];\n    int offset = 0;\n    for (final ZipExtraField ze : data) {\n        offset += ze.writeLocalFileData(result, offset);\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    int length = 0;\n    for (final ZipExtraField extraField : data) \n    {\n        length += extraField.getLocalFileDataLength();\n    }\n    final byte[] result = new byte[length];\n    int offset = 0;\n    for (final ZipExtraField extraField : data) \n    {\n        final byte[] extraFieldData = extraField.getLocalFileDataData();\n        System.arraycopy(extraFieldData, 0, result, offset, extraFieldData.length);\n        offset += extraFieldData.length;\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    int size = 0;\n    for (final ZipExtraField ze : data) {\n        size += WORD + ze.getLocalFileDataLength();\n    }\n    final byte[] result = new byte[size];\n    int pos = 0;\n    for (final ZipExtraField ze : data) {\n        final byte[] b = ze.getLocalFileDataData();\n        System.arraycopy(ze.getHeaderId().getBytes(), 0, result, pos, WORD);\n        pos += WORD;\n        System.arraycopy(new ZipShort(b.length).getBytes(), 0, result, pos, WORD);\n        pos += WORD;\n        System.arraycopy(b, 0, result, pos, b.length);\n        pos += b.length;\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    int length = 0;\n    for (final ZipExtraField extraField : data) {\n        length += extraField.getLocalFileDataLength();\n    }\n    final byte[] buffer = new byte[length];\n    int offset = 0;\n    for (final ZipExtraField extraField : data) {\n        final byte[] extraFieldData = extraField.getLocalFileDataData();\n        System.arraycopy(extraFieldData, 0, buffer, offset, extraFieldData.length);\n        offset += extraFieldData.length;\n    }\n    return buffer;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    int length = 0;\n    for (final ZipExtraField ze : data) {\n        length += WORD + ze.getLocalFileDataLength();\n    }\n    final byte[] result = new byte[length];\n    int pos = 0;\n    for (final ZipExtraField ze : data) {\n        final byte[] b = ze.getLocalFileDataData();\n        System.arraycopy(ze.getHeaderId().getBytes(), 0, result, pos, WORD);\n        pos += WORD;\n        System.arraycopy(new ZipShort(b.length).getBytes(), 0, result, pos, WORD);\n        pos += WORD;\n        System.arraycopy(b, 0, result, pos, b.length);\n        pos += b.length;\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    int length = 0;\n    for (final ZipExtraField extraField : data) \n    {\n        length += extraField.getLocalFileDataLength();\n    }\n    final byte[] result = new byte[length];\n    int offset = 0;\n    for (final ZipExtraField extraField : data) \n    {\n        final byte[] extraFieldData = extraField.getLocalFileDataData();\n        System.arraycopy(extraFieldData, 0, result, offset, extraFieldData.length);\n        offset += extraFieldData.length;\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    int length = 0;\n    for (final ZipExtraField field : data) \n    {\n        length += field.getLocalFileDataLength();\n    }\n    final byte[] result = new byte[length];\n    int pos = 0;\n    for (final ZipExtraField field : data) \n    {\n        final byte[] fieldData = field.getLocalFileDataData();\n        System.arraycopy(fieldData, 0, result, pos, fieldData.length);\n        pos += fieldData.length;\n    }\n    return result;\n}"
    ],
    [
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}"
    ],
    [
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // add removed blanks when not ignoring whitespace chars...\n    if (!ignoreSurroundingSpaces) {\n        while (isWhitespace(ch)) {\n            token.content.append((char) ch);\n            ch = reader.read();\n        }\n    }\n\n    // ok, start of token reached: encapsulated, or token\n    if (isDelimiter(ch)) {\n        // empty token return TOKEN(\"\")\n        token.type = TOKEN;\n    } else if (isEndOfFile(ch)) {\n        // end of file return EOF()\n        // noop: token.content.append(\"\");\n        token.type = EOF;\n        token.isReady = true; // there is data at EOF\n    } else {\n        // next token must be a simple token\n        // add removed blanks when not ignoring whitespace chars...\n        while (!isDelimiter(ch) && !isEndOfFile(ch)) {\n            token.content.append((char) ch);\n            ch = reader.read();\n        }\n        token.type = TOKEN;\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // consume until unescaped delimiter, end of line or end of stream\n    while (true) {\n        if (isEndOfFile(ch) || isEndOfLine(ch)) {\n            // end of line or end of stream return EORECORD\n            token.type = EORECORD;\n            return token;\n        } else if (isDelimiter(ch) && !isEscaped(ch)) {\n            // unescaped delimiter return TOKEN\n            token.type = TOKEN;\n            return token;\n        }\n\n        // append current char to token\n        token.content.append((char) ch);\n\n        // go on char ahead ...\n        ch = reader.read();\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // ok, start of token reached: encapsulated, or token\n    if (isDelimiter(ch)) {\n        // empty token return TOKEN(\"\")\n        token.type = TOKEN;\n    } else if (isEndOfFile(ch)) {\n        // end of file return EOF()\n        // noop: token.content.append(\"\");\n        token.type = EOF;\n        token.isReady = true; // there is data at EOF\n    } else {\n        // next token must be a simple token\n        // add removed blanks when not ignoring whitespace chars...\n        parseSimpleToken(token, ch);\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // read until delimiter or EOL\n    while (!isDelimiter(ch) && !isEndOfFile(ch) && !isEndOfLine(ch)) {\n        // add char to token\n        token.content.append((char) ch);\n        // go on char ahead ...\n        ch = reader.read();\n    }\n\n    // check for end of line\n    if (isEndOfLine(ch)) {\n        token.type = EORECORD;\n    } else {\n        token.type = TOKEN;\n    }\n\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    final StringBuilder content = token.content;\n    boolean isReady = false;\n    while (true) {\n        // end of file reached\n        if (isEndOfFile(ch)) {\n            token.type = EOF;\n            isReady = true;\n            break;\n        }\n        // end of line reached\n        if (isEndOfLine(ch)) {\n            token.type = EORECORD;\n            isReady = true;\n            break;\n        }\n        // unescaped delimiter reached\n        if (isDelimiter(ch) && !isEscaped(ch)) {\n            token.type = TOKEN;\n            isReady = true;\n            break;\n        }\n        // append char to token\n        content.append((char) ch);\n        // read next char\n        ch = reader.read();\n    }\n    // set token.isReady if token is not empty\n    if (isReady && content.length() > 0) {\n        token.isReady = true;\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    final StringBuilder buffer = token.content;\n    boolean isEscaped = false;\n    boolean isEol = false;\n    boolean isEof = false;\n\n    while (true) {\n        // if the last char was a delimiter, we have to check if it was escaped\n        if (isEscaped) {\n            isEscaped = false;\n            buffer.append((char) ch);\n        } else {\n            // if the last char was a delimiter, we have to check if it was escaped\n            if (isDelimiter(ch)) {\n                if (ch == escapeChar) {\n                    isEscaped = true;\n                } else {\n                    // we have reached the end of the token\n                    break;\n                }\n            } else {\n                buffer.append((char) ch);\n            }\n        }\n\n        // end of line detection: eol AND (last char was EOL or beginning)\n        if (ignoreEmptyLines) {\n            while (isEol && isStartOfLine(ch)) {\n                // go on char ahead ...\n                ch = reader.read();\n                isEol = readEndOfLine(ch);\n                // reached end of file without any content (empty line at the end)\n                if (isEndOfFile(ch)) {\n                    token.type = EOF;\n                    // don't set token.isReady here because no content\n                    return token;\n                }\n            }\n        }\n\n        // did we reach eof during the last iteration already ? EOF\n        if (isEndOfFile(ch) || !isDelimiter(ch) && isEndOfFile(ch)) {\n            token.type = EOF;\n            // don't set token.isReady here because no content\n            return token;\n        }\n\n        // important: make sure a new char gets consumed in each iteration\n        ch = reader.read();\n        isEol = readEndOfLine(ch);\n        isEof = isEndOfFile(ch);\n    }\n\n    // important: make sure a new char gets consumed in each iteration\n    ch = reader.read();\n    isEol = readEndOfLine(ch);\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // important: make sure a new char gets consumed in each iteration\n    while (token.type == INVALID) {\n        // ignore whitespaces at beginning of a token\n        if (ignoreSurroundingSpaces) {\n            while (isWhitespace(ch) && !eol) {\n                ch = reader.read();\n                eol = readEndOfLine(ch);\n            }\n        }\n\n        // ok, start of token reached: encapsulated, or token\n        if (isDelimiter(ch)) {\n            // empty token return TOKEN(\"\")\n            token.type = TOKEN;\n        } else if (eol) {\n            // empty token return EORECORD(\"\")\n            // noop: token.content.append(\"\");\n            token.type = EORECORD;\n        } else if (isQuoteChar(ch)) {\n            // consume encapsulated token\n            parseEncapsulatedToken(token);\n        } else if (isEndOfFile(ch)) {\n            // end of file return EOF()\n            // noop: token.content.append(\"\");\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n        } else {\n            // next token must be a simple token\n            // add removed blanks when not ignoring whitespace chars...\n            parseSimpleToken(token, ch);\n        }\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // read the next char and set eol\n    boolean eol = readEndOfLine(ch);\n    // empty line detection: eol AND (last char was EOL or beginning)\n    if (ignoreEmptyLines) {\n        while (eol && isStartOfLine(ch)) {\n            // go on char ahead ...\n            ch = reader.read();\n            eol = readEndOfLine(ch);\n            // reached end of file without any content (empty line at the end)\n            if (isEndOfFile(ch)) {\n                token.type = EOF;\n                // don't set token.isReady here because no content\n                return token;\n            }\n        }\n    }\n\n    // did we reach eof during the last iteration already ? EOF\n    if (isEndOfFile(ch) || !isDelimiter(ch) && isEndOfFile(ch)) {\n        token.type = EOF;\n        // don't set token.isReady here because no content\n        return token;\n    }\n\n    // important: make sure a new char gets consumed in each iteration\n    while (token.type == INVALID) {\n        // ignore whitespaces at beginning of a token\n        if (ignoreSurroundingSpaces) {\n            while (isWhitespace(ch) && !eol) {\n                ch = reader.read();\n                eol = readEndOfLine(ch);\n            }\n        }\n\n        // ok, start of token reached: encapsulated, or token\n        if (isDelimiter(ch)) {\n            // empty token return TOKEN(\"\")\n            token.type = TOKEN;\n        } else if (eol) {\n            // empty token return EORECORD(\"\")\n            // noop: token.content.append(\"\");\n            token.type = EORECORD;\n        } else if (isEndOfFile(ch)) {\n            // end of file return EOF()\n            // noop: token.content.append(\"\");\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n        } else {\n            // next token must be a simple token\n}\n}\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // ok, start of token reached: encapsulated, or token\n    if (isDelimiter(ch)) {\n        // empty token return TOKEN(\"\")\n        token.type = TOKEN;\n    } else if (isEndOfFile(ch)) {\n        // end of file return EOF()\n        // noop: token.content.append(\"\");\n        token.type = EOF;\n        token.isReady = true; // there is data at EOF\n    } else {\n        // next token must be a simple token\n        // add removed blanks when not ignoring whitespace chars...\n        while (!isDelimiter(ch) && !isEndOfFile(ch)) {\n            if (isWhitespace(ch)) {\n                if (!ignoreSurroundingSpaces) {\n                    token.content.append((char) ch);\n                }\n            } else {\n                token.content.append((char) ch);\n            }\n            ch = reader.read();\n        }\n        // we reached a delimiter or end of file\n        if (isDelimiter(ch)) {\n            token.type = TOKEN;\n        } else if (isEndOfFile(ch)) {\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n        }\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    final StringBuilder buffer = token.content;\n    while (true) {\n        if (isEndOfFile(ch)) {\n            // end of file return EOF()\n            // noop: buffer.append(\"\");\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n            return token;\n        } else if (isDelimiter(ch)) {\n            // next token must be a simple token\n            // add removed blanks when not ignoring whitespace chars...\n            token.type = TOKEN;\n            return token;\n        } else if (isEndOfLine(ch)) {\n            // empty token return EORECORD(\"\")\n            // noop: buffer.append(\"\");\n            token.type = EORECORD;\n            return token;\n        } else if (isQuoteChar(ch)) {\n            // consume encapsulated token\n            parseEncapsulatedToken(token);\n            return token;\n        } else {\n            // add the character to the token\n            buffer.append((char) ch);\n        }\n\n        // important: make sure a new char gets consumed in each iteration\n        ch = reader.read();\n    }\n}"
    ],
    [
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index -= counts[i] * uniCounterOffset[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index -= counts[i] * uniCounterOffset[i];\n    }\n\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index -= counts[i] * uniCounterOffset[i];\n    }\n\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n\n    return counts;\n}"
    ],
    [
      "public JsonPointer last()  {\n    if (_nextSegment == null) {\n        return this;\n    }\n    JsonPointer next = _nextSegment;\n    while (next._nextSegment != null) {\n        next = next._nextSegment;\n    }\n    return next;\n}",
      "public JsonPointer last()  {\n    if (_nextSegment == null) {\n        return this;\n    }\n    return _nextSegment.last();\n}",
      "public JsonPointer last()  {\n    JsonPointer ptr = this;\n    while (ptr._nextSegment != null) {\n        ptr = ptr._nextSegment;\n    }\n    return ptr;\n}",
      "public JsonPointer last()  {\n    JsonPointer curr = this;\n    while (curr._nextSegment != null) {\n        curr = curr._nextSegment;\n    }\n    return curr;\n}",
      "public JsonPointer last()  {\n    if (this.nextSegment == null) {\n        return this;\n    }\n    return this.nextSegment.last();\n}",
      "public JsonPointer last()  {\n    if (this.isRoot())\n        return this;\n    else\n        return this.getParent().last();\n}",
      "public JsonPointer last()  {\n    if (matches()) {\n        return this;\n    }\n    JsonPointer tail = _nextSegment;\n    while (tail._nextSegment != null) {\n        tail = tail._nextSegment;\n    }\n    return tail;\n}",
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}",
      "public JsonPointer last()  {\n    if (_nextSegment == null) {\n        return this;\n    }\n    JsonPointer last = _nextSegment;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}",
      "public JsonPointer last()  {\n    if (_nextSegment == null) {\n        return this;\n    }\n    return _nextSegment.last();\n}"
    ],
    [
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1)  {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) \n    {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) \n    {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) \n    {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) \n    {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) \n    {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) \n    {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1)  {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}"
    ],
    [
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        } else if (obj instanceof Cloneable) {\n            try {\n                return (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n            } catch (final NoSuchMethodException ex) {\n                throw new CloneFailedException(\"Clone not supported due to missing method\", ex);\n            } catch (final IllegalAccessException ex) {\n                throw new CloneFailedException(\"Clone not accessible\", ex);\n            } catch (final InvocationTargetException ex) {\n                final Throwable cause = ex.getCause();\n                if (cause instanceof RuntimeException) {\n                    throw (RuntimeException) cause;\n                }\n                if (cause instanceof Error) {\n                    throw (Error) cause;\n                }\n                throw new CloneFailedException(\"Clone operation failed\", cause);\n            }\n        } else {\n            throw new CloneFailedException(\"Clone not supported for \" + obj.getClass().getName());\n        }\n    }",
      "public static <T> T clone(final T obj)  {\n    if (obj == null)\n    {\n        return null;\n    }\n    if (obj instanceof Cloneable)\n    {\n        try\n        {\n            return (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n        }\n        catch (final Exception e)\n        {\n            throw new CloneFailedException(\"Cloning failed.\", e);\n        }\n    }\n    return obj;\n}",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        } else if (obj instanceof Cloneable) {\n            try {\n                return (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n            } catch (final IllegalAccessException ex) {\n                throw new CloneFailedException(\"Clone operation failed.\", ex);\n            } catch (final InvocationTargetException ex) {\n                throw new CloneFailedException(\"Clone operation failed.\", ex);\n            } catch (final NoSuchMethodException ex) {\n                throw new CloneFailedException(\"Clone operation failed.\", ex);\n            }\n        } else {\n            return obj;\n        }\n    }",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) \n    {\n        return null;\n    }\n    if (obj instanceof Cloneable) \n    {\n        try \n        {\n            return (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n        } \n        catch (final Exception ex) \n        {\n            throw new CloneFailedException(\"Cloning failed.\", ex);\n        }\n    }\n    return obj;\n}",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        } else if (obj instanceof Cloneable) {\n            try {\n                @SuppressWarnings(\"unchecked\") // type is not parameterized\n                final T clone = (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n                return clone;\n            } catch (final IllegalAccessException ex) {\n                throw new CloneFailedException(\"Cloneable type \" + obj.getClass().getName() + \" cannot be accessed.\", ex);\n            } catch (final InvocationTargetException ex) {\n                throw new CloneFailedException(\"Cloneable type \" + obj.getClass().getName() + \" cannot be cloned.\", ex);\n            } catch (final NoSuchMethodException ex) {\n                throw new CloneFailedException(\"Cloneable type \" + obj.getClass().getName() + \" does not implement Cloneable.\", ex);\n            }\n        } else {\n            return obj;\n        }\n    }",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        } else if (obj instanceof Cloneable) {\n            try {\n                return (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n            } catch (final NoSuchMethodException ex) {\n                throw new CloneFailedException(\"Clone not supported due to missing method\", ex);\n            } catch (final IllegalAccessException ex) {\n                throw new CloneFailedException(\"Clone not accessible\", ex);\n            } catch (final InvocationTargetException ex) {\n                throw new CloneFailedException(\"Clone operation failed\", ex);\n            }\n        } else {\n            throw new CloneFailedException(\"Clone not supported for \" + obj.getClass().getName());\n        }\n    }",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        } else if (obj instanceof Cloneable) {\n            try {\n                return (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n            } catch (final IllegalAccessException ex) {\n                throw new CloneFailedException(\"Cloning failed.\", ex);\n            } catch (final InvocationTargetException ex) {\n                throw new CloneFailedException(\"Cloning failed.\", ex);\n            } catch (final NoSuchMethodException ex) {\n                throw new CloneFailedException(\"Cloning failed.\", ex);\n            }\n        } else {\n            return obj;\n        }\n    }",
      "public static <T> T clone(final T obj)  {\n    if (obj == null)\n    {\n        return null;\n    }\n    if (obj instanceof Cloneable)\n    {\n        try\n        {\n            return (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n        }\n        catch (final Exception e)\n        {\n            throw new CloneFailedException(\"Cloning failed.\", e);\n        }\n    }\n    return obj;\n}",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        } else if (obj instanceof Cloneable) {\n            try {\n                @SuppressWarnings(\"unchecked\") // assume clonable\n                final\n                T clone = (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n                return clone;\n            } catch (final Exception e) {\n                throw new CloneFailedException(\"Cloning failed.\", e);\n            }\n        } else {\n            return obj;\n        }\n    }",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) \n    {\n        return null;\n    }\n    if (obj instanceof Cloneable) \n    {\n        try \n        {\n            return (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n        } \n        catch (final IllegalAccessException ex) \n        {\n            throw new CloneFailedException(ex);\n        } \n        catch (final InvocationTargetException ex) \n        {\n            throw new CloneFailedException(ex);\n        } \n        catch (final NoSuchMethodException ex) \n        {\n            throw new CloneFailedException(ex);\n        }\n    }\n    return obj;\n}"
    ],
    [
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.getType() != null && sym.getType().isFunctionType()) \n    {\n        FunctionType fnType = sym.getType().toMaybeFunctionType();\n        if (fnType != null) \n        {\n            for (int i = 0; i < fnType.getParameterCount(); i++) \n            {\n                JSType paramType = fnType.getParameters()[i];\n                String paramName = fnType.getParameters()[i].getName();\n                if (paramName.equals(paramName)) \n                {\n                    return getSymbol(paramName);\n                }\n            }\n        }\n    }\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.type == null || !(sym.type instanceof JSTypeFunction)) \n    {\n        return null;\n    }\n    JSTypeFunction type = (JSTypeFunction) sym.type;\n    if (type.getParameters() == null) \n    {\n        return null;\n    }\n    for (JSTypeParameter param : type.getParameters()) \n    {\n        if (param.getName().equals(paramName)) \n        {\n            return getSymbol(param);\n        }\n    }\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  if (sym.getType() != null && sym.getType().isFunctionType()) {\n    for (Symbol param : sym.getType().getParameters()) {\n      if (param.getName().equals(paramName)) {\n        return param;\n      }\n    }\n  }\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  if (sym.type != SymbolType.FUNCTION) {\n    return null;\n  }\n\n  // We're looking for a parameter with the given name.\n  // We do this by looking at the function's parameter list.\n  // The parameter list is a list of Symbols, each of which\n  // has a name.\n  List<Symbol> params = ((FunctionType) sym.type).getParameters();\n  for (Symbol param : params) {\n    if (param.name.equals(paramName)) {\n      return param;\n    }\n  }\n\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.getType() != null && sym.getType().isFunctionType()) \n    {\n        FunctionType functionType = sym.getType().toMaybeFunctionType();\n        if (functionType != null) \n        {\n            JSDocInfo info = functionType.getJSDocInfo();\n            if (info != null) \n            {\n                Node paramNode = info.getParameter(paramName);\n                if (paramNode != null) \n                {\n                    return getSymbol(paramNode);\n                }\n            }\n        }\n    }\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.type != SymbolType.FUNCTION) {\n        return null;\n    }\n    FunctionType funType = (FunctionType) sym.type;\n    JSType formalType = funType.getFormalType();\n    if (formalType == null) {\n        return null;\n    }\n    if (formalType.isUnknownType()) {\n        return null;\n    }\n    if (formalType.isFunctionType()) {\n        return null;\n    }\n    if (formalType.isRecordType()) {\n        return null;\n    }\n    if (formalType.isTemplatizedType()) {\n        return null;\n    }\n    if (formalType.isEnumType()) {\n        return null;\n    }\n    if (formalType.isStructuralInterfaceType()) {\n        return null;\n    }\n    if (formalType.isUnionType()) {\n        return null;\n    }\n    if (formalType.isNullType()) {\n        return null;\n    }\n    if (formalType.isVoidType()) {\n        return null;\n    }\n    if (formalType.isUndefinedType()) {\n        return null;\n    }\n    if (formalType.isAllType()) {\n        return null;\n    }\n    if (formalType.isUnknownType()) {\n        return null;\n    }\n    if (formalType.isBottomType()) {\n        return null;\n    }\n    if (formalType.isObjectType()) {\n        ObjectType objType = (ObjectType) formalType;\n        if (objType.isFunctionPrototypeType()) {\n            return null;\n        }\n        if (objType.isInstanceType()) {\n            return null;\n        }\n        if (objType.isEnumType()) {\n            return null;\n        }\n        if (objType.isStructuralInterfaceType()) {\n            return null;\n        }\n        if (objType.isTemplatizedType()) {\n            return null;\n        }\n        if (objType.isDictionaryType()) {\n            return null;\n        }\n}\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (!sym.isFunction()) {\n        return null;\n    }\n\n    // If we're looking for a parameter in a function, we'll first\n    // look for a parameter with the given name in the function's\n    // scope.\n    Symbol param = getSymbol(sym.scope, paramName);\n    if (param != null) {\n        return param;\n    }\n\n    // If we couldn't find a parameter with the given name in the\n    // function's scope, we'll look for a parameter with the given\n    // name in the function's parent scope.\n    //\n    // This is because the function's scope is created after the\n    // function is defined, so the parameter will be in the function's\n    // parent scope.\n    if (sym.scope.getParent() != null) {\n        param = getSymbol(sym.scope.getParent(), paramName);\n        if (param != null) {\n            return param;\n        }\n    }\n\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  if (sym.type != null && sym.type.isFunctionType()) {\n    // This is a function. Try to find a parameter with the given name.\n    JSType fnType = sym.type;\n    if (fnType.isFunctionType()) {\n      JSType functionType = fnType.toMaybeFunctionType();\n      if (functionType != null) {\n        JSType functionTypeWithoutQmark = functionType.restrictByNotNullOrUndefined();\n        if (functionTypeWithoutQmark != null) {\n          JSType functionTypeWithoutNull = functionTypeWithoutQmark.restrictByNotNull();\n          if (functionTypeWithoutNull != null) {\n            JSType functionTypeWithoutUndefined = functionTypeWithoutNull.restrictByNotUndefined();\n            if (functionTypeWithoutUndefined != null) {\n              JSType functionTypeWithoutNullOrUndefined = functionTypeWithoutNull.restrictByNotUndefined();\n              if (functionTypeWithoutNullOrUndefined != null) {\n                JSType functionTypeWithoutQmarkOrNullOrUndefined = functionTypeWithoutQmark.restrictByNotNullOrUndefined();\n                if (functionTypeWithoutQmarkOrNullOrUndefined != null) {\n                  JSType functionTypeWithoutQmarkOrNullOrUndefinedOrNullOrUndefined = functionTypeWithoutQmarkOrNullOrUndefined.restrictByNotNullOrUndefined();\n                  if (functionTypeWithoutQmarkOrNullOrUndefinedOrNullOrUndefined != null) {\n                    JSType functionTypeWithoutQmarkOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefined = functionTypeWithoutQmarkOrNullOrUndefinedOrNullOrUndefined.restrictByNotNullOrUndefined();\n                    if (functionTypeWithoutQmarkOrNullOrUndefinedOrNullOrUndefinedOrNullOrUndefined != null) {\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.type == null || !sym.type.isFunctionType()) {\n      return null;\n    }\n\n    // The function type is the first type in the union type,\n    // so we can just look at the first type.\n    JSType functionType = sym.type.getTypes().get(0);\n    if (functionType == null || !functionType.isFunctionType()) {\n      return null;\n    }\n\n    // Get the parameters for this function type.\n    // The parameters are the second type in the union type.\n    JSType functionProtoType = functionType.toMaybeFunctionType().getPrototype();\n    if (functionProtoType == null || !functionProtoType.isObjectType()) {\n      return null;\n    }\n\n    ObjectType functionProto = functionProtoType.toObjectType();\n    ObjectType functionInstance = functionProto.getImplicitPrototype();\n    if (functionInstance == null || !functionInstance.isFunctionType()) {\n      return null;\n    }\n\n    // Get the parameters for this function instance.\n    // The parameters are the second type in the union type.\n    JSType functionInstanceType = functionInstance.getPropertyType(\"prototype\");\n    if (functionInstanceType == null || !functionInstanceType.isFunctionType()) {\n      return null;\n    }\n\n    JSType functionInstanceProtoType = functionInstanceType.toMaybeFunctionType().getPrototype();\n    if (functionInstanceProtoType == null || !functionInstanceProtoType.isObjectType()) {\n      return null;\n    }\n\n    ObjectType functionInstanceProto = functionInstanceProtoType.toObjectType();\n    ObjectType functionInstanceInstance = functionInstanceProto.getImplicitPrototype();\n    if (functionInstanceInstance == null || !functionInstanceInstance.isFunctionType()) {\n      return null;\n    }\n\n    // Now we have the parameters for this function instance.\n    // Look for the parameter with the given name.\n    for (String param : functionInstanceInstance.getOwnPropertyNames()) {\n      if (param.equals(paramName)) {\n        return getSymbol(param);\n      }\n    }\n\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.type == null || !(sym.type instanceof FunctionType)) \n    {\n        return null;\n    }\n\n    FunctionType fnType = (FunctionType) sym.type;\n    if (fnType.getParameters() == null) \n    {\n        return null;\n    }\n\n    for (Node paramNode : fnType.getParameters()) \n    {\n        if (paramNode.getFirstChild().getString().equals(paramName)) \n        {\n            return getSymbol(paramNode);\n        }\n    }\n\n    return null;\n}"
    ],
    [
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        int m = matrix.getColumnDimension();\n        int n = matrix.getRowDimension();\n        if (m < 2 || n < 1) {\n            throw new MathIllegalArgumentException(LocalizedCoreFormats.INSUFFICIENT_DATA);\n        }\n        double[][] data = new double[m][m];\n        for (int i = 0; i < m; i++) {\n            for (int j = i; j < m; j++) {\n                data[i][j] = data[j][i] = computeCovariance(matrix, i, j, biasCorrected);\n            }\n        }\n        return new BlockRealMatrix(data);\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        int m = matrix.getColumnDimension();\n        int n = matrix.getRowDimension();\n        if (m < 2 || n < 2) {\n            throw new MathIllegalArgumentException(LocalizedCoreFormats.INSUFFICIENT_DATA);\n        }\n        if (m != n) {\n            throw new MathIllegalArgumentException(LocalizedCoreFormats.NON_SQUARE_MATRIX, m, n);\n        }\n        // compute the covariance matrix\n        RealMatrix covarianceMatrix = new BlockRealMatrix(m, m);\n        for (int i = 0; i < m; i++) {\n            for (int j = i; j < m; j++) {\n                double s = computeCovariance(matrix, i, j, biasCorrected);\n                covarianceMatrix.setEntry(i, j, s);\n                covarianceMatrix.setEntry(j, i, s);\n            }\n        }\n        return covarianceMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        int n = matrix.getRowDimension();\n        if (n < 2) {\n            throw new MathIllegalArgumentException(LocalizedCoreFormats.INSUFFICIENT_DATA_POINTS, n, 2);\n        }\n        int p = matrix.getColumnDimension();\n        if (p < 1) {\n            throw new MathIllegalArgumentException(LocalizedCoreFormats.INSUFFICIENT_DATA_POINTS, p, 1);\n        }\n        double[][] data = matrix.getData();\n        double[][] covariance = new double[p][p];\n        for (int i = 0; i < p; i++) {\n            for (int j = i; j < p; j++) {\n                double sum = 0;\n                for (int k = 0; k < n; k++) {\n                    sum += (data[k][i] - mean[i]) * (data[k][j] - mean[j]);\n                }\n                covariance[i][j] = sum / (n - (biasCorrected ? 1 : 0));\n                covariance[j][i] = covariance[i][j];\n            }\n        }\n        return new BlockRealMatrix(covariance);\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        int m = matrix.getColumnDimension();\n        int n = matrix.getRowDimension();\n        if (m < 2 || n < 2) {\n            throw new MathIllegalArgumentException(LocalizedCoreFormats.INSUFFICIENT_DATA);\n        }\n\n        // compute mean vector\n        double[] meanVector = new double[m];\n        for (int i = 0; i < m; i++) {\n            meanVector[i] = matrix.getColumn(i).getSum() / n;\n        }\n\n        // compute covariance matrix\n        RealMatrix covarianceMatrix = new BlockRealMatrix(m, m);\n        for (int i = 0; i < m; i++) {\n            for (int j = i; j < m; j++) {\n                double covariance = computeCovariance(matrix, i, j, meanVector, biasCorrected);\n                covarianceMatrix.setEntry(i, j, covariance);\n                covarianceMatrix.setEntry(j, i, covariance);\n            }\n        }\n\n        return covarianceMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        final int n = matrix.getRowDimension();\n        final int p = matrix.getColumnDimension();\n        final RealMatrix data = new BlockRealMatrix(n, p);\n        for (int i = 0; i < n; i++) {\n            data.setRowVector(i, matrix.getRowVector(i));\n        }\n        final RealMatrix covarianceMatrix = new BlockRealMatrix(p, p);\n        for (int i = 0; i < p; i++) {\n            for (int j = i; j < p; j++) {\n                final double covariance = computeCovariance(data, i, j, biasCorrected);\n                covarianceMatrix.setEntry(i, j, covariance);\n                covarianceMatrix.setEntry(j, i, covariance);\n            }\n        }\n        return covarianceMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        int n = matrix.getColumnDimension();\n        RealMatrix data = matrix.transpose().multiply(matrix);\n        RealMatrix covarianceMatrix = data.scalarMultiply(1.0 / (n - 1));\n        if (biasCorrected) {\n            covarianceMatrix = covarianceMatrix.scalarMultiply(1.0 / (n - 2));\n        }\n        return covarianceMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        int n = matrix.getRowDimension();\n        if (n < 2) {\n            throw new MathIllegalArgumentException(LocalizedCoreFormats.INSUFFICIENT_DATA);\n        }\n        int p = matrix.getColumnDimension();\n        if (p < 1) {\n            throw new MathIllegalArgumentException(LocalizedCoreFormats.INSUFFICIENT_DATA);\n        }\n        double[][] data = new double[p][p];\n        for (int i = 0; i < p; i++) {\n            for (int j = 0; j < p; j++) {\n                data[i][j] = matrix.getEntry(i, j);\n            }\n        }\n        return new Covariance(data, biasCorrected).getCovarianceMatrix();\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        int n = matrix.getRowDimension();\n        RealMatrix covarianceMatrix = new BlockRealMatrix(n, n);\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                double covariance = computeCovariance(matrix, i, j, biasCorrected);\n                covarianceMatrix.setEntry(i, j, covariance);\n                covarianceMatrix.setEntry(j, i, covariance);\n            }\n        }\n        return covarianceMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        int n = matrix.getRowDimension();\n        int p = matrix.getColumnDimension();\n        double[][] data = new double[p][p];\n        for (int i = 0; i < p; i++) {\n            for (int j = 0; j < p; j++) {\n                data[i][j] = matrix.getEntry(i, j);\n            }\n        }\n        return new Covariance(data, biasCorrected).getCovarianceMatrix();\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        int n = matrix.getRowDimension();\n        int p = matrix.getColumnDimension();\n        RealMatrix covarianceMatrix = new BlockRealMatrix(p, p);\n        double[] mean = new double[p];\n        for (int j = 0; j < p; j++) {\n            mean[j] = matrix.getColumn(j).getSum() / n;\n        }\n        for (int i = 0; i < p; i++) {\n            for (int j = i; j < p; j++) {\n                double sum = 0;\n                for (int k = 0; k < n; k++) {\n                    sum += (matrix.getEntry(k, i) - mean[i]) * (matrix.getEntry(k, j) - mean[j]);\n                }\n                covarianceMatrix.setEntry(i, j, sum / (n - (biasCorrected ? 1 : 0)));\n            }\n        }\n        return covarianceMatrix;\n    }"
    ],
    [
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"Count must be between 0 and 63\");\n    }\n    if (bitsCachedSize < count) {\n        int bitsToRead = count - bitsCachedSize;\n        while (bitsToRead > 0) {\n            final int read = in.read();\n            if (read == -1) {\n                if (bitsCachedSize == 0) {\n                    return -1;\n                }\n                throw new IOException(\"Premature end of stream\");\n            }\n            final int bitsRead = Math.min(8, bitsToRead);\n            bitsCached = (bitsCached << bitsRead) | (read & MASKS[bitsRead]);\n            bitsCachedSize += bitsRead;\n            bitsToRead -= bitsRead;\n        }\n    }\n    final long result = bitsCached & MASKS[count];\n    bitsCached >>>= count;\n    bitsCachedSize -= count;\n    return byteOrder == ByteOrder.BIG_ENDIAN ? result : Long.reverseBytes(result);\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"Count must be between 0 and \" + MAXIMUM_CACHE_SIZE);\n    }\n    long result = 0;\n    while (bitsCachedSize < count) {\n        final int read = in.read();\n        if (read == -1) {\n            return -1;\n        }\n        bitsCached |= (read & 0xFFL) << bitsCachedSize;\n        bitsCachedSize += 8;\n    }\n    result = bitsCached & MASKS[count];\n    bitsCached >>>= count;\n    bitsCachedSize -= count;\n    return byteOrder == ByteOrder.BIG_ENDIAN ? result : Long.reverseBytes(result);\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"Count must be between 0 and 63\");\n    }\n\n    if (bitsCachedSize < count) {\n        final int bytesToRead = (count - bitsCachedSize) / 8 + 1;\n        final byte[] bytes = new byte[bytesToRead];\n        final int read = in.read(bytes);\n        if (read < bytesToRead) {\n            return -1;\n        }\n        final long bits = byteOrder == ByteOrder.BIG_ENDIAN ? 0 : MASKS[bytesToRead * 8 - 1];\n        for (int i = 0; i < bytesToRead; i++) {\n            bitsCached |= ((long) bytes[i] & 0xff) << (bitsCachedSize + i * 8);\n        }\n        bitsCachedSize += bytesToRead * 8;\n    }\n\n    final long result = bitsCached & MASKS[count];\n    bitsCached >>>= count;\n    bitsCachedSize -= count;\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 0 and 63\");\n    }\n    if (count == 0) {\n        return 0;\n    }\n    long bits = 0;\n    int bitsRead = 0;\n    while (bitsRead < count) {\n        if (bitsCachedSize == 0) {\n            final int b = in.read();\n            if (b == -1) {\n                return -1;\n            }\n            bitsCached = b;\n            bitsCachedSize = 8;\n        }\n        final int bitsToRead = Math.min(count - bitsRead, bitsCachedSize);\n        bits |= (bitsCached & MASKS[bitsToRead]) << bitsRead;\n        bitsCached >>= bitsToRead;\n        bitsCachedSize -= bitsToRead;\n        bitsRead += bitsToRead;\n    }\n    return byteOrder == ByteOrder.BIG_ENDIAN ? bits : Long.reverseBytes(bits);\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"Count must be between 0 and \" + MAXIMUM_CACHE_SIZE);\n    }\n    if (bitsCachedSize < count) {\n        final int bytesNeeded = (count - bitsCachedSize) / 8 + 1;\n        final byte[] buffer = new byte[bytesNeeded];\n        final int read = in.read(buffer);\n        if (read == -1) {\n            return -1;\n        }\n        final int bitsRead = read * 8;\n        bitsCached |= ByteBuffer.wrap(buffer, 0, read).order(byteOrder).getLong() << bitsCachedSize;\n        bitsCachedSize += bitsRead;\n    }\n    final long result = bitsCached & MASKS[count];\n    bitsCached >>>= count;\n    bitsCachedSize -= count;\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 0 and \" + MAXIMUM_CACHE_SIZE);\n    }\n    if (bitsCachedSize >= count) {\n        return (bitsCached & MASKS[count]) >>> (bitsCachedSize - count);\n    }\n    final int bitsNeeded = count - bitsCachedSize;\n    final int bytesNeeded = (bitsNeeded + Byte.SIZE - 1) / Byte.SIZE;\n    final int bytesRead = in.read(bytesNeeded);\n    if (bytesRead == -1) {\n        return -1;\n    }\n    final int bitsRead = bytesRead * Byte.SIZE;\n    bitsCached = (bitsCached << bitsRead) | (bytesRead & MASKS[bitsRead]);\n    bitsCachedSize += bitsRead;\n    return (bitsCached & MASKS[count]) >>> (bitsCachedSize - count);\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 0 and \" + MAXIMUM_CACHE_SIZE);\n    }\n    if (count == 0) {\n        return 0;\n    }\n    long result = 0;\n    if (bitsCachedSize >= count) {\n        result = bitsCached & MASKS[count];\n        bitsCachedSize -= count;\n        bitsCached >>>= count;\n        return byteOrder == ByteOrder.BIG_ENDIAN ? result : Long.reverseBytes(result);\n    }\n    final int bitsToRead = count - bitsCachedSize;\n    final int bytesToRead = (bitsToRead + 7) / 8;\n    final byte[] buffer = new byte[bytesToRead];\n    final int read = in.read(buffer);\n    if (read < bytesToRead) {\n        if (read == -1) {\n            return -1;\n        }\n        throw new IOException(\"End of stream reached with \" + read + \" bytes read; \" + bytesToRead + \" bytes expected\");\n    }\n    final long bytes = byteOrder == ByteOrder.BIG_ENDIAN ? 0L : Long.reverseBytes(0L);\n    for (int i = 0; i < bytesToRead; i++) {\n        final byte b = buffer[i];\n        result = (result << 8) + (b & 0xFF);\n    }\n    result >>>= (8 - (bitsToRead % 8));\n    bitsCached = (result & MASKS[bitsToRead]) << (64 - bitsToRead - bitsCachedSize);\n    bitsCachedSize += bitsToRead;\n    result = result & MASKS[count];\n    return byteOrder == ByteOrder.BIG_ENDIAN ? result : Long.reverseBytes(result);\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 0 and \" + MAXIMUM_CACHE_SIZE);\n    }\n    if (bitsCachedSize < count) {\n        final int bytesNeeded = (count - bitsCachedSize) / Byte.SIZE + 1;\n        final byte[] bytes = new byte[bytesNeeded];\n        final int read = in.read(bytes);\n        if (read < bytesNeeded) {\n            return -1;\n        }\n        final long bits = byteOrder == ByteOrder.BIG_ENDIAN ?\n                ByteBuffer.wrap(bytes).getLong() :\n                ByteBuffer.wrap(bytes).order(byteOrder).getLong();\n        bitsCached |= bits << bitsCachedSize;\n        bitsCachedSize += count;\n    }\n    final long result = bitsCached & MASKS[count];\n    bitsCached >>>= count;\n    bitsCachedSize -= count;\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"Maximum number of bits to read is \" + MAXIMUM_CACHE_SIZE);\n    }\n    if (count == 0) {\n        return 0;\n    }\n    if (bitsCachedSize >= count) {\n        final long result = bitsCached & MASKS[count];\n        bitsCached >>>= count;\n        bitsCachedSize -= count;\n        return result;\n    }\n    final int bytesToRead = (count - bitsCachedSize) / 8 + 1;\n    final byte[] buffer = new byte[bytesToRead];\n    final int bytesRead = in.read(buffer);\n    if (bytesRead < bytesToRead) {\n        if (bytesRead == -1) {\n            return -1;\n        }\n        throw new IOException(\"Unexpected end of stream after reading \" + bytesRead + \" bytes\");\n    }\n    long bitsRead = 0;\n    for (int i = 0; i < bytesToRead; i++) {\n        final long bits = byteOrder == ByteOrder.BIG_ENDIAN ?\n                (buffer[i] & 0xFFL) << ((bytesToRead - i - 1) * 8) :\n                (buffer[i] & 0xFFL) << (i * 8);\n        bitsRead |= bits;\n    }\n    bitsRead >>>= (bytesToRead * 8 - count);\n    bitsCached |= bitsRead << bitsCachedSize;\n    bitsCachedSize += count;\n    return bitsRead;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 0 and \" + MAXIMUM_CACHE_SIZE);\n    }\n\n    if (bitsCachedSize < count) {\n        final int bitsNeeded = count - bitsCachedSize;\n        int bitsRead = 0;\n        while (bitsRead < bitsNeeded) {\n            final int byteRead = in.read();\n            if (byteRead == -1) {\n                return -1;\n            }\n            final long bitsToAdd = byteOrder == ByteOrder.BIG_ENDIAN ?\n                    ((long) byteRead & 0xFF) << (bitsCachedSize + bitsRead * 8) :\n                    ((long) byteRead & 0xFF) << (bitsRead * 8);\n            bitsCached |= bitsToAdd;\n            bitsCachedSize += 8;\n            bitsRead += 8;\n        }\n    }\n\n    final long bitsToReturn = bitsCached & MASKS[count];\n    bitsCached >>>= count;\n    bitsCachedSize -= count;\n    return bitsToReturn;\n}"
    ],
    [
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  throws DimensionMismatchException {\n    checkVectorDimensions(v.data.length);\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  throws DimensionMismatchException {\n    checkVectorDimensions(v.data.length);\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  throws DimensionMismatchException {\n    checkVectorDimensions(v.data.length);\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  throws DimensionMismatchException {\n    checkVectorDimensions(v.data.length);\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  throws DimensionMismatchException {\n    checkVectorDimensions(v.data.length);\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  throws DimensionMismatchException {\n    checkVectorDimensions(v.data.length);\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  throws DimensionMismatchException {\n    checkVectorDimensions(v.data.length);\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  throws DimensionMismatchException {\n    checkVectorDimensions(v.data.length);\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  throws DimensionMismatchException {\n    checkVectorDimensions(v.data.length);\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  throws DimensionMismatchException {\n    checkVectorDimensions(v.data.length);\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}"
    ],
    [
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  Node parent = target.getParent();\n  if (parent.isLabel() && parent.getFirstChild().getString().equals(label)) {\n    return true;\n  }\n  return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  return NodeUtil.isLabel(target) &&\n    label.equals(target.getFirstChild().getString());\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  return target.isLabel() && label.equals(target.getFirstChild().getString());\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  return target.isLabel() && label.equals(target.getFirstChild().getString());\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  return target.isLabel() && label.equals(target.getFirstChild().getString());\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  return target.isLabel() && label.equals(target.getFirstChild().getString());\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  return target.isLabel() && label.equals(target.getFirstChild().getString());\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  Node parent = target.getParent();\n  if (parent.getType() == Token.LABEL) {\n    return label.equals(parent.getFirstChild().getString());\n  }\n  return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  return target.isLabel() && label.equals(target.getFirstChild().getString());\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  return NodeUtil.isLabelName(target.getFirstChild()) &&\n      label.equals(target.getFirstChild().getString());\n}"
    ],
    [
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        result = (String) urls.get(item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        result = (String) urls.get(item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        result = (String) urls.get(item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        result = (String) urls.get(item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        result = (String) urls.get(item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        result = (String) urls.get(item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        result = (String) urls.get(item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        result = (String) urls.get(item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        result = (String) urls.get(item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        result = (String) urls.get(item);\n    }\n    return result;\n}"
    ],
    [
      "private final static int _parseIndex(String str)  {\n    if (str.length() == 0) {\n        return -1;\n    }\n    int ix = str.charAt(0) - '0';\n    if ((ix < 0) || (ix > 9)) {\n        return -1;\n    }\n    for (int i = 1, len = str.length(); i < len; ++i) {\n        int ch = str.charAt(i) - '0';\n        if ((ch < 0) || (ch > 9)) {\n            return -1;\n        }\n        ix = ix * 10 + ch;\n    }\n    return ix;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        return -1;\n    }\n    int index = 0;\n    for (int i = 0; i < len; ++i) {\n        char c = str.charAt(i);\n        if (c == '0') {\n            index = 0;\n        } else if (c == '1') {\n            index = 1;\n        } else if (c == '2') {\n            index = 2;\n        } else if (c == '3') {\n            index = 3;\n        } else if (c == '4') {\n            index = 4;\n        } else if (c == '5') {\n            index = 5;\n        } else if (c == '6') {\n            index = 6;\n        } else if (c == '7') {\n            index = 7;\n        } else if (c == '8') {\n            index = 8;\n        } else if (c == '9') {\n            index = 9;\n        } else {\n            return -1;\n        }\n    }\n    return index;\n}",
      "private final static int _parseIndex(String str)  {\n    if (str.length() == 0) {\n        return -1;\n    }\n    int len = str.length();\n    if (str.charAt(0) == '0') {\n        if (len == 1) {\n            return 0;\n        }\n        throw new IllegalArgumentException(\"Invalid index '\"+str+\"'\");\n    }\n    int i = 0;\n    while (i < len) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            throw new IllegalArgumentException(\"Invalid index '\"+str+\"'\");\n        }\n        i++;\n    }\n    return Integer.parseInt(str);\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        return -1;\n    }\n    char c = str.charAt(0);\n    if (c < '0' || c > '9') {\n        return -1;\n    }\n    for (int i = 1; i < len; ++i) {\n        c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    return Integer.parseInt(str);\n}",
      "private final static int _parseIndex(String str)  {\n    if (str.startsWith(\"#/\")) {\n        str = str.substring(2);\n    }\n    if (str.startsWith(\"/\")) {\n        str = str.substring(1);\n    }\n    int index = 0;\n    for (int i = 0, len = str.length(); i < len; ++i) {\n        char c = str.charAt(i);\n        if (c == '/') {\n            ++index;\n        }\n    }\n    return index;\n}",
      "private final static int _parseIndex(String str)  {\n    if (str.length() == 0) {\n        return -1;\n    }\n    if (str.charAt(0) != '0') {\n        int i = 0;\n        while (i < str.length() && str.charAt(i) >= '0' && str.charAt(i) <= '9') {\n            i++;\n        }\n        if (i == str.length()) {\n            try {\n                return Integer.parseInt(str);\n            } catch (NumberFormatException e) {\n                return -1;\n            }\n        }\n    }\n    return -1;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        throw new IllegalArgumentException(\"Empty string not allowed\");\n    }\n    int ix = 0;\n    if (str.charAt(0) == '0') {\n        if (len == 1) {\n            throw new IllegalArgumentException(\"Leading zero not allowed\");\n        }\n        if (str.charAt(1) != ']') {\n            throw new IllegalArgumentException(\"Expected ']'\");\n        }\n        ix = 0;\n    } else {\n        for (; ix < len; ++ix) {\n            char c = str.charAt(ix);\n            if (c < '0' || c > '9') {\n                throw new IllegalArgumentException(\"Non-digit char '\"+c+\"'\");\n            }\n        }\n        ix = Integer.parseInt(str);\n    }\n    return ix;\n}",
      "private final static int _parseIndex(String str)  {\n    if (str.startsWith(\"#/\")) {\n        str = str.substring(2);\n    }\n    int index = str.indexOf('/');\n    if (index < 0) {\n        index = str.length();\n    }\n    try {\n        return Integer.parseInt(str.substring(0, index));\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        return -1;\n    }\n    if (str.charAt(0) != '0') {\n        int start = 0;\n        while (start < len && str.charAt(start) == '0') {\n            start++;\n        }\n        if (start == len) {\n            return -1;\n        }\n        int end = start;\n        while (end < len && str.charAt(end) >= '0' && str.charAt(end) <= '9') {\n            end++;\n        }\n        if (end == start) {\n            return -1;\n        }\n        if (end < len && str.charAt(end) == 'L') {\n            end++;\n        }\n        if (end == len) {\n            return Integer.parseInt(str.substring(start, end));\n        }\n    }\n    return -1;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        throw new IllegalArgumentException(\"Empty string not allowed\");\n    }\n    if (str.charAt(0) != '0') {\n        return Integer.parseInt(str);\n    }\n    if (len == 1) {\n        throw new IllegalArgumentException(\"Invalid index '0'\");\n    }\n    if (str.charAt(1) == '0') {\n        throw new IllegalArgumentException(\"Invalid index '0'\");\n    }\n    return Integer.parseInt(str);\n}"
    ],
    [
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n                                               k);\n    }\n\n    // Get a random permutation of the natural numbers { 0, 1, ..., c.size() - 1 }.\n    int[] index = nextPermutation(c.size(), k);\n\n    // Return a new array containing the first \"k\" entries of \"index\".\n    Object[] result = new Object[k];\n    for (int i = 0; i < k; i++) {\n        result[i] = c.toArray()[index[i]];\n    }\n    return result;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n                k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n                k);\n    }\n\n    int[] index = nextPermutation(c.size(), k);\n    Object[] result = new Object[k];\n    for (int i = 0; i < k; i++) {\n        result[i] = c.toArray()[index[i]];\n    }\n    return result;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n                                               k);\n    }\n\n    int[] index = nextPermutation(c.size(), k);\n    Object[] sample = new Object[k];\n    for (int i = 0; i < k; i++) {\n        sample[i] = c.toArray()[index[i]];\n    }\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n                                               k);\n    }\n\n    int[] index = nextPermutation(c.size(), k);\n    Object[] sample = new Object[k];\n    for (int i = 0; i < k; i++) {\n        sample[i] = c.toArray()[index[i]];\n    }\n\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_EXCEEDS_POPULATION_SIZE,\n                                            k, c.size(), false);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                                               k);\n    }\n\n    int[] index = nextPermutation(c.size(), k);\n    Object[] sample = new Object[k];\n    for (int i = 0; i < k; i++) {\n        sample[i] = c.toArray()[index[i]];\n    }\n\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_EXCEEDS_POPULATION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                                               k);\n    }\n\n    int[] index = nextPermutation(c.size(), k);\n    Object[] sample = new Object[k];\n    for (int i = 0; i < k; i++) {\n        sample[i] = c.toArray()[index[i]];\n    }\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_EXCEEDS_POPULATION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                                               k);\n    }\n\n    int[] index = nextPermutation(c.size(), k);\n    Object[] sample = new Object[k];\n    for (int i = 0; i < k; i++) {\n        sample[i] = c.toArray()[index[i]];\n    }\n\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_EXCEEDS_POPULATION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                                               k);\n    }\n\n    // Create a copy of the collection, and shuffle it.\n    List<?> list = new ArrayList<>(c);\n    MathArrays.shuffle(list, getRandomGenerator());\n\n    // Return a new array containing the first \"k\" entries of \"list\".\n    return MathArrays.copyOf(list, k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_EXCEEDS_POPULATION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                                               k);\n    }\n\n    int[] index = nextPermutation(c.size(), k);\n    Object[] sample = new Object[k];\n    for (int i = 0; i < k; i++) {\n        sample[i] = c.toArray()[index[i]];\n    }\n\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n                k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n                k);\n    }\n\n    int[] index = nextPermutation(c.size(), k);\n    Object[] result = new Object[k];\n    for (int i = 0; i < k; i++) {\n        result[i] = c.toArray()[index[i]];\n    }\n    return result;\n}"
    ],
    [
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  Node methodNameNode = IR.string(methodName);\n  methodNameNode.setStaticSourceFile(srcref.getStaticSourceFile());\n  methodNameNode.setLineno(srcref.getLineno());\n  methodNameNode.setCharno(srcref.getCharno());\n  Node callNode =\n      new Node(Token.CALL,\n               new Node(Token.GETPROP, argumentNode, methodNameNode));\n  callNode.setStaticSourceFile(srcref.getStaticSourceFile());\n  callNode.setLineno(srcref.getLineno());\n  callNode.setCharno(srcref.getCharno());\n  return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  Node callNode = new Node(Token.CALL, argumentNode);\n  callNode.setLineno(srcref.getLineno());\n  callNode.setCharno(srcref.getCharno());\n  Node nameNode = new Node(Token.NAME, methodName);\n  nameNode.setLineno(srcref.getLineno());\n  nameNode.setCharno(srcref.getCharno());\n  callNode.addChildToBack(nameNode);\n  return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  Node callNode = new Node(Token.CALL, argumentNode);\n  callNode.setLength(argumentNode.getLength());\n  callNode.setLineno(argumentNode.getLineno());\n  callNode.setCharno(argumentNode.getCharno());\n  callNode.setToken(Token.CALL);\n  callNode.setJSDocInfo(argumentNode.getJSDocInfo());\n  callNode.setOriginalName(argumentNode.getOriginalName());\n  callNode.setType(Token.CALL);\n  callNode.setSourceFileName(argumentNode.getSourceFileName());\n  callNode.setSourceFileName(argumentNode.getSourceFileName());\n  callNode.setProp(Node.FREE_CALL, true);\n  callNode.setProp(Node.FREE_CALL, true);\n  callNode.setProp(Node.FREE_CALL, true);\n  callNode.setProp(Node.FREE_CALL, true);\n  callNode.setProp(Node.FREE_CALL, true);\n  callNode.setProp(Node.FREE_CALL, true);\n  callNode.setProp(Node.FREE_CALL, true);\n  callNode.setProp(Node.FREE_CALL, true);\n  callNode.setProp(Node.FREE_CALL, true);\n  callNode.setProp(Node.FREE_CALL, true);\n  callNode.setProp(Node.FREE_CALL, true);\n  callNode.setProp(Node.FREE_CALL, true);\n  callNode.setProp(Node.FREE_CALL, true);\n  callNode.setProp(Node.FREE_CALL, true);\n  callNode.setProp(Node.FREE_CALL, true);\n  callNode.setProp(Node.FREE_CALL, true);\n  callNode.setProp(Node.FREE_CALL, true);\n  callNode.setProp(Node.FREE_CALL, true);\n  callNode.setProp(Node.FREE_CALL, true);\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  Node callNode = new Node(Token.CALL,\n      new Node(Token.GETPROP,\n          argumentNode,\n          Node.newString(Token.NAME, methodName)));\n  callNode.srcrefTree(srcref);\n  return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  Node callNode = new Node(Token.CALL, argumentNode);\n  callNode.setLineno(srcref.getLineno());\n  callNode.setCharno(srcref.getCharno());\n  Node nameNode = new Node(Token.NAME, methodName);\n  nameNode.setLineno(srcref.getLineno());\n  nameNode.setCharno(srcref.getCharno());\n  callNode.addChildToBack(nameNode);\n  return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  Node callNode = new Node(Token.CALL, argumentNode);\n  callNode.setLength(0);\n  callNode.setLineno(srcref.getLineno());\n  callNode.setCharno(srcref.getCharno());\n  callNode.setToken(Token.CALL);\n  callNode.setType(Token.CALL);\n  callNode.setJSDocInfo(argumentNode.getJSDocInfo());\n  callNode.setVarArgsElement(argumentNode.getVarArgsElement());\n  callNode.setIsSyntheticBlock(argumentNode.isSyntheticBlock());\n  callNode.setIsSyntheticBlock(argumentNode.isSyntheticBlock());\n  callNode.setIsSyntheticBlock(argumentNode.isSyntheticBlock());\n  callNode.setIsSyntheticBlock(argumentNode.isSyntheticBlock());\n  callNode.setIsSyntheticBlock(argumentNode.isSyntheticBlock());\n  callNode.setIsSyntheticBlock(argumentNode.isSyntheticBlock());\n  callNode.setIsSyntheticBlock(argumentNode.isSyntheticBlock());\n  callNode.setIsSyntheticBlock(argumentNode.isSyntheticBlock());\n  callNode.setIsSyntheticBlock(argumentNode.isSyntheticBlock());\n  callNode.setIsSyntheticBlock(argumentNode.isSyntheticBlock());\n  callNode.setIsSyntheticBlock(argumentNode.isSyntheticBlock());\n  callNode.setIsSyntheticBlock(argumentNode.isSyntheticBlock());\n  callNode.setIsSyntheticBlock(argumentNode.isSyntheticBlock());\n  callNode.setIsSyntheticBlock(argumentNode.isSyntheticBlock());\n  callNode.setIsSyntheticBlock(argumentNode.isSyntheticBlock());\n  callNode.setIsSyntheticBlock(argumentNode.isSyntheticBlock());\n  callNode.setIsSyntheticBlock(argumentNode.isSyntheticBlock());\n  callNode.setIsSyntheticBlock(argumentNode.isSyntheticBlock());\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  Node methodNameNode = IR.string(methodName);\n  Node callNode =\n      IR.call(\n          IR.getprop(\n              IR.name(\"$jscomp\"),\n              methodNameNode),\n          argumentNode);\n  callNode.srcref(srcref);\n  return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  Node callNode = new Node(Token.CALL,\n      new Node(Token.GETPROP, argumentNode,\n          new Node(Token.THIS, null, null, srcref)),\n      new Node(Token.NAME, methodName, srcref));\n  callNode.setLineno(srcref.getLineno());\n  callNode.setCharno(srcref.getCharno());\n  return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  Node callNode = new Node(Token.CALL, argumentNode);\n  callNode.setLineno(srcref.getLineno());\n  callNode.setCharno(srcref.getCharno());\n  callNode.setLength(srcref.getLength());\n  Node methodNameNode = new Node(Token.NAME, methodName);\n  methodNameNode.setLineno(srcref.getLineno());\n  methodNameNode.setCharno(srcref.getCharno());\n  methodNameNode.setLength(srcref.getLength());\n  callNode.addChildToBack(methodNameNode);\n  return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  Node callNode = new Node(Token.CALL,\n      new Node(Token.GETPROP, argumentNode,\n          new Node(Token.NAME, methodName, srcref)),\n      srcref);\n  callNode.setLength(argumentNode.getLength() + 1);\n  return callNode;\n}"
    ],
    [
      "private int[] sortedIndices(final double[] doubles)  {\n    int[] idx = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) \n    {\n        idx[i] = i;\n    }\n    Arrays.sort(idx, new Comparator<Integer>() \n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    int[] idx = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        idx[i] = i;\n    }\n    Arrays.sort(idx, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] idx = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        idx[i] = i;\n    }\n    final double[] vals = new double[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        vals[i] = doubles[i];\n    }\n    final int[] idxSorted = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        idxSorted[i] = idx[i];\n    }\n    for (int i = 0; i < doubles.length; i++) {\n        for (int j = i+1; j < doubles.length; j++) {\n            if (vals[i] > vals[j]) {\n                final int temp = idxSorted[i];\n                idxSorted[i] = idxSorted[j];\n                idxSorted[j] = temp;\n                final double temp2 = vals[i];\n                vals[i] = vals[j];\n                vals[j] = temp2;\n            }\n        }\n    }\n    return idxSorted;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = i;\n    }\n    final double[] copy = MathArrays.copyOf(doubles, doubles.length);\n    Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    int[] idx = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        idx[i] = i;\n    }\n    for (int i = 0; i < doubles.length; i++) {\n        for (int j = i + 1; j < doubles.length; j++) {\n            if (doubles[idx[i]] > doubles[idx[j]]) {\n                int swap = idx[i];\n                idx[i] = idx[j];\n                idx[j] = swap;\n            }\n        }\n    }\n    return idx;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    int[] idx = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        idx[i] = i;\n    }\n    Arrays.sort(idx, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    int[] idx = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        idx[i] = i;\n    }\n    for (int i = 0; i < doubles.length; i++) {\n        for (int j = i + 1; j < doubles.length; j++) {\n            if (doubles[idx[i]] < doubles[idx[j]]) {\n                int tmp = idx[i];\n                idx[i] = idx[j];\n                idx[j] = tmp;\n            }\n        }\n    }\n    return idx;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] idx = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        idx[i] = i;\n    }\n    final double[] copy = MathArrays.copyOf(doubles, doubles.length);\n    Arrays.sort(idx, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] idx = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        idx[i] = i;\n    }\n    Arrays.sort(idx, new Comparator<Integer>() {\n}\n}"
    ],
    [
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = buildQT();\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        final int m = householderVectors.length;\n        final double[][] data = new double[m][m];\n        for (int i = 0; i < m; ++i) {\n            final double[] householderVector = householderVectors[i];\n            for (int j = 0; j < i; ++j) {\n                data[i][j] = 0;\n            }\n            data[i][i] = householderVector[i];\n            for (int j = i + 1; j < m; ++j) {\n                data[i][j] = householderVector[j];\n            }\n        }\n        cachedQt = MatrixUtils.createRealMatrix(data);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = buildQT();\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = new Array2DRowRealMatrix(householderVectors, false);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        final int m = householderVectors.length;\n        final double[][] data = new double[m][m];\n        for (int i = 0; i < m; ++i) {\n            final double[] v = householderVectors[i];\n            for (int j = 0; j < m; ++j) {\n                data[i][j] = v[j];\n            }\n        }\n        cachedQt = MatrixUtils.createRealMatrix(data);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        final int m = householderVectors.length;\n        final double[][] qt = new double[m][m];\n        for (int i = 0; i < m; i++) {\n            final double[] qti = qt[i];\n            for (int j = 0; j < m; j++) {\n                qti[j] = householderVectors[j][i];\n            }\n        }\n        cachedQt = new BlockRealMatrix(qt);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        final int m = householderVectors.length;\n        final double[][] data = new double[m][m];\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < i; ++j) {\n                data[i][j] = 0;\n            }\n            data[i][i] = 1;\n        }\n        cachedQt = new BlockRealMatrix(data);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = buildQT();\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = new Array2DRowRealMatrix(householderVectors, false);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        final int m = householderVectors.length;\n        final double[][] qtData = new double[m][m];\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j <= i; ++j) {\n                qtData[i][j] = householderVectors[i][j];\n            }\n        }\n        cachedQt = new BlockRealMatrix(qtData);\n    }\n    return cachedQt;\n}"
    ],
    [
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) \n    {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) \n    {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) \n    {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) \n    {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}"
    ],
    [
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    final TransformedSet<E> decorated = new TransformedSet<E>(set, transformer);\n    if (set.size() > 0) {\n        final Set<E> decoratedAsSet = Collections.unmodifiableSet(decorated);\n        set.clear();\n        set.addAll(decoratedAsSet);\n    }\n    return decorated;\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    final TransformedSet<E> decorated = new TransformedSet<E>(set, transformer);\n    if (set.size() > 0) {\n        final Set<E> decoratedSet = decorated.decorated();\n        final Transformer<? super E, ? extends E> transformer = decorated.getTransformer();\n        for (final E element : set) {\n            decoratedSet.add(transformer.transform(element));\n        }\n    }\n    return decorated;\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}"
    ],
    [
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        expandCapacity(capacity);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        expandCapacity(capacity);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] newbuffer = new char[capacity];\n        System.arraycopy(buffer, 0, newbuffer, 0, size);\n        buffer = newbuffer;\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (buffer.length < capacity) {\n        expandCapacity(capacity);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] newbuffer = new char[capacity];\n        System.arraycopy(buffer, 0, newbuffer, 0, size);\n        buffer = newbuffer;\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] newbuffer = new char[capacity];\n        System.arraycopy(buffer, 0, newbuffer, 0, size);\n        buffer = newbuffer;\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (buffer.length < capacity) \n    {\n        expandCapacity(capacity);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (buffer.length < capacity) {\n        expandCapacity(capacity);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (buffer.length < capacity) \n    {\n        final int newCapacity = Math.max(buffer.length << 1, capacity);\n        buffer = Arrays.copyOf(buffer, newCapacity);\n    }\n    return this;\n}"
    ],
    [
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    // check arguments\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    // find the range\n    Range result = null;\n    int seriesCount = dataset.getRowCount();\n    for (int series = 0; series < seriesCount; series++) {\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int itemCount = dataset.getColumnCount();\n        for (int item = 0; item < itemCount; item++) {\n            double value = dataset.getValue(series, item).doubleValue();\n            if (!Double.isNaN(value)) {\n                if (value < minimum) {\n                    minimum = value;\n                }\n                if (value > maximum) {\n                    maximum = value;\n                }\n            }\n        }\n        if (minimum <= maximum) {\n            if (result == null) {\n                result = new Range(minimum, maximum);\n            }\n            else {\n                result = result.add(minimum, maximum);\n            }\n        }\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    // check arguments\n    if (dataset == null)\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n\n    // find the range\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getRowCount();\n    for (int series = 0; series < seriesCount; series++)\n    {\n        double total = 0.0;\n        int itemCount = dataset.getColumnCount();\n        for (int item = 0; item < itemCount; item++)\n        {\n            double value = dataset.getValue(series, item);\n            if (!Double.isNaN(value))\n            {\n                total += value;\n                if (total < minimum)\n                    minimum = total;\n                if (total > maximum)\n                    maximum = total;\n            }\n        }\n    }\n\n    // return the result\n    if (minimum <= maximum)\n        return new Range(minimum, maximum);\n    else\n        return null;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    // check arguments\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    // find the range bounds\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    for (int series = 0; series < dataset.getRowCount(); series++) {\n        double total = 0.0;\n        for (int item = 0; item < dataset.getColumnCount(); item++) {\n            double value = dataset.getValue(series, item).doubleValue();\n            if (!Double.isNaN(value)) {\n                total += value;\n                if (total < minimum) {\n                    minimum = total;\n                }\n                if (total > maximum) {\n                    maximum = total;\n                }\n            }\n        }\n    }\n\n    // return the result\n    if (minimum <= maximum) {\n        return new Range(minimum, maximum);\n    }\n    else {\n        return null;\n    }\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    // check arguments\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    // find the range\n    Range result = null;\n    int columnCount = dataset.getColumnCount();\n    for (int column = 0; column < columnCount; column++) {\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int rowCount = dataset.getRowCount(column);\n        for (int row = 0; row < rowCount; row++) {\n            double value = dataset.getValue(row, column).doubleValue();\n            if (!Double.isNaN(value)) {\n                minimum = Math.min(minimum, value);\n                maximum = Math.max(maximum, value);\n            }\n        }\n        if (minimum <= maximum) {\n            if (result == null) {\n                result = new Range(minimum, maximum);\n            }\n            else {\n                result = result.add(minimum, maximum);\n            }\n        }\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    // check arguments\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    // find the range\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    for (int item = 0; item < dataset.getItemCount(); item++) {\n        double total = 0.0;\n        for (int series = 0; series < dataset.getSeriesCount(); series++) {\n            double value = dataset.getValue(series, item).doubleValue();\n            if (!Double.isNaN(value)) {\n                total = total + value;\n            }\n        }\n        if (total < minimum) {\n            minimum = total;\n        }\n        if (total > maximum) {\n            maximum = total;\n        }\n    }\n\n    // return the range\n    if (minimum <= maximum) {\n        return new Range(minimum, maximum);\n    } else {\n        return null;\n    }\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    int columnCount = dataset.getColumnCount();\n    for (int column = 0; column < columnCount; column++) {\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int rowCount = dataset.getRowCount(column);\n        for (int row = 0; row < rowCount; row++) {\n            double value = dataset.getValue(row, column).doubleValue();\n            if (!Double.isNaN(value)) {\n                minimum = Math.min(minimum, value);\n                maximum = Math.max(maximum, value);\n            }\n        }\n        if (minimum <= maximum) {\n            if (result == null) {\n                result = new Range(minimum, maximum);\n            }\n            else {\n                result = result.add(minimum, maximum);\n            }\n        }\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    // check arguments\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    // find the maximum and minimum values\n    double minimum = Double.MAX_VALUE;\n    double maximum = -Double.MAX_VALUE;\n    for (int series = 0; series < dataset.getRowCount(); series++) {\n        double total = 0.0;\n        for (int item = 0; item < dataset.getColumnCount(); item++) {\n            double value = dataset.getValue(series, item).doubleValue();\n            if (!Double.isNaN(value)) {\n                total += value;\n            }\n            if (total < minimum) {\n                minimum = total;\n            }\n            if (total > maximum) {\n                maximum = total;\n            }\n        }\n    }\n\n    // return the result\n    if (minimum <= maximum) {\n        return new Range(minimum, maximum);\n    } else {\n        return null;\n    }\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    // check arguments\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    // find the range\n    Range result = null;\n    int columnCount = dataset.getColumnCount();\n    for (int column = 0; column < columnCount; column++) {\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int rowCount = dataset.getRowCount(column);\n        for (int row = 0; row < rowCount; row++) {\n            double value = dataset.getValue(row, column).doubleValue();\n            if (!Double.isNaN(value)) {\n                if (value < minimum) {\n                    minimum = value;\n                }\n                if (value > maximum) {\n                    maximum = value;\n                }\n            }\n        }\n        if (minimum < maximum) {\n            if (result == null) {\n                result = new Range(minimum, maximum);\n            }\n            else {\n                result = result.add(minimum, maximum);\n            }\n        }\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getRowCount();\n    for (int series = 0; series < seriesCount; series++) {\n        double cumulative = 0.0;\n        int itemCount = dataset.getColumnCount(series);\n        for (int item = 0; item < itemCount; item++) {\n            double value = dataset.getValue(series, item).doubleValue();\n            if (!Double.isNaN(value)) {\n                cumulative += value;\n                if (cumulative < minimum) {\n                    minimum = cumulative;\n                }\n                if (cumulative > maximum) {\n                    maximum = cumulative;\n                }\n            }\n        }\n    }\n    if (minimum <= maximum) {\n        return new Range(minimum, maximum);\n    }\n    else {\n        return null;\n    }\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    // check arguments\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    // find the range\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getRowCount();\n    for (int series = 0; series < seriesCount; series++) {\n        double runningTotal = 0.0;\n        int itemCount = dataset.getColumnCount();\n        for (int item = 0; item < itemCount; item++) {\n            double value = dataset.getValue(series, item);\n            if (!Double.isNaN(value)) {\n                runningTotal = runningTotal + value;\n                if (runningTotal < minimum) {\n                    minimum = runningTotal;\n                }\n                if (runningTotal > maximum) {\n                    maximum = runningTotal;\n                }\n            }\n        }\n    }\n\n    // return the result\n    if (minimum <= maximum) {\n        return new Range(minimum, maximum);\n    } else {\n        return null;\n    }\n}"
    ],
    [
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset > 23 || hoursOffset < -23) {\n        throw new IllegalArgumentException(\"The hour offset must be within -23 and +23\");\n    }\n    if (minutesOffset > 59 || minutesOffset < -59) {\n        throw new IllegalArgumentException(\"The minute offset must be within -59 and +59\");\n    }\n    if (minutesOffset < 0 && hoursOffset > 0) {\n        throw new IllegalArgumentException(\"The minute offset must be zero or positive when the hour offset is positive\");\n    }\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return DateTimeZone.UTC;\n    }\n    int offset = hoursOffset * 60 + minutesOffset;\n    if (offset > 23 * 60 + 59 || offset < -23 * 60 - 59) {\n        throw new IllegalArgumentException(\"The offset exceeds +/- 23:59:59.000\");\n    }\n    String id = printOffset(offset);\n    return fixedOffsetZone(id, offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset > 23 || hoursOffset < -23) {\n        throw new IllegalArgumentException(\"Hours offset exceeds +/- 23\");\n    }\n    if (minutesOffset > 59 || minutesOffset < -59) {\n        throw new IllegalArgumentException(\"Minutes offset exceeds +/- 59\");\n    }\n    if (hoursOffset < 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes must be positive when hours are negative\");\n    }\n    int totalMinutes = hoursOffset * 60 + minutesOffset;\n    if (totalMinutes == 0) {\n        return DateTimeZone.UTC;\n    }\n    if (totalMinutes > 23 * 60 + 59 || totalMinutes < -23 * 60 - 59) {\n        throw new IllegalArgumentException(\"Total offset exceeds +/- 23:59:59.000\");\n    }\n    return fixedOffsetZone(printOffset(totalMinutes), totalMinutes);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"The hours offset is out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"The minutes offset is out of range: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"The minutes offset must be positive when the hours offset is positive: \" + hoursOffset + \", \" + minutesOffset);\n    }\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return DateTimeZone.UTC;\n    }\n    int totalMinutes = hoursOffset * 60 + minutesOffset;\n    if (totalMinutes == 0) {\n        return DateTimeZone.UTC;\n    }\n    if (totalMinutes == 15) {\n        return fixedOffsetZone(\"Etc/GMT-15\", -15 * 60);\n    }\n    if (totalMinutes == -15) {\n        return fixedOffsetZone(\"Etc/GMT+15\", 15 * 60);\n    }\n    if (totalMinutes == 30) {\n        return fixedOffsetZone(\"Etc/GMT-14\", -14 * 60);\n    }\n    if (totalMinutes == -30) {\n        return fixedOffsetZone(\"Etc/GMT+14\", 14 * 60);\n    }\n    if (totalMinutes == 45) {\n        return fixedOffsetZone(\"Etc/GMT-13\", -13 * 60);\n    }\n    if (totalMinutes == -45) {\n        return fixedOffsetZone(\"Etc/GMT+13\", 13 * 60);\n    }\n    if (totalMinutes == 60) {\n        return fixedOffsetZone(\"Etc/GMT-12\", -12 * 60);\n    }\n    if (totalMinutes == -60) {\n}\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (minutesOffset < 0 && hoursOffset > 0) {\n        throw new IllegalArgumentException(\"Minutes must be positive or zero when hours is positive\");\n    }\n    int totalMinutes = hoursOffset * 60 + minutesOffset;\n    if (totalMinutes == 0) {\n        return DateTimeZone.UTC;\n    }\n    if (totalMinutes > 23 * 60 + 59 || totalMinutes < -23 * 60 - 59) {\n        throw new IllegalArgumentException(\"Total minutes out of range: \" + totalMinutes);\n    }\n    return fixedOffsetZone(printOffset(totalMinutes), totalMinutes);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"The hour offset must be within -23 and +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"The minute offset must be within -59 and +59\");\n    }\n    if (minutesOffset < 0 && hoursOffset > 0) {\n        throw new IllegalArgumentException(\"The minute offset must be zero or positive when the hour offset is positive\");\n    }\n    long totalMillis = (hoursOffset * 60L + minutesOffset) * DateTimeConstants.MILLIS_PER_MINUTE;\n    if (totalMillis > 23 * DateTimeConstants.MILLIS_PER_HOUR + 59 * DateTimeConstants.MILLIS_PER_MINUTE) {\n        throw new IllegalArgumentException(\"The offset exceeds +/- 23:59:59.000\");\n    }\n    return fixedOffsetZone(printOffset(totalMillis), totalMillis);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) \n    {\n        throw new IllegalArgumentException(\"The hour offset must be within -23 and +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) \n    {\n        throw new IllegalArgumentException(\"The minute offset must be within -59 and +59\");\n    }\n    if (minutesOffset < 0 && hoursOffset > 0) \n    {\n        throw new IllegalArgumentException(\"The minute offset must be positive when the hour offset is positive\");\n    }\n    if (hoursOffset == 0 && minutesOffset == 0) \n    {\n        return DateTimeZone.UTC;\n    }\n    int totalMinutes = hoursOffset * 60 + minutesOffset;\n    if (totalMinutes == 0) \n    {\n        return DateTimeZone.UTC;\n    }\n    if (totalMinutes > 23 * 60 + 59 || totalMinutes < -23 * 60 - 59) \n    {\n        throw new IllegalArgumentException(\"The total offset must be within +/- 23:59:59.000\");\n    }\n    return fixedOffsetZone(printOffset(totalMinutes), totalMinutes);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset > 23 || hoursOffset < -23) {\n        throw new IllegalArgumentException(\"The hour offset must be within -23 and +23\");\n    }\n    if (minutesOffset > 59 || minutesOffset < -59) {\n        throw new IllegalArgumentException(\"The minute offset must be within -59 and +59\");\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"The minute offset must not be negative when the hour offset is positive\");\n    }\n    int offsetMillis = (hoursOffset * 60 + minutesOffset) * 60 * 1000;\n    if (offsetMillis > 23 * 60 * 60 * 1000 || offsetMillis < -23 * 60 * 60 * 1000) {\n        throw new IllegalArgumentException(\"The offset exceeds +/- 23:59:59.000\");\n    }\n    return fixedOffsetZone(printOffset(offsetMillis), offsetMillis);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"The hour offset must be within -23 and +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"The minute offset must be within -59 and +59\");\n    }\n    if (minutesOffset < 0 && hoursOffset > 0) {\n        throw new IllegalArgumentException(\"The minute offset must not be negative when the hour offset is positive\");\n    }\n    int totalMinutes = hoursOffset * 60 + minutesOffset;\n    if (totalMinutes == 0) {\n        return DateTimeZone.UTC;\n    } else if (totalMinutes > 0) {\n        return fixedOffsetZone(printOffset(totalMinutes), totalMinutes);\n    } else {\n        return fixedOffsetZone(printOffset(totalMinutes), totalMinutes);\n    }\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset > 23 || hoursOffset < -23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset > 59 || minutesOffset < -59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes must be positive when hours are positive\");\n    }\n    int totalOffset = hoursOffset * 60 + minutesOffset;\n    if (totalOffset > 23 * 60 + 59 || totalOffset < -23 * 60 - 59) {\n        throw new IllegalArgumentException(\"Total offset out of range: \" + totalOffset);\n    }\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return DateTimeZone.UTC;\n    }\n    if (hoursOffset > 0) {\n        return fixedOffsetZone(printOffset(totalOffset), totalOffset);\n    }\n    return fixedOffsetZone(printOffset(totalOffset), -totalOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset > 23 || hoursOffset < -23) {\n        throw new IllegalArgumentException(\"The hour offset must be within -23 and +23\");\n    }\n    if (minutesOffset > 59 || minutesOffset < -59) {\n        throw new IllegalArgumentException(\"The minute offset must be within -59 and +59\");\n    }\n    if (minutesOffset < 0 && hoursOffset > 0) {\n        throw new IllegalArgumentException(\"The minute offset must be zero or positive when the hour offset is positive\");\n    }\n    int offsetMillis = hoursOffset * 3600000 + minutesOffset * 60000;\n    if (offsetMillis < -23 * 3600000 - 59 * 60000 || offsetMillis > 23 * 3600000 + 59 * 60000) {\n        throw new IllegalArgumentException(\"The offset exceeds +/- 23:59:59.000\");\n    }\n    return fixedOffsetZone(printOffset(offsetMillis), offsetMillis);\n}"
    ],
    [
      "public String chompBalanced(char open, char close)  {\n    int start = pos;\n    int depth = 0;\n    boolean inQuote = false;\n    boolean escaped = false;\n    while (pos < queue.length()) \n    {\n        char c = queue.charAt(pos);\n        if (c == open && !inQuote && !escaped) \n        {\n            depth++;\n        } \n        else if (c == close && !inQuote && !escaped) \n        {\n            depth--;\n            if (depth < 0) \n            {\n                break;\n            }\n        } \n        else if (c == '\"' || c == '\\'') \n        {\n            inQuote = !inQuote;\n        } \n        else if (c == '\\\\' && escaped == false) \n        {\n            escaped = true;\n        } \n        else \n        {\n            escaped = false;\n        }\n        pos++;\n    }\n    String data = queue.substring(start, pos);\n    pos++;\n    return data;\n}",
      "public String chompBalanced(char open, char close)  {\n    if (isEmpty())\n        return \"\";\n    int start = -1;\n    int end = -1;\n    int max = this.length();\n    Stack<Character> stack = new Stack<Character>();\n    for (int i = pos; i < max; i++) {\n        char c = queue.charAt(i);\n        if (c == open) {\n            stack.push(c);\n            if (start == -1)\n                start = i + 1;\n        }\n        else if (c == close) {\n            if (stack.empty()) {\n                end = i;\n                break;\n            }\n            else\n                stack.pop();\n        }\n    }\n    if (end == -1)\n        end = max;\n    String data = queue.substring(start, end);\n    pos = end;\n    return data;\n}",
      "public String chompBalanced(char open, char close)  {\n    if (isEmpty())\n        return \"\";\n    int start = -1;\n    int end = -1;\n    int depth = 0;\n    boolean inQuote = false;\n    boolean inEscape = false;\n    for (int i = pos; i < queue.length(); i++)\n    {\n        char c = queue.charAt(i);\n        if (inEscape)\n        {\n            inEscape = false;\n            continue;\n        }\n        else if (c == '\\\\')\n        {\n            inEscape = true;\n            continue;\n        }\n        else if (c == open && !inQuote)\n        {\n            depth++;\n            if (start == -1)\n                start = i + 1;\n        }\n        else if (c == close && !inQuote)\n        {\n            depth--;\n            if (depth == 0)\n            {\n                end = i;\n                break;\n            }\n        }\n        else if (c == '\\'' || c == '\"')\n        {\n            inQuote = !inQuote;\n        }\n    }\n    if (start == -1 || end == -1)\n        return \"\";\n    String data = queue.substring(start, end);\n    pos = end;\n    return data;\n}",
      "public String chompBalanced(char open, char close)  {\n    if (isEmpty())\n        return \"\";\n    int start = -1;\n    int end = -1;\n    int max = this.length();\n    boolean inQuote = false;\n    boolean inEscape = false;\n    char last = ' ';\n    for (int i = pos; i < max; i++) {\n        char c = queue.charAt(i);\n        if (c == open) {\n            if (!inEscape) {\n                if (start == -1)\n                    start = i;\n                else\n                    inQuote = !inQuote;\n            }\n        }\n        else if (c == close) {\n            if (!inEscape) {\n                if (end == -1)\n                    end = i;\n                else\n                    inQuote = !inQuote;\n            }\n        }\n        else if (c == '\\\\' && last != '\\\\')\n            inEscape = !inEscape;\n        else\n            inEscape = false;\n        last = c;\n    }\n    if (end == -1)\n        return \"\";\n    String data = queue.substring(pos, start);\n    pos = end + 1;\n    return data;\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = pos;\n    Stack<Character> stack = new Stack<Character>();\n    while (!isEmpty()) {\n        char c = queue.charAt(pos);\n        if (c == open) {\n            stack.push(c);\n        }\n        else if (c == close) {\n            if (stack.size() == 0) break;\n            stack.pop();\n        }\n        pos++;\n    }\n    String data = queue.substring(start, pos);\n    pos++; // consume the close\n    return data;\n}",
      "public String chompBalanced(char open, char close)  {\n    if (isEmpty())\n        return \"\";\n    int start = -1;\n    int end = -1;\n    int max = this.length();\n    boolean inQuote = false;\n    boolean inEscape = false;\n    Stack<Character> stack = new Stack<Character>();\n    for (int i = 0; i < max; i++)\n    {\n        char c = this.charAt(i);\n        if (c == open)\n        {\n            if (!inEscape)\n            {\n                if (inQuote)\n                    stack.push(c);\n                else\n                {\n                    start = i + 1;\n                    break;\n                }\n            }\n            else\n                inEscape = false;\n        }\n        else if (c == close)\n        {\n            if (!inEscape)\n            {\n                if (inQuote)\n                    stack.push(c);\n                else\n                {\n                    end = i;\n                    break;\n                }\n            }\n            else\n                inEscape = false;\n        }\n        else if (c == '\"' || c == '\\'')\n        {\n            if (!inEscape)\n            {\n                inQuote = !inQuote;\n                if (!inQuote && start != -1 && end == -1)\n                    end = i;\n            }\n            else\n                inEscape = false;\n        }\n        else if (c == '\\\\')\n        {\n            if (i < max - 1 && !inQuote)\n            {\n                inEscape = true;\n            }\n        }\n    }\n    if (end == -1 || start == end)\n        return \"\";\n    String data = this.substring(start, end);\n    for (int i = 0; i < data.length(); i++)\n    {\n        char c = data.charAt(i);\n        if (c == '\"' || c == '\\'')\n            data = data.replace(c, ' ');\n    }\n    this.pos = end;\n    return data;\n}",
      "public String chompBalanced(char open, char close)  {\n    if (isEmpty()) return \"\";\n\n    Stack<Character> stack = new Stack<Character>();\n    StringBuilder sb = new StringBuilder();\n    for (int i = pos; i < queue.length(); i++) {\n        char c = queue.charAt(i);\n        if (c == open) {\n            stack.push(c);\n        } else if (c == close) {\n            if (stack.isEmpty()) break;\n            char o = stack.pop();\n            if (o != open) {\n                stack.push(o);\n            }\n        }\n        sb.append(c);\n    }\n    String data = sb.toString();\n    pos += data.length();\n    return data;\n}",
      "public String chompBalanced(char open, char close)  {\n    if (isEmpty())\n        return \"\";\n    int start = -1;\n    int end = -1;\n    int max = this.length();\n    Stack<Character> stack = new Stack<Character>();\n    for (int i = pos; i < max; i++) {\n        char c = queue.charAt(i);\n        if (c == open) {\n            stack.push(c);\n            if (start == -1)\n                start = i + 1;\n        }\n        else if (c == close) {\n            if (stack.isEmpty()) {\n                end = i;\n                break;\n            }\n            stack.pop();\n        }\n    }\n    if (end == -1)\n        end = max;\n    String data = queue.substring(start, end);\n    pos = end;\n    return data;\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = pos;\n    char closeQuote = 0;\n    char openQuote = 0;\n    int depth = 0;\n    while (pos < queue.length()) \n    {\n        char c = queue.charAt(pos);\n        pos++;\n\n        // are we inside a quoted block?\n        if (depth > 0 && c == closeQuote) \n        {\n            depth--;\n            closeQuote = 0;\n            continue;\n        }\n        else if (depth > 0 && c == openQuote) \n        {\n            continue;\n        }\n        else if (c == close) \n        {\n            if (depth > 0) \n            {\n                depth--;\n                continue;\n            }\n            else \n            {\n                break;\n            }\n        }\n        else if (c == open) \n        {\n            depth++;\n            continue;\n        }\n        else if (c == '\\\\' && pos < queue.length()) \n        {\n            // escape. move onto the next and don't increment depth\n            pos++;\n            continue;\n        }\n        else if (closeQuote == 0 && c == '\\'' || c == '\"') \n        {\n            // find a close quote, and leave it on the queue.\n            closeQuote = c;\n            continue;\n        }\n        else if (openQuote == 0 && c == '\\'' || c == '\"') \n        {\n            // find an open quote, and leave it on the queue.\n            openQuote = c;\n            continue;\n        }\n    }\n    return queue.substring(start, pos);\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = pos;\n    int depth = 0;\n    boolean inQuote = false;\n    boolean inEscape = false;\n    while (pos < queue.length()) \n    {\n        char c = queue.charAt(pos);\n        if (inEscape) \n        {\n            inEscape = false;\n        } \n        else if (c == open) \n        {\n            if (!inQuote) \n            {\n                depth++;\n            }\n        } \n        else if (c == close) \n        {\n            if (!inQuote) \n            {\n                depth--;\n                if (depth == 0) \n                {\n                    break;\n                }\n            }\n        } \n        else if (c == '\"' || c == '\\'') \n        {\n            inQuote = !inQuote;\n        } \n        else if (c == '\\\\') \n        {\n            inEscape = true;\n        }\n        pos++;\n    }\n    String data = queue.substring(start, pos);\n    pos++;\n    return data;\n}"
    ],
    [
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final RealMatrix xTransposeX = qr.getQ().transpose().multiply(qr.getR());\n        final int p = getBeta().getDimension();\n        return xTransposeX.subMatrix(0, p - 1, 0, p - 1).inverse();\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final int n = getX().getRowDimension();\n        final int p = getBeta().getDimension();\n        final RealMatrix r = qr.getR();\n        final RealMatrix invR = r.subMatrix(0, p - 1, 0, p - 1).inverse();\n        return invR.multiply(n - 1).scalarMultiply(invR.getEntry(0, 0));\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        return qr.getSolver().solve(getX().transpose().multiply(getX())).inverse();\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final int p = getX().getColumnDimension();\n        final int n = getX().getRowDimension();\n        final RealMatrix r = qr.getR();\n        final RealMatrix rr = r.getSubMatrix(0, p - 1, 0, p - 1);\n        return rr.transpose().multiply(rr).scalarMultiply(1.0 / (n - p)).subtract(\n                new DiagonalMatrix(new double[p]));\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final int p = getBeta().getDimension();\n        final QRDecomposition qr = new QRDecomposition(getX());\n        final RealMatrix r = qr.getR();\n        final RealMatrix rTranspose = r.transpose();\n        final RealMatrix rTransposeR = rTranspose.multiply(r);\n        final RealMatrix rTransposeRInverse = new LUDecomposition(rTransposeR).getSolver().getInverse();\n        return rTransposeRInverse.getSubMatrix(0, p - 1, 0, p - 1);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final RealMatrix xTransposeX = qr.getR().transpose().multiply(qr.getR());\n        final int p = getBeta().getDimension();\n        return xTransposeX.subMatrix(0, p - 1, 0, p - 1).inverse();\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        return qr.getSolver().solve(getX().transpose().multiply(getX())).inverse();\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final int n = getX().getRowDimension();\n        final int p = getBeta().getDimension();\n        final RealMatrix xTx = qr.getR().getSubMatrix(0, p - 1, 0, n - 1).transpose().multiply(qr.getR().getSubMatrix(0, p - 1, 0, n - 1));\n        return xTx.scalarMultiply(1 / (n - p)).subtract(getBeta().scalarMultiply(getBeta().transpose()).scalarMultiply(1 / (n - p)));\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final int n = getX().getRowDimension();\n        final int p = getBeta().getDimension();\n        final RealMatrix xTx = qr.getR().getSubMatrix(0, p - 1, 0, n - 1);\n        final RealMatrix xTxInv = new LUDecomposition(xTx).getSolver().getInverse();\n        return xTxInv;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        return qr.getSolver().solve(getX().transpose().multiply(getX())).inverse();\n    }"
    ],
    [
      "private static String printOffset(int offset)  {\n    // TODO: Consider caching the formatter\n    return offsetFormatter().print(offset);\n}",
      "private static String printOffset(int offset)  {\n    if (offset == 0) {\n        return \"+00:00\";\n    }\n    boolean negative = offset < 0;\n    int absOffset = Math.abs(offset);\n    int hours = absOffset / DateTimeConstants.MILLIS_PER_HOUR;\n    int minutes = (absOffset - (hours * DateTimeConstants.MILLIS_PER_HOUR)) / DateTimeConstants.MILLIS_PER_MINUTE;\n    return (negative ? \"-\" : \"+\") + String.format(\"%02d:%02d\", hours, minutes);\n}",
      "private static String printOffset(int offset)  {\n    // This is a copy of DateTimeFormat.offsetFormatter().print(offset)\n    // with the addition of the colon.\n    int absOffset = Math.abs(offset);\n    int hours = absOffset / DateTimeConstants.MILLIS_PER_HOUR;\n    int minutes = (absOffset - (hours * DateTimeConstants.MILLIS_PER_HOUR)) / DateTimeConstants.MILLIS_PER_MINUTE;\n    StringBuffer buf = new StringBuffer(5);\n    if (offset < 0) {\n        buf.append('-');\n    } else {\n        buf.append('+');\n    }\n    if (hours < 10) {\n        buf.append('0');\n    }\n    buf.append(hours);\n    buf.append(':');\n    if (minutes < 10) {\n        buf.append('0');\n    }\n    buf.append(minutes);\n    return buf.toString();\n}",
      "private static String printOffset(int offset)  {\n    if (offset == 0) {\n        return \"Z\";\n    }\n    int absOffset = Math.abs(offset);\n    int hours = absOffset / DateTimeConstants.MILLIS_PER_HOUR;\n    int minutes = (absOffset - (hours * DateTimeConstants.MILLIS_PER_HOUR)) / DateTimeConstants.MILLIS_PER_MINUTE;\n    char sign = offset < 0 ? '-' : '+';\n    return sign + String.format(\"%02d\", hours) + String.format(\"%02d\", minutes);\n}",
      "private static String printOffset(int offset)  {\n    // Can't use a real chronology if called during class\n    // initialization. Offset parser doesn't need it anyhow.\n}",
      "private static String printOffset(int offset)  {\n    if (offset == 0) {\n        return \"Z\";\n    }\n    int absOffset = Math.abs(offset);\n    int hours = absOffset / DateTimeConstants.MILLIS_PER_HOUR;\n    int minutes = (absOffset - (hours * DateTimeConstants.MILLIS_PER_HOUR)) / DateTimeConstants.MILLIS_PER_MINUTE;\n    String hourStr = Integer.toString(hours);\n    String minuteStr = Integer.toString(minutes);\n    if (offset < 0) {\n        return \"GMT-\" + (hourStr.length() == 1 ? \"0\" + hourStr : hourStr) + \":\" + (minuteStr.length() == 1 ? \"0\" + minuteStr : minuteStr);\n    } else {\n        return \"GMT+\" + (hourStr.length() == 1 ? \"0\" + hourStr : hourStr) + \":\" + (minuteStr.length() == 1 ? \"0\" + minuteStr : minuteStr);\n    }\n}",
      "private static String printOffset(int offset)  {\n    int absOffset = Math.abs(offset);\n    int hours = absOffset / DateTimeConstants.MILLIS_PER_HOUR;\n    int minutes = (absOffset - (hours * DateTimeConstants.MILLIS_PER_HOUR)) / DateTimeConstants.MILLIS_PER_MINUTE;\n    String sign = (offset >= 0 ? \"+\" : \"-\");\n    return sign + String.format(\"%02d:%02d\", hours, minutes);\n}",
      "private static String printOffset(int offset)  {\n    int absOffset = Math.abs(offset);\n    int hours = absOffset / DateTimeConstants.MILLIS_PER_HOUR;\n    int minutes = (absOffset - (hours * DateTimeConstants.MILLIS_PER_HOUR)) / DateTimeConstants.MILLIS_PER_MINUTE;\n    StringBuffer buf = new StringBuffer();\n    if (offset < 0) {\n        buf.append('-');\n    } else {\n        buf.append('+');\n    }\n    if (hours < 10) {\n        buf.append('0');\n    }\n    buf.append(hours);\n    buf.append(':');\n    if (minutes < 10) {\n        buf.append('0');\n    }\n    buf.append(minutes);\n    return buf.toString();\n}",
      "private static String printOffset(int offset)  {\n    if (offset == 0) \n    {\n        return \"Z\";\n    }\n    int absOffset = Math.abs(offset);\n    int hours = absOffset / DateTimeConstants.MILLIS_PER_HOUR;\n    int minutes = (absOffset - (hours * DateTimeConstants.MILLIS_PER_HOUR)) / DateTimeConstants.MILLIS_PER_MINUTE;\n    char sign = (offset < 0) ? '-' : '+';\n    return sign + String.format(\"%02d:%02d\", hours, minutes);\n}",
      "private static String printOffset(int offset)  {\n    if (offset == 0) {\n        return \"+00:00\";\n    }\n    boolean negative = offset < 0;\n    int absOffset = Math.abs(offset);\n    int hours = absOffset / DateTimeConstants.MILLIS_PER_HOUR;\n    int minutes = (absOffset - (hours * DateTimeConstants.MILLIS_PER_HOUR)) / DateTimeConstants.MILLIS_PER_MINUTE;\n    String hourStr = String.format(\"%02d\", hours);\n    String minuteStr = String.format(\"%02d\", minutes);\n    String prefix = negative ? \"-\" : \"+\";\n    return prefix + hourStr + \":\" + minuteStr;\n}"
    ],
    [
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Integer index = (Integer) this.indexMap.get(key);\n    if (index == null) {\n        return -1;\n    }\n    else {\n        return index.intValue();\n    }\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Integer i = (Integer) this.indexMap.get(key);\n    if (i == null) {\n        return -1;\n    }\n    else {\n        return i.intValue();\n    }\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Integer index = (Integer) this.indexMap.get(key);\n    if (index == null) {\n        return -1;\n    }\n    else {\n        return index.intValue();\n    }\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Integer i = (Integer) this.indexMap.get(key);\n    if (i == null) {\n        return -1;\n    }\n    else {\n        return i.intValue();\n    }\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Integer index = (Integer) this.indexMap.get(key);\n    if (index == null) {\n        return -1;\n    }\n    else {\n        return index.intValue();\n    }\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Integer i = (Integer) this.indexMap.get(key);\n    if (i == null) {\n        return -1;\n    }\n    else {\n        return i.intValue();\n    }\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Integer i = (Integer) this.indexMap.get(key);\n    if (i == null) {\n        return -1;\n    }\n    else {\n        return i.intValue();\n    }\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Integer index = (Integer) this.indexMap.get(key);\n    if (index == null) {\n        return -1;\n    }\n    else {\n        return index.intValue();\n    }\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Integer index = (Integer) this.indexMap.get(key);\n    if (index == null) {\n        return -1;\n    }\n    else {\n        return index.intValue();\n    }\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Integer index = (Integer) this.indexMap.get(key);\n    if (index == null) {\n        return -1;\n    }\n    else {\n        return index.intValue();\n    }\n}"
    ],
    [
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> flowSlots = new HashMap<>();\n  for (StaticSlot<JSType> slot : this.cache.dirtySymbols) {\n    flowSlots.put(slot.getName(), slot);\n  }\n  for (StaticSlot<JSType> slot : this.cache.cleanSymbols) {\n    flowSlots.put(slot.getName(), slot);\n  }\n  return flowSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> flowSlots = new HashMap<>();\n  for (StaticSlot<JSType> slot : getAllSlots()) {\n    if (slot.getType() != null) {\n      flowSlots.put(slot.getName(), slot);\n    }\n  }\n  return flowSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n  for (StaticSlot<JSType> slot : cache.slots) {\n    if (slot.isScopeChanged()) {\n      slots.put(slot.getName(), slot);\n    }\n  }\n  return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> result = new HashMap<>();\n  for (StaticSlot<JSType> slot : cache.slots) {\n    if (slot.isDefined()) {\n      result.put(slot.getName(), slot);\n    }\n  }\n  return result;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n  for (StaticSlot<JSType> slot : cache.dirtySymbols) {\n    slots.put(slot.getName(), slot);\n  }\n  return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n  for (StaticSlot<JSType> slot : cache.dirtySymbols) {\n    slots.put(slot.getName(), slot);\n  }\n  for (StaticSlot<JSType> slot : cache.cleanSymbols) {\n    slots.put(slot.getName(), slot);\n  }\n  return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n  for (String name : cache.dirtySymbols) {\n    slots.put(name, getSlot(name));\n  }\n  return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n  for (StaticSlot<JSType> slot : getAllSlots()) {\n    if (slot.isDeclared() && !slot.isUndeclared()) {\n      slots.put(slot.getName(), slot);\n    }\n  }\n  return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> result = new HashMap<>();\n  for (String name : cache.dirtySymbols) {\n    result.put(name, getSlot(name));\n  }\n  return result;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> flowSlots = new HashMap<>();\n  for (StaticSlot<JSType> slot : cache.dirtySymbols) {\n    flowSlots.put(slot.getName(), slot);\n  }\n  for (StaticSlot<JSType> slot : cache.cleanSymbols) {\n    flowSlots.put(slot.getName(), slot);\n  }\n  return flowSlots;\n}"
    ],
    [
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}"
    ],
    [
      "public static double atanh(double a)  {\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n\n    double absAtanh;\n    if (a > 0.96) {\n        absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));\n    } else {\n        final double a2 = a * a;\n        if (a > 0.7) {\n            absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a)) - (a2 - 1) / (2 * (a + 1));\n        } else if (a > 0.097) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.036) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.0036) {\n}\n}\n}",
      "public static double atanh(double a)  {\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n\n    double absAtanh;\n    if (a > 0.96) {\n        absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));\n    } else {\n        final double a2 = a * a;\n        if (a > 0.7) {\n            absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a)) - 0.46691 * a + 0.148782 * a2;\n        } else if (a > 0.42) {\n            absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a)) - 0.166667 * a + 0.0900311 * a2;\n        } else if (a > 0.15) {\n            absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a)) - 0.0625 * a + 0.0301587 * a2;\n        } else {\n}\n}\n}",
      "public static double atanh(double a)  {\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n\n    double absAtanh;\n    if (a > 0.99) {\n        absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));\n    } else {\n        final double a2 = a * a;\n        if (a > 0.75) {\n            absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a)) - (a2 - 1) / (2 * (a + 1));\n        } else if (a > 0.5) {\n            absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a)) + (a2 - 1) / (2 * a);\n        } else if (a > 0.25) {\n            absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a)) - (a2 - 1) / (2 * (1 - a));\n        } else if (a > 0.125) {\n            absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a)) + (a2 - 1) / (2 * (1 + a));\n        } else {\n            absAtanh = a - (a2 - 1) / (2 * (1 + a));\n        }\n    }\n\n    return negative ? -absAtanh : absAtanh;\n}",
      "public static double atanh(double a)  {\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n\n    double absAtanh;\n    if (a > 0.167) {\n        absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));\n    } else {\n        final double a2 = a * a;\n        if (a > 0.097) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.036) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.0036) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else {\n}\n}\n}",
      "public static double atanh(double a)  {\n        boolean negative = false;\n        if (a < 0) {\n            negative = true;\n            a = -a;\n        }\n\n        double absAtanh;\n        if (a > 0.167) {\n            absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));\n        } else {\n            final double a2 = a * a;\n            if (a > 0.097) {\n                absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n            } else if (a > 0.036) {\n                absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n            } else if (a > 0.0036) {\n                absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n            } else {\n}\n}\n}",
      "public static double atanh(double a)  {\n    boolean negative = false;\n    if (a < 0) \n    {\n        negative = true;\n        a = -a;\n    }\n\n    double absAtanh;\n    if (a > 0.167) \n    {\n        absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));\n    } \n    else \n    {\n        final double a2 = a * a;\n        if (a > 0.097) \n        {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } \n        else if (a > 0.036) \n        {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } \n        else if (a > 0.0036) \n        {\n}\n}\n}",
      "public static double atanh(double a)  {\n    boolean negative = false;\n    if (a < 0) \n    {\n        negative = true;\n        a = -a;\n    }\n\n    double absAtanh;\n    if (a > 0.9999999999999999) \n    {\n        absAtanh = 0.5 * FastMath.log1p(2 * a);\n    } \n    else \n    {\n        final double a2 = a * a;\n        if (a > 0.7071067811865475) \n        {\n            absAtanh = 0.5 * FastMath.log1p(2 * a) - 0.25 * FastMath.log1p(a2);\n        } \n        else if (a > 0.2928932188134525) \n        {\n            absAtanh = 0.5 * FastMath.log1p(2 * a) + 0.25 * FastMath.log1p(a2);\n        } \n        else if (a > 0.09730702258459936) \n        {\n            absAtanh = 0.5 * FastMath.log1p(2 * a) - 0.25 * FastMath.log1p(a2) + 0.125 * FastMath.log1p(a2 * a2);\n        } \n        else if (a > 0.036787944117144234) \n        {\n            absAtanh = 0.5 * FastMath.log1p(2 * a) - 0.25 * FastMath.log1p(a2) + 0.0625 * FastMath.log1p(a2 * a2) - 0.015625 * FastMath.log1p(a2 * a2 * a2);\n        } \n        else \n        {\n}\n}\n}",
      "public static double atanh(double a)  {\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n\n    double absAtanh;\n    if (a > 0.167) {\n        absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));\n    } else {\n        final double a2 = a * a;\n        if (a > 0.097) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.036) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.0036) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else {\n}\n}\n}",
      "public static double atanh(double a)  {\n    return 0.5 * FastMath.log((1+a)/(1-a));\n}",
      "public static double atanh(double a)  {\n    return 0.5 * FastMath.log((1 + a) / (1 - a));\n}"
    ],
    [
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_NOT_SUPPORTED,\n                                               normalizedSum);\n    }\n    double sum = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_WITH_ZERO_SUM,\n                                          sum);\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            result[i] = values[i];\n        } else {\n            result[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_NOT_SUPPORTED,\n                                               normalizedSum);\n    }\n\n    // Compute sum of all non-NaN elements.\n    double sum = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n\n    // Verify that input array does not contain any infinite elements.\n    if (Double.isInfinite(sum)) {\n        throw new MathArithmeticException(LocalizedFormats.ARRAY_CONTAINS_INVALID_ELEMENTS,\n                                          values);\n    }\n\n    // Verify that input array does not sum to zero.\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ARRAY_CANNOT_BE_NORMALIZED,\n                                          values);\n    }\n\n    // Normalize array.\n    double[] normalized = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            normalized[i] = values[i] * normalizedSum / sum;\n        } else {\n            normalized[i] = Double.NaN;\n        }\n    }\n\n    return normalized;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n    double sum = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n    if (Double.isInfinite(normalizedSum) ||\n            Double.isNaN(normalizedSum) ||\n            Double.isInfinite(sum) ||\n            sum == 0) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NAN_OR_INFINITE_SUM,\n                Double.valueOf(normalizedSum), Double.valueOf(sum));\n    }\n\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] * normalizedSum / sum;\n        } else {\n            result[i] = values[i];\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_MUST_BE_FINITE,\n                                               normalizedSum);\n    }\n\n    double sum = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n\n    if (Double.isInfinite(sum) || sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_ARRAY_WITH_SUM,\n                                          sum);\n    }\n\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            result[i] = values[i];\n        } else {\n            result[i] = values[i] * normalizedSum / sum;\n        }\n    }\n\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    double sum = 0;\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_MUST_BE_FINITE,\n                                               normalizedSum);\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_WITH_ZERO_SUM,\n                                          sum);\n    }\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] / sum * normalizedSum;\n        } else {\n            result[i] = values[i];\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedCoreFormats.NAN_OR_INF);\n    }\n\n    // Compute sum of all non-NaN elements.\n    double sum = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n\n    if (Double.isInfinite(sum) || sum == 0) {\n        throw new MathArithmeticException(LocalizedCoreFormats.ZERO_SUM);\n    }\n\n    // Compute the scale factor.\n    double scale = normalizedSum / sum;\n\n    // Apply the scale factor to all non-NaN elements.\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] * scale;\n        } else {\n            result[i] = Double.NaN;\n        }\n    }\n\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedCoreFormats.NAN_OR_INF);\n    }\n    double sum = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n    if (Double.isInfinite(sum) || sum == 0) {\n        throw new MathArithmeticException(LocalizedCoreFormats.ZERO_SUM);\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] * normalizedSum / sum;\n        } else {\n            result[i] = values[i];\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedCoreFormats.NAN_OR_INF);\n    }\n\n    double sum = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n\n    if (Double.isInfinite(sum) || sum == 0) {\n        throw new MathArithmeticException(LocalizedCoreFormats.ZERO_SUM);\n    }\n\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] * normalizedSum / sum;\n        } else {\n            result[i] = values[i];\n        }\n    }\n\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n    double sum = 0;\n    double[] result = new double[values.length];\n\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n\n    if (Double.isInfinite(sum) ||\n        Double.isInfinite(normalizedSum) ||\n        Double.isNaN(sum) ||\n        Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedCoreFormats.NAN_OR_INF);\n    }\n\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedCoreFormats.ZERO_SUM);\n    }\n\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] / sum * normalizedSum;\n        } else {\n            result[i] = values[i];\n        }\n    }\n\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    double sum = 0;\n    double[] result = new double[values.length];\n    int n = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n            result[n++] = values[i];\n        }\n    }\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_IS_NOT_A_NUMBER,\n                                               normalizedSum);\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_WITH_ZERO_SUM,\n                                          sum);\n    }\n    for (int i = 0; i < n; i++) {\n        result[i] = result[i] * normalizedSum / sum;\n    }\n    return result;\n}"
    ],
    [
      "public static String capitalize(final String str, final char... delimiters)  {\n    return capitalize(str, delimiters, null);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    return capitalize(str, delimiters, null);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    int delimLen = (delimiters == null ? -1 : delimiters.length);\n    if (str == null || str.length() == 0 || delimLen == 0) \n    {\n        return str;\n    }\n    int strLen = str.length();\n    StringBuilder buffer = new StringBuilder(strLen);\n    boolean capitalizeNext = true;\n    for (int i = 0; i < strLen; i++) \n    {\n        char ch = str.charAt(i);\n\n        if (isDelimiter(ch, delimiters)) \n        {\n            buffer.append(ch);\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer.append(Character.toTitleCase(ch));\n            capitalizeNext = false;\n        } \n        else \n        {\n            buffer.append(ch);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    return capitalize(str, delimiters, null);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    int delimLen = (delimiters == null ? -1 : delimiters.length);\n    if (str == null || str.length() == 0 || delimLen == 0) \n    {\n        return str;\n    }\n    int strLen = str.length();\n    StringBuilder buffer = new StringBuilder(strLen);\n    boolean capitalizeNext = true;\n    for (int i = 0; i < strLen; i++) \n    {\n        char ch = str.charAt(i);\n\n        if (isDelimiter(ch, delimiters)) \n        {\n            buffer.append(ch);\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer.append(Character.toTitleCase(ch));\n            capitalizeNext = false;\n        } \n        else \n        {\n            buffer.append(ch);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    int delimLen = (delimiters == null ? -1 : delimiters.length);\n    if (str == null || str.length() == 0 || delimLen == 0) \n    {\n        return str;\n    }\n    int strLen = str.length();\n    StringBuilder buffer = new StringBuilder(strLen);\n    boolean capitalizeNext = true;\n    for (int i = 0; i < strLen; i++) \n    {\n        char ch = str.charAt(i);\n\n        if (isDelimiter(ch, delimiters)) \n        {\n            buffer.append(ch);\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer.append(Character.toTitleCase(ch));\n            capitalizeNext = false;\n        } \n        else \n        {\n            buffer.append(ch);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    int delimLen = (delimiters == null ? -1 : delimiters.length);\n    if (str == null || str.length() == 0 || delimLen == 0) \n    {\n        return str;\n    }\n    int strLen = str.length();\n    StringBuilder buffer = new StringBuilder(strLen);\n    boolean capitalizeNext = true;\n    for (int i = 0; i < strLen; i++) \n    {\n        char ch = str.charAt(i);\n\n        if (isDelimiter(ch, delimiters)) \n        {\n            buffer.append(ch);\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer.append(Character.toTitleCase(ch));\n            capitalizeNext = false;\n        } \n        else \n        {\n            buffer.append(ch);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    int delimLen = (delimiters == null ? -1 : delimiters.length);\n    if (str == null || str.length() == 0 || delimLen == 0) \n    {\n        return str;\n    }\n    int strLen = str.length();\n    StringBuilder buffer = new StringBuilder(strLen);\n    boolean capitalizeNext = true;\n    for (int i = 0; i < strLen; i++) \n    {\n        char ch = str.charAt(i);\n\n        if (isDelimiter(ch, delimiters)) \n        {\n            buffer.append(ch);\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer.append(Character.toTitleCase(ch));\n            capitalizeNext = false;\n        } \n        else \n        {\n            buffer.append(ch);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    return capitalize(str, delimiters, null);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    return capitalize(str, delimiters, null);\n}"
    ],
    [
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}"
    ],
    [
      "@Override\n    protected RealVector calculateBeta()  {\n        final RealMatrix x = getX();\n        final RealVector y = getY();\n        final RealMatrix omegaInverse = getOmegaInverse();\n        return omegaInverse.multiply(x.transpose().multiply(x)).inverse().multiply(x.transpose().multiply(y));\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        final RealMatrix XT = getXT();\n        final RealMatrix XTX = XT.multiply(getOmegaInverse()).multiply(XT);\n        final RealMatrix XTXI = XTX.inverse();\n        final RealMatrix XTXI_XT = XTXI.multiply(XT);\n        return XTXI_XT.multiply(getYT());\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        final RealMatrix X = getX();\n        final RealMatrix XOmegaInverseX = X.transpose().multiply(getOmegaInverse()).multiply(X);\n        final RealMatrix XOmegaInverse = X.transpose().multiply(getOmegaInverse());\n        return XOmegaInverseX.multiply(getY()).multiply(XOmegaInverse);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        final RealMatrix xTomegaInverseX = getX().transpose().multiply(getOmegaInverse()).multiply(getX());\n        final RealMatrix xTomegaInverse = getX().transpose().multiply(getOmegaInverse());\n        return xTomegaInverseX.multiply(xTomegaInverse).multiply(getY());\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        final RealMatrix XTOmegaInverseXT = getXTX().multiply(getOmegaInverse());\n        return XTOmegaInverseXT.multiply(getXTY());\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        final RealMatrix XT = getXT();\n        final RealMatrix XTX = XT.multiply(getOmegaInverse()).multiply(XT);\n        final RealMatrix XTXI = XTX.inverse();\n        final RealMatrix XTXI_XT = XTXI.multiply(XT);\n        return XTXI_XT.multiply(getY());\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix XOmegaInverseX = getX().transpose().multiply(getOmegaInverse()).multiply(getX());\n        RealMatrix XOmegaInverse = getX().transpose().multiply(getOmegaInverse());\n        return XOmegaInverseX.inverse().multiply(XOmegaInverse).multiply(getY());\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        final RealMatrix xTomegaInverseX = getX().transpose().multiply(getOmegaInverse()).multiply(getX());\n        final RealMatrix xTomegaInverse = getX().transpose().multiply(getOmegaInverse());\n        return xTomegaInverseX.multiply(xTomegaInverse).multiply(getY());\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        final RealMatrix xOmegaInverseX = getX().transpose().multiply(getOmegaInverse()).multiply(getX());\n        final RealMatrix xOmegaInverse = getX().transpose().multiply(getOmegaInverse());\n        return xOmegaInverseX.multiply(xOmegaInverse).multiply(getY());\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        final RealMatrix xT = getX().transpose();\n        final RealMatrix xXT = xT.multiply(getX());\n        final RealMatrix omegaInverse = getOmegaInverse();\n        final RealMatrix xXTomegaInverse = xXT.multiply(omegaInverse);\n        final RealMatrix xTomegaInversey = xT.multiply(omegaInverse).multiply(getY());\n        return xXTomegaInverse.multiply(xTomegaInversey);\n    }"
    ],
    [
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    Elements elements = Collector.collect(new Evaluator.Id(id), this);\n    return elements.isEmpty() ? null : elements.first();\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    Elements elements = Collector.collect(new Evaluator.Id(id), this);\n    if (elements.isEmpty())\n        return null;\n    return elements.get(0);\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    Elements elements = Collector.collect(new Evaluator.Id(id), this);\n    if (elements.size() > 0)\n        return elements.get(0);\n    else\n        return null;\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n\n    Elements elements = Collector.collect(new Evaluator.Id(id), this);\n    if (elements.isEmpty())\n        return null;\n    else\n        return elements.get(0);\n}",
      "public Element getElementById(String id)  {\n    if (id == null)\n        return null;\n    id = id.trim();\n    if (id.isEmpty())\n        return null;\n\n    Elements elements = Collector.collect(new Evaluator.Id(id), this);\n    if (elements.size() > 0)\n        return elements.get(0);\n    else\n        return null;\n}",
      "public Element getElementById(String id)  {\n    if (id == null) return null;\n    id = id.trim();\n    if (id.isEmpty()) return null;\n\n    Elements elements = Collector.collect(new Evaluator.Id(id), this);\n    if (elements.size() > 0)\n        return elements.get(0);\n    else\n        return null;\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n\n    // first try the simple case of the ID attribute\n    Elements elements = this.getElementsByAttribute(\"id\", id);\n    if (elements.size() > 0)\n        return elements.get(0);\n\n    // then try the case where the ID is a prefix for an attribute\n    // (as per the spec for <https://html.spec.whatwg.org/multipage/dom.html#the-id-attribute>)\n    String prefixed = \"id\" + id;\n    elements = this.getElementsByAttribute(prefixed);\n    if (elements.size() > 0)\n        return elements.get(0);\n\n    // finally try the case where the ID is a prefix for a property\n    // (as per the spec for <https://html.spec.whatwg.org/multipage/dom.html#the-id-attribute>)\n    prefixed = \"data-\" + id;\n    elements = this.getElementsByAttribute(prefixed);\n    if (elements.size() > 0)\n        return elements.get(0);\n\n    return null;\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    id = id.trim();\n    Elements elements = Collector.collect(new Evaluator.Id(id), this);\n    if (elements.size() > 0)\n        return elements.get(0);\n    else\n        return null;\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    id = id.trim();\n    if (id.isEmpty())\n        return null;\n\n    Elements elements = Collector.collect(new Evaluator.Id(id), this);\n    if (elements.size() > 0)\n        return elements.get(0);\n    else\n        return null;\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    return Collector.collectFirst(new Evaluator.Id(id), this);\n}"
    ],
    [
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    if (customPatterns.isEmpty()) {\n        return pattern;\n    }\n    final StringBuilder result = new StringBuilder(pattern.length() + 2 * customPatterns.size());\n    int pos = 0;\n    for (final String customPattern : customPatterns) {\n        result.append(pattern, pos, start);\n        result.append(customPattern);\n        pos = end + 1;\n    }\n    result.append(pattern, pos, pattern.length());\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder();\n    final int length = pattern.length();\n    int i = 0;\n    while (i < length) {\n        final char c = pattern.charAt(i);\n        if (c == START_FMT) {\n            final int end = pattern.indexOf(END_FMT, i + 1);\n            if (end == -1) {\n                throw new IllegalArgumentException(\"Unterminated format element at position \" + i);\n            }\n            final String format = pattern.substring(i + 1, end);\n            final int argIndex = Integer.parseInt(format);\n            if (customPatterns != null && argIndex >= 0 && argIndex < customPatterns.size()) {\n                result.append(customPatterns.get(argIndex));\n            } else {\n                result.append(format);\n            }\n            i = end + 1;\n        } else {\n            result.append(c);\n            i++;\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    if (customPatterns == null || customPatterns.size() == 0) \n    {\n        return pattern;\n    }\n    final StringBuilder result = new StringBuilder(pattern);\n    for (final String customPattern : customPatterns) \n    {\n        final int i = result.indexOf(customPattern);\n        result.replace(i, i + customPattern.length(), \"{\" + (customPatterns.indexOf(customPattern) + 1) + \"}\");\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder(pattern.length() + 16 * customPatterns.size());\n    int pos = 0;\n    while (pos < pattern.length()) {\n        final int start = pos;\n        final int i = pattern.indexOf(START_FMT, pos);\n        if (i >= 0) {\n            result.append(pattern.substring(pos, i));\n            pos = i;\n            final int j = pattern.indexOf(END_FE, pos + 1);\n            if (j >= 0) {\n                final String desc = pattern.substring(pos + 1, j);\n                final int k = desc.indexOf(ARG_INDEX);\n                if (k >= 0) {\n                    final String arg = desc.substring(k + 1);\n                    final int argIndex = Integer.parseInt(arg);\n                    if (argIndex >= 0 && argIndex < customPatterns.size()) {\n                        result.append(customPatterns.get(argIndex));\n                    }\n                }\n                pos = j + 1;\n            } else {\n                result.append(pattern.substring(pos));\n                pos = pattern.length();\n            }\n        } else {\n            result.append(pattern.substring(pos));\n            pos = pattern.length();\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder buf = new StringBuilder(pattern.length() + 20 * customPatterns.size());\n    int lastPos = 0;\n    for (final String customPattern : customPatterns) {\n        buf.append(pattern, lastPos, customPatterns.indexOf(customPattern));\n        buf.append(customPattern);\n        lastPos = customPatterns.indexOf(customPattern) + customPattern.length();\n    }\n    buf.append(pattern, lastPos, pattern.length());\n    return buf.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder();\n    final int len = pattern.length();\n    int pos = 0;\n    while (pos < len) \n    {\n        final int start = pos;\n        pos = pattern.indexOf(START_FMT, pos);\n        if (pos < 0) \n        {\n            result.append(pattern.substring(start));\n            break;\n        }\n        result.append(pattern.substring(start, pos));\n        pos += START_FMT.length();\n        final int end = pattern.indexOf(END_FE, pos);\n        if (end < 0) \n        {\n            throw new IllegalArgumentException(\"Unterminated format element at position \" + pos);\n        }\n        final String desc = pattern.substring(pos, end);\n        pos = end + END_FE.length();\n        if (customPatterns != null) \n        {\n            final int i = desc.indexOf(START_FMT);\n            if (i > 0) \n            {\n                final String name = desc.substring(0, i).trim();\n                final String args = desc.substring(i + 1).trim();\n                final String customPattern = customPatterns.get(name);\n                if (customPattern != null) \n                {\n                    result.append(customPattern);\n                    continue;\n                }\n            }\n        }\n        final int argIndex = readArgumentIndex(desc, new ParsePosition(0));\n        final Format format = getFormat(desc);\n        if (format == null) \n        {\n            throw new IllegalArgumentException(\"Unknown format element '\" + desc + \"' at position \" + start);\n        }\n        result.append(format.format(getArgument(argIndex)));\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder();\n    final int length = pattern.length();\n    int pos = 0;\n    while (pos < length) {\n        final int start = pos;\n        while (pos < length && pattern.charAt(pos) != START_FMT) {\n            pos++;\n        }\n        if (pos > start) {\n            result.append(pattern.substring(start, pos));\n        }\n        if (pos < length) {\n            pos++; // skip {\n            final int end = pattern.indexOf(END_FMT, pos);\n            if (end > 0) {\n                final String format = pattern.substring(pos, end);\n                pos = end + 1;\n                final int arg = readArgumentIndex(format, new ParsePosition(0));\n                final String desc = parseFormatDescription(format, new ParsePosition(0));\n                final Format formatObject = getFormat(desc);\n                if (formatObject != null) {\n                    result.append(formatObject.format(getArgument(arg)));\n                } else {\n                    result.append(START_FMT).append(format).append(END_FMT);\n                }\n            } else {\n                result.append(START_FMT).append(pattern.substring(pos)).append(END_FMT);\n                pos = length;\n            }\n        }\n    }\n    if (customPatterns != null) {\n        for (final String customPattern : customPatterns) {\n            result.append(customPattern);\n        }\n    }\n    return result.toString();\n}\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder(pattern.length());\n    final int length = pattern.length();\n    int pos = 0;\n    while (pos < length) \n    {\n        final int start = pos;\n        final int i = pattern.indexOf(START_FMT, pos);\n        if (i >= 0) \n        {\n            result.append(pattern, pos, i);\n            pos = i + 1;\n            final int end = pattern.indexOf(END_FE, pos);\n            if (end >= 0) \n            {\n                final String desc = pattern.substring(pos, end);\n                final int arg = readArgumentIndex(pattern, new ParsePosition(pos));\n                pos = end + 1;\n                final String format = getFormat(desc).getPattern();\n                if (customPatterns != null) \n                {\n                    customPatterns.add(format);\n                }\n                result.append(format);\n            } \n            else \n            {\n                pos = length;\n            }\n        } \n        else \n        {\n            result.append(pattern, pos, length);\n            pos = length;\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder(pattern.length());\n    final int length = pattern.length();\n    int pos = 0;\n    while (pos < length) {\n        final int start = pos;\n        pos = pattern.indexOf(START_FE, pos);\n        if (pos == -1) {\n            result.append(pattern.substring(start));\n            break;\n        }\n        result.append(pattern.substring(start, pos));\n        pos += 1;\n        final int end = pattern.indexOf(END_FE, pos);\n        if (end == -1) {\n            result.append(pattern.substring(pos));\n            break;\n        }\n        final String format = pattern.substring(pos, end);\n        pos = end + 1;\n        final int arg = readArgumentIndex(format, new ParsePosition(0));\n        if (arg >= 0 && arg < customPatterns.size()) {\n            result.append(customPatterns.get(arg));\n        } else {\n            result.append(START_FE);\n            result.append(format);\n            result.append(END_FE);\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder();\n    int pos = 0;\n    int last = 0;\n    while (pos < pattern.length()) {\n        final int start = pattern.indexOf(START_FMT, pos);\n        if (start < 0) {\n            result.append(pattern.substring(last, pos));\n            break;\n        }\n        result.append(pattern.substring(last, start));\n        last = start + 1;\n        pos = start + 1;\n        final int end = pattern.indexOf(END_FMT, pos);\n        if (end < 0) {\n            throw new IllegalArgumentException(\n                    \"Unterminated format element at position \" + start);\n        }\n        final String desc = pattern.substring(pos, end);\n        pos = end + 1;\n        if (desc.length() == 0) {\n            throw new IllegalArgumentException(\n                    \"Format element at position \" + start + \" has no format description\");\n        }\n        final int arg = readArgumentIndex(pattern, new ParsePosition(start + 1));\n        final String format = customPatterns.get(arg);\n        if (format == null) {\n            throw new IllegalArgumentException(\n                    \"No format found for argument index \" + arg + \" at position \" + start);\n        }\n        result.append(START_FMT).append(format).append(END_FMT);\n    }\n    return result.toString();\n}"
    ],
    [
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.equals(to)) {\n      return true;\n    }\n    Type fromOwner = from.getOwnerType();\n    Type toOwner = to.getOwnerType();\n    if (fromOwner == null) {\n      if (toOwner != null) {\n        return false;\n      }\n    } else {\n      if (!typeEquals(fromOwner, toOwner, typeVarMap)) {\n        return false;\n      }\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!typeEquals(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!typeEquals(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!typeEquals(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.equals(to)) {\n      return true;\n    }\n\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!typeEquals(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!typeEquals(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!typeEquals(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!typeEquals(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.equals(to)) {\n      return true;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!typeEquals(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!typeEquals(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.equals(to)) {\n      return true;\n    }\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!typeEquals(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }"
    ],
    [
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n        if (iterator instanceof Unmodifiable) {\n            return iterator;\n        }\n        return new UnmodifiableIterator<E>(iterator);\n    }",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator instanceof Unmodifiable) {\n        return iterator;\n    }\n    return new UnmodifiableIterator<>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator instanceof Unmodifiable) \n    {\n        return iterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator instanceof Unmodifiable) {\n        return iterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator instanceof Unmodifiable) {\n        return iterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator instanceof Unmodifiable) \n    {\n        return iterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n        if (iterator instanceof Unmodifiable) {\n            return iterator;\n        }\n        return new UnmodifiableIterator<E>(iterator);\n    }",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator instanceof Unmodifiable) {\n        return iterator;\n    }\n    return new UnmodifiableIterator<>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator instanceof Unmodifiable) {\n        return iterator;\n    }\n    return new UnmodifiableIterator<>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator instanceof Unmodifiable) {\n        return iterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}"
    ],
    [
      "public N getPartitionSuperNode(N node)  {\n    return colorToNodeMap[getColor(node)];\n}",
      "public N getPartitionSuperNode(N node)  {\n    Color color = (Color) node.getAnnotation();\n    if (color == null) {\n        return null;\n    }\n    N superNode = colorToNodeMap[color.color];\n    if (superNode == null) {\n        superNode = colorToNodeMap[color.color] = node;\n    }\n    return superNode;\n}",
      "public N getPartitionSuperNode(N node)  {\n    Color color = (Color) node.getAnnotation();\n    if (color == null) \n    {\n        return null;\n    }\n    return colorToNodeMap[color.getColor()];\n}",
      "public N getPartitionSuperNode(N node)  {\n  int color = getColor(node);\n  if (colorToNodeMap[color] == null) {\n    colorToNodeMap[color] = node;\n  }\n  return colorToNodeMap[color];\n}",
      "public N getPartitionSuperNode(N node)  {\n    return colorToNodeMap[getColor(node)];\n}",
      "public N getPartitionSuperNode(N node)  {\n    N superNode = node;\n    while (superNode.getAnnotation() != null) \n    {\n        superNode = (N) superNode.getAnnotation();\n    }\n    return superNode;\n}",
      "public N getPartitionSuperNode(N node)  {\n  N superNode = node;\n  while (superNode != null) {\n    N superNodeForSuperNode = getPartitionSuperNode(superNode);\n    if (superNodeForSuperNode != null) {\n      superNode = superNodeForSuperNode;\n    } else {\n      break;\n    }\n  }\n  return superNode;\n}",
      "public N getPartitionSuperNode(N node)  {\n    return colorToNodeMap[graph.getNode(node).getAnnotation().getColor()];\n}",
      "public N getPartitionSuperNode(N node)  {\n    // Get the color of the node.\n    Color color = (Color) graph.getNode(node).getAnnotation();\n\n    // Get the super node of the color.\n    N superNode = colorToNodeMap[color.getColor()];\n\n    // If the super node is null, then this is the first node to be colored\n    // with this color. So, set the super node to be the node itself.\n    if (superNode == null) \n    {\n        superNode = node;\n        colorToNodeMap[color.getColor()] = superNode;\n    }\n\n    return superNode;\n}",
      "public N getPartitionSuperNode(N node)  {\n  int color = ((Color) node.getAnnotation()).getColor();\n  return colorToNodeMap[color];\n}"
    ],
    [
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getKey());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getKey());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getIndex());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getKey());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getKey());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getIndex());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}"
    ],
    [
      "public double integrate(UnivariateFunction f)  {\n        double sum = 0;\n        for (int i = 0; i < points.length; i++) {\n            sum += weights[i] * f.value(points[i]);\n        }\n        return sum;\n    }",
      "public double integrate(UnivariateFunction f)  {\n        double sum = 0;\n        for (int i = 0; i < points.length; i++) {\n            sum += weights[i] * f.value(points[i]);\n        }\n        return sum;\n    }",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0;\n    for (int i = 0; i < points.length; i++) {\n        result += weights[i] * f.value(points[i]);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n        double result = 0;\n        for (int i = 0; i < points.length; i++) {\n            result += weights[i] * f.value(points[i]);\n        }\n        return result;\n    }",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0;\n    for (int i = 0; i < points.length; i++) {\n        result += weights[i] * f.value(points[i]);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}"
    ],
    [
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null) {\n        return map2 == null;\n    }\n    if (map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    if (!keys1.equals(keys2)) {\n        return false;\n    }\n    Iterator iterator1 = keys1.iterator();\n    while (iterator1.hasNext()) {\n        Comparable key = (Comparable) iterator1.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null) {\n        throw new IllegalArgumentException(\"Null 'map1' argument.\");\n    }\n    if (map2 == null) {\n        throw new IllegalArgumentException(\"Null 'map2' argument.\");\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    if (!keys1.equals(keys2)) {\n        return false;\n    }\n    Iterator iterator = keys1.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    if (!keys1.equals(keys2)) {\n        return false;\n    }\n    Iterator iterator1 = keys1.iterator();\n    while (iterator1.hasNext()) {\n        Comparable key = (Comparable) iterator1.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null) {\n        return false;\n    }\n    if (map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    if (!keys1.equals(keys2)) {\n        return false;\n    }\n    Iterator iterator1 = keys1.iterator();\n    while (iterator1.hasNext()) {\n        Comparable key = (Comparable) iterator1.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) {\n        return true;\n    }\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    if (!keys1.equals(keys2)) {\n        return false;\n    }\n    Iterator iterator1 = keys1.iterator();\n    while (iterator1.hasNext()) {\n        Comparable key = (Comparable) iterator1.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null) {\n        return false;\n    }\n    if (map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    if (!keys1.equals(keys2)) {\n        return false;\n    }\n    Iterator iterator1 = keys1.iterator();\n    while (iterator1.hasNext()) {\n        Comparable key = (Comparable) iterator1.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null) {\n        return map2 == null;\n    }\n    if (map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    if (!keys1.equals(keys2)) {\n        return false;\n    }\n    Iterator iterator = keys1.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) {\n        return true;\n    }\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    if (!keys1.equals(keys2)) {\n        return false;\n    }\n    Iterator iterator = keys1.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null) {\n        throw new IllegalArgumentException(\"Null 'map1' argument.\");\n    }\n    if (map2 == null) {\n        throw new IllegalArgumentException(\"Null 'map2' argument.\");\n    }\n    if (map1.equals(map2)) {\n        return true;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    Iterator iterator1 = keys1.iterator();\n    while (iterator1.hasNext()) {\n        Comparable key = (Comparable) iterator1.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    if (!keys1.equals(keys2)) {\n        return false;\n    }\n    Iterator iterator = keys1.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  // TODO(user): Implement this method.\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  if (expr.isString()) {\n    String originalString = expr.getString();\n    String encodedString = encodeString(originalString);\n    if (encodedString != null) {\n      Node newString = Node.newString(t.getSourceName(), expr.getLineno(), expr.getCharno(), encodedString);\n      parent.replaceChild(expr, newString);\n      return newString;\n    }\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) \n    {\n        String value = expr.getString();\n        if (value.length() > 0) \n        {\n            String encoded = encodeString(value);\n            if (encoded.length() < value.length()) \n            {\n                Node newNode = Node.newString(encoded);\n                parent.replaceChild(expr, newNode);\n                return newNode;\n            }\n        }\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  if (expr.isString()) \n  {\n    String value = expr.getString();\n    if (value.length() > 0) \n    {\n      int index = value.indexOf(' ');\n      if (index == -1) \n      {\n        index = value.length();\n      }\n      if (index > 0) \n      {\n        String shortValue = value.substring(0, index);\n        Node replacement = IR.string(shortValue);\n        replacement.useSourceInfoIfMissingFromForTree(expr);\n        parent.replaceChild(expr, replacement);\n        return replacement;\n      }\n    }\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  // TODO(user): Implement this method.\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  if (expr.isString()) {\n    String originalString = expr.getString();\n    String shortString = shortenString(originalString);\n    if (shortString != null) {\n      Node newString = Node.newString(t.getSourceName(), shortString);\n      parent.replaceChild(expr, newString);\n      return newString;\n    }\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  if (expr.isString()) {\n    String value = expr.getString();\n    if (value.length() <= MAX_STRING_LENGTH) {\n      return expr;\n    }\n    String encoded = encodeString(value);\n    if (encoded.length() <= MAX_STRING_LENGTH) {\n      return IR.string(encoded).srcref(expr);\n    }\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  // Replace the expression with a short encoded string.\n  String shortEncodedString = encodeString(expr.getString());\n  Node replacement = IR.string(shortEncodedString).srcref(expr);\n  parent.replaceChild(expr, replacement);\n  return replacement;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  if (expr.isString()) {\n    String str = expr.getString();\n    if (str.length() > 10) {\n      String encoded = encodeString(str);\n      if (encoded != null) {\n        Node newExpr = Node.newString(Token.STRING, encoded).srcref(expr);\n        parent.replaceChild(expr, newExpr);\n        compiler.reportCodeChange();\n        return newExpr;\n      }\n    }\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  if (expr.isString()) {\n    String value = expr.getString();\n    if (value.length() > 100) {\n      // Shorten the string.\n      String shortValue = value.substring(0, 100);\n      Node replacement = IR.string(shortValue).srcref(expr);\n      parent.replaceChild(expr, replacement);\n      compiler.reportCodeChange();\n      return replacement;\n    }\n  }\n  return expr;\n}"
    ],
    [
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}"
    ],
    [
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    JSDocInfo info = node.getJSDocInfo();\n    if (info != null) {\n      Node descNode = info.getFirstChildByName(\"desc\");\n      if (descNode != null) {\n        String desc = descNode.getString();\n        if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n          builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n          builder.setIsHidden(true);\n        } else {\n          builder.setDesc(desc);\n        }\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    if (node.isQualifiedName()) {\n      Node parent = node.getParent();\n      if (parent.isAssign() && parent.getFirstChild() == node) {\n        Node rhs = parent.getLastChild();\n        if (rhs.isCall()) {\n          extractFromCallNode(builder, rhs);\n          return true;\n        }\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    JSDocInfo jsdoc = node.getJSDocInfo();\n    if (jsdoc != null) {\n      String desc = jsdoc.getDescription();\n      if (desc != null) {\n        if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n          builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n          builder.setIsHidden(true);\n        } else {\n          builder.setDesc(desc);\n        }\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    JSDocInfo info = node.getJSDocInfo();\n    if (info != null) {\n      if (info.hasTypedefType()) {\n        builder.setIsTypedef(true);\n      }\n      if (info.hasEnumParameterType()) {\n        builder.setIsEnum(true);\n      }\n      if (info.hasConstantParameterType()) {\n        builder.setIsConstant(true);\n      }\n      if (info.hasSuppressions()) {\n        builder.setIsSuppressed(true);\n      }\n      if (info.hasVisibility()) {\n        builder.setVisibility(info.getVisibility().name());\n      }\n      if (info.hasDescription()) {\n        String desc = info.getDescription();\n        if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n          builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n          builder.setIsHidden(true);\n        } else {\n          builder.setDesc(desc);\n        }\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    JSDocInfo info = node.getJSDocInfo();\n    if (info != null) {\n      Node descNode = info.getFirstChildByName(DESC_ANNOTATION);\n      if (descNode != null) {\n        String desc = extractStringFromStringExprNode(descNode.getFirstChild());\n        if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n          builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n          builder.setIsHidden(true);\n        } else {\n          builder.setDesc(desc);\n        }\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    if (node.isQualifiedName()) {\n      Node jsDocInfo = node.getJSDocInfo();\n      if (jsDocInfo != null) {\n        JSDocInfo info = jsDocInfo.getJSDocInfo();\n        if (info != null) {\n          String desc = info.getDescription();\n          if (desc != null) {\n            if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n              builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n              builder.setIsHidden(true);\n            } else {\n              builder.setDesc(desc);\n            }\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    if (node == null) {\n      return false;\n    }\n    JSDocInfo jsDocInfo = node.getJSDocInfo();\n    if (jsDocInfo == null) {\n      return false;\n    }\n    String desc = jsDocInfo.getDescription();\n    if (desc == null) {\n      return false;\n    }\n    if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n      builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n      builder.setIsHidden(true);\n    } else {\n      builder.setDesc(desc);\n    }\n    return true;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    if (node.isGetProp()) {\n      Node propNode = node.getFirstChild();\n      if (propNode.getString().equals(JsDoc.DESCRIPTION_FIELD)) {\n        Node valueNode = propNode.getNext();\n        if (valueNode.isString()) {\n          String desc = extractStringFromStringExprNode(valueNode);\n          if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n            builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n            builder.setIsHidden(true);\n          } else {\n            builder.setDesc(desc);\n          }\n          return true;\n        }\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    if (node == null) {\n      return false;\n    }\n    JSDocInfo info = node.getJSDocInfo();\n    if (info == null) {\n      return false;\n    }\n    if (info.hasDesc()) {\n      String desc = info.getDescription();\n      if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n        builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n        builder.setIsHidden(true);\n      } else {\n        builder.setDesc(desc);\n      }\n      return true;\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    JSDocInfo jsDocInfo = node.getJSDocInfo();\n    if (jsDocInfo != null) {\n      String desc = jsDocInfo.getDescription();\n      if (desc != null) {\n        if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n          builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n          builder.setIsHidden(true);\n        } else {\n          builder.setDesc(desc);\n        }\n        return true;\n      }\n    }\n    return false;\n  }"
    ],
    [
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int changes = 0;\n        for (final T point : points) {\n            int closestCluster = 0;\n            double closestDistance = Double.POSITIVE_INFINITY;\n            for (int i = 0; i < clusters.size(); i++) {\n                final double distance = distance(point, clusters.get(i).getCenter().getPoint());\n                if (distance < closestDistance) {\n                    closestDistance = distance;\n                    closestCluster = i;\n                }\n            }\n            if (assignments[closestCluster] != points.indexOf(point)) {\n                changes++;\n            }\n            assignments[closestCluster] = points.indexOf(point);\n            clusters.get(closestCluster).addPoint(point);\n        }\n        return changes;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int changes = 0;\n    for (final T point : points) {\n        final int oldAssignment = assignments[point.hashCode()];\n        int newAssignment = 0;\n        double minDistance = Double.POSITIVE_INFINITY;\n        for (final CentroidCluster<T> cluster : clusters) {\n            final double distance = distance(point, cluster.getCenter().getPoint());\n            if (distance < minDistance) {\n                minDistance = distance;\n                newAssignment = cluster.getIndex();\n            }\n        }\n        if (newAssignment != oldAssignment) {\n            changes++;\n        }\n        assignments[point.hashCode()] = newAssignment;\n    }\n    return changes;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int changes = 0;\n        for (final T point : points) {\n            final int clusterIndex = closestClusterIndex(clusters, point);\n            if (clusterIndex != assignments[point.hashCode()]) {\n                // assign the point to the closest cluster\n                clusters.get(clusterIndex).addPoint(point);\n                // update the assignment\n                assignments[point.hashCode()] = clusterIndex;\n                changes++;\n            }\n        }\n        return changes;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int changes = 0;\n        for (final T point : points) {\n            int closestCluster = 0;\n            double closestDistance = Double.POSITIVE_INFINITY;\n            for (int i = 0; i < clusters.size(); i++) {\n                final double distance = distance(point, clusters.get(i).getCenter().getPoint());\n                if (distance < closestDistance) {\n                    closestDistance = distance;\n                    closestCluster = i;\n                }\n            }\n            if (assignments[closestCluster] != closestCluster) {\n                changes++;\n            }\n            assignments[closestCluster] = closestCluster;\n            clusters.get(closestCluster).addPoint(point);\n        }\n        return changes;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int changes = 0;\n    for (final T point : points) {\n        final int oldAssignment = assignments[point.hashCode()];\n        int newAssignment = 0;\n        double minDistance = Double.POSITIVE_INFINITY;\n        for (final CentroidCluster<T> cluster : clusters) {\n            final double distance = distance(point, cluster.getCenter().getPoint());\n            if (distance < minDistance) {\n                minDistance = distance;\n                newAssignment = cluster.hashCode();\n            }\n        }\n        if (oldAssignment != newAssignment) {\n            assignments[point.hashCode()] = newAssignment;\n            changes++;\n        }\n    }\n    return changes;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int changes = 0;\n        for (final T point : points) {\n            final int oldAssignment = assignments[point.hashCode()];\n            final int newAssignment = closestCluster(clusters, point).getId();\n            if (oldAssignment != newAssignment) {\n                changes++;\n            }\n            assignments[point.hashCode()] = newAssignment;\n        }\n        return changes;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int changes = 0;\n    for (final T point : points) {\n        int closestCluster = 0;\n        double closestDistance = Double.POSITIVE_INFINITY;\n        for (int i = 0; i < clusters.size(); i++) {\n            final double distance = distance(point, clusters.get(i).getCenter().getPoint());\n            if (distance < closestDistance) {\n                closestDistance = distance;\n                closestCluster = i;\n            }\n        }\n        if (assignments[closestCluster] != points.indexOf(point)) {\n            changes++;\n        }\n        assignments[closestCluster] = points.indexOf(point);\n        clusters.get(closestCluster).addPoint(point);\n    }\n    return changes;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int changes = 0;\n        for (final T point : points) {\n            int closestCluster = 0;\n            double closestDistance = Double.POSITIVE_INFINITY;\n            for (int i = 0; i < clusters.size(); i++) {\n                final double distance = distance(point, clusters.get(i).getCenter().getPoint());\n                if (distance < closestDistance) {\n                    closestDistance = distance;\n                    closestCluster = i;\n                }\n            }\n            if (assignments[closestCluster] != points.indexOf(point)) {\n                changes++;\n            }\n            assignments[closestCluster] = points.indexOf(point);\n            clusters.get(closestCluster).addPoint(point);\n        }\n        return changes;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int changes = 0;\n    for (final T point : points) {\n        int closest = 0;\n        double closestDistance = Double.POSITIVE_INFINITY;\n        for (int i = 0; i < clusters.size(); i++) {\n            final double distance = distance(point, clusters.get(i).getCenter().getPoint());\n            if (distance < closestDistance) {\n                closestDistance = distance;\n                closest = i;\n            }\n        }\n        if (assignments[closest] != closest) {\n            changes++;\n        }\n        assignments[closest] = closest;\n        clusters.get(closest).addPoint(point);\n    }\n    return changes;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int changes = 0;\n    for (final T point : points) {\n        final int oldAssignment = assignments[point.hashCode()];\n        int newAssignment = -1;\n        double minDistance = Double.POSITIVE_INFINITY;\n        for (int i = 0; i < clusters.size(); i++) {\n            final double distance = distance(point, clusters.get(i).getCenter().getPoint());\n            if (distance < minDistance) {\n                minDistance = distance;\n                newAssignment = i;\n            }\n        }\n        if (newAssignment != oldAssignment) {\n            assignments[point.hashCode()] = newAssignment;\n            changes++;\n        }\n    }\n    return changes;\n}"
    ],
    [
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedCoreFormats.DIFFERENT_LENGTHS,\n                xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedCoreFormats.INSUFFICIENT_DATA);\n    }\n    final double xMean = Mean.evaluate(xArray);\n    final double yMean = Mean.evaluate(yArray);\n    double sum = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sum += (xArray[i] - xMean) * (yArray[i] - yMean);\n    }\n    final double cov = sum / (xArray.length - (biasCorrected ? 1 : 0));\n    return cov;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    int n = xArray.length;\n    if (n != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedCoreFormats.DIFFERENT_LENGTHS, n, yArray.length);\n    }\n    if (n < 2) {\n        throw new MathIllegalArgumentException(LocalizedCoreFormats.INSUFFICIENT_DATA);\n    }\n    double xMean = Mean.evaluate(xArray);\n    double yMean = Mean.evaluate(yArray);\n    double sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum += (xArray[i] - xMean) * (yArray[i] - yMean);\n    }\n    return sum / (n - (biasCorrected ? 1 : 0));\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    int length = xArray.length;\n    if (length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedCoreFormats.DIFFERENT_LENGTHS,\n                                               length, yArray.length);\n    }\n    if (length < 2) {\n        throw new MathIllegalArgumentException(LocalizedCoreFormats.INSUFFICIENT_DATA);\n    }\n    double sumDiffProd = 0;\n    double sumX = 0;\n    double sumY = 0;\n    for (int i = 0; i < length; i++) {\n        sumDiffProd += (xArray[i] - meanX) * (yArray[i] - meanY);\n        sumX += xArray[i];\n        sumY += yArray[i];\n    }\n    double cov = sumDiffProd / (length - (biasCorrected ? 1 : 0));\n    return cov;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedCoreFormats.DIMENSIONS_MISMATCH,\n                                               xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedCoreFormats.INSUFFICIENT_DATA);\n    }\n\n    // Compute the sample covariance\n    double cov = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        cov += (xArray[i] - xArray.mean()) * (yArray[i] - yArray.mean());\n    }\n    cov /= (xArray.length - (biasCorrected ? 1 : 0));\n\n    return cov;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    int length = xArray.length;\n    if (length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedCoreFormats.DIFFERENT_LENGTHS,\n                                               length, yArray.length);\n    }\n    if (length < 2) {\n        throw new MathIllegalArgumentException(LocalizedCoreFormats.INSUFFICIENT_DATA);\n    }\n    double sum = 0;\n    for (int i = 0; i < length; i++) {\n        sum += (xArray[i] - xArray[0]) * (yArray[i] - yArray[0]);\n    }\n    double mean = sum / (length - 1);\n    if (biasCorrected) {\n        return mean;\n    }\n    return mean * (length - 1) / (length - 2);\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedCoreFormats.DIMENSIONS_MISMATCH,\n                                               xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedCoreFormats.INSUFFICIENT_DATA);\n    }\n\n    double result = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        result += (xArray[i] - mean(xArray)) * (yArray[i] - mean(yArray));\n    }\n\n    if (biasCorrected) {\n        result /= (xArray.length - 1);\n    } else {\n        result /= xArray.length;\n    }\n\n    return result;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedCoreFormats.DIMENSIONS_MISMATCH,\n                                               xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedCoreFormats.INSUFFICIENT_DATA);\n    }\n\n    double xMean = mean(xArray);\n    double yMean = mean(yArray);\n    double cov = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        cov += (xArray[i] - xMean) * (yArray[i] - yMean);\n    }\n    if (biasCorrected) {\n        cov /= (xArray.length - 1);\n    } else {\n        cov /= xArray.length;\n    }\n    return cov;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    int n = xArray.length;\n    if (n != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedCoreFormats.DIFFERENT_LENGTHS,\n                                               n, yArray.length);\n    }\n    if (n < 2) {\n        throw new MathIllegalArgumentException(LocalizedCoreFormats.INSUFFICIENT_DATA);\n    }\n    double sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum += (xArray[i] - xArray[0]) * (yArray[i] - yArray[0]);\n    }\n    return biasCorrected ? sum / (n - 1) : sum / n;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    int n = xArray.length;\n    if (n != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedCoreFormats.DIFFERENT_LENGTHS,\n                                               n, yArray.length);\n    }\n    if (n < 2) {\n        throw new MathIllegalArgumentException(LocalizedCoreFormats.INSUFFICIENT_DATA);\n    }\n    double meanX = mean(xArray);\n    double meanY = mean(yArray);\n    double sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum += (xArray[i] - meanX) * (yArray[i] - meanY);\n    }\n    double cov = sum / (n - (biasCorrected ? 1 : 0));\n    return cov;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    int n = xArray.length;\n    if (n != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedCoreFormats.DIFFERENT_LENGTHS,\n                n, yArray.length);\n    }\n    if (n < 2) {\n        throw new MathIllegalArgumentException(LocalizedCoreFormats.INSUFFICIENT_DATA);\n    }\n    double sumX = 0;\n    double sumY = 0;\n    double sumXSq = 0;\n    double sumYSq = 0;\n    double sumCross = 0;\n    for (int i = 0; i < n; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXSq += xArray[i] * xArray[i];\n        sumYSq += yArray[i] * yArray[i];\n        sumCross += xArray[i] * yArray[i];\n    }\n    double meanX = sumX / n;\n    double meanY = sumY / n;\n    double varX = sumXSq / n - meanX * meanX;\n    double varY = sumYSq / n - meanY * meanY;\n    double cov = sumCross / n - meanX * meanY;\n    if (biasCorrected) {\n        cov /= (n - 1);\n    } else {\n        cov /= n;\n    }\n    if (varX <= 0 || varY <= 0) {\n        throw new MathIllegalArgumentException(LocalizedCoreFormats.CORRELATION_NOT_STRICLY_POSITIVE,\n                cov, varX, varY);\n    }\n    return cov;\n}"
    ],
    [
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) {\n        final long read = in.read(buf.array(), 0, (int) Math.min(value - skipped, buf.capacity()));\n        if (read == -1) {\n            throw new EOFException(\"Unexpected EOF: skipped \" + skipped + \" bytes out of \" + value);\n        }\n        skipped += read;\n    }\n    bytesRead(skipped);\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) {\n        final long n = in.skip(value - skipped);\n        if (n > 0) {\n            skipped += n;\n        } else {\n            break;\n        }\n    }\n    bytesRead += skipped;\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) {\n        final long toSkip = value - skipped;\n        final long skippedNow = in.skip(toSkip);\n        if (skippedNow > 0) {\n            skipped += skippedNow;\n            bytesRead(skippedNow);\n        } else {\n            break;\n        }\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    final long skipped = in.skip(value);\n    if (skipped > 0) {\n        bytesRead += skipped;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) {\n        final long toSkip = value - skipped;\n        final int n = (int) Math.min(toSkip, Integer.MAX_VALUE);\n        final int read = in.read(buf, 0, n);\n        if (read == -1) {\n            break;\n        }\n        skipped += read;\n    }\n    bytesRead += skipped;\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) {\n        final long n = in.skip(value - skipped);\n        if (n <= 0) {\n            break;\n        }\n        skipped += n;\n    }\n    bytesRead += skipped;\n}",
      "private void realSkip(final long value) throws IOException  {\n    long toSkip = value;\n    while (toSkip > 0) {\n        final long skipped = in.skip(toSkip);\n        if (skipped > 0) {\n            toSkip -= skipped;\n            bytesRead += skipped;\n        } else if (skipped == 0) {\n            // skipped == 0 implies that in.skip returned before\n            // reaching the end of the stream. This means that\n            // we've reached the end of the stream.\n            break;\n        } else {\n            // skipped < 0 implies that in.skip returned before\n            // reaching the end of the stream. This means that\n            // we've reached the end of the stream.\n            break;\n        }\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) {\n        final long toSkip = Math.min(value - skipped, 2048);\n        final int n = in.read(buf, 0, (int) toSkip);\n        if (n == -1) {\n            throw new EOFException(\"Unexpected EOF in archive\");\n        }\n        skipped += n;\n    }\n    bytesRead += skipped;\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) {\n        final long skip = in.skip(value - skipped);\n        if (skip == 0) {\n            final int read = readOneByte();\n            if (read == -1) {\n                break;\n            }\n            skipped++;\n        } else {\n            skipped += skip;\n        }\n    }\n    bytesRead += skipped;\n}",
      "private void realSkip(final long value) throws IOException  {\n    final long skipped = in.skip(value);\n    if (skipped > 0) {\n        bytesRead(skipped);\n    }\n}"
    ],
    [
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    Class<?> cls = target.getClass();\n    Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    Class<?> cls = target.getClass();\n    Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    Class<?> cls = target.getClass();\n    Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    Class<?> cls = target.getClass();\n    Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    Class<?> cls = target.getClass();\n    Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    Class<?> cls = target.getClass();\n    Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    Class<?> cls = target.getClass();\n    Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}"
    ],
    [
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // Calculate the fingerprint of the message\n    String fingerprint = \"\";\n    for (CharSequence part : messageParts) \n    {\n        fingerprint += part;\n    }\n    fingerprint = fingerprint.toUpperCase();\n    fingerprint = fingerprint.replaceAll(\"[^A-Z0-9]\", \"\");\n    // Return the fingerprint\n    return fingerprint;\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder builder = new StringBuilder();\n    for (CharSequence part : messageParts) \n    {\n        builder.append(part);\n    }\n    String message = builder.toString();\n    byte[] bytes = message.getBytes(Charsets.UTF_8);\n    MessageDigest digest;\n    try \n    {\n        digest = MessageDigest.getInstance(\"SHA-256\");\n    } \n    catch (NoSuchAlgorithmException e) \n    {\n        throw new RuntimeException(\"Unable to get SHA-256 MessageDigest instance\", e);\n    }\n    byte[] hash = digest.digest(bytes);\n    BigInteger bigInt = new BigInteger(1, hash);\n    String result = bigInt.toString(Character.MAX_RADIX);\n    return result.substring(0, Math.min(result.length(), 63));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // Create a MessageDigest object for MD5\n    MessageDigest md;\n    try \n    {\n        md = MessageDigest.getInstance(\"MD5\");\n    } \n    catch (NoSuchAlgorithmException e) \n    {\n        e.printStackTrace();\n        return \"\";\n    }\n\n    // Add each part of the message to the digest\n    for (CharSequence part : messageParts) \n    {\n        md.update(part.toString().getBytes(StandardCharsets.UTF_8));\n    }\n\n    // Get the hashed bytes and base64 encode them\n    byte[] bytes = md.digest();\n    return Base64.getEncoder().encodeToString(bytes);\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    MessageDigest md;\n    try {\n        md = MessageDigest.getInstance(\"SHA-1\");\n    } catch (NoSuchAlgorithmException e) {\n        throw new RuntimeException(e);\n    }\n\n    for (CharSequence part : messageParts) {\n        md.update(part.toString().getBytes(StandardCharsets.UTF_8));\n    }\n\n    byte[] bytes = md.digest();\n    BigInteger bigInt = new BigInteger(1, bytes);\n    String hash = bigInt.toString(16);\n    while (hash.length() < 63) {\n        hash = \"0\" + hash;\n    }\n\n    return hash.toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // Calculate the fingerprint of the message parts\n    // ...\n    return fingerprint;\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // TODO: Implement this function\n    return null;\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // Create a message fingerprint using SHA-256\n    MessageDigest md;\n    try \n    {\n        md = MessageDigest.getInstance(\"SHA-256\");\n    } \n    catch (NoSuchAlgorithmException e) \n    {\n        throw new RuntimeException(\"Could not create SHA-256 MessageDigest\", e);\n    }\n\n    // Concatenate all message parts and hash them\n    StringBuilder message = new StringBuilder();\n    for (CharSequence part : messageParts) \n    {\n        message.append(part);\n    }\n    md.update(message.toString().getBytes(StandardCharsets.UTF_8));\n    byte[] digest = md.digest();\n\n    // Convert the hash to a compact, uppercase alphanumeric string\n    char[] fingerprint = new char[63];\n    int fingerprintIndex = 0;\n    for (byte b : digest) \n    {\n        int value = b & 0xFF;\n        if (value < 10) \n        {\n            fingerprint[fingerprintIndex++] = (char) ('0' + value);\n        } \n        else if (value < 36) \n        {\n            fingerprint[fingerprintIndex++] = (char) ('A' + value - 10);\n        } \n        else \n        {\n            fingerprint[fingerprintIndex++] = (char) ('a' + value - 36);\n        }\n    }\n    return new String(fingerprint).toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // Calculate the SHA-1 hash of the message parts.\n    MessageDigest digest;\n    try {\n        digest = MessageDigest.getInstance(\"SHA-1\");\n    } catch (NoSuchAlgorithmException e) {\n        throw new RuntimeException(e);\n    }\n\n    for (CharSequence part : messageParts) {\n        digest.update(part.toString().getBytes(StandardCharsets.UTF_8));\n    }\n\n    byte[] bytes = digest.digest();\n\n    // Convert the SHA-1 hash to a compact alphanumeric representation.\n    // This is similar to Base64, but with a few differences:\n    // - we use a slightly different character set (see below)\n    // - we use a fixed length of 63 bits (instead of 64)\n    // - we use a slightly different padding scheme (see below)\n    StringBuilder builder = new StringBuilder();\n    for (int i = 0; i < bytes.length; i++) {\n        int b = bytes[i] & 0xFF;\n        if (i == bytes.length - 1 && b == 0) {\n            // Ignore trailing zero bytes.\n            break;\n        }\n        if (i % 3 == 0) {\n            builder.append('_');\n        }\n        builder.append(FINGERPRINT_CHARS[b >> 4]);\n        builder.append(FINGERPRINT_CHARS[b & 0xF]);\n    }\n\n    // The resulting string is 13 characters longer than the actual fingerprint.\n    // We remove the last 13 characters (the padding) and return the rest.\n    return builder.substring(0, builder.length() - 13);\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n  MessageDigest md = null;\n  try {\n    md = MessageDigest.getInstance(\"SHA-1\");\n  } catch (NoSuchAlgorithmException e) {\n    // This should never happen.\n    throw new RuntimeException(e);\n  }\n  for (CharSequence part : messageParts) {\n    md.update(part.toString().getBytes(Charsets.UTF_8));\n  }\n  byte[] digest = md.digest();\n  StringBuilder sb = new StringBuilder();\n  for (byte b : digest) {\n    int n = b & 0xff;\n    if (n < 16) {\n      sb.append('0');\n    }\n    sb.append(Integer.toHexString(n));\n  }\n  return sb.toString().substring(0, 63);\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // Implement this function\n    return null;\n}"
    ],
    [
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long pos = archive.length() - minDistanceFromEnd;\n    if (pos < 0) {\n        pos = 0;\n    }\n    final long max = archive.length() - maxDistanceFromEnd;\n    if (max < 0) {\n        max = 0;\n    }\n    while (pos < max) {\n        archive.position(pos);\n        wordBbuf.rewind();\n        IOUtils.readFully(archive, wordBbuf);\n        if (Arrays.equals(wordBuf, sig)) {\n            return true;\n        }\n        pos++;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long maxPosition = archive.length() - maxDistanceFromEnd;\n    final long minPosition = archive.length() - minDistanceFromEnd;\n    long position = archive.length();\n    while (position >= minPosition) {\n        archive.position(position);\n        if (IOUtils.matchSignature(archive, sig)) {\n            return true;\n        }\n        position--;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long distanceFromEnd = minDistanceFromEnd;\n    long maxPosition = archive.length() - maxDistanceFromEnd;\n    while (distanceFromEnd <= maxDistanceFromEnd) {\n        archive.position(archive.length() - distanceFromEnd);\n        if (IOUtils.matchSignature(archive, sig)) {\n            return true;\n        }\n        distanceFromEnd += WORD;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long distanceFromEnd = minDistanceFromEnd;\n    while (distanceFromEnd <= maxDistanceFromEnd) {\n        archive.position(archive.length() - distanceFromEnd);\n        wordBbuf.rewind();\n        IOUtils.readFully(archive, wordBbuf);\n        if (Arrays.equals(wordBuf, sig)) {\n            return true;\n        }\n        distanceFromEnd += WORD;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long distanceFromEnd = minDistanceFromEnd;\n    while (distanceFromEnd <= maxDistanceFromEnd) {\n        long pos = archive.length() - distanceFromEnd;\n        if (pos < 0) {\n            return false;\n        }\n        archive.position(pos);\n        byteBbuf.rewind();\n        IOUtils.readFully(archive, byteBbuf);\n        if (Arrays.equals(byteBuf, sig)) {\n            return true;\n        }\n        distanceFromEnd += WORD;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long maxPos = archive.length() - maxDistanceFromEnd;\n    final long minPos = archive.length() - minDistanceFromEnd;\n    for (long pos = archive.length() - WORD; pos >= minPos; pos -= WORD) {\n        archive.position(pos);\n        wordBbuf.rewind();\n        IOUtils.readFully(archive, wordBbuf);\n        if (Arrays.equals(wordBuf, sig)) {\n            return true;\n        }\n    }\n    for (long pos = maxPos; pos >= minPos; pos -= WORD) {\n        archive.position(pos);\n        wordBbuf.rewind();\n        IOUtils.readFully(archive, wordBbuf);\n        if (Arrays.equals(wordBuf, sig)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long maxPos = archive.length() - maxDistanceFromEnd;\n    long minPos = archive.length() - minDistanceFromEnd;\n    if (minPos < 0) {\n        minPos = 0;\n    }\n    for (long pos = archive.length(); pos >= minPos; pos--) {\n        archive.position(pos);\n        if (Arrays.equals(sig, readFully(4))) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long maxPosition = archive.length() - maxDistanceFromEnd;\n    final long minPosition = archive.length() - minDistanceFromEnd;\n    long position = archive.length();\n    while (position >= minPosition) {\n        archive.position(position);\n        wordBbuf.rewind();\n        IOUtils.readFully(archive, wordBbuf);\n        if (Arrays.equals(wordBuf, sig)) {\n            return true;\n        }\n        position--;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long maxPosition = archive.length() - maxDistanceFromEnd;\n    final long minPosition = archive.length() - minDistanceFromEnd;\n    long position = archive.length() - WORD;\n    while (position >= minPosition) {\n        archive.position(position);\n        wordBbuf.rewind();\n        IOUtils.readFully(archive, wordBbuf);\n        if (Arrays.equals(wordBuf, sig)) {\n            return true;\n        }\n        position -= WORD;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long maxPosition = archive.length() - maxDistanceFromEnd;\n    final long minPosition = archive.length() - minDistanceFromEnd;\n    long position = archive.length();\n    while (position > minPosition) {\n        archive.position(position);\n        if (IOUtils.matchSignature(archive, sig)) {\n            return true;\n        }\n        position -= WORD;\n    }\n    archive.position(maxPosition);\n    return IOUtils.matchSignature(archive, sig);\n}"
    ],
    [
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    RectangleEdge result = null;\n    AxisLocation location = getDomainAxisLocation(index);\n    if (location != null) {\n        PlotOrientation orientation = getOrientation();\n        if (orientation == PlotOrientation.HORIZONTAL) {\n            if (location == AxisLocation.TOP_OR_LEFT) {\n                result = RectangleEdge.TOP;\n            }\n            else if (location == AxisLocation.BOTTOM_OR_RIGHT) {\n                result = RectangleEdge.BOTTOM;\n            }\n        }\n        else if (orientation == PlotOrientation.VERTICAL) {\n            if (location == AxisLocation.TOP_OR_LEFT) {\n                result = RectangleEdge.LEFT;\n            }\n            else if (location == AxisLocation.BOTTOM_OR_RIGHT) {\n                result = RectangleEdge.RIGHT;\n            }\n        }\n    }\n    if (result == null) {\n        result = RectangleEdge.TOP;\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    RectangleEdge result = null;\n    AxisLocation location = getDomainAxisLocation(index);\n    if (location != null) {\n        PlotOrientation orientation = getOrientation();\n        if (orientation == PlotOrientation.HORIZONTAL) {\n            if (location == AxisLocation.TOP_OR_RIGHT) {\n                result = RectangleEdge.TOP;\n            }\n            else if (location == AxisLocation.BOTTOM_OR_LEFT) {\n                result = RectangleEdge.BOTTOM;\n            }\n        }\n        else if (orientation == PlotOrientation.VERTICAL) {\n            if (location == AxisLocation.TOP_OR_RIGHT) {\n                result = RectangleEdge.RIGHT;\n            }\n            else if (location == AxisLocation.BOTTOM_OR_LEFT) {\n                result = RectangleEdge.LEFT;\n            }\n        }\n    }\n    if (result == null) {\n        result = RectangleEdge.TOP;\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    RectangleEdge result = null;\n    if (index < this.domainAxisLocations.size()) {\n        AxisLocation location = (AxisLocation) this.domainAxisLocations.get(index);\n        if (location == null) {\n            location = AxisLocation.getOpposite(getDomainAxisLocation(0));\n        }\n        result = RectangleEdge.getEdge(location);\n    }\n    if (result == null) {\n        result = RectangleEdge.TOP;\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    RectangleEdge result = null;\n    if (index < this.domainAxisEdges.size()) {\n        result = (RectangleEdge) this.domainAxisEdges.get(index);\n    }\n    if (result == null) {\n        result = RectangleEdge.getOpposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    PlotOrientation orientation = getOrientation();\n    RectangleEdge result = null;\n    if (location == AxisLocation.TOP_OR_RIGHT) {\n        if (orientation == PlotOrientation.HORIZONTAL) {\n            result = RectangleEdge.TOP;\n        }\n        else if (orientation == PlotOrientation.VERTICAL) {\n            result = RectangleEdge.RIGHT;\n        }\n    }\n    else if (location == AxisLocation.BOTTOM_OR_LEFT) {\n        if (orientation == PlotOrientation.HORIZONTAL) {\n            result = RectangleEdge.BOTTOM;\n        }\n        else if (orientation == PlotOrientation.VERTICAL) {\n            result = RectangleEdge.LEFT;\n        }\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    RectangleEdge result = null;\n    if (index < this.domainAxisEdges.size()) {\n        result = (RectangleEdge) this.domainAxisEdges.get(index);\n    }\n    if (result == null) {\n        AxisLocation location = getDomainAxisLocation(index);\n        PlotOrientation orientation = getOrientation();\n        if (location == AxisLocation.TOP_OR_RIGHT) {\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                result = RectangleEdge.TOP;\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                result = RectangleEdge.RIGHT;\n            }\n        }\n        else if (location == AxisLocation.BOTTOM_OR_LEFT) {\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                result = RectangleEdge.BOTTOM;\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                result = RectangleEdge.LEFT;\n            }\n        }\n        else if (location == AxisLocation.TOP) {\n            result = RectangleEdge.TOP;\n        }\n        else if (location == AxisLocation.BOTTOM) {\n            result = RectangleEdge.BOTTOM;\n        }\n        else if (location == AxisLocation.LEFT) {\n            result = RectangleEdge.LEFT;\n        }\n        else if (location == AxisLocation.RIGHT) {\n            result = RectangleEdge.RIGHT;\n        }\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = null;\n    if (location == AxisLocation.TOP_OR_RIGHT) {\n        result = RectangleEdge.TOP;\n    }\n    else if (location == AxisLocation.BOTTOM_OR_LEFT) {\n        result = RectangleEdge.BOTTOM;\n    }\n    else if (location == AxisLocation.TOP_OR_LEFT) {\n        result = RectangleEdge.LEFT;\n    }\n    else if (location == AxisLocation.BOTTOM_OR_RIGHT) {\n        result = RectangleEdge.RIGHT;\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = null;\n    if (location == AxisLocation.TOP_OR_RIGHT) {\n        result = RectangleEdge.TOP;\n    }\n    else if (location == AxisLocation.BOTTOM_OR_LEFT) {\n        result = RectangleEdge.BOTTOM;\n    }\n    else if (location == AxisLocation.TOP_OR_LEFT) {\n        result = RectangleEdge.LEFT;\n    }\n    else if (location == AxisLocation.BOTTOM_OR_RIGHT) {\n        result = RectangleEdge.RIGHT;\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    RectangleEdge result = null;\n    if (index < this.domainAxisEdges.size()) {\n        result = (RectangleEdge) this.domainAxisEdges.get(index);\n    }\n    if (result == null) {\n        result = RectangleEdge.getOpposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    PlotOrientation orientation = getOrientation();\n    RectangleEdge result = null;\n    if (location == AxisLocation.TOP_OR_RIGHT) {\n        if (orientation == PlotOrientation.HORIZONTAL) {\n            result = RectangleEdge.TOP;\n        }\n        else if (orientation == PlotOrientation.VERTICAL) {\n            result = RectangleEdge.RIGHT;\n        }\n    }\n    else if (location == AxisLocation.BOTTOM_OR_LEFT) {\n        if (orientation == PlotOrientation.HORIZONTAL) {\n            result = RectangleEdge.BOTTOM;\n        }\n        else if (orientation == PlotOrientation.VERTICAL) {\n            result = RectangleEdge.LEFT;\n        }\n    }\n    return result;\n}"
    ],
    [
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "public InputStream getDataStream()  {\n    // if no match, just return original stream\n    if (_match == null) {\n        return _originalStream;\n    }\n\n    // if we had to buffer, just return buffered data\n    if (_bufferedData != null) {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n\n    // otherwise, create a stream that will read from original stream, but\n    // buffer up to 4k\n}",
      "public InputStream getDataStream()  {\n    // Create a new input stream that reads from the original stream, but\n    // first returns the buffered data.\n    return new InputStream() \n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    return new SequenceInputStream(new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength), _originalStream);\n}",
      "public InputStream getDataStream()  {\n    // if we have a buffered stream, use that; otherwise, construct one\n    if (_bufferedData != null) {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    // otherwise, create a stream that will read from underlying stream\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    return new SequenceInputStream(\n            new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength),\n            _originalStream);\n}",
      "public InputStream getDataStream()  {\n    // TODO: implement this\n    return null;\n}",
      "public InputStream getDataStream()  {\n    return new InputStream()\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}"
    ],
    [
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (this.sectionKeys != null) \n    {\n        result = this.sectionKeys.get(section);\n    }\n    if (result == null) \n    {\n        result = new Integer(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (this.sectionKeyMap != null) {\n        result = (Comparable) this.sectionKeyMap.get(new Integer(section));\n    }\n    if (result == null) {\n        result = new Integer(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (this.sectionKeys != null) \n    {\n        result = this.sectionKeys.get(section);\n    }\n    if (result == null) \n    {\n        result = new Integer(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (this.sectionKeyMap != null) \n    {\n        result = this.sectionKeyMap.get(new Integer(section));\n    }\n    if (result == null) \n    {\n        result = new Integer(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (this.sectionKeyMap != null) {\n        result = (Comparable) this.sectionKeyMap.get(new Integer(section));\n    }\n    if (result == null) {\n        result = new Integer(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (this.sectionKeys != null) \n    {\n        result = this.sectionKeys.get(section);\n    }\n    if (result == null) \n    {\n        result = new Integer(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (this.sectionKeyMap.containsKey(section)) {\n        result = this.sectionKeyMap.get(section);\n    }\n    else {\n        result = new Integer(section);\n        this.sectionKeyMap.put(section, result);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    // look up the key for the section\n    Comparable result = this.sectionKeyMap.getKey(section);\n    if (result == null) {\n        // no key defined - generate one\n        result = new Integer(section);\n        this.sectionKeyMap.put(result, section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (section >= 0 && section < this.sectionKeys.size()) {\n        result = this.sectionKeys.get(section);\n    }\n    if (result == null) {\n        result = new Integer(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (this.sectionKeys != null) \n    {\n        result = this.sectionKeys.get(section);\n    }\n    if (result == null) \n    {\n        result = new Integer(section);\n    }\n    return result;\n}"
    ],
    [
      "@Override\n        public boolean isNaN()  { return false; }",
      "@Override\n        public boolean isNaN()  { return false; }",
      "@Override\n        public boolean isNaN()  { return false; }",
      "@Override\n        public boolean isNaN()  { return false; }",
      "@Override\n        public boolean isNaN()  { return false; }",
      "@Override\n        public boolean isNaN()  { return false; }",
      "@Override\n        public boolean isNaN()  { return false; }",
      "@Override\n        public boolean isNaN()  { return false; }",
      "@Override\n        public boolean isNaN()  { return _currToken == JsonToken.VALUE_NUMBER_FLOAT && Double.isNaN(_numberDouble); }",
      "@Override\n        public boolean isNaN()  { return false; }"
    ],
    [
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    for (int i = 0; i < prefix.length(); i++) \n    {\n        if (ignoreCase) \n        {\n            if (Character.toLowerCase(str.charAt(i)) != Character.toLowerCase(prefix.charAt(i))) \n            {\n                return false;\n            }\n        } \n        else if (str.charAt(i) != prefix.charAt(i)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    for (int i = 0; i < prefix.length(); i++) {\n        if (ignoreCase) {\n            if (Character.toLowerCase(str.charAt(i)) != Character.toLowerCase(prefix.charAt(i))) {\n                return false;\n            }\n        } else {\n            if (str.charAt(i) != prefix.charAt(i)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n        if (str == null || prefix == null) {\n            return str == prefix;\n        }\n        if (prefix.length() > str.length()) {\n            return false;\n        }\n        for (int i = 0; i < prefix.length(); i++) {\n            final char ch = str.charAt(i);\n            final char pch = prefix.charAt(i);\n            if (ch != pch && !(ignoreCase && Character.toUpperCase(ch) == Character.toUpperCase(pch) && Character.toLowerCase(ch) == Character.toLowerCase(pch))) {\n                return false;\n            }\n        }\n        return true;\n    }",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    for (int i = 0; i < prefix.length(); i++) \n    {\n        if (ignoreCase) \n        {\n            if (Character.toLowerCase(str.charAt(i)) != Character.toLowerCase(prefix.charAt(i))) \n            {\n                return false;\n            }\n        } \n        else if (str.charAt(i) != prefix.charAt(i)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    for (int i = 0; i < prefix.length(); i++) \n    {\n        if (ignoreCase) \n        {\n            if (Character.toLowerCase(str.charAt(i)) != Character.toLowerCase(prefix.charAt(i))) \n            {\n                return false;\n            }\n        } \n        else if (str.charAt(i) != prefix.charAt(i)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == prefix;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    for (int i = 0; i < prefix.length(); i++) {\n        final char ch = str.charAt(i);\n        final char pch = prefix.charAt(i);\n        if (ch != pch && !(ignoreCase && Character.toLowerCase(ch) == Character.toLowerCase(pch))) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    for (int i = 0; i < prefix.length(); i++) \n    {\n        final char ch = str.charAt(i);\n        final char pch = prefix.charAt(i);\n        if (ch != pch && !(ignoreCase && Character.toLowerCase(ch) == Character.toLowerCase(pch))) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n        if (str == null || prefix == null) {\n            return str == prefix;\n        }\n        if (prefix.length() > str.length()) {\n            return false;\n        }\n        for (int i = 0; i < prefix.length(); i++) {\n            char ch = str.charAt(i);\n            if (ch != prefix.charAt(i) && !(ignoreCase && Character.toLowerCase(ch) == Character.toLowerCase(prefix.charAt(i)))) {\n                return false;\n            }\n        }\n        return true;\n    }",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == prefix;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    for (int i = 0; i < prefix.length(); i++) {\n        char c = prefix.charAt(i);\n        if (c != str.charAt(i) && !(ignoreCase && Character.toLowerCase(c) == Character.toLowerCase(str.charAt(i)))) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    for (int i = 0; i < prefix.length(); i++) \n    {\n        if (ignoreCase) \n        {\n            if (Character.toLowerCase(str.charAt(i)) != Character.toLowerCase(prefix.charAt(i))) \n            {\n                return false;\n            }\n        } \n        else if (str.charAt(i) != prefix.charAt(i)) \n        {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "public String nextString() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_UNQUOTED) {\n    peeked = PEEKED_NONE;\n    return nextUnquotedValue();\n  } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n    peeked = PEEKED_NONE;\n    return nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n  } else if (p == PEEKED_BUFFERED) {\n    peeked = PEEKED_NONE;\n    String result = buffer.readUtf8(peekedStringLength);\n    pos += peekedStringLength;\n    return result;\n  } else if (p == PEEKED_LONG) {\n    peeked = PEEKED_NONE;\n    return Long.toString(peekedLong);\n  } else if (p == PEEKED_NUMBER) {\n    peeked = PEEKED_NONE;\n    return new String(buffer, pos, peekedNumberLength - 1);\n  }\n  throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED) \n    {\n        peeked = PEEKED_NONE;\n        return nextUnquotedValue();\n    } \n    else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) \n    {\n        peeked = PEEKED_NONE;\n        return nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } \n    else if (p == PEEKED_BUFFERED) \n    {\n        peeked = PEEKED_NONE;\n        return buffer.readUtf8(peekedStringLength);\n    } \n    else if (p == PEEKED_LONG) \n    {\n        peeked = PEEKED_NONE;\n        return Long.toString(peekedLong);\n    } \n    else if (p == PEEKED_NUMBER) \n    {\n        peeked = PEEKED_NONE;\n        return new String(buffer, pos, peekedNumberLength - 1);\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED) \n    {\n        peeked = PEEKED_NONE;\n        return nextUnquotedValue();\n    } \n    else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) \n    {\n        peeked = PEEKED_NONE;\n        return nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } \n    else if (p == PEEKED_BUFFERED) \n    {\n        peeked = PEEKED_NONE;\n        String result = peekedString;\n        peekedString = null;\n        return result;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n        result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n        result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n        result = nextQuotedValue('\"');\n    } else {\n        throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED) {\n        peeked = PEEKED_NONE;\n        return nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        peeked = PEEKED_NONE;\n        return nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else if (p == PEEKED_BUFFERED) {\n        peeked = PEEKED_NONE;\n        return buffer.readUtf8(peekedStringLength);\n    } else if (p == PEEKED_LONG) {\n        peeked = PEEKED_NONE;\n        return Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n        peeked = PEEKED_NONE;\n        return new String(buffer, pos, peekedNumberLength);\n    } else {\n        throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n        result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n        result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n        result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n        result = peekedString;\n        peekedString = null;\n    } else {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n        result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n        result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n        result = nextQuotedValue('\"');\n    } else {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextString() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  String result;\n  if (p == PEEKED_UNQUOTED) {\n    result = nextUnquotedValue();\n  } else if (p == PEEKED_SINGLE_QUOTED) {\n    result = nextQuotedValue('\\'');\n  } else if (p == PEEKED_DOUBLE_QUOTED) {\n    result = nextQuotedValue('\"');\n  } else {\n    throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return result;\n}",
      "public String nextString() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_UNQUOTED) {\n    peeked = PEEKED_NONE;\n    return nextUnquotedValue();\n  } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) {\n    peeked = PEEKED_NONE;\n    return nextQuotedValue('\\'');\n  } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) {\n    peeked = PEEKED_NONE;\n    return nextQuotedValue('\"');\n  } else if (p == PEEKED_BUFFERED) {\n    peeked = PEEKED_NONE;\n    String result = peekedString;\n    peekedString = null;\n    return result;\n  } else if (p == PEEKED_LONG) {\n    peeked = PEEKED_NONE;\n    return Long.toString(peekedLong);\n  } else if (p == PEEKED_NUMBER) {\n    peeked = PEEKED_NONE;\n    return new String(buffer, pos, peekedNumberLength);\n  } else {\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n  }\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n        result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n        result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n        result = nextQuotedValue('\"');\n    } else {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}"
    ],
    [
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return \"...\" + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (maxWidth < 4) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) \n    {\n        return str;\n    }\n    if (offset > str.length()) \n    {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) \n    {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 4) \n    {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth < 7) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) \n    {\n        return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return \"...\" + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (maxWidth < 4) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) \n    {\n        return str;\n    }\n    if (offset > str.length()) \n    {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) \n    {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 4) \n    {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth < 7) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) \n    {\n        return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return \"...\" + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (maxWidth < 4) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) \n    {\n        return str;\n    }\n    if (offset > str.length()) \n    {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) \n    {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 4) \n    {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth < 7) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) \n    {\n        return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return \"...\" + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return \"...\" + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (maxWidth < 4) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) \n    {\n        return str;\n    }\n    if (offset > str.length()) \n    {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) \n    {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 4) \n    {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth < 7) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) \n    {\n        return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return \"...\" + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (maxWidth < 4) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) \n    {\n        return str;\n    }\n    if (offset > str.length()) \n    {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) \n    {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 4) \n    {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth < 7) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) \n    {\n        return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return \"...\" + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return \"...\" + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return \"...\" + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return \"...\" + str.substring(str.length() - (maxWidth - 3));\n}"
    ],
    [
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        if (s2 == null) {\n            return true;\n        }\n        return false;\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        if (s2 == null) {\n            return true;\n        }\n        return false;\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        if (s2 == null) {\n            return true;\n        }\n        return false;\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        if (s2 == null) {\n            return true;\n        }\n        return false;\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == s2) {\n        return true;\n    }\n    if (s1 == null || s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == s2) {\n        return true;\n    }\n    if (s1 == null || s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == s2) {\n        return true;\n    }\n    if (s1 == null || s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "private int getNameId(String symbolName)  {\n  if (symbolName != lastSymbolName) {\n    lastSymbolName = symbolName;\n    Integer index = symbolNameMap.get(symbolName);\n    if (index != null) {\n      lastSymbolNameIndex = index;\n    } else {\n      lastSymbolNameIndex = symbolNameMap.size();\n      symbolNameMap.put(symbolName, lastSymbolNameIndex);\n    }\n  }\n  return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastName) {\n        lastName = symbolName;\n        Integer index = nameMap.get(symbolName);\n        if (index != null) {\n            lastNameIndex = index;\n        } else {\n            lastNameIndex = nameMap.size();\n            nameMap.put(symbolName, lastNameIndex);\n        }\n    }\n    return lastNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n  if (symbolName != lastName) {\n    lastName = symbolName;\n    Integer index = nameMap.get(symbolName);\n    if (index != null) {\n      lastNameIndex = index;\n    } else {\n      lastNameIndex = nameMap.size();\n      nameMap.put(symbolName, lastNameIndex);\n    }\n  }\n  return lastNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n  if (symbolName != lastName) \n  {\n    lastName = symbolName;\n    Integer index = nameMap.get(symbolName);\n    if (index != null) \n    {\n      lastNameIndex = index;\n    } \n    else \n    {\n      lastNameIndex = nameMap.size();\n      nameMap.put(symbolName, lastNameIndex);\n    }\n  }\n  return lastNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n  if (symbolName != lastSymbolName) \n  {\n    lastSymbolName = symbolName;\n    Integer index = symbolNameMap.get(symbolName);\n    if (index != null) \n    {\n      lastSymbolNameIndex = index;\n    } \n    else \n    {\n      lastSymbolNameIndex = symbolNameMap.size();\n      symbolNameMap.put(symbolName, lastSymbolNameIndex);\n    }\n  }\n  return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) {\n        lastSymbolName = symbolName;\n        Integer index = nameMap.get(symbolName);\n        if (index != null) {\n            lastSymbolNameIndex = index;\n        } else {\n            lastSymbolNameIndex = nameMap.size();\n            nameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n  Integer index = nameMap.get(symbolName);\n  if (index != null) {\n    return index;\n  }\n  index = nameMap.size();\n  nameMap.put(symbolName, index);\n  return index;\n}",
      "private int getNameId(String symbolName)  {\n  if (symbolName != lastName) \n  {\n    lastName = symbolName;\n    Integer index = nameMap.get(symbolName);\n    if (index != null) \n    {\n      lastNameIndex = index;\n    } \n    else \n    {\n      lastNameIndex = nameMap.size();\n      nameMap.put(symbolName, lastNameIndex);\n    }\n  }\n  return lastNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastName) {\n        lastName = symbolName;\n        Integer index = nameMap.get(symbolName);\n        if (index != null) {\n            lastNameIndex = index;\n        } else {\n            lastNameIndex = nameMap.size();\n            nameMap.put(symbolName, lastNameIndex);\n        }\n    }\n    return lastNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n  if (symbolName != lastSymbolName) {\n    lastSymbolName = symbolName;\n    Integer index = symbolNameMap.get(symbolName);\n    if (index != null) {\n      lastSymbolNameIndex = index;\n    } else {\n      lastSymbolNameIndex = symbolNameMap.size();\n      symbolNameMap.put(symbolName, lastSymbolNameIndex);\n    }\n  }\n  return lastSymbolNameIndex;\n}"
    ],
    [
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_LONG) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return (double) peekedLong;\n  } else if (p == PEEKED_NUMBER) {\n    peekedString = new String(buffer, pos, peekedNumberLength);\n    pos += peekedNumberLength;\n  } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_SINGLE_QUOTED || p == PEEKED_UNQUOTED) {\n    peekedString = nextQuotedValue((p == PEEKED_SINGLE_QUOTED) ? '\\'' : '\"');\n    p = PEEKED_NONE;\n  } else {\n    throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n  }\n  double result = Double.parseDouble(peekedString);\n  if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n    throw new MalformedJsonException(\"JSON forbids NaN and infinities: \" + peekedString);\n  }\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return result;\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_LONG) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return (double) peekedLong;\n    } \n    else if (p == PEEKED_NUMBER) \n    {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    } \n    else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_SINGLE_QUOTED || p == PEEKED_UNQUOTED) \n    {\n        peekedString = nextQuotedValue((p == PEEKED_SINGLE_QUOTED) ? '\\'' : '\"');\n        p = PEEKED_NONE;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n\n    double result;\n    if (peekedString.equals(\"-Infinity\")) \n    {\n        result = Double.NEGATIVE_INFINITY;\n    } \n    else if (peekedString.equals(\"Infinity\")) \n    {\n        result = Double.POSITIVE_INFINITY;\n    } \n    else \n    {\n        try \n        {\n            result = Double.parseDouble(peekedString);\n        } \n        catch (NumberFormatException e) \n        {\n            throw new NumberFormatException(\"Error: Expecting a double but was \" + peekedString + locationString());\n        }\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_LONG) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return (double) peekedLong;\n  } else if (p == PEEKED_NUMBER) {\n    peekedString = new String(buffer, pos, peekedNumberLength);\n    pos += peekedNumberLength;\n  } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_SINGLE_QUOTED || p == PEEKED_UNQUOTED) {\n    peekedString = nextQuotedValue((p == PEEKED_SINGLE_QUOTED) ? '\\'' : '\"');\n    p = PEEKED_NONE;\n  } else {\n    throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n  }\n  double result;\n  if (peekedString.equals(\"-Infinity\")) {\n    result = Double.NEGATIVE_INFINITY;\n  } else if (peekedString.equals(\"Infinity\")) {\n    result = Double.POSITIVE_INFINITY;\n  } else {\n    try {\n      result = Double.parseDouble(peekedString);\n    } catch (NumberFormatException e) {\n      throw new NumberFormatException(\"Expected a double but was \" + peekedString + locationString());\n    }\n  }\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return result;\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_LONG) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return (double) peekedLong;\n  } else if (p == PEEKED_NUMBER) {\n    peekedString = new String(buffer, pos, peekedNumberLength);\n    pos += peekedNumberLength;\n  } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_SINGLE_QUOTED || p == PEEKED_UNQUOTED) {\n    peekedString = nextQuotedValue((p == PEEKED_DOUBLE_QUOTED) ? '\"' : '\\'');\n    p = PEEKED_SINGLE_QUOTED; // view it as a single-quoted string for now\n  } else {\n    throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  double result = Double.parseDouble(peekedString);\n  if (!Double.isNaN(result) && !Double.isInfinite(result)) {\n    return result;\n  }\n  throw new NumberFormatException(\"JSON forbids non-finite numbers: \" + peekedString);\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_LONG) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return (double) peekedLong;\n    }\n    if (p == PEEKED_NUMBER) \n    {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    }\n    else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) \n    {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        p = PEEKED_SINGLE_QUOTED;\n    }\n    else \n    {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n\n    double result;\n    if (peekedString.equals(\"-Infinity\")) \n    {\n        result = Double.NEGATIVE_INFINITY;\n    } \n    else if (peekedString.equals(\"Infinity\")) \n    {\n        result = Double.POSITIVE_INFINITY;\n    } \n    else \n    {\n        try \n        {\n            result = Double.parseDouble(peekedString);\n        } \n        catch (NumberFormatException e) \n        {\n            throw new NumberFormatException(\"Expected a double but was \" + peekedString + locationString());\n        }\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_LONG) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return (double) peekedLong;\n  } else if (p == PEEKED_NUMBER) {\n    peekedString = new String(buffer, pos, peekedNumberLength);\n    pos += peekedNumberLength;\n    /*\n     * We've read a number. The next characters are either the end of the\n     * string or a comma followed by white space. We need to figure out which\n     * one it is.\n     */\n    if (peek() == ',' || peek() == ';') {\n      if (peek() == ',') {\n        if (lenient) {\n          // We're allowed toaleniently accept compressed numbers like 1,00 (one hundred)\n          // before a comma.\n          int i = 0;\n          while (i < peekedNumberLength && peekedString.charAt(i) == '0') {\n            i++;\n          }\n          if (i == peekedNumberLength) {\n            // All zeros! When lenient, we read this as a 0.\n            peekedString = \"0\";\n            return 0.0d;\n          }\n        } else {\n          throw syntaxError(\"Invalid number: \" + peekedString);\n        }\n      }\n      checkLenient(); // Must be a trailing comma before EOF\n      if (peek() == ';') {\n        pos++;\n      }\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return Double.parseDouble(peekedString);\n    }\n    peekedString = null;\n    peeked = PEEKED_NUMBER;\n    throw new IllegalStateException(\"Expected value\");\n  } else if (p == PEEKED_UNQUOTED) {\n}\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_LONG) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return (double) peekedLong;\n    } \n    else if (p == PEEKED_NUMBER) \n    {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    } \n    else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_SINGLE_QUOTED || p == PEEKED_UNQUOTED) \n    {\n        peekedString = nextQuotedValue((p == PEEKED_SINGLE_QUOTED) ? '\\'' : '\"');\n        try \n        {\n            double result = Double.parseDouble(peekedString);\n            if (!(result == result)) \n            {\n                throw new NumberFormatException(\"JSON forbids non-finite numbers: \" + peekedString);\n            }\n            if (result == 0d && Double.doubleToRawLongBits(result) == 0L) \n            {\n                // Returning -0.0 here would be a breaking change.\n                return result;\n            }\n            peeked = PEEKED_NONE;\n            pathIndices[stackSize - 1]++;\n            return result;\n        } \n        catch (NumberFormatException expected) \n        {\n            throw new MalformedJsonException(\"JSON forbids non-finite numbers: \" + peekedString);\n        }\n    }\n    throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return (double) peekedLong;\n    } else if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_SINGLE_QUOTED || p == PEEKED_UNQUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_DOUBLE_QUOTED ? '\"' : '\\'');\n      p = PEEKED_SINGLE_QUOTED; // view it as a single-quoted string to check for NaN\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n\n    double result;\n    if (peekedString.equals(\"NaN\")) {\n      result = Double.NaN;\n    } else if (peekedString.equals(\"Infinity\") || peekedString.equals(\"-Infinity\")) {\n      result = Double.parseDouble(peekedString);\n    } else {\n      try {\n        result = Double.parseDouble(peekedString);\n      } catch (NumberFormatException e) {\n        throw new NumberFormatException(\"Error: Expecting a double but was \" + peekedString + locationString());\n      }\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_LONG) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return (double) peekedLong;\n    } else if (p == PEEKED_NUMBER) {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_SINGLE_QUOTED || p == PEEKED_UNQUOTED) {\n        peekedString = nextQuotedValue(p == PEEKED_DOUBLE_QUOTED ? '\"' : '\\'');\n        p = PEEKED_NONE;\n    } else {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    if (p == PEEKED_NONE) {\n        double result = Double.parseDouble(peekedString);\n        if (!Double.isNaN(result) && !Double.isInfinite(result)) {\n            peekedString = null;\n            peeked = PEEKED_NONE;\n            pathIndices[stackSize - 1]++;\n            return result;\n        }\n    }\n    throw new NumberFormatException(\"Expected a double but was \" + peekedString + locationString());\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_LONG) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return (double) peekedLong;\n  } else if (p == PEEKED_NUMBER) {\n    peekedString = new String(buffer, pos, peekedNumberLength);\n    pos += peekedNumberLength;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return Double.parseDouble(peekedString);\n  }\n  throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n}"
    ],
    [
      "public static String repeat(final String str, final int repeat)  {\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return padding(repeat, str.charAt(0));\n        }\n\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                char ch = str.charAt(0);\n                char[] output1 = new char[outputLength];\n                for (int i = repeat - 1; i >= 0; i--) {\n                    output1[i] = ch;\n                }\n                return new String(output1);\n            case 2 :\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }\n\n    // Padding",
      "public static String repeat(final String str, final int repeat)  {\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return padding(repeat, str.charAt(0));\n        }\n\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                char ch = str.charAt(0);\n                char[] output1 = new char[outputLength];\n                for (int i = repeat - 1; i > 0; i--) {\n                    output1[i] = ch;\n                }\n                return new String(output1);\n            case 2 :\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }\n\n    // Padding",
      "public static String repeat(final String str, final int repeat)  {\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return padding(repeat, str.charAt(0));\n        }\n\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                char ch = str.charAt(0);\n                char[] output1 = new char[outputLength];\n                for (int i = repeat - 1; i >= 0; i--) {\n                    output1[i] = ch;\n                }\n                return new String(output1);\n            case 2 :\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }\n\n    // Padding",
      "public static String repeat(final String str, final int repeat)  {\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return padding(repeat, str.charAt(0));\n        }\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                char ch = str.charAt(0);\n                char[] output1 = new char[outputLength];\n                for (int i = repeat - 1; i > 0; i--) {\n                    output1[i] = ch;\n                }\n                return new String(output1);\n            case 2 :\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }",
      "public static String repeat(final String str, final int repeat)  {\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return padding(repeat, str.charAt(0));\n        }\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                char ch = str.charAt(0);\n                char[] output1 = new char[outputLength];\n                for (int i = repeat - 1; i > 0; i--) {\n                    output1[i] = ch;\n                }\n                return new String(output1);\n            case 2 :\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }",
      "public static String repeat(final String str, final int repeat)  {\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return padding(repeat, str.charAt(0));\n        }\n\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                char ch = str.charAt(0);\n                char[] output1 = new char[outputLength];\n                for (int i = repeat - 1; i >= 0; i--) {\n                    output1[i] = ch;\n                }\n                return new String(output1);\n            case 2 :\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }",
      "public static String repeat(final String str, final int repeat)  {\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return padding(repeat, str.charAt(0));\n        }\n\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                char ch = str.charAt(0);\n                char[] output1 = new char[outputLength];\n                for (int i = repeat - 1; i >= 0; i--) {\n                    output1[i] = ch;\n                }\n                return new String(output1);\n            case 2 :\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }",
      "public static String repeat(final String str, final int repeat)  {\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return padding(repeat, str.charAt(0));\n        }\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                char ch = str.charAt(0);\n                char[] output1 = new char[outputLength];\n                for (int i = repeat - 1; i > 0; i--) {\n                    output1[i] = ch;\n                }\n                return new String(output1);\n            case 2 :\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }",
      "public static String repeat(final String str, final int repeat)  {\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return padding(repeat, str.charAt(0));\n        }\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                char ch = str.charAt(0);\n                char[] output1 = new char[outputLength];\n                for (int i = repeat - 1; i > 0; i--) {\n                    output1[i] = ch;\n                }\n                return new String(output1);\n            case 2 :\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }\n\n    // Padding",
      "public static String repeat(final String str, final int repeat)  {\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return padding(repeat, str.charAt(0));\n        }\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                char ch = str.charAt(0);\n                char[] output1 = new char[outputLength];\n                for (int i = repeat - 1; i >= 0; i--) {\n                    output1[i] = ch;\n                }\n                return new String(output1);\n            case 2 :\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }"
    ],
    [
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        clazz = UnrecognizedExtraField.class;\n    }\n    return (ZipExtraField) clazz.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> c = implementations.get(headerId);\n    if (c == null) {\n        c = UnrecognizedExtraField.class;\n    }\n    return (ZipExtraField) c.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> c = implementations.get(headerId);\n    if (c == null) {\n        c = UnrecognizedExtraField.class;\n    }\n    return (ZipExtraField) c.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        clazz = UnrecognizedExtraField.class;\n    }\n    return (ZipExtraField) clazz.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> extraClass = implementations.get(headerId);\n    if (extraClass == null) {\n        return new UnrecognizedExtraField(headerId);\n    }\n    return (ZipExtraField) extraClass.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> c = implementations.get(headerId);\n    if (c == null) {\n        c = UnrecognizedExtraField.class;\n    }\n    return (ZipExtraField) c.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> extraFieldClass = implementations.get(headerId);\n    if (extraFieldClass == null) {\n        extraFieldClass = UnrecognizedExtraField.class;\n    }\n    return (ZipExtraField) extraFieldClass.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> c = implementations.get(headerId);\n    if (c == null) {\n        c = UnrecognizedExtraField.class;\n    }\n    return (ZipExtraField) c.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        clazz = UnrecognizedExtraField.class;\n    }\n    return (ZipExtraField) clazz.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> c = implementations.get(headerId);\n    if (c == null) {\n        c = UnrecognizedExtraField.class;\n    }\n    return (ZipExtraField) c.newInstance();\n}"
    ],
    [
      "public static int count(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        for (final char c : str.toCharArray()) {\n            if (chars.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    }",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        for (final char c : str.toCharArray()) {\n            if (chars.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    }",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        for (final char c : str.toCharArray()) {\n            if (chars.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    }",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}"
    ],
    [
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map cloned = new HashMap();\n    Iterator iterator = map.keySet().iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        cloned.put(key, (Marker) map.get(key).clone());\n    }\n    return cloned;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map cloned = new HashMap();\n    Iterator iterator = map.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        CategoryItemRenderer renderer = (CategoryItemRenderer) entry.getKey();\n        if (renderer instanceof PublicCloneable) {\n            PublicCloneable pc = (PublicCloneable) renderer;\n            CategoryItemRenderer clonedRenderer = (CategoryItemRenderer) pc.clone();\n            cloned.put(clonedRenderer, entry.getValue());\n        }\n    }\n    return cloned;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map cloned = new HashMap();\n    Iterator iterator = map.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        CategoryItemRenderer renderer = (CategoryItemRenderer) entry.getKey();\n        if (renderer instanceof PublicCloneable) {\n            PublicCloneable pc = (PublicCloneable) renderer;\n            CategoryItemRenderer rc = (CategoryItemRenderer) pc.clone();\n            cloned.put(rc, entry.getValue());\n        }\n    }\n    return cloned;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map cloned = new HashMap();\n    Iterator iterator = map.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        CategoryItemRenderer renderer = (CategoryItemRenderer) entry.getKey();\n        CategoryItemRenderer clonedRenderer = (CategoryItemRenderer)\n                renderer.clone();\n        cloned.put(clonedRenderer, entry.getValue());\n    }\n    return cloned;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map cloned = new HashMap();\n    Iterator iterator = map.keySet().iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Object value = map.get(key);\n        if (value instanceof PublicCloneable) {\n            PublicCloneable pc = (PublicCloneable) value;\n            cloned.put(key, pc.clone());\n        }\n        else {\n            cloned.put(key, value);\n        }\n    }\n    return cloned;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map cloned = new HashMap();\n    Iterator iterator = map.keySet().iterator();\n    while (iterator.hasNext()) {\n        Object key = iterator.next();\n        Object value = map.get(key);\n        cloned.put(key, value);\n    }\n    return cloned;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map cloned = new HashMap();\n    Iterator iterator = map.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        CategoryItemRenderer renderer = (CategoryItemRenderer) entry.getKey();\n        if (renderer instanceof PublicCloneable) {\n            PublicCloneable pc = (PublicCloneable) renderer;\n            CategoryItemRenderer rc = (CategoryItemRenderer) pc.clone();\n            cloned.put(rc, entry.getValue());\n        }\n    }\n    return cloned;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map cloned = new HashMap();\n    Iterator iterator = map.keySet().iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        cloned.put(key, ObjectUtilities.deepClone((Object) map.get(key)));\n    }\n    return cloned;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map cloned = new HashMap();\n    Iterator iterator = map.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        CategoryItemRenderer renderer = (CategoryItemRenderer) entry.getKey();\n        PublicCloneable pc = (PublicCloneable) renderer;\n        CategoryItemRenderer rc = (CategoryItemRenderer) pc.clone();\n        cloned.put(rc, entry.getValue());\n    }\n    return cloned;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map cloned = new HashMap();\n    Iterator iterator = map.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Object key = entry.getKey();\n        Object value = entry.getValue();\n        cloned.put(key, value);\n    }\n    return cloned;\n}"
    ],
    [
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}"
    ],
    [
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds all elements if unique\n        for (final E e : coll) {\n            add(index++, e);\n        }\n\n        // compares sizes to detect if collection changed\n        return sizeBefore != size();\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // iterates over collection\n        for (final E object : coll) \n        {\n            // adds element if it is not contained already\n            if (set.contains(object) == false) \n            {\n                super.add(index, object);\n                set.add(object);\n            }\n        }\n\n        // returns true if collection changed\n        return coll.size() != size();\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds elements if unique\n        for (final E object : coll) \n        {\n            add(index++, object);\n        }\n\n        // compares sizes to detect if collection changed\n        return sizeBefore != size();\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds all elements if unique\n        for (final E object : coll) \n        {\n            add(index, object);\n        }\n\n        // compares sizes to detect if collection changed\n        return sizeBefore != size();\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // iterates over collection\n        for (final E object : coll) \n        {\n            // adds element if it is not contained already\n            if (set.contains(object) == false) \n            {\n                super.add(index, object);\n                set.add(object);\n            }\n        }\n        return true;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (final E e : coll) {\n            if (set.contains(e) == false) {\n                super.add(index, e);\n                set.add(e);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // checks for null and empty collections\n        if (coll == null) {\n            return false;\n        }\n        // iterates over the collection\n        boolean changed = false;\n        for (final E object : coll) {\n            // adds element if it is not contained already\n            if (set.contains(object) == false) {\n                super.add(index++, object);\n                set.add(object);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // iterates over the collection\n        for (final E object : coll) {\n            // adds element if it is not contained already\n            if (set.contains(object) == false) {\n                super.add(index++, object);\n                set.add(object);\n            }\n        }\n        return true;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // iterates over collection\n        for (final E object : coll) \n        {\n            // adds element if it is not contained already\n            if (set.contains(object) == false) \n            {\n                super.add(index, object);\n                set.add(object);\n            }\n        }\n        return true;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // iterates over the collection\n        for (final E object : coll) {\n            // adds element if it is not contained already\n            if (set.contains(object) == false) {\n                super.add(index++, object);\n                set.add(object);\n            }\n        }\n\n        // compares sizes to detect if collection changed\n        return size() != index;\n    }"
    ],
    [
      "private double eval(UnivariateFunction f, double x)  {\n    try {\n        return f.value(x);\n    } catch (MaxCountExceededException e) {\n        throw new TooManyEvaluationsException(e.getMaxCount(), e.getCount());\n    }\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    try \n    {\n        return f.value(x);\n    } \n    catch (EvaluationException e) \n    {\n        throw new TooManyEvaluationsException(e.getMessage(), evaluations.getCount());\n    }\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    // TODO: Implement this method\n    // HINT: Use the evaluations counter to keep track of the number of evaluations.\n    // HINT: If the number of evaluations exceeds the maximal number of evaluations,\n    //       throw a TooManyEvaluationsException.\n    // HINT: If the number of evaluations is odd, return {@code f(x)}.\n    // HINT: If the number of evaluations is even, return {@code -f(x)}.\n    // HINT: Use the provided context to make use of the provided function and\n    //       argument.\n    // HINT: If you need to evaluate the function at a point, use the provided\n    //       context to do so.\n    // HINT: If you need to evaluate the function at a point, use the provided\n    //       context to do so.\n    // HINT: If you need to evaluate the function at a point, use the provided\n    //       context to do so.\n    // HINT: If you need to evaluate the function at a point, use the provided\n    //       context to do so.\n    // HINT: If you need to evaluate the function at a point, use the provided\n    //       context to do so.\n    // HINT: If you need to evaluate the function at a point, use the provided\n    //       context to do so.\n    // HINT: If you need to evaluate the function at a point, use the provided\n    //       context to do so.\n    // HINT: If you need to evaluate the function at a point, use the provided\n    //       context to do so.\n    // HINT: If you need to evaluate the function at a point, use the provided\n    //       context to do so.\n    // HINT: If you need to evaluate the function at a point, use the provided\n    //       context to do so.\n    // HINT: If you need to evaluate the function at a point, use the provided\n    //       context to do so.\n    // HINT: If you need to evaluate the function at a point, use the provided\n    //       context to do so.\n    // HINT: If you need to evaluate the function at a point, use the provided\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    evaluations.incrementCount();\n    return f.value(x);\n}"
    ],
    [
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        if (constraint.getRelationship() == Relationship.GEQ) \n        {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(), constraint.getValue() * -1, Relationship.LEQ));\n        } \n        else if (constraint.getRelationship() == Relationship.LEQ) \n        {\n            normalizedConstraints.add(constraint);\n        } \n        else \n        {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(), constraint.getValue() * -1, Relationship.GEQ));\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        if (constraint.getRelationship() == Relationship.LEQ) \n        {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(), constraint.getValue(), Relationship.GEQ));\n        } \n        else \n        {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        LinearConstraint normalizedConstraint = null;\n        if (constraint.getRelationship() == Relationship.LEQ) \n        {\n            normalizedConstraint = new LinearConstraint(constraint.getCoefficients(), \n                    constraint.getValue() * -1, Relationship.GEQ);\n        } \n        else if (constraint.getRelationship() == Relationship.GEQ) \n        {\n            normalizedConstraint = new LinearConstraint(constraint.getCoefficients(), \n                    constraint.getValue(), Relationship.LEQ);\n        } \n        else \n        {\n            normalizedConstraint = constraint;\n        }\n        normalizedConstraints.add(normalizedConstraint);\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        if (constraint.getRelationship() == Relationship.GEQ) \n        {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(), constraint.getValue() * -1, Relationship.LEQ));\n        } \n        else \n        {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        if (constraint.getRelationship() == Relationship.LEQ) \n        {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(), \n                    constraint.getValue() * -1, Relationship.GEQ));\n        } \n        else if (constraint.getRelationship() == Relationship.GEQ) \n        {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(), \n                    constraint.getValue() * -1, Relationship.LEQ));\n        } \n        else \n        {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        if (constraint.getRelationship() == Relationship.GEQ) \n        {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(), constraint.getValue() * -1, Relationship.LEQ));\n        } \n        else \n        {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        if (constraint.getRelationship() == Relationship.LEQ) \n        {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(), constraint.getValue() * -1, Relationship.GEQ));\n        } \n        else if (constraint.getRelationship() == Relationship.GEQ) \n        {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(), constraint.getValue(), Relationship.LEQ));\n        } \n        else \n        {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        if (constraint.getRelationship() == Relationship.LEQ) \n        {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(), \n                    constraint.getValue() * -1, Relationship.GEQ));\n        } \n        else if (constraint.getRelationship() == Relationship.GEQ) \n        {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(), \n                    constraint.getValue(), Relationship.LEQ));\n        } \n        else \n        {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        if (constraint.getRelationship() == Relationship.GEQ) \n        {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(), \n                    constraint.getValue() * -1, Relationship.LEQ));\n        } \n        else \n        {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        if (constraint.getRelationship() == Relationship.GEQ) \n        {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(), \n                    constraint.getValue() * -1, Relationship.LEQ));\n        } \n        else \n        {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}"
    ],
    [
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.equals(bin)) {\n        return true;\n    }\n    double lower = Math.min(this.getLowerBound(), bin.getLowerBound());\n    double upper = Math.max(this.getUpperBound(), bin.getUpperBound());\n    return (lower <= upper);\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.upperBound < bin.getLowerBound()) \n    {\n        return false;\n    }\n    if (this.lowerBound > bin.getUpperBound()) \n    {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.equals(bin)) {\n        return true;\n    }\n    if (this.getLowerBound() > bin.getUpperBound()) {\n        return false;\n    }\n    if (this.getUpperBound() < bin.getLowerBound()) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.getUpperBound() < bin.getLowerBound()) {\n        return false;\n    }\n    if (this.getLowerBound() > bin.getUpperBound()) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.upperBound < bin.getLowerBound()) {\n        return false;\n    }\n    if (this.lowerBound > bin.getUpperBound()) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.getUpperBound() < bin.getLowerBound()) {\n        return false;\n    }\n    if (this.getLowerBound() > bin.getUpperBound()) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.getUpperBound() < bin.getLowerBound()) \n    {\n        return false;\n    }\n    if (this.getLowerBound() > bin.getUpperBound()) \n    {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound > bin.getUpperBound()) {\n        return false;\n    }\n    if (this.upperBound < bin.getLowerBound()) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.getLowerBound() > bin.getUpperBound()) {\n        return false;\n    }\n    if (this.getUpperBound() < bin.getLowerBound()) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound > bin.getUpperBound()) {\n        return false;\n    }\n    if (this.upperBound < bin.getLowerBound()) {\n        return false;\n    }\n    return true;\n}"
    ],
    [
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n        if (str == null) {\n            return null;\n        }\n        if (str.isEmpty()) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        final int sz = str.length();\n        List<String> list = new ArrayList<String>();\n        int tokenStart = 0;\n        int currentType = Character.getType(str.charAt(0));\n        for (int c = 1; c < sz; c++) {\n            final int type = Character.getType(str.charAt(c));\n            if (type == currentType) {\n                continue;\n            }\n            if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n                list.set(list.size() - 1, list.get(list.size() - 1) + str.substring(tokenStart, c));\n                tokenStart = c;\n            } else {\n                list.add(str.substring(tokenStart, c));\n                tokenStart = c;\n                currentType = type;\n            }\n        }\n        list.add(str.substring(tokenStart, sz));\n        return list.toArray(new String[list.size()]);\n    }",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n        if (str == null) {\n            return null;\n        }\n        if (str.isEmpty()) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        final int sz = str.length();\n        List<String> list = new ArrayList<String>();\n        int tokenStart = 0;\n        int currentType = Character.getType(str.charAt(tokenStart));\n        for (int pos = tokenStart + 1; pos < sz; pos++) {\n            final int type = Character.getType(str.charAt(pos));\n            if (type == currentType) {\n                continue;\n            }\n            if (type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n                if (camelCase) {\n                    list.add(str.substring(tokenStart, pos - 1));\n                    tokenStart = pos - 1;\n                } else {\n                    tokenStart = pos;\n                }\n            } else {\n                list.add(str.substring(tokenStart, pos));\n                tokenStart = pos;\n            }\n            currentType = type;\n        }\n        list.add(str.substring(tokenStart, sz));\n        return list.toArray(new String[list.size()]);\n    }",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (str.isEmpty()) \n    {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final int sz = str.length();\n    List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(str.charAt(tokenStart));\n    for (int i = tokenStart + 1; i < sz; i++) \n    {\n        final int type = Character.getType(str.charAt(i));\n        if (type == currentType) \n        {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) \n        {\n            i--;\n            continue;\n        }\n        list.add(str.substring(tokenStart, i));\n        tokenStart = i;\n        currentType = type;\n    }\n    list.add(str.substring(tokenStart, sz));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n        if (str == null) {\n            return null;\n        }\n        if (str.isEmpty()) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        final int sz = str.length();\n        List<String> list = new ArrayList<String>(sz / 2);\n        int tokenStart = 0;\n        int currentType = Character.getType(str.charAt(0));\n        for (int c = 1; c < sz; c++) {\n            final int type = Character.getType(str.charAt(c));\n            if (type == currentType) {\n                continue;\n            }\n            if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n                tokenStart = c;\n                continue;\n            }\n            list.add(str.substring(tokenStart, c));\n            tokenStart = c;\n            currentType = type;\n        }\n        list.add(str.substring(tokenStart, sz));\n        return list.toArray(new String[list.size()]);\n    }",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (str.isEmpty()) \n    {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final int sz = str.length();\n    List<String> list = new ArrayList<String>(sz / 2);\n    int tokenStart = 0;\n    int currentType = Character.getType(str.charAt(0));\n    for (int c = 1; c < sz; c++) \n    {\n        final int type = Character.getType(str.charAt(c));\n        if (type != currentType) \n        {\n            if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) \n            {\n                tokenStart = c;\n            } \n            else \n            {\n                list.add(str.substring(tokenStart, c));\n                tokenStart = c;\n            }\n            currentType = type;\n        }\n    }\n    list.add(str.substring(tokenStart, sz));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (str.isEmpty()) \n    {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final int sz = str.length();\n    List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(str.charAt(0));\n    for (int c = 1; c < sz; c++) \n    {\n        final int type = Character.getType(str.charAt(c));\n        if (type == currentType) \n        {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) \n        {\n            list.add(str.substring(tokenStart, c - 1));\n            tokenStart = c - 1;\n        } \n        else \n        {\n            list.add(str.substring(tokenStart, c));\n            tokenStart = c;\n        }\n        currentType = type;\n    }\n    list.add(str.substring(tokenStart, sz));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (str.isEmpty()) \n    {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final int sz = str.length();\n    List<String> list = new ArrayList<String>(sz / 2);\n    int tokenStart = 0;\n    int currentType = Character.getType(str.charAt(tokenStart));\n    for (int pos = tokenStart + 1; pos < sz; pos++) \n    {\n        final int type = Character.getType(str.charAt(pos));\n        if (type == currentType) \n        {\n            continue;\n        }\n        if (type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) \n        {\n            if (camelCase) \n            {\n                list.add(str.substring(tokenStart, pos - 1));\n                tokenStart = pos - 1;\n            }\n            else \n            {\n                tokenStart = pos;\n            }\n        } \n        else \n        {\n            list.add(str.substring(tokenStart, pos));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(str.substring(tokenStart, sz));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n        if (str == null) {\n            return null;\n        }\n        if (str.isEmpty()) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        final int sz = str.length();\n        List<String> list = new ArrayList<String>();\n        int tokenStart = 0;\n        int currentType = Character.getType(str.charAt(tokenStart));\n        for (int pos = tokenStart + 1; pos < sz; pos++) {\n            final int type = Character.getType(str.charAt(pos));\n            if (type == currentType) {\n                continue;\n            }\n            if (type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n                if (camelCase) {\n                    list.add(str.substring(tokenStart, pos - 1));\n                    tokenStart = pos - 1;\n                } else {\n                    tokenStart = pos;\n                }\n            } else {\n                list.add(str.substring(tokenStart, pos));\n                tokenStart = pos;\n            }\n            currentType = type;\n        }\n        list.add(str.substring(tokenStart, sz));\n        return list.toArray(new String[list.size()]);\n    }",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n        if (str == null) {\n            return null;\n        }\n        if (str.isEmpty()) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        final int sz = str.length();\n        List<String> list = new ArrayList<String>(sz / 2);\n        int tokenStart = 0;\n        int currentType = Character.getType(str.charAt(0));\n        for (int c = 1; c < sz; c++) {\n            final int type = Character.getType(str.charAt(c));\n            if (type == currentType) {\n                continue;\n            }\n            if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n                tokenStart = c;\n                continue;\n            }\n            list.add(str.substring(tokenStart, c));\n            tokenStart = c;\n            currentType = type;\n        }\n        list.add(str.substring(tokenStart, sz));\n        return list.toArray(new String[list.size()]);\n    }",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n        if (str == null) {\n            return null;\n        }\n        if (str.isEmpty()) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        final int sz = str.length();\n        List<String> list = new ArrayList<String>(sz / 2);\n        int tokenStart = 0;\n        int currentType = Character.getType(str.charAt(tokenStart));\n        for (int c = tokenStart + 1; c < sz; c++) {\n            final int type = Character.getType(str.charAt(c));\n            if (type == currentType) {\n                continue;\n            }\n            if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n                tokenStart = c - 1;\n                continue;\n            }\n            list.add(str.substring(tokenStart, c));\n            tokenStart = c;\n            currentType = type;\n        }\n        list.add(str.substring(tokenStart, sz));\n        return list.toArray(new String[list.size()]);\n    }"
    ],
    [
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        iPivotYear, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos < 0) {\n        throw new IllegalArgumentException(\"Invalid format: \" + text);\n    }\n    return bucket.computeMillis(false, text);\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0L, ISOChronology.getInstance(), iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos < 0) {\n        throw new IllegalArgumentException(\"Invalid format: \" + text);\n    }\n    return bucket.computeMillis(false, text);\n}",
      "public long parseMillis(String text)  {\n        DateTimeParser parser = requireParser();\n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            DateTimeUtils.getInstantMillis(DateTimeZone.UTC),\n            ISOChronology.getInstance(DateTimeZone.UTC),\n            iLocale, iPivotYear, DateTimeUtils.getChronology(ISOChronology.getInstance(DateTimeZone.UTC)).year().get(DateTimeUtils.getInstantMillis(DateTimeZone.UTC)));\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            return bucket.computeMillis(false, text);\n        }\n        throw new IllegalArgumentException(\"Invalid format: \" + text);\n    }",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0L, ISOChronology.getInstance(), null, iPivotYear, 0);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        return bucket.computeMillis(false, text);\n    }\n    throw new IllegalArgumentException(\"Invalid format: \" + text);\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n            iPivotYear, iLocale, iZone, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos < 0) {\n        throw new IllegalArgumentException(\"Invalid format: \" + text);\n    }\n    return bucket.computeMillis(false, text);\n}",
      "public long parseMillis(String text)  {\n        DateTimeParser parser = requireParser();\n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            iPivotYear, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            return bucket.computeMillis(false, text);\n        }\n        throw new IllegalArgumentException(\"Invalid format: \\\"\" + text + \"\\\"\");\n    }",
      "public long parseMillis(String text)  {\n        DateTimeParser parser = requireParser();\n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n                iPivotYear, iLocale, iZone, iPivotYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos < 0) {\n            throw new IllegalArgumentException(\"Invalid format: \" + text);\n        }\n        return bucket.computeMillis(false, text);\n    }",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n            ISOChronology.getInstance(), iLocale, iPivotYear, 0);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos < 0) {\n        throw new IllegalArgumentException(\"Invalid format: \" + text);\n    }\n    return bucket.computeMillis(false, text);\n}",
      "public long parseMillis(String text)  {\n        DateTimeParser parser = requireParser();\n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            iPivotYear, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos < 0) {\n            throw new IllegalArgumentException(\"Invalid format: \" + text);\n        }\n        return bucket.computeMillis(false, text);\n    }",
      "public long parseMillis(String text)  {\n        DateTimeParser parser = requireParser();\n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n                DateTimeUtils.getInstantMillis(0L), ISOChronology.getInstance(), null, iPivotYear, 0);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos < 0) {\n            throw new IllegalArgumentException(\"Invalid format: \" + text);\n        }\n        return bucket.computeMillis(false, text);\n    }"
    ],
    [
      "static MinimizedCondition unoptimized(Node n)  {\n  Preconditions.checkArgument(n.getParent() == null);\n  MeasuredNode positive = MeasuredNode.fromNode(n);\n  MeasuredNode negative = MeasuredNode.fromNode(Node.newScript(n.getSourceFileName()));\n  return new MinimizedCondition(positive, negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Node placeholder = swapWithPlaceholderNode(n);\n  return new MinimizedCondition(\n      MeasuredNode.fromNode(n),\n      MeasuredNode.fromNode(Node.newScript(n.getSourceFileName(), 1000000)));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Node placeholder = swapWithPlaceholderNode(n);\n  return new MinimizedCondition(\n      MeasuredNode.create(n),\n      MeasuredNode.create(new Node(Token.SCRIPT, 1000000000)))\n      .setPlaceholder(placeholder);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Preconditions.checkArgument(n.getParent() == null);\n  Node placeholder = swapWithPlaceholderNode(n);\n  return new MinimizedCondition(\n      MeasuredNode.fromNode(n),\n      MeasuredNode.fromNode(new Node(Token.SCRIPT).copyInformationFrom(n))\n          .setLength(Integer.MAX_VALUE))\n      .setPlaceholder(placeholder);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Preconditions.checkArgument(n.getParent() == null);\n  Node placeholder = swapWithPlaceholderNode(n);\n  return new MinimizedCondition(\n      MeasuredNode.from(n),\n      MeasuredNode.from(Node.newScript(n.getSourceFileName(),\n          \"Unminimized condition placeholder\"))).setPlaceholder(placeholder);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Node placeholder = swapWithPlaceholderNode(n);\n  return new MinimizedCondition(\n      MeasuredNode.fromNode(n),\n      MeasuredNode.fromNode(Node.newScript(n.getSourceFileName(), 1000000)));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Node placeholder = swapWithPlaceholderNode(n);\n  return new MinimizedCondition(MeasuredNode.from(n),\n      MeasuredNode.from(Node.newScript(n.getStaticSourceFile(),\n          n.getLineno(), n.getCharno(), n.getLength() + 1000000)));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Preconditions.checkArgument(n.getParent() == null);\n  MeasuredNode positive = new MeasuredNode(n);\n  Node script = new Node(Token.SCRIPT);\n  script.setLength(Integer.MAX_VALUE);\n  MeasuredNode negative = new MeasuredNode(script);\n  return new MinimizedCondition(positive, negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Node placeholder = swapWithPlaceholderNode(n);\n  return new MinimizedCondition(\n      MeasuredNode.fromNode(n),\n      MeasuredNode.fromNode(new Node(Token.SCRIPT, 1000000)));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Node placeholder = swapWithPlaceholderNode(n);\n  return new MinimizedCondition(\n      MeasuredNode.fromNode(n),\n      MeasuredNode.fromNode(new Node(Token.SCRIPT, 1000000000)));\n}"
    ],
    [
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    final List<E> list = new ArrayList<E>(64);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        list.add(constant);\n    }\n    final int length = list.size();\n    final long[] bitVectors = new long[length / 64 + 1];\n    for (int i = 0; i < length; i++) {\n        bitVectors[i / 64] |= 1L << list.get(i).ordinal();\n    }\n    return bitVectors;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    final List<E> valueList = new ArrayList<E>();\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        valueList.add(constant);\n    }\n    final int length = valueList.size();\n    final long[] result = new long[length / 64 + 1];\n    for (int i = 0; i < length; i++) {\n        result[i / 64] |= 1L << valueList.get(i).ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    final List<E> list = new ArrayList<E>();\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        list.add(constant);\n    }\n    final int length = list.size();\n    final long[] result = new long[length / Long.SIZE + 1];\n    for (int i = 0; i < length; i++) {\n        result[i / Long.SIZE] |= 1L << list.get(i).ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    final List<E> valueList = Arrays.asList(values);\n    Validate.noNullElements(valueList);\n    final int numBits = valueList.size();\n    final int numLongs = (numBits + 63) / 64;\n    final long[] bitVectors = new long[numLongs];\n    for (final E constant : valueList) {\n        bitVectors[constant.ordinal() / 64] |= 1L << constant.ordinal() % 64;\n    }\n    return bitVectors;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    final List<E> list = new ArrayList<E>(64);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        list.add(constant);\n    }\n    final int size = list.size();\n    final long[] bitVectors = new long[MathUtils.ceil(size, 64)];\n    int bitIndex = 0;\n    for (int i = 0; i < size; i++) {\n        bitVectors[bitIndex / 64] |= 1L << bitIndex % 64;\n        bitIndex++;\n    }\n    return bitVectors;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    final List<E> list = new ArrayList<E>();\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        list.add(constant);\n    }\n    final long[] bitVectors = new long[list.size()];\n    int i = 0;\n    for (final E constant : list) {\n        bitVectors[i++] = 1L << constant.ordinal();\n    }\n    return bitVectors;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    final List<E> list = new ArrayList<E>();\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        list.add(constant);\n    }\n    final long[] bitVectors = new long[list.size()];\n    for (int i = 0; i < list.size(); i++) {\n        bitVectors[i] = 1L << list.get(i).ordinal();\n    }\n    return bitVectors;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    final List<Long> longs = new ArrayList<Long>();\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        longs.add(1L << constant.ordinal());\n    }\n    final long[] longArray = new long[longs.size()];\n    for (int i = 0; i < longs.size(); i++) {\n        longArray[i] = longs.get(i);\n    }\n    return longArray;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    final List<E> list = new ArrayList<E>(64);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        list.add(constant);\n    }\n    final int size = list.size();\n    final long[] bitVectors = new long[Long.SIZE - Integer.numberOfLeadingZeros(size - 1) / Long.SIZE];\n    int i = 0;\n    for (final E constant : list) {\n        bitVectors[i++ / Long.SIZE] |= 1L << constant.ordinal();\n    }\n    return bitVectors;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    final List<E> list = new ArrayList<E>();\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        list.add(constant);\n    }\n    final int size = list.size();\n    final long[] result = new long[Long.SIZE / Long.SIZE - 1 + (size / Long.SIZE)];\n    for (int i = 0; i < size; i++) {\n        result[i / Long.SIZE] |= 1L << list.get(i).ordinal();\n    }\n    return result;\n}"
    ],
    [
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getDepth();\n  } else {\n    Preconditions.checkState(scope.isPropertyScope(),\n        \"We can only sort property scopes\");\n    SymbolScope currentScope = scope;\n    int depth = 0;\n    while (!currentScope.isLexicalScope()) {\n      currentScope = getScope(currentScope.getParentSymbol());\n      depth++;\n    }\n    return depth + currentScope.getDepth();\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getDepth();\n  } else {\n    Preconditions.checkState(scope.isPropertyScope(),\n                             \"We can only sort property scopes\");\n    SymbolScope currentScope = scope;\n    int depth = 0;\n    while (!currentScope.isLexicalScope()) {\n      currentScope = getScope(currentScope.getParentSymbol());\n      depth++;\n    }\n    return depth + currentScope.getDepth();\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getDepth();\n  } else if (scope.isPropertyScope()) {\n    return getLexicalScopeDepth(scope.getParentScope()) + 1;\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getDepth();\n  } else {\n    return getLexicalScopeDepth(scope.getParentScope()) + 1;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getDepth();\n  } else {\n    Preconditions.checkState(scope.isPropertyScope(),\n                             \"We can only sort property scopes\");\n    SymbolScope currentScope = scope;\n    int depth = 0;\n    while (!currentScope.isLexicalScope()) {\n      currentScope = getScope(currentScope.getParentSymbol());\n      depth++;\n    }\n    return depth + currentScope.getDepth();\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getDepth();\n  } else if (scope.isPropertyScope()) {\n    SymbolScope parent = scope.getParentScope();\n    return getLexicalScopeDepth(parent) + parent.getDepth();\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getDepth();\n  } else if (scope.isPropertyScope()) {\n    SymbolScope parent = scope.getParentScope();\n    if (parent.isLexicalScope()) {\n      return parent.getDepth() + 1;\n    } else {\n      return getLexicalScopeDepth(parent);\n    }\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getDepth();\n  } else if (scope.isPropertyScope()) {\n    SymbolScope parentScope = scope.getParentScope();\n    return getLexicalScopeDepth(parentScope) + parentScope.getDepth();\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getDepth();\n  } else if (scope.isPropertyScope()) {\n    SymbolScope currentScope = scope;\n    int depth = 0;\n    while (!currentScope.isLexicalScope()) {\n      currentScope = getScope(currentScope.getParentSymbol());\n      depth++;\n    }\n    return depth + currentScope.getDepth();\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getDepth();\n  } else if (scope.isPropertyScope()) {\n    return getLexicalScopeDepth(scope.getParentScope()) + 1;\n  } else {\n    return 0;\n  }\n}"
    ],
    [
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    if (rows != columns) {\n        throw new DimensionMismatchException(rows, columns);\n    }\n\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final double[][] blocks = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            final int jWidth = blockWidth(jBlock);\n            blocks[index] = new double[iHeight * jWidth];\n            for (int i = 0; i < iHeight; ++i) {\n                for (int j = 0; j < jWidth; ++j) {\n                    blocks[index][i * jWidth + j] = rawData[iBlock * BLOCK_SIZE + i][jBlock * BLOCK_SIZE + j];\n                }\n            }\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    if (rows != columns) {\n        throw new DimensionMismatchException(rows, columns);\n    }\n\n    // number of blocks\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    final double[][] blocks = createBlocksLayout(rows, columns);\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            final int jWidth = blockWidth(jBlock);\n            for (int i = 0; i < iHeight; ++i) {\n                System.arraycopy(rawData[iBlock * BLOCK_SIZE + i],\n                                 jBlock * BLOCK_SIZE,\n                                 blocks[index], i * jWidth, jWidth);\n            }\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    if (rows != columns) {\n        throw new DimensionMismatchException(rows, columns);\n    }\n\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blockData = new double[blockRows * blockColumns][];\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            blockData[index] = new double[iHeight * blockWidth(jBlock)];\n            for (int i = iBlock * BLOCK_SIZE; i < iBlock * BLOCK_SIZE + iHeight; ++i) {\n                for (int j = jBlock * BLOCK_SIZE; j < jBlock * BLOCK_SIZE + blockWidth(jBlock); ++j) {\n                    blockData[index][(i - iBlock * BLOCK_SIZE) * blockWidth(jBlock) + j - jBlock * BLOCK_SIZE] =\n                            rawData[i][j];\n                }\n            }\n        }\n    }\n\n    return blockData;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    if (rows != columns) {\n        throw new DimensionMismatchException(rows, columns);\n    }\n\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final double[][] blockData = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            final int jWidth = blockWidth(jBlock);\n            blockData[index] = new double[iHeight * jWidth];\n            for (int i = iBlock * BLOCK_SIZE; i < iBlock * BLOCK_SIZE + iHeight; ++i) {\n                for (int j = jBlock * BLOCK_SIZE; j < jBlock * BLOCK_SIZE + jWidth; ++j) {\n                    blockData[index][(i - iBlock * BLOCK_SIZE) * jWidth + j - jBlock * BLOCK_SIZE] =\n                            rawData[i][j];\n                }\n            }\n        }\n    }\n\n    return blockData;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            final int jWidth = blockWidth(jBlock);\n            blocks[index] = new double[iHeight * jWidth];\n            for (int i = 0; i < iHeight; ++i) {\n                System.arraycopy(rawData[iBlock * BLOCK_SIZE + i],\n                                 jBlock * BLOCK_SIZE,\n                                 blocks[index], i * jWidth, jWidth);\n            }\n        }\n    }\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final double[][] blockData = new double[blockRows * blockColumns][];\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            final int jWidth = blockWidth(jBlock);\n            blockData[index] = new double[iHeight * jWidth];\n            for (int i = 0; i < iHeight; ++i) {\n                System.arraycopy(rawData[iBlock * BLOCK_SIZE + i],\n                                 jBlock * BLOCK_SIZE,\n                                 blockData[index], i * jWidth, jWidth);\n            }\n        }\n    }\n    return blockData;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            blocks[index] = new double[iHeight * blockWidth(jBlock)];\n            for (int i = 0; i < iHeight; ++i) {\n                System.arraycopy(rawData[iBlock * BLOCK_SIZE + i],\n                                 jBlock * BLOCK_SIZE,\n                                 blocks[index], i * blockWidth(jBlock),\n                                 blockWidth(jBlock));\n            }\n        }\n    }\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    if (rows != columns) {\n        throw new DimensionMismatchException(rows, columns);\n    }\n\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blockData = new double[blockRows * blockColumns][];\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            blockData[index] = new double[iHeight * blockWidth(jBlock)];\n            for (int i = 0; i < iHeight; ++i) {\n                System.arraycopy(rawData[iBlock * BLOCK_SIZE + i],\n                                 jBlock * BLOCK_SIZE,\n                                 blockData[index], i * blockWidth(jBlock),\n                                 blockWidth(jBlock));\n            }\n        }\n    }\n\n    return blockData;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            final int jWidth = blockWidth(jBlock);\n            blocks[index] = new double[iHeight * jWidth];\n            for (int i = iBlock * BLOCK_SIZE; i < iBlock * BLOCK_SIZE + iHeight; ++i) {\n                for (int j = jBlock * BLOCK_SIZE; j < jBlock * BLOCK_SIZE + jWidth; ++j) {\n                    blocks[index][(i - iBlock * BLOCK_SIZE) * jWidth + (j - jBlock * BLOCK_SIZE)] =\n                        rawData[i][j];\n                }\n            }\n        }\n    }\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            blocks[index] = new double[iHeight * blockWidth(jBlock)];\n            for (int i = 0; i < iHeight; ++i) {\n                System.arraycopy(rawData[iBlock * BLOCK_SIZE + i], jBlock * BLOCK_SIZE,\n                                 blocks[index], i * blockWidth(jBlock), blockWidth(jBlock));\n            }\n        }\n    }\n    return blocks;\n}"
    ],
    [
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null) {\n        throw new NullPointerException(\"Enum class must not be null\");\n    }\n    if (values == null) {\n        throw new NullPointerException(\"Values must not be null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"Specified class \" + enumClass.getName() + \" is not an enum\");\n    }\n    final E[] enumConstants = enumClass.getEnumConstants();\n    if (enumConstants == null) {\n        throw new IllegalArgumentException(\"Specified class \" + enumClass.getName() + \" is not an enum\");\n    }\n    if (enumConstants.length > 64) {\n        throw new IllegalArgumentException(\"Specified enum has more than 64 values\");\n    }\n    long bitVector = 0;\n    for (final E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"Values must not contain null\");\n        }\n        bitVector |= 1L << value.ordinal();\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null) {\n        throw new NullPointerException(\"Enum class must not be null\");\n    }\n    if (values == null) {\n        throw new NullPointerException(\"Values must not be null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(enumClass.getName() + \" is not an enum class\");\n    }\n    final long[] bitVectors = new long[values.iterator().hasNext() ? 64 : 1];\n    int i = 0;\n    for (final E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"Values must not contain null\");\n        }\n        bitVectors[i++] = 1L << value.ordinal();\n    }\n    return bitVectors[0];\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null) {\n        throw new NullPointerException(\"Enum class must not be null\");\n    }\n    if (values == null) {\n        throw new NullPointerException(\"Values must not be null\");\n    }\n    final long[] bitVectors = new long[values.size()];\n    int i = 0;\n    for (final E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"Values must not contain null\");\n        }\n        bitVectors[i++] = 1L << value.ordinal();\n    }\n    return bitVectors[0];\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null) {\n        throw new NullPointerException(\"Enum class must not be null\");\n    }\n    if (values == null) {\n        throw new NullPointerException(\"Values must not be null\");\n    }\n    final E[] enumConstants = enumClass.getEnumConstants();\n    if (enumConstants == null) {\n        throw new IllegalArgumentException(\"Enum class \" + enumClass.getName() + \" has no constants\");\n    }\n    if (enumConstants.length > 64) {\n        throw new IllegalArgumentException(\"Enum class \" + enumClass.getName() + \" has more than 64 values\");\n    }\n    long bitVector = 0;\n    for (final E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"Values must not contain null\");\n        }\n        final int ordinal = value.ordinal();\n        if (ordinal >= enumConstants.length) {\n            throw new IllegalArgumentException(\"Value \" + value + \" is not a valid enum of \" + enumClass.getName());\n        }\n        bitVector |= (1L << ordinal);\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null) {\n        throw new NullPointerException(\"Enum class must not be null\");\n    }\n    if (values == null) {\n        throw new NullPointerException(\"Values must not be null\");\n    }\n    final E[] enumConstants = enumClass.getEnumConstants();\n    if (enumConstants == null) {\n        throw new IllegalArgumentException(\"Enum class must be an enum\");\n    }\n    if (enumConstants.length > 64) {\n        throw new IllegalArgumentException(\"Enum class must have less than 64 values\");\n    }\n    long bitVector = 0;\n    for (final E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"Values must not contain null\");\n        }\n        bitVector |= 1L << value.ordinal();\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null) {\n        throw new NullPointerException(\"Enum class must not be null\");\n    }\n    if (values == null) {\n        throw new NullPointerException(\"Values must not be null\");\n    }\n    final long[] bitVectors = new long[values.size()];\n    int i = 0;\n    for (final E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"Values must not contain null\");\n        }\n        bitVectors[i++] = 1L << value.ordinal();\n    }\n    return bitVectors[0];\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null) {\n        throw new NullPointerException(\"Enum class must not be null\");\n    }\n    if (values == null) {\n        throw new NullPointerException(\"Values must not be null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(enumClass.getName() + \" is not an enum class\");\n    }\n    final E[] enumConstants = enumClass.getEnumConstants();\n    if (enumConstants.length > 64) {\n        throw new IllegalArgumentException(enumClass.getName() + \" has more than 64 values\");\n    }\n    long bitVector = 0;\n    for (final E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"Values must not contain null\");\n        }\n        for (int i = 0; i < enumConstants.length; i++) {\n            if (enumConstants[i].equals(value)) {\n                bitVector |= 1L << i;\n                break;\n            }\n        }\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null) {\n        throw new NullPointerException(\"Enum class must not be null\");\n    }\n    if (values == null) {\n        throw new NullPointerException(\"Values must not be null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"Specified class \" + enumClass.getName() + \" is not an enum\");\n    }\n    if (Enum.class.getEnumConstants().length > 64) {\n        throw new IllegalArgumentException(\"Specified enum class \" + enumClass.getName() + \" has more than 64 values\");\n    }\n    long bitVector = 0;\n    for (final E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"Values must not contain null\");\n        }\n        bitVector |= 1L << value.ordinal();\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null) {\n        throw new NullPointerException(\"Enum class must not be null\");\n    }\n    if (values == null) {\n        throw new NullPointerException(\"Values must not be null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"Specified class \" + enumClass + \" is not an enum\");\n    }\n    if (enumClass.getEnumConstants().length > 64) {\n        throw new IllegalArgumentException(\"More than 64 values in Enum \" + enumClass);\n    }\n    long bitVector = 0;\n    for (final E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"Values must not contain null\");\n        }\n        bitVector |= 1L << value.ordinal();\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null) {\n        throw new NullPointerException(\"Enum class must not be null\");\n    }\n    if (values == null) {\n        throw new NullPointerException(\"Values must not be null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"Specified class \" + enumClass.getName() + \" is not an enum\");\n    }\n    final E[] enumConstants = enumClass.getEnumConstants();\n    if (enumConstants.length > 64) {\n        throw new IllegalArgumentException(\"Specified enum has more than 64 values\");\n    }\n    long bitVector = 0;\n    for (final E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"Values must not contain null\");\n        }\n        for (int i = 0; i < enumConstants.length; i++) {\n            if (enumConstants[i].equals(value)) {\n                bitVector |= 1L << i;\n                break;\n            }\n        }\n    }\n    return bitVector;\n}"
    ],
    [
      "protected static Dfp expInternal(final Dfp a)  {\n\n    final Dfp e = a.getField().getESplit();\n    final Dfp x = a.abs();\n    final Dfp x2 = x.multiply(x);\n    final Dfp x3 = x2.multiply(x);\n    final Dfp x4 = x3.multiply(x);\n    final Dfp x5 = x4.multiply(x);\n    final Dfp x6 = x5.multiply(x);\n    final Dfp x7 = x6.multiply(x);\n    final Dfp x8 = x7.multiply(x);\n    final Dfp x9 = x8.multiply(x);\n    final Dfp x10 = x9.multiply(x);\n    final Dfp x11 = x10.multiply(x);\n    final Dfp x12 = x11.multiply(x);\n    final Dfp x13 = x12.multiply(x);\n    final Dfp x14 = x13.multiply(x);\n    final Dfp x15 = x14.multiply(x);\n    final Dfp x16 = x15.multiply(x);\n    final Dfp x17 = x16.multiply(x);\n    final Dfp x18 = x17.multiply(x);\n    final Dfp x19 = x18.multiply(x);\n    final Dfp x20 = x19.multiply(x);\n    final Dfp x21 = x20.multiply(x);\n    final Dfp x22 = x21.multiply(x);\n    final Dfp x23 = x22.multiply(x);\n    final Dfp x24 = x23.multiply(x);\n    final Dfp x25 = x24.multiply(x);\n    final Dfp x26 = x25.multiply(x);\n    final Dfp x27 = x26.multiply(x);\n    final Dfp x28 = x27.multiply(x);\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n\n        final Dfp one = a.getField().getOne();\n        final Dfp two = one.add(one);\n        final Dfp four = two.add(two);\n\n        Dfp x = a;\n        Dfp x2 = x.multiply(x);\n        Dfp result = one.add(x2.divide(two));\n\n        Dfp x4 = x2.multiply(x2);\n        Dfp term = x4.divide(four);\n        result = result.add(term);\n\n        Dfp x8 = x4.multiply(x4);\n        term = x8.divide(four.multiply(four));\n        result = result.add(term);\n\n        Dfp x16 = x8.multiply(x8);\n        term = x16.divide(four.multiply(four).multiply(four));\n        result = result.add(term);\n\n        Dfp x32 = x16.multiply(x16);\n        term = x32.divide(four.multiply(four).multiply(four).multiply(four));\n        result = result.add(term);\n\n        Dfp x64 = x32.multiply(x32);\n        term = x64.divide(four.multiply(four).multiply(four).multiply(four).multiply(four));\n        result = result.add(term);\n\n        Dfp x128 = x64.multiply(x64);\n        term = x128.divide(four.multiply(four).multiply(four).multiply(four).multiply(four).multiply(four));\n        result = result.add(term);\n\n        Dfp x256 = x128.multiply(x128);\n        term = x256.divide(four.multiply(four).multiply(four).multiply(four).multiply(four).multiply(four).multiply(four));\n        result = result.add(term);\n\n        Dfp x512 = x256.multiply(x256);\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    // Taylor series\n    // 1 + x**2/2! + x**3/3! + x**4/4!  ...\n    Dfp result = a.getOne();\n    Dfp term = a;\n    Dfp factorial = a.getOne().add(a.getOne());\n    Dfp nextTerm = a.multiply(term).divide(factorial);\n    while (nextTerm.abs().compareTo(a.getField().getEpsilon()) > 0) \n    {\n        result = result.add(nextTerm);\n        factorial = factorial.add(a.getOne());\n        term = nextTerm;\n        nextTerm = a.multiply(term).divide(factorial);\n    }\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp x = a.multiply(a);\n    Dfp result = a.add(Dfp.ONE);\n    Dfp term = x;\n    Dfp factorial = Dfp.TWO;\n\n    while (term.abs().compareTo(Dfp.EPSILON) > 0) {\n        result = result.add(term);\n        factorial = factorial.add(Dfp.TWO);\n        term = term.multiply(x).divide(factorial);\n    }\n\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = a.getField().getOne();\n    Dfp term = a;\n    Dfp nextTerm = a.multiply(term);\n    Dfp prevTerm = null;\n    int i = 2;\n\n    while (nextTerm.compareTo(term) != 0) {\n        result = result.add(nextTerm);\n        prevTerm = term;\n        term = nextTerm;\n        nextTerm = a.multiply(term).divide(i);\n        i++;\n    }\n\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp x = a.multiply(Dfp.LOG_2_E);\n    Dfp result = Dfp.ONE;\n    Dfp term = x;\n    Dfp prevTerm = Dfp.ONE;\n    int i = 2;\n\n    while (term.abs().compareTo(Dfp.EPSILON) > 0) \n    {\n        prevTerm = term;\n        term = term.multiply(x).divide(i);\n        result = result.add(term);\n        i += 1;\n    }\n\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n\n    if (a.signum() == -1) {\n        return a.newInstance(1).divide(expInternal(a.negate()));\n    }\n\n    if (a.signum() == 0) {\n        return a.newInstance(1);\n    }\n\n    if (a.signum() == 1) {\n        Dfp result = a.newInstance(1);\n        Dfp x = a;\n        Dfp fact = a.newInstance(1);\n        Dfp term = a.newInstance(1);\n        int i = 1;\n        do {\n            fact = fact.multiply(i);\n            term = term.multiply(x).divide(fact);\n            result = result.add(term);\n            i++;\n        } while (term.signum() != 0);\n        return result;\n    }\n\n    return a.newInstance(1);\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    // Compute e**a = 1 + a + a**2/2! + a**3/3! + a**4/4!  ...\n    // Use the Taylor series for the exponential function\n    // 1 + x + x**2/2! + x**3/3! + x**4/4!  ...\n    // where |x| < 1\n\n    // We use the following identity:\n    // exp(x) = 1 + x + x**2/2! + x**3/3! + x**4/4!  ...\n    // = 1 + x * (1 + x**2/2! + x**3/3! + x**4/4!  ...)\n    // = 1 + x * exp(x)\n    // Therefore\n    // exp(x) = (1 + x * exp(x)) / (1 + x)\n    // exp(x) = (1 + x * (1 + x**2/2! + x**3/3! + x**4/4!  ...)) / (1 + x)\n    // exp(x) = (1 + x + x**2/2! + x**3/3! + x**4/4!  ...) / (1 + x)\n    // exp(x) = (1 + x + x**2/2! + x**3/3! + x**4/4!  ...) / (1 + x)\n    // exp(x) = (1 + x + x**2/2! + x**3/3! + x**4/4!  ...) / (1 + x)\n    // exp(x) = (1 + x + x**2/2! + x**3/3! + x**4/4!  ...) / (1 + x)\n    // exp(x) = (1 + x + x**2/2! + x**3/3! + x**4/4!  ...) / (1 + x)\n    // exp(x) = (1 + x + x**2/2! + x**3/3! + x**4/4!  ...) / (1 + x)\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp x = a.abs();\n    final Dfp result = new Dfp(1, 0);\n\n    Dfp term = new Dfp(1, 0);\n    Dfp fact = new Dfp(1, 0);\n    Dfp xn = x;\n\n    for (int i = 1; i < 1000; i++) {\n        fact = fact.multiply(i);\n        term = term.multiply(xn).divide(fact);\n        result = result.add(term);\n        xn = xn.multiply(x);\n        if (xn.compareTo(term) <= 0) {\n            break;\n        }\n    }\n\n    if (a.signum() < 0) {\n        result = result.divide(a.abs());\n    }\n\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    // 1 + x**2/2! + x**3/3! + x**4/4!  ...\n    Dfp result = a.getOne();\n    Dfp term = a;\n    Dfp factorial = a.getOne().add(a.getOne());\n    Dfp xSquared = term.multiply(term);\n    Dfp xCubed = xSquared.multiply(term);\n    Dfp xQuad = xCubed.multiply(term);\n    Dfp xNext = xQuad.divide(factorial);\n    while (xNext.abs().compareTo(a.getEpsilon()) > 0) \n    {\n        result = result.add(xNext);\n        factorial = factorial.add(a.getOne());\n        xSquared = xSquared.multiply(xSquared);\n        xCubed = xCubed.multiply(xCubed);\n        xQuad = xQuad.multiply(xQuad);\n        xNext = xQuad.divide(factorial);\n    }\n    return result;\n}"
    ],
    [
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final T norm = getNorm();\n    if (norm.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_ORTHOGONALIZE_A_NULL_NORM_VECTOR);\n    }\n    final FieldVector3D<T> v = new FieldVector3D<T>(x.add(y.multiply(2)).add(z.multiply(2)),\n                                                    y.add(z.multiply(2)).subtract(x.multiply(2)),\n                                                    z.subtract(x.multiply(2)).subtract(y.multiply(2)));\n    return v.scalarMultiply(norm.reciprocal());\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final FieldVector3D<T> n = new FieldVector3D<T>(x.subtract(y.multiply(0.5)), y.add(x.multiply(0.5)), z);\n    final T norm = n.getNorm();\n    if (norm.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_COMPUTE_ORTHOGONAL_VECTOR);\n    }\n    return n.scalarMultiply(norm.reciprocal());\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final FieldVector3D<T> i = new FieldVector3D<T>(x.subtract(y.multiply(2)),\n                                                    y.add(x.multiply(2)),\n                                                    z);\n    final T norm = i.getNorm();\n    if (norm.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_COMPUTE_ORTHOGONAL_VECTOR);\n    }\n    return i.scalarMultiply(norm.reciprocal());\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final T x = this.x;\n    final T y = this.y;\n    final T z = this.z;\n    final T absX = x.getField().getZero().add(x.getReal()).abs();\n    final T absY = y.getField().getZero().add(y.getReal()).abs();\n    final T absZ = z.getField().getZero().add(z.getReal()).abs();\n    if (absX.getReal() >= absY.getReal() && absX.getReal() >= absZ.getReal()) {\n        return new FieldVector3D<T>(y.subtract(x.multiply(y.getReal() / x.getReal())),\n                                    z.subtract(x.multiply(z.getReal() / x.getReal())),\n                                    x);\n    } else if (absY.getReal() >= absZ.getReal()) {\n        return new FieldVector3D<T>(z.subtract(y.multiply(z.getReal() / y.getReal())),\n                                    x.subtract(y.multiply(x.getReal() / y.getReal())),\n                                    y);\n    } else {\n        return new FieldVector3D<T>(x.subtract(z.multiply(x.getReal() / z.getReal())),\n                                    y.subtract(z.multiply(y.getReal() / z.getReal())),\n                                    z);\n    }\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final FieldVector3D<T> u = new FieldVector3D<T>(x, y, z);\n    final FieldVector3D<T> v = new FieldVector3D<T>(y, z, x);\n    final FieldVector3D<T> w = new FieldVector3D<T>(z, x, y);\n    final FieldVector3D<T> n = u.crossProduct(v);\n    if (n.getNorm().getReal() == 0) {\n        return w.crossProduct(u);\n    }\n    return n;\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final T norm = getNorm();\n    if (norm.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_COMPUTE_ORTHOGONAL_VECTOR_WITH_NULL_NORM);\n    }\n    final T invNorm = norm.reciprocal();\n    final T x = this.x.multiply(invNorm);\n    final T y = this.y.multiply(invNorm);\n    final T z = this.z.multiply(invNorm);\n    final T x2 = x.multiply(x);\n    final T y2 = y.multiply(y);\n    final T z2 = z.multiply(z);\n    final T xy = x.multiply(y);\n    final T xz = x.multiply(z);\n    final T yz = y.multiply(z);\n    final T x2m = x2.subtract(1);\n    final T y2m = y2.subtract(1);\n    final T z2m = z2.subtract(1);\n    final T xy2m = xy.multiply(2);\n    final T xz2m = xz.multiply(2);\n    final T yz2m = yz.multiply(2);\n    final T x2m2 = x2m.multiply(x2m);\n    final T y2m2 = y2m.multiply(y2m);\n    final T z2m2 = z2m.multiply(z2m);\n    final T xy2m2 = xy2m.multiply(xy2m);\n    final T xz2m2 = xz2m.multiply(xz2m);\n    final T yz2m2 = yz2m.multiply(yz2m);\n    final T x2m2p2y2m2 = x2m2.add(y2m2);\n    final T x2m2m2y2m2 = x2m2.subtract(y2m2);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final FieldVector3D<T> i = new FieldVector3D<T>(x.getField().getOne(),\n                                                    y.subtract(z.multiply(2)),\n                                                    z.add(y.multiply(2)));\n    final T norm = i.getNorm();\n    if (norm.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_COMPUTE_ORTHOGONAL_VECTOR_WITH_NULL_NORM);\n    }\n    return i.scalarMultiply(norm.reciprocal());\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final T norm = getNorm();\n    if (norm.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_ORTHOGONALIZE_A_NULL_NORM_VECTOR);\n    }\n    return new FieldVector3D<T>(x.subtract(y.multiply(2.0 * x.dotProduct(y) / norm.multiply(norm).getReal())),\n                                y.add(x.multiply(2.0 * y.dotProduct(x) / norm.multiply(norm).getReal())),\n                                z.multiply(norm.getReal() - x.dotProduct(x) / norm.multiply(norm).getReal() - y.dotProduct(y) / norm.multiply(norm).getReal()));\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final T x2 = x.multiply(x);\n    final T y2 = y.multiply(y);\n    final T z2 = z.multiply(z);\n    final T xy = x.multiply(y);\n    final T xz = x.multiply(z);\n    final T yz = y.multiply(z);\n    final T x2m = x2.subtract(y2).subtract(z2);\n    final T y2m = y2.subtract(z2).subtract(x2);\n    final T z2m = z2.subtract(x2).subtract(y2);\n    final T xm = x.negate();\n    final T ym = y.negate();\n    final T zm = z.negate();\n    final T x2p = x2.add(y2).add(z2);\n    final T y2p = y2.add(z2).add(x2);\n    final T z2p = z2.add(x2).add(y2);\n    final T xy2m = xy.multiply(2);\n    final T xz2m = xz.multiply(2);\n    final T yz2m = yz.multiply(2);\n    return new FieldVector3D<T>(x2m.multiply(xm).add(y2m.multiply(ym)).add(z2m.multiply(zm)),\n                                x2p.multiply(xm).add(y2p.multiply(ym)).add(z2p.multiply(zm)),\n                                xz2m.add(yz2m),\n                                xy2m);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final T norm = getNorm();\n    if (norm.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_COMPUTE_ORTHOGONAL_VECTOR_WITH_NULL_NORM);\n    }\n    final T x2 = x.multiply(x);\n    final T y2 = y.multiply(y);\n    final T z2 = z.multiply(z);\n    final T xy = x.multiply(y);\n    final T xz = x.multiply(z);\n    final T yz = y.multiply(z);\n    final T x2m = x2.subtract(norm);\n    final T y2m = y2.subtract(norm);\n    final T z2m = z2.subtract(norm);\n    final T xy2m = xy.subtract(norm);\n    final T xz2m = xz.subtract(norm);\n    final T yz2m = yz.subtract(norm);\n    final T x2m2 = x2m.multiply(x2m);\n    final T y2m2 = y2m.multiply(y2m);\n    final T z2m2 = z2m.multiply(z2m);\n    final T xy2m2 = xy2m.multiply(xy2m);\n    final T xz2m2 = xz2m.multiply(xz2m);\n    final T yz2m2 = yz2m.multiply(yz2m);\n    final T x2m2y2m2 = x2m2.multiply(y2m2);\n    final T x2m2z2m2 = x2m2.multiply(z2m2);\n    final T y2m2z2m2 = y2m2.multiply(z2m2);\n    final T x2m2y2m2z2m2 = x2m2y2m2.multiply(z2m2);\n}"
    ],
    [
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap\");\n    }\n    if (equals(other)) {\n        return this;\n    }\n    return new Range<T>(\n            max(minimum, other.minimum),\n            min(maximum, other.maximum)\n    );\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap\");\n    }\n    if (equals(other)) {\n        return this;\n    }\n    return new Range<T>(\n            comparator,\n            comparator.compare(minimum, other.minimum) <= 0 ? minimum : other.minimum,\n            comparator.compare(maximum, other.maximum) >= 0 ? maximum : other.maximum);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap\");\n    }\n    if (this.equals(other)) {\n        return this;\n    }\n    return new Range<T>(\n            ComparableComparators.max(this.comparator, other.comparator),\n            ComparableComparators.min(this.comparator, other.comparator),\n            this.minimum.compareTo(other.minimum) <= 0 ? this.minimum : other.minimum,\n            this.maximum.compareTo(other.maximum) >= 0 ? this.maximum : other.maximum);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"Range must not be null\");\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap\");\n    }\n    if (equals(other)) {\n        return this;\n    }\n    return new Range<>(\n            comparator,\n            Math.max(minimum, other.minimum),\n            Math.min(maximum, other.maximum)\n    );\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap\");\n    }\n    if (this.equals(other)) {\n        return this;\n    }\n    final T min = this.minimum.compareTo(other.minimum) <= 0 ? this.minimum : other.minimum;\n    final T max = this.maximum.compareTo(other.maximum) >= 0 ? this.maximum : other.maximum;\n    return new Range<T>(min, max);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap\");\n    }\n    if (equals(other)) {\n        return this;\n    }\n    return new Range<T>(Math.max(minimum, other.minimum), Math.min(maximum, other.maximum));\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap\");\n    }\n    if (equals(other)) {\n        return this;\n    }\n    return new Range<>(max(minimum, other.minimum), min(maximum, other.maximum));\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap\");\n    }\n    if (this.equals(other)) {\n        return this;\n    }\n    final T min = comparator.compare(this.minimum, other.minimum) <= 0 ? this.minimum : other.minimum;\n    final T max = comparator.compare(this.maximum, other.maximum) >= 0 ? this.maximum : other.maximum;\n    return new Range<T>(min, max, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap\");\n    }\n    if (equals(other)) {\n        return this;\n    }\n    final int cmpMin = minimum.compareTo(other.minimum);\n    if (cmpMin < 0) {\n        return new Range<>(minimum, other.minimum);\n    }\n    final int cmpMax = maximum.compareTo(other.maximum);\n    if (cmpMax > 0) {\n        return new Range<>(other.maximum, maximum);\n    }\n    return this;\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap\");\n    }\n    if (this.equals(other)) {\n        return this;\n    }\n    return new Range<T>(\n            max(this.minimum, other.minimum),\n            min(this.maximum, other.maximum)\n    );\n}"
    ],
    [
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8WriterJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8OutputStreamJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8WriterJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8WriterJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8WriterBasedJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8WriterJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8WriterJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8WriterJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8WriterJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8WriterJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}"
    ],
    [
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (o1 == o2) {\n        return true;\n    }\n    if (o1 == null || o2 == null) {\n        return false;\n    }\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return annotationMemberEquals((Annotation) o1, (Annotation) o2);\n    }\n    return type.isEnum() ? enumMemberEquals((Enum) o1, (Enum) o2)\n            : type.isPrimitive() ? primitiveMemberEquals(type, o1, o2)\n            : o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (o1 instanceof Annotation && o2 instanceof Annotation) {\n        return hashCode((Annotation) o1) == hashCode((Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (o1 == o2) {\n        return true;\n    }\n    if (o1 == null || o2 == null) {\n        return false;\n    }\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return annotationMemberEquals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (o1 == o2) {\n        return true;\n    }\n    if (o1 == null || o2 == null) {\n        return false;\n    }\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return annotationMemberEquals((Annotation) o1, (Annotation) o2);\n    }\n    return type.isEnum() ? enumMemberEquals((Enum) o1, (Enum) o2) : o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return annotationMemberEquals((Annotation) o1, (Annotation) o2);\n    }\n    return Objects.equals(o1, o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (o1 == o2) {\n        return true;\n    }\n    if (o1 == null || o2 == null) {\n        return false;\n    }\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return annotationMemberEquals((Annotation) o1, (Annotation) o2);\n    }\n    return type.isEnum() ? enumMemberEquals((Enum) o1, (Enum) o2)\n            : o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return annotationMemberEquals((Annotation) o1, (Annotation) o2);\n    }\n    return Objects.equals(o1, o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return annotationMemberEquals((Annotation) o1, (Annotation) o2);\n    }\n    return Objects.equals(o1, o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return annotationMemberEquals((Annotation) o1, (Annotation) o2);\n    }\n    return Objects.equals(o1, o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (o1 == o2) {\n        return true;\n    }\n    if (o1 == null || o2 == null) {\n        return false;\n    }\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return annotationMemberEquals((Annotation) o1, (Annotation) o2);\n    }\n    return type.isEnum() ? enumMemberEquals((Enum) o1, (Enum) o2) : o1.equals(o2);\n}"
    ],
    [
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  }\n  return type.getLeastSupertype(JSType.NO_RESOLVED_TYPE);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  }\n  return type.getLeastSupertype(type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE));\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  }\n  return type.getLeastSupertype(type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE));\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  }\n  return type.getLeastSupertype(JSType.NO_RESOLVED_TYPE);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  }\n  return type.getLeastSupertype(JSType.NO_RESOLVED_TYPE);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  }\n  if (type.isUnionType()) {\n    return type.toMaybeUnionType().filterNoResolvedType();\n  }\n  if (type.isTemplatizedType()) {\n    return type.toMaybeTemplatizedType().filterNoResolvedType();\n  }\n  if (type.isFunctionType()) {\n    return type.toMaybeFunctionType().filterNoResolvedType();\n  }\n  if (type.isObjectType()) {\n    return type.toMaybeObjectType().filterNoResolvedType();\n  }\n  return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  }\n  if (type.isUnionType()) {\n    UnionType unionType = type.toMaybeUnionType();\n    List<JSType> filteredMembers = new ArrayList<>();\n    for (JSType member : unionType.getMembers()) {\n      if (!member.isNoResolvedType()) {\n        filteredMembers.add(member);\n      }\n    }\n    if (filteredMembers.isEmpty()) {\n      return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n    }\n    return type.getNativeType(JSTypeNative.UNKNOWN_TYPE);\n  }\n  return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  }\n  if (type.isUnionType()) {\n    return type.toMaybeUnionType().filterNoResolvedType();\n  }\n  if (type.isTemplatizedType()) {\n    return type.toMaybeTemplatizedType().filterNoResolvedType();\n  }\n  if (type.isObjectType()) {\n    return type.toMaybeObjectType().filterNoResolvedType();\n  }\n  return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  }\n  return type.registry.createNoResolvedType(type);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  }\n  if (type.isUnionType()) {\n    return type.toMaybeUnionType().filterNoResolvedType();\n  }\n  if (type.isTemplatizedType()) {\n    return type.toMaybeTemplatizedType().filterNoResolvedType();\n  }\n  if (type.isFunctionType()) {\n    return type.toMaybeFunctionType().filterNoResolvedType();\n  }\n  if (type.isRecordType()) {\n    return type.toMaybeRecordType().filterNoResolvedType();\n  }\n  return type;\n}"
    ],
    [
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null) {\n      return blindScope;\n    }\n    if (originalType == null) {\n      return blindScope;\n    }\n    if (originalType.isUnknownType() || restrictedType.isUnknownType()) {\n      return blindScope;\n    }\n    if (originalType.isEquivalentTo(restrictedType)) {\n      return blindScope;\n    }\n    // We have a type change, so we need to branch the flow scope.\n    // We do not want to create a new scope for every type change,\n    // because that makes type inference slower.\n    // So we only create a new scope if the type change is significant.\n    // We define \"significant\" as \"not a subtype of the original type\".\n    if (restrictedType.isSubtypeOf(originalType)) {\n      return blindScope;\n    }\n    // We have a type change, so we need to branch the flow scope.\n    // We do not want to create a new scope for every type change,\n    // because that makes type inference slower.\n    // So we only create a new scope if the type change is significant.\n    // We define \"significant\" as \"not a subtype of the original type\".\n    if (restrictedType.isSubtypeOf(originalType)) {\n      return blindScope;\n    }\n    // We have a type change, so we need to branch the flow scope.\n    // We do not want to create a new scope for every type change,\n    // because that makes type inference slower.\n    // So we only create a new scope if the type change is significant.\n    // We define \"significant\" as \"not a subtype of the original type\".\n    if (restrictedType.isSubtypeOf(originalType)) {\n      return blindScope;\n    }\n    // We have a type change, so we need to branch the flow scope.\n    // We do not want to create a new scope for every type change,\n    // because that makes type inference slower.\n    // So we only create a new scope if the type change is significant.\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null) {\n      return blindScope;\n    }\n    if (originalType == null) {\n      return blindScope.createChildFlowScope();\n    }\n    if (originalType.isSubtype(restrictedType)) {\n      return blindScope;\n    }\n    if (restrictedType.isSubtype(originalType)) {\n      return blindScope.createChildFlowScope();\n    }\n    return blindScope.createChildFlowScope();\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null) {\n      return blindScope;\n    }\n    if (originalType != null && originalType.isSubtype(restrictedType)) {\n      return blindScope;\n    }\n    if (originalType == null) {\n      return blindScope.createChildFlowScope();\n    }\n    // If we have a name, then we want to create a new scope\n    // that has the name declared with the new type.\n    StaticSlot<JSType> slot = blindScope.findUniqueRefinedSlot(blindScope);\n    if (slot == null || !slot.getName().equals(node.getString())) {\n      return blindScope.createChildFlowScope();\n    }\n    FlowScope informed = blindScope.createChildFlowScope();\n    informed.inferSlotType(slot.getName(), restrictedType);\n    return informed;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null) {\n      return blindScope;\n    }\n    if (originalType == null || restrictedType.isSubtype(originalType)) {\n      return blindScope;\n    }\n    StaticSlot<JSType> slot = blindScope.getSlot(node);\n    if (slot == null) {\n      return blindScope;\n    }\n    JSType type = slot.getType();\n    if (type == null || type.isSubtype(restrictedType)) {\n      return blindScope;\n    }\n    // We're going to create a new flow scope, so we need to freeze the current one.\n    // This is because we're going to branch, and we don't want the current flow scope\n    // to be modified.\n    blindScope.freeze();\n    // We're going to create a new flow scope, so we need to create a new child flow scope.\n    // This is because we're going to branch, and we don't want the current flow scope\n    // to be modified.\n    FlowScope informed = blindScope.createChildFlowScope();\n    // We're going to create a new flow scope, so we need to create a new flow scope.\n    // This is because we're going to branch, and we don't want the current flow scope\n    // to be modified.\n    informed.inferSlotType(slot.getName(), restrictedType);\n    return informed;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null) {\n      return blindScope;\n    }\n    if (originalType != null &&\n        restrictedType.isSubtype(originalType)) {\n      return blindScope;\n    }\n    // We need to create a new scope because the type of the name\n    // has changed.\n    FlowScope informed = blindScope.createChildFlowScope();\n    informed.inferSlotType(node.getQualifiedName(), restrictedType);\n    return informed;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null) {\n      return blindScope;\n    }\n    if (originalType != null && originalType.isSubtype(restrictedType)) {\n      return blindScope;\n    }\n    if (node.isName()) {\n      String name = node.getString();\n      FlowScope informed = blindScope.createChildFlowScope();\n      informed.inferSlotType(name, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null) {\n      return blindScope;\n    }\n    if (originalType == null || restrictedType.isSubtypeOf(originalType)) {\n      return blindScope;\n    }\n    if (node.isQualifiedName()) {\n      String varName = node.getQualifiedName();\n      StaticSlot<JSType> slot = blindScope.getSlot(varName);\n      if (slot != null && slot.getType().isSubtypeOf(restrictedType)) {\n        return blindScope;\n      }\n    }\n    FlowScope informed = blindScope.createChildFlowScope();\n    informed.inferSlotType(node, restrictedType);\n    return informed;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null) {\n      return blindScope;\n    }\n    if (originalType == null) {\n      return blindScope;\n    }\n    if (originalType.equals(restrictedType)) {\n      return blindScope;\n    }\n    if (originalType.isUnknownType() || restrictedType.isUnknownType()) {\n      return blindScope;\n    }\n    if (originalType.isAllType() || restrictedType.isAllType()) {\n      return blindScope;\n    }\n    if (originalType.isNoneType() || restrictedType.isNoneType()) {\n      return blindScope;\n    }\n    if (originalType.isSubtypeOf(restrictedType)) {\n      return blindScope;\n    }\n    if (restrictedType.isSubtypeOf(originalType)) {\n      return blindScope;\n    }\n    if (node.isName()) {\n      String name = node.getString();\n      if (blindScope.isDeclared(name, false)) {\n        FlowScope informed = blindScope.createChildFlowScope();\n        informed.inferSlotType(name, restrictedType);\n        return informed;\n      }\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null) {\n      return blindScope;\n    }\n    if (originalType == null || restrictedType.isSubtypeOf(originalType)) {\n      return blindScope;\n    }\n    // If we did create a more precise scope, blindScope has a child and\n    // it is frozen. We can't just throw it away to return it. So we\n    // must create a child instead.\n    return blindScope == this ?\n        this : this.createChildFlowScope();\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null) {\n      return blindScope;\n    }\n    if (originalType == null) {\n      return blindScope;\n    }\n    if (originalType.equals(restrictedType)) {\n      return blindScope;\n    }\n    if (originalType.isUnknownType() || restrictedType.isUnknownType()) {\n      return blindScope;\n    }\n    if (node.isName()) {\n      String name = node.getString();\n      if (blindScope.isDeclared(name)) {\n        FlowScope informed = blindScope.createChildFlowScope();\n        informed.inferSlotType(name, restrictedType);\n        return informed;\n      }\n    }\n    return blindScope;\n  }"
    ],
    [
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token != JsDocToken.FUNCTION) \n    {\n        return reportGenericTypeSyntaxWarning();\n    }\n\n    Node functionType = newNode(Token.FUNCTION);\n    functionType.setLineno(stream.getLineno());\n    functionType.setCharno(stream.getCharno());\n\n    // TypeParameters\n    skipEOLs();\n    if (match(JsDocToken.LT)) \n    {\n        next();\n        skipEOLs();\n        functionType.addChildToFront(parseTypeParameterList(next()));\n        skipEOLs();\n        if (!match(JsDocToken.GT)) \n        {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n        }\n\n        next();\n    }\n\n    // '('\n    skipEOLs();\n    if (match(JsDocToken.LP)) \n    {\n        next();\n    }\n    else \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    // 'this' ':' TypeName\n    skipEOLs();\n    if (match(JsDocToken.THIS)) \n    {\n        next();\n        skipEOLs();\n        if (!match(JsDocToken.COLON)) \n        {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n        }\n\n        next();\n        skipEOLs();\n        functionType.addChildToFront(parseTypeName(next()));\n    }\n\n    // ParametersType\n    skipEOLs();\n    functionType.addChildToFront(parseParametersType(next()));\n\n    // ')' ResultType\n    skipEOLs();\n    if (!match(JsDocToken.RP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    next();\n    skipEOLs();\n    functionType.addChildToFront(parseResultType(next()));\n\n    return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  if (token != JsDocToken.STRING || !\"function\".equals(stream.getString())) {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  int lineno = stream.getLineno();\n  int charno = stream.getCharno();\n  next();\n  skipEOLs();\n\n  Node functionType = newNode(Token.FUNCTION);\n\n  if (match(JsDocToken.LT)) {\n    next();\n    skipEOLs();\n    functionType.addChildToFront(parseTypeParameters(next()));\n    skipEOLs();\n    if (!match(JsDocToken.GT)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n    }\n    next();\n  }\n\n  skipEOLs();\n  if (!match(JsDocToken.LP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n  next();\n  skipEOLs();\n\n  Node thisType = null;\n  if (match(JsDocToken.THIS)) {\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n    skipEOLs();\n    thisType = parseTypeName(next());\n    skipEOLs();\n  }\n\n  Node parametersType = parseParametersType(next());\n  if (parametersType == null) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.parameters\");\n  }\n\n  functionType.addChildToFront(parametersType);\n  skipEOLs();\n  if (!match(JsDocToken.RP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n  next();\n\n  skipEOLs();\n  if (match(JsDocToken.COLON)) {\n    next();\n    skipEOLs();\n    Node resultType = parseTypeExpression(next());\n    if (resultType != null) {\n      functionType.addChildToFront(resultType);\n    }\n  }\n\n  return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token != JsDocToken.STRING || !\"function\".equals(stream.getString())) \n    {\n        return reportGenericTypeSyntaxWarning();\n    }\n\n    int lineno = stream.getLineno();\n    int charno = stream.getCharno();\n    skipEOLs();\n\n    Node functionType = newNode(Token.FUNCTION);\n\n    // TypeParameters\n    if (match(JsDocToken.LT)) \n    {\n        next();\n        skipEOLs();\n        Node typeParameters = parseTypeParameters(next());\n        if (typeParameters != null) \n        {\n            functionType.addChildToFront(typeParameters);\n        }\n    }\n\n    // '('\n    if (!match(JsDocToken.LP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    next();\n    skipEOLs();\n\n    // 'this' ':' TypeName\n    if (match(JsDocToken.THIS)) \n    {\n        next();\n        skipEOLs();\n        if (!match(JsDocToken.COLON)) \n        {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n        }\n\n        next();\n        skipEOLs();\n        Node thisType = parseTypeName(next());\n        if (thisType != null) \n        {\n            functionType.addChildToFront(thisType);\n        }\n    }\n\n    // ParametersType\n    if (!match(JsDocToken.RP)) \n    {\n        Node parametersType = parseParametersType(next());\n        if (parametersType != null) \n        {\n            functionType.addChildToFront(parametersType);\n        }\n    }\n\n    // ')' ResultType\n    if (!match(JsDocToken.RP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    next();\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType != null) \n    {\n}\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token != JsDocToken.STRING ||\n        !\"function\".equals(stream.getString())) {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    int lineno = stream.getLineno();\n    int charno = stream.getCharno();\n    next();\n\n    skipEOLs();\n    if (!match(JsDocToken.LT)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lt\");\n    }\n\n    next();\n    skipEOLs();\n    Node typeParameters = parseTypeParameters(next());\n    if (typeParameters != null) {\n      skipEOLs();\n      if (!match(JsDocToken.LP)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n      }\n\n      next();\n      skipEOLs();\n      if (!match(JsDocToken.THIS)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n      }\n\n      next();\n      skipEOLs();\n      if (!match(JsDocToken.COLON)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n      }\n\n      next();\n      skipEOLs();\n      Node typeName = parseTypeName(next());\n      if (typeName != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RP)) {\n          return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n        }\n\n        next();\n        skipEOLs();\n        Node parametersType = parseParametersType(next());\n        if (parametersType != null) {\n          skipEOLs();\n          if (!match(JsDocToken.RP)) {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n          }\n\n          next();\n          skipEOLs();\n          Node resultType = parseResultType(next());\n          if (resultType != null) {\n            return newFunctionType(typeParameters, typeName, parametersType, resultType, lineno, charno);\n          }\n        }\n      }\n    }\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token != JsDocToken.STRING || !\"function\".equals(stream.getString())) {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    int lineno = stream.getLineno();\n    int charno = stream.getCharno();\n    next();\n    skipEOLs();\n\n    Node functionType = newNode(Token.FUNCTION);\n\n    // TypeParameters\n    if (match(JsDocToken.LT)) {\n      next();\n      skipEOLs();\n      functionType.addChildToFront(parseTypeParameters(next()));\n      skipEOLs();\n      if (!match(JsDocToken.GT)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n      }\n\n      next();\n    }\n\n    // '('\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    next();\n    skipEOLs();\n\n    // 'this' ':' TypeName\n    if (match(JsDocToken.THIS)) {\n      next();\n      skipEOLs();\n      if (!match(JsDocToken.COLON)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n      }\n\n      next();\n      skipEOLs();\n      functionType.addChildToFront(parseTypeName(next()));\n      skipEOLs();\n    }\n\n    // ParametersType\n    functionType.addChildToFront(parseParametersType(next()));\n    skipEOLs();\n\n    // ')'\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    next();\n    skipEOLs();\n\n    // ResultType\n    functionType.addChildToFront(parseResultType(next()));\n    skipEOLs();\n\n    return functionType;\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token != JsDocToken.FUNCTION) \n    {\n        return reportGenericTypeSyntaxWarning();\n    }\n\n    Node functionType = newNode(Token.FUNCTION);\n\n    // TypeParameters\n    if (match(JsDocToken.LT)) \n    {\n        next();\n        skipEOLs();\n        Node typeParameters = parseTypeParameters(next());\n        if (typeParameters != null) \n        {\n            functionType.addChildToFront(typeParameters);\n        }\n    }\n\n    // '('\n    if (!match(JsDocToken.LP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    next();\n    skipEOLs();\n\n    // 'this' ':' TypeName\n    if (match(JsDocToken.THIS)) \n    {\n        next();\n        skipEOLs();\n        if (!match(JsDocToken.COLON)) \n        {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n        }\n\n        next();\n        skipEOLs();\n        Node typeName = parseTypeName(next());\n        if (typeName != null) \n        {\n            functionType.addChildToFront(typeName);\n        }\n    }\n\n    // ParametersType\n    if (!match(JsDocToken.RP)) \n    {\n        Node parametersType = parseParametersType(next());\n        if (parametersType != null) \n        {\n            functionType.addChildToFront(parametersType);\n        }\n    }\n\n    // ')'\n    if (!match(JsDocToken.RP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    next();\n    skipEOLs();\n\n    // ResultType\n    Node resultType = parseResultType(next());\n    if (resultType != null) \n    {\n        functionType.addChildToFront(resultType);\n    }\n\n    return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token != JsDocToken.FUNCTION) \n    {\n        return reportGenericTypeSyntaxWarning();\n    }\n\n    Node functionType = newNode(Token.FUNCTION);\n    functionType.setLineno(stream.getLineno());\n    functionType.setCharno(stream.getCharno());\n\n    // TypeParameters\n    if (match(JsDocToken.LT)) \n    {\n        next();\n        skipEOLs();\n        functionType.addChildToFront(parseTypeExpressionList(next()));\n\n        skipEOLs();\n        if (!match(JsDocToken.GT)) \n        {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n        }\n\n        next();\n    }\n\n    // '('\n    if (!match(JsDocToken.LP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    next();\n    skipEOLs();\n\n    // 'this' ':' TypeName\n    if (match(JsDocToken.THIS)) \n    {\n        next();\n        skipEOLs();\n        if (!match(JsDocToken.COLON)) \n        {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n        }\n\n        next();\n        skipEOLs();\n        functionType.addChildToFront(parseTypeName(next()));\n    }\n\n    // ParametersType\n    functionType.addChildToFront(parseParametersType(next()));\n\n    skipEOLs();\n    if (!match(JsDocToken.RP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    next();\n    skipEOLs();\n\n    // ResultType\n    functionType.addChildToFront(parseResultType(next()));\n\n    return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token != JsDocToken.STRING || !\"function\".equals(stream.getString())) {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    int lineno = stream.getLineno();\n    int charno = stream.getCharno();\n    next();\n\n    skipEOLs();\n    if (!match(JsDocToken.LT)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lt\");\n    }\n\n    next();\n    skipEOLs();\n    Node typeParameters = parseTypeParameters(next());\n    if (typeParameters != null) {\n      Node thisType = parseThisType(next());\n      if (thisType != null) {\n        Node parametersType = parseParametersType(next());\n        if (parametersType != null) {\n          Node resultType = parseResultType(next());\n          if (resultType != null) {\n            return newNode(Token.FUNCTION, typeParameters, thisType, parametersType, resultType);\n          }\n        }\n      }\n    }\n\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token != JsDocToken.FUNCTION) {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    skipEOLs();\n    Node functionType = newNode(Token.FUNCTION);\n\n    if (match(JsDocToken.LT)) {\n      next();\n      skipEOLs();\n      functionType.addChildToFront(parseTypeParameters(next()));\n\n      skipEOLs();\n      if (!match(JsDocToken.LP)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n      }\n\n      next();\n      skipEOLs();\n      functionType.addChildToFront(parseTypeName(next()));\n\n      skipEOLs();\n      if (!match(JsDocToken.COLON)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n      }\n\n      next();\n      skipEOLs();\n      functionType.addChildToFront(parseTypeName(next()));\n\n      skipEOLs();\n      if (!match(JsDocToken.RP)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n      }\n\n      next();\n      skipEOLs();\n      functionType.addChildToFront(parseParametersType(next()));\n\n      skipEOLs();\n      if (!match(JsDocToken.RP)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n      }\n\n      next();\n      skipEOLs();\n      functionType.addChildToFront(parseResultType(next()));\n    }\n    return functionType;\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token != JsDocToken.STRING || !\"function\".equals(stream.getString())) {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    int lineno = stream.getLineno();\n    int charno = stream.getCharno();\n    skipEOLs();\n\n    Node functionType = newNode(Token.FUNCTION);\n\n    // TypeParameters\n    if (match(JsDocToken.LT)) {\n      next();\n      skipEOLs();\n      functionType.addChildToFront(parseTypeParameters(next()));\n      skipEOLs();\n      if (!match(JsDocToken.GT)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n      }\n      next();\n    }\n\n    // '('\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n\n    // 'this' ':' TypeName\n    if (match(JsDocToken.THIS)) {\n      next();\n      skipEOLs();\n      if (!match(JsDocToken.COLON)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n      }\n      next();\n      skipEOLs();\n      functionType.addChildToFront(parseTypeName(next()));\n      skipEOLs();\n    }\n\n    // ParametersType\n    if (!match(JsDocToken.RP)) {\n      functionType.addChildToFront(parseParametersType(next()));\n      skipEOLs();\n    }\n\n    // ')' ResultType\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n    skipEOLs();\n    functionType.addChildToFront(parseResultType(next()));\n    skipEOLs();\n\n    return functionType;\n  }"
    ],
    [
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n        if (str == null) {\n            return null;\n        }\n        final int sz = str.length();\n        final char[] chs = new char[sz];\n        int count = 0;\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                chs[count++] = str.charAt(i);\n            }\n        }\n        if (count == sz) {\n            return str;\n        }\n        return new String(chs, 0, count);\n    }",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) \n    {\n        return null;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) \n    {\n        if (!Character.isWhitespace(str.charAt(i))) \n        {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) \n    {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n        if (str == null) {\n            return null;\n        }\n        final int sz = str.length();\n        final char[] chs = new char[sz];\n        int count = 0;\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                chs[count++] = str.charAt(i);\n            }\n        }\n        if (count == sz) {\n            return str;\n        }\n        return new String(chs, 0, count);\n    }",
      "public static String deleteWhitespace(final String str)  {\n        if (str == null) {\n            return null;\n        }\n        final int sz = str.length();\n        final char[] chs = new char[sz];\n        int count = 0;\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                chs[count++] = str.charAt(i);\n            }\n        }\n        if (count == sz) {\n            return str;\n        }\n        return new String(chs, 0, count);\n    }",
      "public static String deleteWhitespace(final String str)  {\n        if (str == null) {\n            return null;\n        }\n        final int sz = str.length();\n        final char[] chs = new char[sz];\n        int count = 0;\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                chs[count++] = str.charAt(i);\n            }\n        }\n        if (count == sz) {\n            return str;\n        }\n        return new String(chs, 0, count);\n    }",
      "public static String deleteWhitespace(final String str)  {\n        if (str == null) {\n            return null;\n        }\n        final int sz = str.length();\n        final char[] chs = new char[sz];\n        int count = 0;\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                chs[count++] = str.charAt(i);\n            }\n        }\n        if (count == sz) {\n            return str;\n        }\n        return new String(chs, 0, count);\n    }",
      "public static String deleteWhitespace(final String str)  {\n        if (str == null) {\n            return null;\n        }\n        final int sz = str.length();\n        final char[] chs = new char[sz];\n        int count = 0;\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                chs[count++] = str.charAt(i);\n            }\n        }\n        if (count == sz) {\n            return str;\n        }\n        return new String(chs, 0, count);\n    }"
    ],
    [
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    double sum = 0;\n    double sumsq = 0;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    double mean = 0;\n    double variance = 0;\n    double geometricMean = 1;\n    int n = 0;\n\n    for (SummaryStatistics stat : statistics) {\n        if (stat == null) {\n            continue;\n        }\n\n        n += stat.getN();\n        sum += stat.getSum();\n        sumsq += stat.getSumsq();\n        min = Math.min(min, stat.getMin());\n        max = Math.max(max, stat.getMax());\n        mean = sum / n;\n        variance = (sumsq - (sum * sum / n)) / n;\n        geometricMean = geometricMean * Math.pow(stat.getGeometricMean(), n);\n    }\n\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null) {\n        return null;\n    }\n    double mean = 0;\n    double variance = 0;\n    double n = 0;\n    double max = Double.NEGATIVE_INFINITY;\n    double min = Double.POSITIVE_INFINITY;\n    double sum = 0;\n    double sumsq = 0;\n    double sumLog = 0;\n    double gmean = 1;\n    for (SummaryStatistics stats : statistics) {\n        if (stats == null) {\n            continue;\n        }\n        mean += stats.getMean();\n        variance += stats.getVariance();\n        n += stats.getN();\n        max = Math.max(max, stats.getMax());\n        min = Math.min(min, stats.getMin());\n        sum += stats.getSum();\n        sumsq += stats.getSumsq();\n        sumLog += stats.getSumOfLogs();\n        gmean *= stats.getGeometricMean();\n    }\n    if (n < 2) {\n        return null;\n    }\n    mean /= n;\n    variance /= n;\n    variance -= mean * mean;\n    if (variance < 0) {\n        variance = 0;\n    }\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum, sumsq, sumLog, gmean);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null) {\n        return null;\n    }\n    double sum = 0.0;\n    double sumsq = 0.0;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    long n = 0;\n    for (SummaryStatistics stat : statistics) {\n        if (stat == null) {\n            continue;\n        }\n        sum += stat.getSum();\n        sumsq += stat.getSumsq();\n        min = Math.min(min, stat.getMin());\n        max = Math.max(max, stat.getMax());\n        n += stat.getN();\n    }\n    return new StatisticalSummaryValues(sum / n, (sumsq - ((sum * sum) / n)) / (n - 1), n, min, max, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    double sum = 0;\n    double sumsq = 0;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    double sumLogs = 0;\n    double geometricMean = 1;\n    double n = 0;\n\n    for (SummaryStatistics stat : statistics) {\n        if (stat == null) {\n            continue;\n        }\n        n += stat.getN();\n        sum += stat.getSum();\n        sumsq += stat.getSumsq();\n        min = Math.min(min, stat.getMin());\n        max = Math.max(max, stat.getMax());\n        sumLogs += stat.getSumOfLogs();\n        geometricMean *= stat.getGeometricMean();\n    }\n\n    return new StatisticalSummaryValues(sum / n, (sumsq - ((sum * sum) / n)) / (n - 1), n, min, max, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null) {\n        return null;\n    }\n\n    double sum = 0.0;\n    double sumsq = 0.0;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    double sumLog = 0.0;\n    double geometricMean = 1.0;\n    double n = 0.0;\n\n    for (SummaryStatistics stat : statistics) {\n        if (stat == null) {\n            continue;\n        }\n        n += stat.getN();\n        sum += stat.getSum();\n        sumsq += stat.getSumsq();\n        min = Math.min(min, stat.getMin());\n        max = Math.max(max, stat.getMax());\n        sumLog += stat.getSumOfLogs();\n        geometricMean *= stat.getGeometricMean();\n    }\n\n    return new StatisticalSummaryValues(sum / n, (sumsq - ((sum * sum) / n)) / (n - 1), n, min, max, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null) {\n        return null;\n    }\n\n    // Create a new AggregateSummaryStatistics instance\n    AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();\n\n    // Iterate over the collection and add each SummaryStatistics instance to the aggregate\n    for (SummaryStatistics stat : statistics) {\n        aggregate.add(stat);\n    }\n\n    // Return the aggregate summary statistics\n    return aggregate.getSummary();\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    // Create a new SummaryStatistics instance to aggregate the data\n    SummaryStatistics aggregatedStatistics = new AggregatingSummaryStatistics(null);\n\n    // Aggregate the data\n    for (SummaryStatistics contributingStatistics : statistics) {\n        SummaryStatistics.add(aggregatedStatistics, contributingStatistics);\n    }\n\n    // Return the aggregate statistics\n    return new StatisticalSummaryValues(aggregatedStatistics.getMean(),\n            aggregatedStatistics.getVariance(), aggregatedStatistics.getN(),\n            aggregatedStatistics.getMax(), aggregatedStatistics.getMin(),\n            aggregatedStatistics.getSum());\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    // Create a new AggregatingSummaryStatistics to hold the aggregated data\n    AggregatingSummaryStatistics aggregatingSummaryStatistics = new AggregatingSummaryStatistics();\n\n    // For each SummaryStatistics instance in the collection, copy its data into the\n    // aggregatingSummaryStatistics instance\n    for (SummaryStatistics summaryStatistics : statistics) {\n        SummaryStatistics.copy(summaryStatistics, aggregatingSummaryStatistics);\n    }\n\n    // Return the aggregated data as a StatisticalSummaryValues instance\n    return aggregatingSummaryStatistics.getSummary();\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    // Create an initial statistics instance with the same prototype as the first one\n    SummaryStatistics prototype = statistics.iterator().next();\n    SummaryStatistics aggregated = new AggregatingSummaryStatistics(prototype);\n\n    // No try - catch or advertising NAE because neither argument will ever be null\n    SummaryStatistics.copy(prototype, aggregated);\n\n    // Aggregate all statistics\n    for (SummaryStatistics stat : statistics) {\n        SummaryStatistics.add(aggregated, stat);\n    }\n\n    return new StatisticalSummaryValues(aggregated.getMean(), aggregated.getVariance(),\n            aggregated.getN(), aggregated.getMax(), aggregated.getMin(), aggregated.getSum());\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    SummaryStatistics contributingStatistics = new AggregatingSummaryStatistics(null);\n    for (SummaryStatistics s : statistics) {\n        SummaryStatistics.copy(s, contributingStatistics);\n    }\n    return new StatisticalSummaryValues(contributingStatistics.getMean(), contributingStatistics.getVariance(),\n            contributingStatistics.getN(), contributingStatistics.getMax(), contributingStatistics.getMin(),\n            contributingStatistics.getSum());\n}"
    ],
    [
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += (sample1[i] - sample2[i]) * (sample1[i] - sample2[i]);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += (sample1[i] - sample2[i]) * (sample1[i] - sample2[i]);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        double sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += (sample1[i] - sample2[i]) * (sample1[i] - sample2[i]);\n        }\n        return sum / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        double sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += (sample1[i] - sample2[i]) * (sample1[i] - sample2[i]);\n        }\n        return sum / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        double sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += (sample1[i] - sample2[i]) - meanDifference;\n        }\n        return sum / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += (sample1[i] - sample2[i]) * (sample1[i] - sample2[i]);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += (sample1[i] - sample2[i]) * (sample1[i] - sample2[i]);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        double sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += (sample1[i] - sample2[i]) * (sample1[i] - sample2[i]);\n        }\n        return sum / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += (sample1[i] - sample2[i]) * (sample1[i] - sample2[i]);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += (sample1[i] - sample2[i]) * (sample1[i] - sample2[i]);\n        }\n        return result / (n - 1);\n    }"
    ],
    [
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    // check arguments...\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    // start with a total of zero...\n    double total = 0.0;\n    // get the keys...\n    int count = dataset.getItemCount();\n    // add the values for each key...\n    for (int i = 0; i < count; i++) {\n        Comparable key = dataset.getItemKey(i);\n        Number value = dataset.getValue(key);\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int count = dataset.getItemCount();\n    for (int i = 0; i < count; i++) {\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) {\n        Comparable itemKey = dataset.getItemKey(i);\n        Number value = dataset.getValue(itemKey);\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    // check arguments...\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    // start with a total of zero...\n    double total = 0.0;\n    // get the number of items in the dataset...\n    int itemCount = dataset.getItemCount();\n    // iterate over the items and add the values to the total...\n    for (int itemIndex = 0; itemIndex < itemCount; itemIndex++) {\n        Comparable itemKey = dataset.getItemKey(itemIndex);\n        Number value = dataset.getValue(itemKey);\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n    // return the total...\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) {\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) {\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    // defer argument checking\n    return calculatePieDatasetTotal(dataset, true);\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) {\n        Comparable itemKey = dataset.getItemKey(i);\n        Number value = dataset.getValue(itemKey);\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int count = dataset.getItemCount();\n    for (int i = 0; i < count; i++) {\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    // defer argument checking\n    return calculatePieDatasetTotal(dataset, false);\n}"
    ],
    [
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedName();\n    } else if (p == PEEKED_NAME) {\n      result = nextQuotedName(buffer[pos++]);\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedName();\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedName('\"');\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedName('\\'');\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED_NAME) {\n      peeked = PEEKED_NONE;\n      return source.subSequence(peekedStringStart, peekedStringLength).toString();\n    }\n    if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      peeked = PEEKED_NONE;\n      return nextQuotedValue(true);\n    }\n    if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      peeked = PEEKED_NONE;\n      return nextQuotedValue(false);\n    }\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedName();\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedName('\"');\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedName('\\'');\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek()\n          + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedName();\n    } else if (p == PEEKED_NAME) {\n      result = nextQuotedValue(PEEKED_NAME);\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedName();\n    } else if (p == PEEKED_NAME) {\n      result = nextQuotedName();\n    } else {\n      throw new JsonDataException(\"Expected a name but was \" + peek()\n          + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedName();\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedName('\"');\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedName('\\'');\n    } else if (p == PEEKED_BUFFERED_NAME) {\n      result = peekedString;\n      peekedString = null;\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED_NAME) {\n      peeked = PEEKED_NONE;\n      return source.subSequence(pendingName, peekedNameEnd).toString();\n    }\n    if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      peeked = PEEKED_NONE;\n      return nextQuotedValue(true);\n    }\n    if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      peeked = PEEKED_NONE;\n      return nextQuotedValue(false);\n    }\n    if (p == PEEKED_BUFFERED_NAME) {\n      buffer.writeUtf8(source, peekedNameEnd, source.available());\n      int length = peekedNameEnd + source.available();\n      peeked = PEEKED_NONE;\n      return buffer.readUtf8(length);\n    }\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      return Long.toString(peekedLong);\n    }\n    if (p == PEEKED_NUMBER) {\n      peeked = PEEKED_NONE;\n      return new String(source, peekedNumberLength + peekedNumberOffset, peekedNumberLength - peekedNumberPendingEscapeCount, UTF8_CHARSET);\n    }\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED_NAME) {\n      peeked = PEEKED_NONE;\n      pos += peekedString.length();\n      return peekedString;\n    }\n    if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      peekedString = nextQuotedValue(DOUBLE_QUOTE_OR_SLASH);\n      peeked = PEEKED_NONE;\n      pos += peekedString.length();\n      return peekedString;\n    }\n    if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      peekedString = nextQuotedValue(SINGLE_QUOTE);\n      peeked = PEEKED_NONE;\n      pos += peekedString.length();\n      return peekedString;\n    }\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedName();\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedName('\"');\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedName('\\'');\n    } else if (p == PEEKED_NAME) {\n      result = peekedString;\n      doPeek();\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek()\n          + locationString());\n    }\n    pathNames[stackSize - 1] = result;\n    return result;\n  }"
    ],
    [
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    }\n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}"
    ],
    [
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) {\n        return -1;\n    }\n    int read = currentCompressedChunk.read(b, off, len);\n    if (read == -1) {\n        currentCompressedChunk.close();\n        currentCompressedChunk = null;\n    }\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) {\n        return -1;\n    }\n    final int read = currentCompressedChunk.read(b, off, len);\n    if (read == -1) {\n        currentCompressedChunk.close();\n        currentCompressedChunk = null;\n        if (endReached) {\n            return -1;\n        }\n    }\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) {\n        return -1;\n    }\n    int read = currentCompressedChunk.read(b, off, len);\n    if (read == -1) {\n        currentCompressedChunk.close();\n        currentCompressedChunk = null;\n    }\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) {\n        return -1;\n    }\n    final int read = currentCompressedChunk.read(b, off, len);\n    if (read == -1) {\n        currentCompressedChunk.close();\n        currentCompressedChunk = null;\n    }\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) {\n        return -1;\n    }\n    int read = currentCompressedChunk.read(b, off, len);\n    if (read == -1) {\n        currentCompressedChunk.close();\n        currentCompressedChunk = null;\n    }\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) {\n        return -1;\n    }\n    final int read = currentCompressedChunk.read(b, off, len);\n    if (read == -1) {\n        currentCompressedChunk.close();\n        currentCompressedChunk = null;\n    }\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) {\n        return -1;\n    }\n    int read = currentCompressedChunk.read(b, off, len);\n    if (read == -1) {\n        currentCompressedChunk.close();\n        currentCompressedChunk = null;\n    }\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) {\n        return -1;\n    }\n    final int bytesRead = currentCompressedChunk.read(b, off, len);\n    if (bytesRead == -1) {\n        currentCompressedChunk.close();\n        currentCompressedChunk = null;\n        return -1;\n    }\n    return bytesRead;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) {\n        return -1;\n    }\n    int read = currentCompressedChunk.read(b, off, len);\n    if (read == -1) {\n        currentCompressedChunk.close();\n        currentCompressedChunk = null;\n    }\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) {\n        return -1;\n    }\n    int read = currentCompressedChunk.read(b, off, len);\n    if (read == -1) {\n        currentCompressedChunk.close();\n        currentCompressedChunk = null;\n    }\n    return read;\n}"
    ],
    [
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n  Node node = site.node;\n  Node parent = node.getParent();\n  if (parent.isCall() || parent.isNew() || parent.isGetProp()) {\n    Node arg = node.getNext();\n    for (int i = 0; i < argIndex; i++) {\n      if (arg == null) {\n        return null;\n      }\n      arg = arg.getNext();\n    }\n    return arg;\n  }\n  return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n  Node node = site.node;\n  if (node.isCall() || node.isNew()) {\n    Node arg = node.getChildAtIndex(argIndex + 1);\n    if (arg != null) {\n      return arg;\n    }\n  } else if (node.isGetProp()) {\n    Node arg = node.getNext();\n    if (arg != null && arg.isNumber() && arg.getInt() == argIndex) {\n      return arg.getNext();\n    }\n  }\n  return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n  Node callNode = site.node;\n  Node arg = null;\n  if (callNode.isCall()) {\n    arg = callNode.getChildAtIndex(argIndex);\n  } else if (callNode.isNew()) {\n    arg = callNode.getChildAtIndex(argIndex + 1);\n  } else if (callNode.isGetProp()) {\n    arg = callNode.getNext();\n  }\n  return arg;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n  Node callNode = site.getNode();\n  if (callNode.isCall() || callNode.isNew() || callNode.isDotCall()) {\n    Node arg = callNode.getChildAtIndex(argIndex + 1);\n    return arg;\n  }\n  return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n  Node call = site.getNode();\n  if (call.isCall() || call.isNew()) {\n    Node arg = call.getSecondChild();\n    for (int i = 0; i < argIndex; i++) {\n      arg = arg.getNext();\n    }\n    return arg;\n  } else if (call.isGetProp()) {\n    Node arg = call.getNext();\n    for (int i = 0; i < argIndex; i++) {\n      arg = arg.getNext();\n    }\n    return arg;\n  }\n  return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n  Node callNode = site.node;\n  if (callNode.isCall() || callNode.isNew()) {\n    Node arg = callNode.getChildAtIndex(argIndex);\n    if (arg != null) {\n      return arg;\n    }\n  } else if (callNode.isGetProp()) {\n    Node arg = callNode.getNext();\n    if (arg != null && arg.getNext() == null && arg.isNumber()\n        && arg.getDouble() == argIndex) {\n      return arg;\n    }\n  }\n  return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n  Node callNode = site.getNode();\n  Node parent = callNode.getParent();\n  if (parent.isNew()) {\n    if (argIndex == 0) {\n      return parent.getFirstChild();\n    } else {\n      return null;\n    }\n  } else if (parent.isCall() && parent.getFirstChild() == callNode) {\n    Node arg = callNode.getNext();\n    for (int i = 0; i < argIndex; i++) {\n      arg = arg.getNext();\n      if (arg == null) {\n        return null;\n      }\n    }\n    return arg;\n  } else if (parent.isGetProp() && parent.getFirstChild() == callNode) {\n    Node arg = callNode.getNext();\n    for (int i = 0; i < argIndex; i++) {\n      arg = arg.getNext();\n      if (arg == null) {\n        return null;\n      }\n    }\n    return arg;\n  }\n  return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n  Node call = site.getNode();\n  Node parent = call.getParent();\n  if (parent.isNew()) {\n    return getArgumentForCallOrNewOrDotCall(call, argIndex);\n  } else if (parent.isGetProp() && parent.getLastChild().isCall()) {\n    return getArgumentForCallOrNewOrDotCall(parent.getLastChild(), argIndex);\n  } else if (call.getChildCount() > argIndex) {\n    return call.getChildAtIndex(argIndex);\n  }\n  return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n  Node callNode = site.getNode();\n  if (callNode.isCall() || callNode.isNew() || callNode.isDotCall()) {\n    Node arg = callNode.getChildAtIndex(argIndex + 1);\n    if (arg != null) {\n      return arg;\n    }\n  }\n  return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n  Node callNode = site.getNode();\n  if (callNode.isCall() || callNode.isNew() || callNode.isGetProp()) {\n    Node arg = callNode.getNext();\n    for (int i = 0; i < argIndex; i++) {\n      arg = arg.getNext();\n    }\n    return arg;\n  }\n  return null;\n}"
    ],
    [
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type != null) {\n    DeprecatedTypeInfo info = type.getDeprecationInfo();\n    if (info != null) {\n      return info.getReason();\n    }\n  }\n\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type == null) {\n    return null;\n  }\n\n  // Check if the type is a deprecated type.\n  if (type.isDeprecated()) {\n    // If the type is deprecated, return the deprecation reason.\n    return type.getDeprecationReason();\n  }\n\n  // If the type is not deprecated, check if it has a supertype that is\n  // deprecated.\n  Iterator<JSType> iter = type.getImplicitPrototype().getSupertypeIterator();\n  while (iter.hasNext()) {\n    JSType supertype = iter.next();\n    if (supertype.isDeprecated()) {\n      return supertype.getDeprecationReason();\n    }\n  }\n\n  // If the type is not deprecated and has no supertype that is deprecated,\n  // return null.\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type == null) {\n    return null;\n  }\n\n  String reason = type.getPropertyString(JSType.DEPRECATED_PROP);\n  if (reason == null) {\n    return null;\n  }\n\n  if (reason.isEmpty()) {\n    return \"\";\n  }\n\n  return reason;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type == null) {\n    return null;\n  }\n\n  // We don't want to emit warnings for types that are not in the\n  // global scope.\n  if (!type.isInGlobalHoistScope()) {\n    return null;\n  }\n\n  // If the type is a function, check if it is marked as deprecated.\n  if (type.isFunctionType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType.isDeprecated()) {\n      return fnType.getDeprecationReason();\n    }\n  }\n\n  // If the type is an object, check if it is marked as deprecated.\n  if (type.isObjectType()) {\n    ObjectType objType = type.toMaybeObjectType();\n    if (objType.isDeprecated()) {\n      return objType.getDeprecationReason();\n    }\n  }\n\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type == null) {\n    return null;\n  }\n\n  // Check for the deprecated type annotation.\n  if (type.isDeprecated()) {\n    return type.getDeprecationReason();\n  }\n\n  // Check for the deprecated interface annotation.\n  if (type.isInterface()) {\n    return getTypeDeprecationInfo(type.toMaybeInterfaceType().getImplementedType());\n  }\n\n  // Check for the deprecated class annotation.\n  if (type.isClass()) {\n    return getTypeDeprecationInfo(type.toMaybeClassType().getImplementedType());\n  }\n\n  // Check for the deprecated record annotation.\n  if (type.isRecordType()) {\n    return getTypeDeprecationInfo(type.toMaybeRecordType().getImplementedType());\n  }\n\n  // Check for the deprecated enum annotation.\n  if (type.isEnumType()) {\n    return getTypeDeprecationInfo(type.toMaybeEnumType().getImplementedType());\n  }\n\n  // Check for the deprecated union annotation.\n  if (type.isUnionType()) {\n    return getTypeDeprecationInfo(type.toMaybeUnionType().getAlternateType1());\n  }\n\n  // Check for the deprecated template type annotation.\n  if (type.isTemplateType()) {\n    return getTypeDeprecationInfo(type.toMaybeTemplateType().getReferencedType());\n  }\n\n  // Check for the deprecated type parameter annotation.\n  if (type.isTypeVariable()) {\n    return getTypeDeprecationInfo(type.toMaybeTypeVariable().getBound());\n  }\n\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type == null) {\n    return null;\n  }\n\n  DeprecationInfo info = type.getDeprecationInfo();\n  if (info == null) {\n    return null;\n  }\n\n  return info.getReason();\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type != null) {\n    ObjectType objType = type.toObjectType();\n    if (objType != null) {\n      return objType.getDeprecationReason();\n    }\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type == null) {\n    return null;\n  }\n\n  // Check if the type is deprecated.\n  if (!type.isDeprecated()) {\n    return null;\n  }\n\n  // If the type is deprecated, check if it has a deprecation reason.\n  if (type.getDeprecationReason() != null) {\n    return type.getDeprecationReason();\n  }\n\n  // If the type is deprecated but has no reason, return an empty string.\n  return \"\";\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type == null) {\n    return null;\n  }\n\n  DeprecatedTypeInfo info = type.getDeprecationInfo();\n  return info == null ? null : info.getReason();\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type == null) {\n    return null;\n  }\n\n  if (type.isUnknownType()) {\n    return null;\n  }\n\n  // If this type is a union, we only care about the first type.\n  // This is because we only care about the first type's deprecation\n  // status.\n  if (type.isUnionType()) {\n    type = type.toMaybeUnionType().getAlternateType1();\n  }\n\n  // If this type is a template type, we only care about the first\n  // type. This is because we only care about the first type's\n  // deprecation status.\n  if (type.isTemplatizedType()) {\n    type = type.toMaybeTemplatizedType().getReferencedType();\n  }\n\n  if (type.isEnumType()) {\n    return getTypeDeprecationInfo(type.toMaybeEnumType().getReferencedType());\n  }\n\n  if (type.isStructType()) {\n    return getTypeDeprecationInfo(type.toMaybeStructType().getReferencedType());\n  }\n\n  if (type.isObjectType()) {\n    ObjectType objectType = type.toMaybeObjectType();\n    if (objectType.isFunctionType()) {\n      return getTypeDeprecationInfo(objectType.toMaybeFunctionType());\n    }\n\n    if (objectType.isClassType()) {\n      return getTypeDeprecationInfo(objectType.toMaybeClassType());\n    }\n  }\n\n  return null;\n}"
    ],
    [
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String displayName = cTimeZoneDisplayCache.get(key);\n    if (displayName == null) \n    {\n        displayName = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, displayName);\n    }\n    return displayName;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, value);\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        final TimeZoneDisplayKey existing = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (existing != null) {\n            value = existing;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String text = cTimeZoneDisplayCache.get(key);\n    if (text == null) {\n        text = tz.getDisplayName(daylight, style, locale);\n        final TimeZoneDisplayKey existing = cTimeZoneDisplayCache.putIfAbsent(key, text);\n        if (existing != null) {\n            text = existing;\n        }\n    }\n    return text;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String text = cTimeZoneDisplayCache.get(key);\n    if (text == null) {\n        text = tz.getDisplayName(daylight, style, locale);\n        final TimeZoneDisplayKey existing = cTimeZoneDisplayCache.putIfAbsent(key, text);\n        if (existing != null) {\n            text = existing;\n        }\n    }\n    return text;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String displayName = cTimeZoneDisplayCache.get(key);\n    if (displayName == null) {\n        displayName = tz.getDisplayName(daylight, style, locale);\n        final TimeZoneDisplayKey existing = cTimeZoneDisplayCache.putIfAbsent(key, displayName);\n        if (existing != null) {\n            displayName = existing;\n        }\n    }\n    return displayName;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        final TimeZoneDisplayKey existing = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (existing != null) {\n            value = existing;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        final TimeZoneDisplayKey existing = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (existing != null) {\n            value = existing;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        final TimeZoneDisplayKey existing = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (existing != null) {\n            value = existing;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, value);\n    }\n    return value;\n}"
    ],
    [
      "public int getColumnIndex(Comparable key)  {\n    // TODO: implement this method\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int last = lastCategoryIndex();\n    if (last < 0) {\n        return -1;\n    }\n    for (int i = this.firstCategoryIndex; i <= last; i++) {\n        if (this.underlying.getColumnKey(i).equals(key)) {\n            return i;\n        }\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int index = this.underlying.getColumnIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    //TODO: implement this method\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int index = this.underlying.getColumnIndex(key);\n    if (index >= this.firstCategoryIndex) {\n        return index - this.firstCategoryIndex;\n    }\n    else {\n        return -1;\n    }\n}",
      "public int getColumnIndex(Comparable key)  {\n    //TODO: implement this method\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int first = getFirstCategoryIndex();\n    int last = lastCategoryIndex();\n    for (int i = first; i <= last; i++) {\n        if (getColumnKey(i).equals(key)) {\n            return i;\n        }\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int index = this.underlying.getColumnIndex(key);\n    if (index >= this.firstCategoryIndex && index <= this.lastCategoryIndex()) {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    //TODO: implement\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int first = getFirstCategoryIndex();\n    int last = lastCategoryIndex();\n    for (int i = first; i <= last; i++) {\n        if (getUnderlyingDataset().getColumnKey(i).equals(key)) {\n            return i;\n        }\n    }\n    return -1;\n}"
    ],
    [
      "public Location checkPoint(final double point, final double tolerance)  {\n        if (point < lower - tolerance) {\n            return Location.OUTSIDE;\n        } else if (point > upper + tolerance) {\n            return Location.OUTSIDE;\n        } else if (point <= lower + tolerance) {\n            return Location.BOUNDARY;\n        } else if (point >= upper - tolerance) {\n            return Location.BOUNDARY;\n        } else {\n            return Location.INSIDE;\n        }\n    }",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    }\n    if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    }\n    if (point <= lower + tolerance) {\n        return Location.BOUNDARY;\n    }\n    if (point >= upper - tolerance) {\n        return Location.BOUNDARY;\n    }\n    return Location.INSIDE;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point <= lower + tolerance) {\n        return Location.BOUNDARY;\n    } else if (point >= upper - tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    }\n    if (point <= upper + tolerance) {\n        return Location.INSIDE;\n    }\n    return Location.BOUNDARY;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    }\n    if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    }\n    if (point <= lower + tolerance) {\n        return Location.BOUNDARY;\n    }\n    if (point >= upper - tolerance) {\n        return Location.BOUNDARY;\n    }\n    return Location.INSIDE;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    }\n    if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    }\n    if (point <= lower + tolerance) {\n        return Location.BOUNDARY;\n    }\n    if (point >= upper - tolerance) {\n        return Location.BOUNDARY;\n    }\n    return Location.INSIDE;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point <= lower + tolerance) {\n        return Location.BOUNDARY;\n    } else if (point >= upper - tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n        if (point < lower - tolerance) {\n            return Location.OUTSIDE;\n        }\n        if (point <= upper + tolerance) {\n            return Location.INSIDE;\n        }\n        return Location.BOUNDARY;\n    }",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point <= upper + tolerance) {\n        return Location.INSIDE;\n    } else {\n        return Location.BOUNDARY;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    }\n    if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    }\n    if (point <= lower + tolerance) {\n        return Location.BOUNDARY;\n    }\n    if (point >= upper - tolerance) {\n        return Location.BOUNDARY;\n    }\n    return Location.INSIDE;\n}"
    ],
    [
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    List units = new java.util.ArrayList();\n    units.add(new NumberTickUnit(0.1, new DecimalFormat(\"0.0\", new DecimalFormatSymbols(locale))));\n    units.add(new NumberTickUnit(0.2, new DecimalFormat(\"0.0\", new DecimalFormatSymbols(locale))));\n    units.add(new NumberTickUnit(0.5, new DecimalFormat(\"0.0\", new DecimalFormatSymbols(locale))));\n    units.add(new NumberTickUnit(1.0, new DecimalFormat(\"0.0\", new DecimalFormatSymbols(locale))));\n    units.add(new NumberTickUnit(2.0, new DecimalFormat(\"0.0\", new DecimalFormatSymbols(locale))));\n    units.add(new NumberTickUnit(5.0, new DecimalFormat(\"0.0\", new DecimalFormatSymbols(locale))));\n    units.add(new NumberTickUnit(10.0, new DecimalFormat(\"0.0\", new DecimalFormatSymbols(locale))));\n    return new ListTickUnitSource(units);\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    List<TickUnit> list = new ArrayList<TickUnit>();\n    list.add(new NumberTickUnit(1.0, new DecimalFormat(\"0\", new DecimalFormatSymbols(locale))));\n    list.add(new NumberTickUnit(2.0, new DecimalFormat(\"0\", new DecimalFormatSymbols(locale))));\n    list.add(new NumberTickUnit(5.0, new DecimalFormat(\"0\", new DecimalFormatSymbols(locale))));\n    list.add(new NumberTickUnit(10.0, new DecimalFormat(\"0\", new DecimalFormatSymbols(locale))));\n    list.add(new NumberTickUnit(20.0, new DecimalFormat(\"0\", new DecimalFormatSymbols(locale))));\n    list.add(new NumberTickUnit(50.0, new DecimalFormat(\"0\", new DecimalFormatSymbols(locale))));\n    list.add(new NumberTickUnit(100.0, new DecimalFormat(\"0\", new DecimalFormatSymbols(locale))));\n    list.add(new NumberTickUnit(200.0, new DecimalFormat(\"0\", new DecimalFormatSymbols(locale))));\n    list.add(new NumberTickUnit(500.0, new DecimalFormat(\"0\", new DecimalFormatSymbols(locale))));\n    list.add(new NumberTickUnit(1000.0, new DecimalFormat(\"0\", new DecimalFormatSymbols(locale))));\n    list.add(new NumberTickUnit(2000.0, new DecimalFormat(\"0\", new DecimalFormatSymbols(locale))));\n    list.add(new NumberTickUnit(5000.0, new DecimalFormat(\"0\", new DecimalFormatSymbols(locale))));\n    list.add(new NumberTickUnit(10000.0, new DecimalFormat(\"0\", new DecimalFormatSymbols(locale))));\n    list.add(new NumberTickUnit(20000.0, new DecimalFormat(\"0\", new DecimalFormatSymbols(locale))));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new LogTickUnitSource(locale);\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new LogTickUnitSource(locale);\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new LogTickUnitSource(locale);\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new LogTickUnitSource(locale);\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    List result = new java.util.ArrayList();\n    result.add(new NumberTickUnit(1.0, new DecimalFormat(\"0\", new DecimalFormatSymbols(locale))));\n    result.add(new NumberTickUnit(0.1, new DecimalFormat(\"0.0\", new DecimalFormatSymbols(locale))));\n    result.add(new NumberTickUnit(0.01, new DecimalFormat(\"0.00\", new DecimalFormatSymbols(locale))));\n    result.add(new NumberTickUnit(0.001, new DecimalFormat(\"0.000\", new DecimalFormatSymbols(locale))));\n    result.add(new NumberTickUnit(0.0001, new DecimalFormat(\"0.0000\", new DecimalFormatSymbols(locale))));\n    result.add(new NumberTickUnit(0.00001, new DecimalFormat(\"0.00000\", new DecimalFormatSymbols(locale))));\n    result.add(new NumberTickUnit(0.000001, new DecimalFormat(\"0.000000\", new DecimalFormatSymbols(locale))));\n    result.add(new NumberTickUnit(0.0000001, new DecimalFormat(\"0.0000000\", new DecimalFormatSymbols(locale))));\n    result.add(new NumberTickUnit(0.00000001, new DecimalFormat(\"0.00000000\", new DecimalFormatSymbols(locale))));\n    result.add(new NumberTickUnit(0.000000001, new DecimalFormat(\"0.000000000\", new DecimalFormatSymbols(locale))));\n    result.add(new NumberTickUnit(0.0000000001, new DecimalFormat(\"0.0000000000\", new DecimalFormatSymbols(locale))));\n    return new ListTickUnitSource(result);\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new LogTickUnitSource(locale);\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    List units = new ArrayList();\n    units.add(new NumberTickUnit(1.0, new DecimalFormat(\"0\", new DecimalFormatSymbols(locale))));\n    units.add(new NumberTickUnit(0.1, new DecimalFormat(\"0.0\", new DecimalFormatSymbols(locale))));\n    units.add(new NumberTickUnit(0.01, new DecimalFormat(\"0.00\", new DecimalFormatSymbols(locale))));\n    units.add(new NumberTickUnit(0.001, new DecimalFormat(\"0.000\", new DecimalFormatSymbols(locale))));\n    units.add(new NumberTickUnit(0.0001, new DecimalFormat(\"0.0000\", new DecimalFormatSymbols(locale))));\n    units.add(new NumberTickUnit(0.00001, new DecimalFormat(\"0.00000\", new DecimalFormatSymbols(locale))));\n    units.add(new NumberTickUnit(0.000001, new DecimalFormat(\"0.000000\", new DecimalFormatSymbols(locale))));\n    units.add(new NumberTickUnit(0.0000001, new DecimalFormat(\"0.0000000\", new DecimalFormatSymbols(locale))));\n    units.add(new NumberTickUnit(0.00000001, new DecimalFormat(\"0.00000000\", new DecimalFormatSymbols(locale))));\n    units.add(new NumberTickUnit(0.000000001, new DecimalFormat(\"0.000000000\", new DecimalFormatSymbols(locale))));\n    units.add(new NumberTickUnit(0.0000000001, new DecimalFormat(\"0.0000000000\", new DecimalFormatSymbols(locale))));\n}"
    ],
    [
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int mostNegative = 0;\n    for (int i = 1; i <= tableau.getNumObjectiveFunctionVariables(); i++) {\n        if (tableau.get(0, i) < tableau.get(0, mostNegative)) {\n            mostNegative = i;\n        }\n    }\n    return mostNegative;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotColumn = -1;\n    double pivotValue = Double.POSITIVE_INFINITY;\n    for (int i = 0; i < tableau.getNumObjectiveFunctionVariables(); i++) {\n        if (tableau.get(tableau.getNumConstraints(), i) < pivotValue) {\n            pivotValue = tableau.get(tableau.getNumConstraints(), i);\n            pivotColumn = i;\n        }\n    }\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int col = 0;\n    double max = tableau.get(0, 0);\n    for (int i = 1; i < tableau.getNumColumns(); i++) {\n        if (tableau.get(0, i) > max) {\n            max = tableau.get(0, i);\n            col = i;\n        }\n    }\n    return col;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    Integer column = null;\n    double max = 0;\n    for (int i = 0; i < tableau.getNumObjectiveFunctionVariables(); i++) {\n        if (tableau.get(tableau.getNumConstraints(), i) < max) {\n            continue;\n        }\n        if (tableau.get(tableau.getNumConstraints(), i) == max) {\n            if (tableau.get(tableau.getNumConstraints(), i) == 0) {\n                continue;\n            }\n            if (column == null) {\n                column = i;\n                continue;\n            }\n            if (Math.abs(tableau.get(tableau.getNumConstraints(), i)) < Math.abs(tableau.get(tableau.getNumConstraints(), column))) {\n                column = i;\n            }\n            continue;\n        }\n        column = i;\n        max = tableau.get(tableau.getNumConstraints(), i);\n    }\n    return column;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int mostNegative = 0;\n    for (int i = 1; i < tableau.getNumObjectiveFunctionVariables(); i++) {\n        if (tableau.get(0, i) < tableau.get(0, mostNegative)) {\n            mostNegative = i;\n        }\n    }\n    return mostNegative;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    Integer pivotColumn = null;\n    double pivotValue = 0;\n    for (int i = 0; i < tableau.getNumObjectiveFunctionVariables(); i++) {\n        if (tableau.get(0, i) < -epsilon) {\n            if (pivotColumn == null || tableau.get(0, i) < pivotValue) {\n                pivotColumn = i;\n                pivotValue = tableau.get(0, i);\n            }\n        }\n    }\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int mostNegative = 0;\n    for (int i = 1; i <= tableau.getNumObjectiveFunctionVariables(); i++) {\n        if (tableau.get(0, i) < tableau.get(0, mostNegative)) {\n            mostNegative = i;\n        }\n    }\n    return mostNegative;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    Integer pivotColumn = null;\n    double pivotValue = 0;\n    for (int i = 0; i < tableau.getNumObjectiveFunctionVariables(); i++) {\n        if (tableau.get(tableau.getNumConstraints(), i) < pivotValue) {\n            pivotColumn = i;\n            pivotValue = tableau.get(tableau.getNumConstraints(), i);\n        }\n    }\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double max = 0;\n    int col = 0;\n    for (int i = 0; i < tableau.getNumObjectiveFunctionCoefficients(); i++) {\n        if (tableau.get(tableau.getNumConstraints(), i) < max) {\n            max = tableau.get(tableau.getNumConstraints(), i);\n            col = i;\n        }\n    }\n    return col;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    Integer pivotColumn = null;\n    double pivotValue = 0;\n    for (int i = 0; i < tableau.getNumObjectiveFunctionVariables(); i++) {\n        final double value = tableau.get(tableau.getNumConstraints(), i);\n        if (value < pivotValue || pivotColumn == null) {\n            pivotColumn = i;\n            pivotValue = value;\n        }\n    }\n    return pivotColumn;\n}"
    ]
  ]
}