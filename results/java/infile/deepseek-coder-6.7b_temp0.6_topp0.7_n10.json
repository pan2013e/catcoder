{
  "benchmark": "javaeval_if",
  "lastest_eval": {
    "compile@1": 0.4929648241206028,
    "pass@1": 0.26834170854271355,
    "compile@3": 0.5850083752093802,
    "pass@3": 0.3265075376884422,
    "compile@5": 0.6209619526202442,
    "pass@5": 0.3523570232112946
  },
  "n": 10,
  "k": [
    1,
    3,
    5
  ],
  "fn_codes": [
    [
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(ser);\n         return this;\n     }"
    ],
    [
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        result = task.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) \n        {\n            long start = duration.getStart().getTime();\n            long end = duration.getEnd().getTime();\n            long now = System.currentTimeMillis();\n            if (now >= start && now <= end) \n            {\n                long elapsed = now - start;\n                long total = end - start;\n                result = new Long(elapsed * 100 / total);\n            } \n            else \n            {\n                result = new Long(100);\n            }\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) \n        {\n            long start = duration.getStart().getTime();\n            long end = duration.getEnd().getTime();\n            long now = System.currentTimeMillis();\n            if (now >= start && now <= end) \n            {\n                long total = end - start;\n                long elapsed = now - start;\n                result = new Long(100 * elapsed / total);\n            }\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) \n        {\n            long start = duration.getStart().getTime();\n            long end = duration.getEnd().getTime();\n            long now = System.currentTimeMillis();\n            if (now >= start && now <= end) \n            {\n                long elapsed = now - start;\n                long total = end - start;\n                result = new Long(elapsed * 100 / total);\n            }\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) \n        {\n            long start = duration.getStart().getTime();\n            long end = duration.getEnd().getTime();\n            long now = System.currentTimeMillis();\n            if (now >= start && now <= end) \n            {\n                long elapsed = now - start;\n                long total = end - start;\n                result = new Long((elapsed * 100) / total);\n            } \n            else if (now > end) \n            {\n                result = new Long(100);\n            }\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) \n        {\n            long start = duration.getStart().getTime();\n            long end = duration.getEnd().getTime();\n            long now = System.currentTimeMillis();\n            if (start <= now && now <= end) \n            {\n                long elapsed = now - start;\n                long total = end - start;\n                result = new Long((elapsed * 100) / total);\n            }\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        result = task.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) \n        {\n            long start = duration.getStart().getTime();\n            long end = duration.getEnd().getTime();\n            long now = System.currentTimeMillis();\n            if (now >= start && now <= end) \n            {\n                long total = end - start;\n                long elapsed = now - start;\n                result = new Long((elapsed * 100) / total);\n            } \n            else if (now < start) \n            {\n                result = new Long(0);\n            } \n            else if (now > end) \n            {\n                result = new Long(100);\n            }\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) \n        {\n            long start = duration.getStart().getTime();\n            long end = duration.getEnd().getTime();\n            long now = System.currentTimeMillis();\n            if (start <= now && now <= end) \n            {\n                long elapsed = now - start;\n                long total = end - start;\n                result = new Long(elapsed * 100 / total);\n            }\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) \n        {\n            long start = duration.getStart().getTime();\n            long end = duration.getEnd().getTime();\n            long now = System.currentTimeMillis();\n            if (now >= start && now <= end) \n            {\n                long elapsed = now - start;\n                long total = end - start;\n                result = new Long(elapsed * 100 / total);\n            } \n            else \n            {\n                result = new Long(100);\n            }\n        }\n    }\n    return result;\n}"
    ],
    [
      "public StrBuilder deleteFirst(final String str)  {\n    if (str != null) \n    {\n        final int index = indexOf(str);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + str.length(), str.length());\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str != null) \n    {\n        final int index = indexOf(str);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + str.length(), str.length());\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if(str != null)\n    {\n        final int len = str.length();\n        for (int i = 0; i < size - len + 1; i++) \n        {\n            if (regionMatches(i, str, 0, len)) \n            {\n                deleteImpl(i, i + len, len);\n                break;\n            }\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str != null) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + str.length(), str.length());\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str != null) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + str.length(), str.length());\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str != null) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + str.length(), str.length());\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str != null) \n    {\n        final int index = indexOf(str);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + str.length(), str.length());\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str != null) \n    {\n        final int index = indexOf(str);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + str.length(), str.length());\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if(str != null)\n    {\n        final int len = str.length();\n        for (int i = 0; i < size - len + 1; i++) \n        {\n            if (regionMatches(i, str, 0, len)) \n            {\n                deleteImpl(i, i + len, len);\n                break;\n            }\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if(str != null)\n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + str.length(), str.length());\n        }\n    }\n    return this;\n}"
    ],
    [
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new Iterable<E>() {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new Iterable<E>() \n    {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new Iterable<E>() \n    {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new Iterable<E>() {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new Iterable<E>() \n    {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new Iterable<E>() \n    {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new Iterable<E>() \n    {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new Iterable<E>() \n    {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new Iterable<E>() {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new Iterable<E>() \n    {\n}\n}"
    ],
    [
      "private static RealMatrix diag(final RealMatrix m)  {\n        final double[][] d;\n        if (m.getRowDimension() == 1) {\n            d = new double[1][m.getColumnDimension()];\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[0][c] = m.getEntry(0, c);\n            }\n        } else {\n            d = new double[m.getRowDimension()][1];\n            for (int r = 0; r < m.getRowDimension(); r++) {\n                d[r][0] = m.getEntry(r, 0);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
      "private static RealMatrix diag(final RealMatrix m)  {\n        final double[][] d;\n        if (m.getRowDimension() == 1) {\n            d = new double[m.getColumnDimension()][m.getColumnDimension()];\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[c][c] = m.getEntry(0, c);\n            }\n        } else {\n            d = new double[1][m.getRowDimension()];\n            for (int r = 0; r < m.getRowDimension(); r++) {\n                d[0][r] = m.getEntry(r, r);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final double[][] d;\n    if (m.getRowDimension() == 1) {\n        d = new double[1][m.getColumnDimension()];\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            d[0][c] = m.getEntry(0, c);\n        }\n    } else {\n        d = new double[m.getRowDimension()][1];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            d[r][0] = m.getEntry(r, 0);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n        final double[][] d;\n        if (m.getRowDimension() == 1) {\n            d = new double[1][m.getColumnDimension()];\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[0][c] = m.getEntry(0, c);\n            }\n        } else {\n            d = new double[m.getRowDimension()][1];\n            for (int r = 0; r < m.getRowDimension(); r++) {\n                d[r][0] = m.getEntry(r, 0);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final double[][] d;\n    if (m.getRowDimension() == 1) \n    {\n        d = new double[1][m.getColumnDimension()];\n        for (int c = 0; c < m.getColumnDimension(); c++) \n        {\n            d[0][c] = m.getEntry(0, c);\n        }\n    } \n    else \n    {\n        d = new double[m.getRowDimension()][1];\n        for (int r = 0; r < m.getRowDimension(); r++) \n        {\n            d[r][0] = m.getEntry(r, 0);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final double[][] d;\n    if (m.getRowDimension() == 1) \n    {\n        d = new double[1][m.getColumnDimension()];\n        for (int c = 0; c < m.getColumnDimension(); c++) \n        {\n            d[0][c] = m.getEntry(0, c);\n        }\n    } \n    else \n    {\n        d = new double[m.getRowDimension()][1];\n        for (int r = 0; r < m.getRowDimension(); r++) \n        {\n            d[r][0] = m.getEntry(r, 0);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final double[][] d;\n    if (m.getRowDimension() == 1) {\n        d = new double[1][m.getColumnDimension()];\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            d[0][c] = m.getEntry(0, c);\n        }\n    } else {\n        d = new double[m.getRowDimension()][1];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            d[r][0] = m.getEntry(r, 0);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final double[][] d;\n    if (m.getRowDimension() == 1) \n    {\n        d = new double[1][m.getColumnDimension()];\n        for (int c = 0; c < m.getColumnDimension(); c++) \n        {\n            d[0][c] = m.getEntry(0, c);\n        }\n    } \n    else \n    {\n        d = new double[m.getRowDimension()][1];\n        for (int r = 0; r < m.getRowDimension(); r++) \n        {\n            d[r][0] = m.getEntry(r, 0);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final double[][] d;\n    if (m.getRowDimension() == 1) {\n        d = new double[1][m.getColumnDimension()];\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            d[0][c] = m.getEntry(0, c);\n        }\n    } else {\n        d = new double[m.getRowDimension()][1];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            d[r][0] = m.getEntry(r, 0);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n        final double[][] d;\n        if (m.getRowDimension() == 1) {\n            d = new double[m.getColumnDimension()][m.getColumnDimension()];\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[c][c] = m.getEntry(0, c);\n            }\n        } else {\n            d = new double[m.getRowDimension()][1];\n            for (int r = 0; r < m.getRowDimension(); r++) {\n                d[r][0] = m.getEntry(r, 0);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }"
    ],
    [
      "public static double[][] createBlocksLayout(final int rows, final int columns)  throws DimensionMismatchException {\n        final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // allocate storage blocks\n        double[][] blocks = new double[blockRows * blockColumns][];\n\n        int index = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int iHeight = blockHeight(iBlock);\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n                // allocate new block\n                final double[] block = new double[iHeight * blockWidth(jBlock)];\n                blocks[index] = block;\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  throws DimensionMismatchException {\n        final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // allocate storage blocks\n        double[][] blocks = new double[blockRows * blockColumns][];\n\n        int index = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int iHeight = blockHeight(iBlock);\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n                final int jWidth = blockWidth(jBlock);\n                blocks[index] = new double[iHeight * jWidth];\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  throws DimensionMismatchException {\n        final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // create blocks\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int iHeight = blockHeight(iBlock);\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n                final int jWidth = blockWidth(jBlock);\n                blocks[blockIndex] = new double[iHeight * jWidth];\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  throws DimensionMismatchException {\n        final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // create new blocks\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int iHeight = blockHeight(iBlock);\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n                final int jWidth = blockWidth(jBlock);\n                blocks[blockIndex] = new double[iHeight * jWidth];\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  throws DimensionMismatchException {\n        final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // allocate storage blocks, taking care of smaller ones at right and bottom\n        double[][] blocks = new double[blockRows * blockColumns][];\n\n        int index = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int iHeight = blockHeight(iBlock);\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n                if (iHeight * blockWidth(jBlock) > rows || blockWidth(jBlock) > columns) {\n                    throw new DimensionMismatchException(iHeight * blockWidth(jBlock),\n                                                         rows);\n                }\n                // allocate new block\n                final double[] block = new double[iHeight * blockWidth(jBlock)];\n                blocks[index] = block;\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // create blocks\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n            final int jWidth = blockWidth(jBlock);\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // create blocks\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = Math.min(BLOCK_SIZE, rows - iBlock * BLOCK_SIZE);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int jWidth = Math.min(BLOCK_SIZE, columns - jBlock * BLOCK_SIZE);\n            blocks[iBlock * blockColumns + jBlock] = new double[iHeight * jWidth];\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  throws DimensionMismatchException {\n        final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // allocate storage blocks, taking care of smaller ones at right and bottom\n        double[][] blocks = new double[blockRows * blockColumns][];\n\n        int index = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int iHeight = blockHeight(iBlock);\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n                final int jWidth = blockWidth(jBlock);\n                blocks[index] = new double[iHeight * jWidth];\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  throws DimensionMismatchException {\n        final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // allocate storage blocks, taking care of smaller ones at right and bottom\n        double[][] blocks = new double[blockRows * blockColumns][];\n\n        int index = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int iHeight = blockHeight(iBlock);\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n                final int jWidth = blockWidth(jBlock);\n                blocks[index] = new double[iHeight * jWidth];\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  throws DimensionMismatchException {\n        final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // allocate storage blocks, taking care of smaller ones at right and bottom\n        double[][] blocks = new double[blockRows * blockColumns][];\n\n        int index = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int iHeight = blockHeight(iBlock);\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n                // allocate new block\n                final double[] block = new double[iHeight * blockWidth(jBlock)];\n                blocks[index] = block;\n            }\n        }\n\n        return blocks;\n    }"
    ],
    [
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field must be static\");\n    }\n    try {\n        if (!MemberUtils.isAccessible(field)) {\n            if (forceAccess) {\n                field.setAccessible(true);\n            } else {\n                throw new IllegalAccessException(\"The field is not accessible\");\n            }\n        }\n        return field.get(null);\n    } catch (final IllegalAccessException e) {\n        throw new IllegalAccessException(\"The field is not accessible\");\n    }\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field must be static\");\n    }\n    if (!MemberUtils.isAccessible(field)) {\n        if (forceAccess) {\n            field.setAccessible(true);\n        } else {\n            throw new IllegalAccessException(\"The field is not accessible\");\n        }\n    }\n    try {\n        return field.get(null);\n    } catch (IllegalAccessException e) {\n        if (forceAccess) {\n            throw e;\n        }\n        throw new IllegalAccessException(\"The field is not accessible\");\n    }\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field must be static\");\n    }\n    try {\n        if (!MemberUtils.isAccessible(field)) {\n            if (forceAccess) {\n                field.setAccessible(true);\n            } else {\n                throw new IllegalAccessException(\"The field is not accessible\");\n            }\n        }\n        return field.get(null);\n    } catch (final IllegalAccessException e) { // NOPMD\n        throw new IllegalAccessException(\"The field is not accessible\");\n    }\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field must be static\");\n    }\n    if (!MemberUtils.isAccessible(field)) {\n        if (forceAccess) {\n            field.setAccessible(true);\n        } else {\n            throw new IllegalAccessException(\"The field is not accessible\");\n        }\n    }\n    try {\n        return field.get(null);\n    } catch (IllegalAccessException e) {\n        if (forceAccess) {\n            throw e;\n        }\n        throw new IllegalAccessException(\"The field is not accessible\");\n    }\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field must be static\");\n    }\n    if (!MemberUtils.isAccessible(field)) {\n        if (forceAccess) {\n            field.setAccessible(true);\n        } else {\n            throw new IllegalAccessException(\"The field is not accessible\");\n        }\n    }\n    try {\n        return field.get(null);\n    } catch (IllegalAccessException e) {\n        if (forceAccess) {\n            throw e;\n        }\n        throw new IllegalAccessException(\"The field is not accessible\");\n    }\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field must be static\");\n    }\n    try {\n        if (!MemberUtils.isAccessible(field)) {\n            if (forceAccess) {\n                field.setAccessible(true);\n            } else {\n                throw new IllegalAccessException(\"The field is not accessible\");\n            }\n        }\n        return field.get(null);\n    } catch (final IllegalAccessException e) { // NOPMD\n        throw new IllegalAccessException(\"The field is not accessible\");\n    }\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field must be static\");\n    }\n    try {\n        if (!MemberUtils.isAccessible(field)) {\n            if (forceAccess) {\n                field.setAccessible(true);\n            } else {\n                throw new IllegalAccessException(\"The field is not accessible\");\n            }\n        }\n        return field.get(null);\n    } catch (final IllegalAccessException e) {\n        throw new IllegalAccessException(\"The field is not accessible\");\n    }\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field must be static\");\n    }\n    try {\n        if (!MemberUtils.isAccessible(field)) {\n            if (forceAccess) {\n                field.setAccessible(true);\n            } else {\n                throw new IllegalAccessException(\"The field is not accessible\");\n            }\n        }\n        return field.get(null);\n    } catch (final IllegalAccessException e) {\n        throw new IllegalAccessException(\"The field is not accessible\");\n    }\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field must be static\");\n    }\n    if (!MemberUtils.isAccessible(field)) {\n        if (forceAccess) {\n            field.setAccessible(true);\n        } else {\n            throw new IllegalAccessException(\"The field is not accessible\");\n        }\n    }\n    try {\n        return field.get(null);\n    } catch (IllegalAccessException e) {\n        if (forceAccess) {\n            throw e;\n        }\n        throw new IllegalAccessException(\"The field is not accessible\");\n    }\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field must be static\");\n    }\n    if (!MemberUtils.isAccessible(field)) {\n        if (forceAccess) {\n            field.setAccessible(true);\n        } else {\n            throw new IllegalAccessException(\"The field is not accessible\");\n        }\n    }\n    try {\n        return field.get(null);\n    } catch (IllegalAccessException e) {\n        if (forceAccess) {\n            throw e;\n        }\n        throw new IllegalAccessException(\"The field is not accessible\");\n    }\n}"
    ],
    [
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            return DateTimeZone.forOffset(parseOffset(id));\n        }\n        if (cAvailableIDs.contains(id)) {\n            return DateTimeZone.forID(id);\n        }\n        throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (cAvailableIDs.contains(id)) {\n            return new DateTimeZone(id);\n        }\n        throw new IllegalArgumentException(\"Invalid ID: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (cAvailableIDs.contains(id)) {\n            return DateTimeZone.of(id);\n        }\n        throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            return DateTimeZone.forOffset(parseOffset(id));\n        }\n        if (cAvailableIDs.contains(id)) {\n            return new DateTimeZone(id);\n        }\n        throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            return forOffset(DateTimeZone.parseOffset(id));\n        }\n        if (cAvailableIDs.contains(id)) {\n            return new DateTimeZone(id);\n        }\n        throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (cAvailableIDs.contains(id)) {\n            return new DateTimeZone(id);\n        }\n        throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (cAvailableIDs.contains(id)) {\n            return DateTimeZone.of(id);\n        }\n        throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = null;\n        if (cFixedOffsetCache != null) {\n            SoftReference<DateTimeZone> ref = cFixedOffsetCache.get(id);\n            zone = ref != null ? ref.get() : null;\n        }\n        if (zone == null) {\n            if (cAvailableIDs.contains(id)) {\n                zone = DateTimeZone.forID(id);\n                if (cFixedOffsetCache != null) {\n                    cFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n                }\n            } else {\n                throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n            }\n        }\n        return zone;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = null;\n        synchronized (DateTimeZone.class) {\n            if (iFixedOffsetCache != null) {\n                SoftReference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n                zone = ref != null ? ref.get() : null;\n            }\n        }\n        if (zone == null) {\n            try {\n                zone = DateTimeZone.parseResolveFields(id);\n            } catch (IllegalArgumentException ex) {\n                throw new IllegalArgumentException(\"Invalid ID: \" + id);\n            }\n            if (zone != null) {\n                synchronized (DateTimeZone.class) {\n                    if (iFixedOffsetCache == null) {\n                        iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>();\n                    }\n                    iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n                }\n            }\n        }\n        return zone;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = null;\n        synchronized (DateTimeZone.class) {\n            if (iFixedOffsetCache != null) {\n                SoftReference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n                zone = ref != null ? ref.get() : null;\n            }\n        }\n        if (zone == null) {\n            try {\n                zone = DateTimeZone.parse(id);\n            } catch (IllegalArgumentException ex) {\n                throw new IllegalArgumentException(\"Invalid ID: \" + id);\n            }\n            if (iFixedOffsetCache != null) {\n                iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n            }\n        }\n        return zone;\n    }"
    ],
    [
      "private Dfp multiplyFast(final int x)  {\n    Dfp result = newInstance(this);\n    int rh = 0;\n    for (int i = 0; i < mant.length; i++) {\n        int r = mant[i] * x + rh;\n        rh = r / RADIX;\n        result.mant[i] = r - rh * RADIX;\n    }\n    result.exp += rh;\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    Dfp result = newInstance(this);\n    int rh = 0;\n    for (int i = 0; i < mant.length; i++) {\n        int r = mant[i] * x + rh;\n        rh = r / RADIX;\n        result.mant[i] = r - rh * RADIX;\n    }\n    if (rh != 0) {\n        throw new ArithmeticException(\"Overflow in multiplyFast\");\n    }\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    Dfp result = newInstance(this);\n    for (int i = 0; i < mant.length; i++) {\n        int r = mant[i] * x;\n        result.mant[i] = r % RADIX;\n        r /= RADIX;\n        if (i + 1 < mant.length) {\n            result.mant[i + 1] += r;\n        } else {\n            result.exp += r;\n        }\n    }\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    Dfp result = newInstance(this);\n    int rh = 0;  // acts as a carry\n    for (int i = 0; i < mant.length; i++) {\n        int r = mant[i] * x + rh;  // multiply the digit by x and add carry in\n        rh = r / RADIX;\n        result.mant[i] = r - rh * RADIX;\n    }\n    result.exp += rh;\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    Dfp result = newInstance(this);\n    int carry = 0;\n    for (int i = 0; i < mant.length; i++) {\n        int prod = mant[i] * x + carry;\n        result.mant[i] = prod % RADIX;\n        carry = prod / RADIX;\n    }\n    if (carry != 0) {\n        throw new ArithmeticException(\"Overflow in multiplyFast\");\n    }\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n        Dfp result = newInstance(this);\n        int rh = 0;  // acts as a carry\n        for (int i = 0; i < mant.length; i++) {\n            int r = mant[i] * x + rh;  // multiply the digit by x and add the carry\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp += rh;\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n        Dfp result = newInstance(this);\n        int rh = 0;  // acts as a carry\n        for (int i = 0; i < mant.length; i++) {\n            int r = mant[i] * x + rh;  // multiply the digit with carry in\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp += rh;\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n    Dfp result = newInstance(this);\n    int carry = 0;\n    for (int i = 0; i < mant.length; i++) {\n        int prod = mant[i] * x + carry;\n        result.mant[i] = prod % RADIX;\n        carry = prod / RADIX;\n    }\n    result.exp += carry;\n    if (result.mant[mant.length-1] == 0) {\n        result.exp = 0;\n    }\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    Dfp result = newInstance(this);\n    for (int i = 0; i < mant.length; i++) {\n        int r = mant[i] * x;\n        result.mant[i] = r;\n    }\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n        Dfp result = newInstance(this);\n        int rh = 0;  // acts as a carry\n        for (int i = 0; i < mant.length; i++) {\n            int r = mant[i] * x + rh;  // multiply the digit by x and add carry in\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp += rh;\n        return result;\n    }"
    ],
    [
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> transformedMap = new HashMap<>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            K key = transformKey(entry.getKey());\n            V value = transformValue(entry.getValue());\n            transformedMap.put(key, value);\n        }\n        return transformedMap;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> transformedMap = new HashMap<K, V>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            K key = transformKey(entry.getKey());\n            V value = transformValue(entry.getValue());\n            transformedMap.put(key, value);\n        }\n        return transformedMap;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> transformedMap = new HashMap<K, V>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            transformedMap.put((K) transformKey(entry.getKey()), (V) transformValue(entry.getValue()));\n        }\n        return transformedMap;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> transformedMap = new HashMap<K, V>();\n        for (Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            transformedMap.put((K) transformKey(entry.getKey()), (V) transformValue(entry.getValue()));\n        }\n        return transformedMap;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> transformedMap = new HashMap<K, V>();\n        for (Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            K key = transformKey((K) entry.getKey());\n            V value = transformValue((V) entry.getValue());\n            transformedMap.put(key, value);\n        }\n        return transformedMap;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map == null) {\n            throw new NullPointerException(\"Map must not be null\");\n        }\n        Map<K, V> transformedMap = new HashMap<K, V>();\n        for (Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            transformedMap.put((K) transformKey(entry.getKey()), (V) transformValue(entry.getValue()));\n        }\n        return transformedMap;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map == null) {\n            throw new NullPointerException(\"Map must not be null\");\n        }\n        Map<K, V> transformedMap = new HashMap<K, V>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            K key = transformKey(entry.getKey());\n            V value = transformValue(entry.getValue());\n            transformedMap.put(key, value);\n        }\n        return transformedMap;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> transformedMap = new HashMap<>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            K key = transformKey(entry.getKey());\n            V value = transformValue(entry.getValue());\n            transformedMap.put(key, value);\n        }\n        return transformedMap;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> transformedMap = new HashMap<K, V>();\n        for (Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            transformedMap.put((K) transformKey(entry.getKey()), (V) transformValue(entry.getValue()));\n        }\n        return transformedMap;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> transformedMap = new HashMap<>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            K key = transformKey(entry.getKey());\n            V value = transformValue(entry.getValue());\n            transformedMap.put(key, value);\n        }\n        return transformedMap;\n    }"
    ],
    [
      "private Node createExternFunction(Node exportedFunction)  {\n    List<Node> parameters = new ArrayList<>();\n    Node returnType = exportedFunction.getReturnType();\n\n    for (Node parameter : exportedFunction.getParameters()) {\n        String parameterName = parameter.getName();\n        Node parameterType = parameter.getType();\n\n        if (parameterName == null || parameterType == null) {\n            compiler.warning(\"Function parameter is missing name or type: \" + parameter);\n            continue;\n        }\n\n        parameters.add(NodeUtil.newVarNode(parameterName, parameterType));\n    }\n\n    return NodeUtil.newFunctionNode(parameters, returnType, Collections.emptyList());\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = NodeUtil.newFunctionNode();\n    List<Node> params = new ArrayList<>();\n    Node returnType = NodeUtil.newTypeNode();\n\n    // Get the parameters of the exported function\n    for (Node param : exportedFunction.getChildren()) {\n        if (param.isParam()) {\n            Node externParam = NodeUtil.newParamNode(param.getName());\n            params.add(externParam);\n        } else if (param.isReturnType()) {\n            returnType = param;\n        }\n    }\n\n    // Set the parameters of the extern function\n    for (Node param : params) {\n        externFunction.addChildToBack(param);\n    }\n\n    // Set the return type of the extern function\n    externFunction.addChildToBack(returnType);\n\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = null;\n    try {\n        String functionName = exportedFunction.getFirstChild().getStringValue();\n        Node parameters = exportedFunction.getSecondChild();\n        Node returnType = exportedFunction.getThirdChild();\n\n        if (parameters == null || returnType == null) {\n            throw new Exception(\"Function to export is missing parameter or return type\");\n        }\n\n        externFunction = IR.function(\n            functionName,\n            parameters,\n            returnType,\n            IR.block()\n        );\n    } catch (Exception e) {\n        System.out.println(\"Warning: \" + e.getMessage());\n    }\n\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = NodeUtil.newFunctionNode(\n        exportedFunction.getType(),\n        exportedFunction.getName(),\n        exportedFunction.getParameters(),\n        IR.empty());\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    FunctionNode functionNode = (FunctionNode) exportedFunction;\n    List<String> paramNames = Lists.newArrayList();\n    List<Node> paramTypes = Lists.newArrayList();\n\n    for (int i = 0; i < functionNode.getParamCount(); i++) {\n        paramNames.add(functionNode.getParamName(i));\n        paramTypes.add(functionNode.getParamType(i));\n    }\n\n    return IR.function(IR.name(functionNode.getName()), paramNames, paramTypes, functionNode.getReturnType());\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    List<Node> params = new ArrayList<>();\n    List<Node> paramNames = new ArrayList<>();\n\n    for (Node param : exportedFunction.getParams()) {\n        Node paramName = param.getFirstChildByClass(Name.class);\n        if (paramName == null) {\n            throw new IllegalArgumentException(\"Missing parameter name\");\n        }\n        paramNames.add(paramName);\n        params.add(IR.var(paramName));\n    }\n\n    Node returnType = exportedFunction.getReturnType();\n    if (returnType == null) {\n        throw new IllegalArgumentException(\"Missing return type\");\n    }\n\n    return IR.function(IR.name(\"\"), params, returnType, IR.block());\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    List<Node> parameters = new ArrayList<>();\n    for (Node parameter : exportedFunction.getParameters()) {\n        if (parameter.getType() == null) {\n            compiler.getDiagnosticReporter().reportWarning(\n                \"Missing type for parameter in function exported to externs: \" + parameter.getName());\n            continue;\n        }\n        parameters.add(IR.param(parameter.getName(), parameter.getType()));\n    }\n\n    if (exportedFunction.getReturnType() == null) {\n        compiler.getDiagnosticReporter().reportWarning(\n            \"Missing return type for function exported to externs: \" + exportedFunction.getName());\n        return IR.func(parameters.toArray(new Node[0]));\n    }\n\n    return IR.func(exportedFunction.getReturnType(), parameters.toArray(new Node[0]));\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    // TODO: Implement this method.\n    return null;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    List<Node> params = Lists.newArrayList();\n    List<String> paramNames = Lists.newArrayList();\n\n    Node body = IR.block();\n\n    if (exportedFunction.isFunction()) {\n        Node function = (Node) exportedFunction;\n\n        for (Node param : function.getParams()) {\n            String paramName = param.getName();\n\n            if (paramName == null) {\n                compiler.addWarning(\"Function \" + function.getFullName() + \" has a parameter with no name.\");\n                continue;\n            }\n\n            paramNames.add(paramName);\n            params.add(IR.param(IR.name(paramName)));\n        }\n\n        if (function.getReturnType() != null) {\n            body = IR.return_(IR.name(function.getReturnType().getFullName()));\n        }\n    }\n\n    return IR.func(IR.params(params), body, IR.type(IR.name(\"Function\")));\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    List<Node> parameters = new ArrayList<>();\n    Node returnType = null;\n\n    // Get the parameters and return type of the function\n    for (Node child : exportedFunction.getChildren()) {\n        if (child.getNodeType() == NodeType.PARAMETER) {\n            parameters.add(child);\n        } else if (child.getNodeType() == NodeType.RETURN_TYPE) {\n            returnType = child;\n        }\n    }\n\n    // If the function is missing parameters or return type, create a warning\n    if (parameters.isEmpty() || returnType == null) {\n        compiler.addWarning(new MissingFunctionTypeWarning(exportedFunction));\n    }\n\n    // Create the extern function\n    Node externFunction = IR.function(returnType, parameters.toArray(new Node[0]));\n    return externFunction;\n}"
    ],
    [
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n        double[][] covarianceMatrix = computeCovariances(params,\n                                                         covarianceSingularityThreshold);\n        int len = covarianceMatrix.length;\n        double[] sigma = new double[len];\n        for (int i = 0; i < len; i++) {\n            sigma[i] = Math.sqrt(covarianceMatrix[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n        double[][] covariance = computeCovariances(params, \n                                                   covarianceSingularityThreshold);\n        double[] sigma = new double[params.length];\n        for (int i = 0; i < params.length; i++) {\n            sigma[i] = Math.sqrt(covariance[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n        // Compute the covariance matrix.\n        double[][] covarianceMatrix = computeCovariances(params, \n        covarianceSingularityThreshold);\n\n        // Compute the standard deviation.\n        double[] sigma = new double[params.length];\n        for (int i = 0; i < params.length; i++) {\n            sigma[i] = Math.sqrt(covarianceMatrix[i][i]);\n        }\n\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n        double[][] cov = computeCovariances(params, covarianceSingularityThreshold);\n        double[] sigma = new double[cov.length];\n        for (int i = 0; i < cov.length; i++) {\n            sigma[i] = Math.sqrt(cov[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n        double[][] cov = computeCovariances(params, covarianceSingularityThreshold);\n        double[] sigma = new double[cov.length];\n        for (int i = 0; i < cov.length; i++) {\n            sigma[i] = Math.sqrt(cov[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n        // Compute the covariance matrix.\n        double[][] covarianceMatrix = computeCovariances(params,\n                                                         covarianceSingularityThreshold);\n\n        // Compute the standard deviation.\n        double[] sigma = new double[covarianceMatrix.length];\n        for (int i = 0; i < covarianceMatrix.length; i++) {\n            sigma[i] = Math.sqrt(covarianceMatrix[i][i]);\n        }\n\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n        double[][] covarianceMatrix = computeCovariances(params,\n                                                         covarianceSingularityThreshold);\n        int n = params.length;\n        double[] sigma = new double[n];\n        for (int i = 0; i < n; i++) {\n            sigma[i] = Math.sqrt(covarianceMatrix[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n        double[][] cov = computeCovariances(params, covarianceSingularityThreshold);\n        double[] sigma = new double[cov.length];\n        for (int i = 0; i < cov.length; i++) {\n            sigma[i] = Math.sqrt(cov[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n        double[][] covMatrix = computeCovariances(params,\n                                                  covarianceSingularityThreshold);\n        double[] sigma = new double[covMatrix.length];\n        for (int i = 0; i < covMatrix.length; i++) {\n            sigma[i] = Math.sqrt(covMatrix[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n        double[][] covarianceMatrix = computeCovariances(params, \n                                                         covarianceSingularityThreshold);\n        int length = covarianceMatrix.length;\n        double[] sigma = new double[length];\n        for (int i = 0; i < length; i++) {\n            sigma[i] = Math.sqrt(covarianceMatrix[i][i]);\n        }\n        return sigma;\n    }"
    ],
    [
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalArgumentException(\"Cyclic substitution detected: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalArgumentException(\"Cyclic substitution detected for variable: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalArgumentException(\"Cyclic substitution detected: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalArgumentException(\"Cyclic substitution detected for variable: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalArgumentException(\"Cyclic substitution detected: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalArgumentException(\"Cyclic substitution detected for variable: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalArgumentException(\"Cyclic substitution detected for variable: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalArgumentException(\"Cyclic substitution detected: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalArgumentException(\"Cyclic substitution detected for variable: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalArgumentException(\"Cyclic substitution detected for variable: \" + varName);\n    }\n}"
    ],
    [
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws MissingProvideException {\n    Multimap<INPUT, INPUT> deps = HashMultimap.create();\n    for (INPUT root : roots) {\n      for (String symbol : root.getRequires()) {\n        INPUT required = getInputProviding(symbol);\n        deps.put(required, root);\n      }\n    }\n\n    if (sorted) {\n      return topologicalSort(deps);\n    } else {\n      return new ArrayList<>(deps.keySet());\n    }\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws MissingProvideException, CircularDependencyException {\n\n    // Create a copy of the provideMap\n    Map<String, INPUT> provideMapCopy = new HashMap<>(provideMap);\n\n    // Create a multimap to store the dependencies\n    Multimap<INPUT, INPUT> deps = HashMultimap.create();\n\n    // Create a list to store the sorted inputs\n    List<INPUT> sortedList = new ArrayList<>();\n\n    // Iterate over the roots\n    for (INPUT root : roots) {\n      // Get the input providing the root symbol\n      INPUT input = getInputProviding(root.getProvides().iterator().next());\n\n      // Remove the input from the provideMapCopy\n      provideMapCopy.remove(input.getProvides().iterator().next());\n\n      // Add the input to the sortedList\n      sortedList.add(input);\n\n      // Add the dependencies of the input to the deps multimap\n      for (String symbol : input.getRequires()) {\n        INPUT dep = getInputProviding(symbol);\n        deps.put(input, dep);\n      }\n    }\n\n    // If there are any remaining inputs in the provideMapCopy, add them to the sortedList\n    sortedList.addAll(provideMapCopy.values());\n\n    // If sorted is true, sort the sortedList in topological order\n    if (sorted) {\n      // Create a list to store the circular dependencies\n      List<INPUT> circularDeps = new ArrayList<>();\n\n      // Iterate over the sortedList\n      for (INPUT input : sortedList) {\n        // If the input has circular dependencies, add them to the circularDeps list\n        if (deps.containsKey(input)) {\n          circularDeps.addAll(deps.get(input));\n        }\n      }\n\n      // If there are any circular dependencies, throw a CircularDependencyException\n      if (!circularDeps.isEmpty()) {\n        throw new CircularDependencyException(cycleToString(findCycle(circularDeps, deps)));\n      }\n    }\n\n    return sortedList;\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws MissingProvideException {\n    List<INPUT> result = new ArrayList<>();\n    Multimap<INPUT, INPUT> deps = ArrayListMultimap.create();\n\n    for (INPUT root : roots) {\n      for (String symbol : root.getRequires()) {\n        INPUT candidate = getInputProviding(symbol);\n        deps.put(candidate, root);\n      }\n    }\n\n    for (INPUT root : roots) {\n      if (!result.contains(root)) {\n        result.addAll(getDependenciesOf(root, deps));\n      }\n    }\n\n    if (sorted) {\n      sortDependencies(result, deps);\n    }\n\n    return result;\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws MissingProvideException {\n    // Create a map to store the dependencies\n    Multimap<INPUT, INPUT> deps = HashMultimap.create();\n    // Create a list to store the sorted inputs\n    List<INPUT> sortedList = new ArrayList<>();\n    // Create a set to store the visited inputs\n    Set<INPUT> visited = new HashSet<>();\n\n    for (INPUT root : roots) {\n      // Check if the root is in the provideMap\n      if (!provideMap.containsKey(root)) {\n        throw new MissingProvideException(root.getProvides().iterator().next());\n      }\n      // Add the root to the visited set\n      visited.add(root);\n      // Add the root to the sorted list\n      sortedList.add(root);\n      // Get the dependencies of the root\n      deps.putAll(root, getDependencies(root, visited));\n    }\n\n    if (sorted) {\n      // Sort the inputs in topological order\n      sortInputs(sortedList, deps);\n    }\n\n    return sortedList;\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws MissingProvideException {\n    // Initialize the dependency map.\n    Multimap<INPUT, INPUT> deps = HashMultimap.create();\n    for (INPUT input : provideMap.values()) {\n      for (String symbol : input.getRequires()) {\n        INPUT required = getInputProviding(symbol);\n        deps.put(input, required);\n      }\n    }\n\n    // Initialize the subgraph.\n    List<INPUT> subGraph = new ArrayList<>(roots);\n\n    // Find cycles in the subgraph.\n    List<INPUT> cycle = findCycle(subGraph, deps);\n    if (cycle.size() > 1) {\n      throw new IllegalArgumentException(\n          \"Cycle detected: \" + cycleToString(cycle));\n    }\n\n    // Remove the roots from the subgraph.\n    subGraph.removeAll(roots);\n\n    // If the subgraph is not empty, add its dependencies to the subgraph.\n    if (!subGraph.isEmpty()) {\n      subGraph.addAll(deps.get(subGraph.get(0)));\n    }\n\n    // Sort the subgraph.\n    if (sorted) {\n      sortSubGraph(subGraph, deps);\n    }\n\n    return subGraph;\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws MissingProvideException {\n    Multimap<INPUT, INPUT> deps = ArrayListMultimap.create();\n    for (INPUT root : roots) {\n      deps.putAll(root, findDependencies(root));\n    }\n\n    if (sorted) {\n      return topologicalSort(deps);\n    } else {\n      return Lists.newArrayList(deps.keySet());\n    }\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws MissingProvideException {\n    List<INPUT> inputs = new ArrayList<INPUT>();\n    Multimap<INPUT, INPUT> deps = ArrayListMultimap.create();\n    Set<INPUT> visited = new HashSet<INPUT>();\n\n    for (INPUT root : roots) {\n        inputs.addAll(getDependenciesOf(root, deps, visited));\n    }\n\n    if (sorted) {\n        TopologicalSort<INPUT> sorter = new TopologicalSort<INPUT>(deps);\n        inputs = sorter.sort();\n    }\n\n    return inputs;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws MissingProvideException, CircularDependencyException {\n\n    // Create a map of dependencies for each input\n    Multimap<INPUT, INPUT> deps = ArrayListMultimap.create();\n    for (INPUT input : roots) {\n      for (String symbol : input.getRequires()) {\n        INPUT dependency = getInputProviding(symbol);\n        deps.put(input, dependency);\n      }\n    }\n\n    // Find all cycles in the graph\n    List<List<INPUT>> cycles = new ArrayList<>();\n    for (INPUT root : roots) {\n      Set<INPUT> visited = new HashSet<>();\n      List<INPUT> cycle = findCycle(root, visited, deps);\n      if (!cycle.isEmpty()) {\n        cycles.add(cycle);\n      }\n    }\n\n    // If there are any cycles, throw an exception\n    if (!cycles.isEmpty()) {\n      throw new CircularDependencyException(\n          \"Circular dependencies detected: \" +\n          Joiner.on(\", \").join(cycles.stream().map(this::cycleToString).collect(Collectors.toList())));\n    }\n\n    // If sorted is true, sort the inputs in topological order\n    if (sorted) {\n      List<INPUT> sortedList = new ArrayList<>();\n      for (INPUT root : roots) {\n        sortInput(root, sortedList, deps);\n      }\n      return sortedList;\n    }\n\n    // Otherwise, return the inputs in the order they were passed to the compiler\n    return new ArrayList<>(roots);\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws MissingProvideException {\n    // Create a dependency map.\n    Multimap<INPUT, INPUT> deps = HashMultimap.create();\n    for (INPUT input : provideMap.values()) {\n      for (String symbol : input.getRequires()) {\n        deps.put(input, getInputProviding(symbol));\n      }\n    }\n\n    // Create a subgraph of the roots.\n    Set<INPUT> subGraph = Sets.newHashSet(roots);\n    for (INPUT input : roots) {\n      addToSubGraph(input, deps, subGraph);\n    }\n\n    // Find the cycle in the subgraph.\n    List<INPUT> cycle = findCycle(Lists.newArrayList(subGraph), deps);\n    if (!cycle.isEmpty()) {\n      throw new IllegalStateException(\"Cycle detected: \" + cycleToString(cycle));\n    }\n\n    // If not sorted, return the subgraph.\n    if (!sorted) {\n      return Lists.newArrayList(subGraph);\n    }\n\n    // Sort the subgraph.\n    List<INPUT> sortedList = new ArrayList<>();\n    for (INPUT input : roots) {\n      if (!sortedList.contains(input)) {\n        addToSortedList(input, deps, sortedList);\n      }\n    }\n\n    return sortedList;\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws MissingProvideException {\n    Multimap<INPUT, INPUT> deps = HashMultimap.create();\n    for (INPUT root : roots) {\n      for (String symbol : root.getRequires()) {\n        INPUT dep = getInputProviding(symbol);\n        deps.put(root, dep);\n      }\n    }\n\n    if (sorted) {\n      return topologicalSort(roots, deps);\n    } else {\n      return new ArrayList<>(roots);\n    }\n  }"
    ],
    [
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) \n    {\n        return str;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    final int strLen = str.length();\n    final StringBuilder sb = new StringBuilder(strLen);\n    boolean capitalizeNext = true;\n    for (int i = 0; i < strLen; i++) \n    {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n            sb.append(ch);\n        } \n        else if (capitalizeNext) \n        {\n            sb.append(Character.toLowerCase(ch));\n            capitalizeNext = false;\n        } \n        else \n        {\n            sb.append(ch);\n        }\n    }\n    return sb.toString();\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) \n    {\n        return str;\n    }\n\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        if (isDelimiter(buffer[i], delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext && Character.isTitleCase(buffer[i])) \n        {\n            buffer[i] = Character.toLowerCase(buffer[i]);\n            uncapitalizeNext = false;\n        } \n        else \n        {\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n\n    for (int i = 0; i < buffer.length; i++) \n    {\n        if (uncapitalizeNext && Character.isLetter(buffer[i])) \n        {\n            buffer[i] = Character.toLowerCase(buffer[i]);\n            uncapitalizeNext = false;\n        } \n        else if (delimLen > 0 && i < buffer.length - 1) \n        {\n            for (int j = 0; j < delimLen; j++) \n            {\n                if (buffer[i] == delimiters[j]) \n                {\n                    uncapitalizeNext = true;\n                    break;\n                }\n            }\n        } \n        else \n        {\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) \n    {\n        return str;\n    }\n\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    final char[] buffer = str.toCharArray();\n    boolean uncapNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        if (uncapNext && Character.isLetter(buffer[i])) \n        {\n            buffer[i] = Character.toLowerCase(buffer[i]);\n            uncapNext = false;\n        } \n        else if (delimLen > 0 && i < buffer.length - 1) \n        {\n            for (char delimiter : delimiters) \n            {\n                if (buffer[i] == delimiter && Character.isLetter(buffer[i + 1])) \n                {\n                    buffer[i + 1] = Character.toLowerCase(buffer[i + 1]);\n                    break;\n                }\n            }\n        }\n        uncapNext = Character.isWhitespace(buffer[i]);\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    final int strLen = str.length();\n    final StringBuilder sb = new StringBuilder(strLen);\n    boolean capitalize = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            sb.append(ch);\n            capitalize = true;\n        } else {\n            if (capitalize) {\n                sb.append(Character.toLowerCase(ch));\n                capitalize = false;\n            } else {\n                sb.append(ch);\n            }\n        }\n    }\n    return sb.toString();\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    final int strLen = str.length();\n    final StringBuilder sb = new StringBuilder(strLen);\n    boolean uncapNext = true;\n    for (int i = 0; i < strLen; i++) {\n        final char c = str.charAt(i);\n        if (isDelimiter(c, delimiters)) {\n            uncapNext = true;\n            sb.append(c);\n        } else if (uncapNext && Character.isTitleCase(c)) {\n            sb.append(Character.toLowerCase(c));\n            uncapNext = false;\n        } else {\n            sb.append(c);\n            uncapNext = false;\n        }\n    }\n    return sb.toString();\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) \n    {\n        return str;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    final int strLen = str.length();\n    boolean uncapitalizeNext = true;\n    StringBuilder buffer = new StringBuilder(strLen);\n    for (int i = 0; i < strLen; i++) \n    {\n        char c = str.charAt(i);\n        if (uncapitalizeNext && Character.isLetter(c)) \n        {\n            c = Character.toLowerCase(c);\n            uncapitalizeNext = false;\n        } \n        else if (i + 1 < strLen) \n        {\n            for (int j = 0; j < delimLen; j++) \n            {\n                if (c == delimiters[j]) \n                {\n                    uncapitalizeNext = true;\n                    break;\n                }\n            }\n        }\n        buffer.append(c);\n    }\n    return buffer.toString();\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        if (uncapitalizeNext) \n        {\n            if (i == 0 || isDelimiter(buffer[i - 1], delimiters)) \n            {\n                buffer[i] = Character.toLowerCase(buffer[i]);\n            }\n        }\n        uncapitalizeNext = isDelimiter(buffer[i], delimiters);\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) \n    {\n        return str;\n    }\n\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    final int strLen = str.length();\n    final StringBuilder sb = new StringBuilder(strLen);\n    boolean capitalize = true;\n    for (int i = 0; i < strLen; i++) \n    {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalize = true;\n            sb.append(ch);\n        } \n        else if (capitalize) \n        {\n            sb.append(Character.toLowerCase(ch));\n            capitalize = false;\n        } \n        else \n        {\n            sb.append(ch);\n        }\n    }\n    return sb.toString();\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    final int strLen = str.length();\n    final StringBuilder sb = new StringBuilder(strLen);\n\n    boolean uncapNext = true;\n    for (int i = 0; i < strLen; i++) {\n        final char c = str.charAt(i);\n        if (uncapNext) {\n            if (i == 0 || (delimLen > 0 && isDelimiter(c, delimiters))) {\n                sb.append(Character.toLowerCase(c));\n            } else {\n                sb.append(c);\n            }\n            uncapNext = false;\n        } else {\n            sb.append(c);\n        }\n        if (Character.isWhitespace(c)) {\n            uncapNext = true;\n        }\n    }\n\n    return sb.toString();\n}"
    ],
    [
      "protected static Dfp[] split(final Dfp a)  {\n        Dfp result[] = new Dfp[2];\n        DfpField field = a.getField();\n        String aStr = a.toString();\n        char[] buf;\n        boolean leading = true;\n        int sp = 0;\n        int sig = 0;\n\n        buf = new char[aStr.length()];\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = aStr.charAt(i);\n\n            if (buf[i] >= '1' && buf[i] <= '9') {\n                leading = false;\n            }\n\n            if (buf[i] == '.') {\n                sig += (field.getRadixDigits() / 2) * 4;\n                leading = false;\n            }\n\n            if (sig == (field.getRadixDigits() / 2) * 4) {\n                sp = i;\n                break;\n            }\n\n            if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n                sig ++;\n            }\n        }\n\n        result[0] = field.newDfp(new String(buf, 0, sp));\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = aStr.charAt(i);\n            if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n                buf[i] = '0';\n            }\n        }\n\n        result[1] = field.newDfp(new String(buf));\n\n        return result;\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n        Dfp result[] = new Dfp[2];\n        DfpField field = a.getField();\n        String aStr = a.toString();\n        char[] buf;\n        boolean leading = true;\n        int sp = 0;\n        int sig = 0;\n\n        buf = new char[aStr.length()];\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = aStr.charAt(i);\n\n            if (buf[i] >= '1' && buf[i] <= '9') {\n                leading = false;\n            }\n\n            if (buf[i] == '.') {\n                sig += (field.getRadixDigits() / 2) % 4;\n                leading = false;\n            }\n\n            if (sig == field.getRadixDigits() / 2) {\n                sp = i;\n                break;\n            }\n\n            if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n                sig ++;\n            }\n        }\n\n        result[0] = field.newDfp(new String(buf, 0, sp));\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = aStr.charAt(i);\n            if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n                buf[i] = '0';\n            }\n        }\n\n        result[1] = field.newDfp(new String(buf));\n\n        return result;\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n        Dfp result[] = new Dfp[2];\n        DfpField field = a.getField();\n        char[] buf;\n        boolean leading = true;\n        int sp = 0;\n        int sig = 0;\n\n        buf = a.toString().toCharArray();\n\n        for (int i = 0; i < buf.length; i++) {\n            if (buf[i] >= '1' && buf[i] <= '9') {\n                leading = false;\n            }\n\n            if (buf[i] == '.') {\n                sig += (400 - sig) % 4;\n                leading = false;\n            }\n\n            if (sig == (field.getRadixDigits() / 2) * 4) {\n                sp = i;\n                break;\n            }\n\n            if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n                sig ++;\n            }\n        }\n\n        result[0] = field.newDfp(new String(buf, 0, sp));\n\n        for (int i = 0; i < buf.length; i++) {\n            if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n                buf[i] = '0';\n            }\n        }\n\n        result[1] = field.newDfp(new String(buf));\n\n        return result;\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n        Dfp[] result = new Dfp[2];\n        DfpField field = a.getField();\n        String aStr = a.toString();\n        char[] buf;\n        boolean leading = true;\n        int sp = 0;\n        int sig = 0;\n\n        buf = new char[aStr.length()];\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = aStr.charAt(i);\n\n            if (buf[i] >= '1' && buf[i] <= '9') {\n                leading = false;\n            }\n\n            if (buf[i] == '.') {\n                sig += (400 - sig) % 4;\n                leading = false;\n            }\n\n            if (sig == (field.getRadixDigits() / 2) * 4) {\n                sp = i;\n                break;\n            }\n\n            if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n                sig ++;\n            }\n        }\n\n        result[0] = field.newDfp(new String(buf, 0, sp));\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = aStr.charAt(i);\n            if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n                buf[i] = '0';\n            }\n        }\n\n        result[1] = field.newDfp(new String(buf));\n\n        return result;\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n        Dfp result[] = new Dfp[2];\n        DfpField field = a.getField();\n        String aStr = a.toString();\n        char[] buf;\n        boolean leading = true;\n        int sp = 0;\n        int sig = 0;\n\n        buf = new char[aStr.length()];\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = aStr.charAt(i);\n\n            if (buf[i] >= '1' && buf[i] <= '9') {\n                leading = false;\n            }\n\n            if (buf[i] == '.') {\n                sig += (400 - sig) % 4;\n                leading = false;\n            }\n\n            if (sig == (field.getRadixDigits() / 2) * 4) {\n                sp = i;\n                break;\n            }\n\n            if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n                sig ++;\n            }\n        }\n\n        result[0] = field.newDfp(new String(buf, 0, sp));\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = aStr.charAt(i);\n            if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n                buf[i] = '0';\n            }\n        }\n\n        result[1] = field.newDfp(new String(buf));\n\n        return result;\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n        Dfp result[] = new Dfp[2];\n        DfpField field = a.getField();\n        String aStr = a.toString();\n        char[] buf;\n        boolean leading = true;\n        int sp = 0;\n        int sig = 0;\n\n        buf = new char[aStr.length()];\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = aStr.charAt(i);\n\n            if (buf[i] >= '1' && buf[i] <= '9') {\n                leading = false;\n            }\n\n            if (buf[i] == '.') {\n                sig += (400 - sig) % 4;\n                leading = false;\n            }\n\n            if (sig == (field.getRadixDigits() / 2) * 4) {\n                sp = i;\n                break;\n            }\n\n            if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n                sig ++;\n            }\n        }\n\n        result[0] = field.newDfp(new String(buf, 0, sp));\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = aStr.charAt(i);\n            if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n                buf[i] = '0';\n            }\n        }\n\n        result[1] = field.newDfp(new String(buf));\n\n        return result;\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n        Dfp[] result = new Dfp[2];\n        DfpField field = a.getField();\n        String aStr = a.toString();\n        char[] buf = new char[aStr.length()];\n        boolean leading = true;\n        int sp = 0;\n        int sig = 0;\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = aStr.charAt(i);\n\n            if (buf[i] >= '1' && buf[i] <= '9') {\n                leading = false;\n            }\n\n            if (buf[i] == '.') {\n                sig += (field.getRadixDigits() / 2);\n                leading = false;\n            }\n\n            if (sig == field.getRadixDigits() / 2) {\n                sp = i;\n                break;\n            }\n\n            if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n                sig ++;\n            }\n        }\n\n        result[0] = field.newDfp(new String(buf, 0, sp));\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = aStr.charAt(i);\n            if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n                buf[i] = '0';\n            }\n        }\n\n        result[1] = field.newDfp(new String(buf));\n\n        return result;\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n        Dfp result[] = new Dfp[2];\n        DfpField field = a.getField();\n        String aStr = a.toString();\n        char[] buf;\n        boolean leading = true;\n        int sp = 0;\n        int sig = 0;\n\n        buf = new char[aStr.length()];\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = aStr.charAt(i);\n\n            if (buf[i] >= '1' && buf[i] <= '9') {\n                leading = false;\n            }\n\n            if (buf[i] == '.') {\n                sig += (400 - sig) % 4;\n                leading = false;\n            }\n\n            if (sig == (field.getRadixDigits() / 2) * 4) {\n                sp = i;\n                break;\n            }\n\n            if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n                sig ++;\n            }\n        }\n\n        result[0] = field.newDfp(new String(buf, 0, sp));\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = aStr.charAt(i);\n            if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n                buf[i] = '0';\n            }\n        }\n\n        result[1] = field.newDfp(new String(buf));\n\n        return result;\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n        Dfp[] result = new Dfp[2];\n        DfpField field = a.getField();\n        String aString = a.toString();\n        char[] buf = new char[aString.length()];\n        boolean leading = true;\n        int sp = 0;\n        int sig = 0;\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = aString.charAt(i);\n\n            if (buf[i] >= '1' && buf[i] <= '9') {\n                leading = false;\n            }\n\n            if (buf[i] == '.') {\n                sig += (field.getRadixDigits() / 2) * 4;\n                leading = false;\n            }\n\n            if (sig == (field.getRadixDigits() / 2) * 4) {\n                sp = i;\n                break;\n            }\n\n            if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n                sig ++;\n            }\n        }\n\n        result[0] = field.newDfp(new String(buf, 0, sp));\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = aString.charAt(i);\n            if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n                buf[i] = '0';\n            }\n        }\n\n        result[1] = field.newDfp(new String(buf));\n\n        return result;\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n        Dfp result[] = new Dfp[2];\n        DfpField field = a.getField();\n        String aStr = a.toString();\n        char[] buf;\n        boolean leading = true;\n        int sp = 0;\n        int sig = 0;\n\n        buf = new char[aStr.length()];\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = aStr.charAt(i);\n\n            if (buf[i] >= '1' && buf[i] <= '9') {\n                leading = false;\n            }\n\n            if (buf[i] == '.') {\n                sig += (400 - sig) % 4;\n                leading = false;\n            }\n\n            if (sig == (field.getRadixDigits() / 2) * 4) {\n                sp = i;\n                break;\n            }\n\n            if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n                sig ++;\n            }\n        }\n\n        result[0] = field.newDfp(new String(buf, 0, sp));\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = aStr.charAt(i);\n            if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n                buf[i] = '0';\n            }\n        }\n\n        result[1] = field.newDfp(new String(buf));\n\n        return result;\n    }"
    ],
    [
      "public String cssSelector()  {\n    StringBuilder selector = new StringBuilder();\n    if (!id().isEmpty()) \n    {\n        selector.append(\"#\").append(id());\n        return selector.toString();\n    } \n    else if (parent() != null) \n    {\n        selector.append(parent().cssSelector()).append(\">\");\n    }\n    selector.append(tagName());\n    String cssClass = attribute(\"class\");\n    if (!cssClass.isEmpty()) \n    {\n        selector.append(\".\").append(cssClass);\n    }\n    selector.append(\":nth-child(\").append(siblingIndex()).append(\")\");\n    return selector.toString();\n}",
      "public String cssSelector()  {\n    StringBuilder selector = new StringBuilder();\n    if (!attributes().get(\"id\").isEmpty()) {\n        selector.append(\"#\").append(attributes().get(\"id\"));\n    } else if (parent() != null) {\n        selector.append(parent().cssSelector()).append(\">\");\n        int index = 0;\n        for (Node node : parent().children()) {\n            if (node == this) {\n                break;\n            }\n            if (node.nodeName().equals(nodeName())) {\n                index++;\n            }\n        }\n        selector.append(nodeName());\n        if (!attributes().get(\"class\").isEmpty()) {\n            selector.append(\".\").append(attributes().get(\"class\"));\n        }\n        if (!attributes().get(\"class\").isEmpty() && index > 0) {\n            selector.append(\":nth-child(\").append(index).append(\")\");\n        }\n    }\n    return selector.toString();\n}",
      "public String cssSelector()  {\n    StringBuilder selector = new StringBuilder();\n    if (!attributes.get(\"id\").isEmpty()) \n    {\n        selector.append(\"#\").append(attributes.get(\"id\"));\n    } \n    else \n    {\n        if (parent != null) \n        {\n            selector.append(parent.cssSelector()).append(\">\");\n        }\n        selector.append(tagName);\n        if (!attributes.get(\"class\").isEmpty()) \n        {\n            selector.append(\".\").append(attributes.get(\"class\"));\n        }\n        if (parent != null) \n        {\n            int index = 0;\n            for (Node node : parent.children()) \n            {\n                if (node == this) \n                {\n                    break;\n                }\n                if (node.tagName().equals(tagName)) \n                {\n                    index++;\n                }\n            }\n            selector.append(\":nth-child(\").append(index + 1).append(\")\");\n        }\n    }\n    return selector.toString();\n}",
      "public String cssSelector()  {\n    StringBuilder selector = new StringBuilder();\n    if (!attributes.get(\"id\").isEmpty()) \n    {\n        selector.append(\"#\").append(attributes.get(\"id\"));\n    } \n    else \n    {\n        Element parent = parent();\n        if (parent != null) \n        {\n            selector.append(parent.cssSelector()).append(\">\");\n        }\n        selector.append(tagName());\n        if (!attributes.get(\"class\").isEmpty()) \n        {\n            selector.append(\".\").append(attributes.get(\"class\"));\n        }\n        selector.append(\":nth-child(\").append(siblingIndex() + 1).append(\")\");\n    }\n    return selector.toString();\n}",
      "public String cssSelector()  {\n    StringBuilder selector = new StringBuilder();\n    if (!id().isEmpty()) \n    {\n        selector.append(\"#\").append(id());\n    } \n    else \n    {\n        Element parent = parent();\n        if (parent != null) \n        {\n            selector.append(parent.cssSelector()).append(\">\");\n        }\n        selector.append(tagName());\n        String cssClass = classes().toString().replace(' ', '.');\n        if (!cssClass.isEmpty()) \n        {\n            selector.append('.').append(cssClass);\n        }\n        selector.append(':nth-child(').append(siblingIndex()).append(')');\n    }\n    return selector.toString();\n}",
      "public String cssSelector()  {\n    StringBuilder selector = new StringBuilder();\n    if (!attributes.get(\"id\").isEmpty()) \n    {\n        selector.append(\"#\");\n        selector.append(attributes.get(\"id\"));\n    } \n    else \n    {\n        if (parent != null) \n        {\n            selector.append(parent.cssSelector());\n            selector.append(\">\");\n        }\n        selector.append(tagName);\n        if (!attributes.get(\"class\").isEmpty()) \n        {\n            selector.append(\".\");\n            selector.append(attributes.get(\"class\"));\n        }\n        selector.append(\":nth-child(\");\n        selector.append(parent.children().indexOf(this) + 1);\n        selector.append(\")\");\n    }\n    return selector.toString();\n}",
      "public String cssSelector()  {\n    StringBuilder selector = new StringBuilder();\n    if (!id().isEmpty()) {\n        selector.append(\"#\").append(id());\n    } else if (parent() != null) {\n        selector.append(parent().cssSelector()).append(\" > \");\n        selector.append(tagName());\n        if (!className().isEmpty()) {\n            selector.append(\".\").append(className());\n        }\n        // TODO: handle nth-child\n    } else {\n        selector.append(tagName());\n        if (!className().isEmpty()) {\n            selector.append(\".\").append(className());\n        }\n    }\n    return selector.toString();\n}",
      "public String cssSelector()  {\n        StringBuilder selector = new StringBuilder();\n        if (!id().isEmpty()) {\n            selector.append(\"#\").append(id());\n        } else if (parent() != null) {\n            selector.append(parent().cssSelector()).append(\" > \");\n            int index = parent().children().indexOf(this);\n            selector.append(tagName());\n            if (!className().isEmpty()) {\n                selector.append(\".\").append(className());\n            }\n            if (index > 0) {\n                selector.append(\":nth-child(\").append(index + 1).append(\")\");\n            }\n        }\n        return selector.toString();\n    }",
      "public String cssSelector()  {\n    StringBuilder selector = new StringBuilder();\n    if (!id().isEmpty()) \n    {\n        selector.append(\"#\").append(id());\n    } \n    else \n    {\n        if (parent() != null) \n        {\n            selector.append(parent().cssSelector()).append(\" > \");\n        }\n        selector.append(tagName());\n        if (!className().isEmpty()) \n        {\n            selector.append(\".\").append(className());\n        }\n        if (siblingIndex() > 1) \n        {\n            selector.append(\":nth-child(\").append(siblingIndex()).append(\")\");\n        }\n    }\n    return selector.toString();\n}",
      "public String cssSelector()  {\n    StringBuilder selector = new StringBuilder();\n    if (!id().isEmpty()) {\n        selector.append(\"#\").append(id());\n    } else if (parent() != null) {\n        selector.append(parent().cssSelector()).append(\" > \");\n        selector.append(tagName());\n        if (!className().isEmpty()) {\n            selector.append(\".\").append(className());\n        }\n        // Adding pseudo class for nth child\n        int index = parent().children().indexOf(this) + 1;\n        selector.append(\":nth-child(\").append(index).append(\")\");\n    } else {\n        selector.append(tagName());\n        if (!className().isEmpty()) {\n            selector.append(\".\").append(className());\n        }\n    }\n    return selector.toString();\n}"
    ],
    [
      "private static int estimateCostOneLevel(Node n)  {\n    int count = 0;\n    if (n.getType() == Token.NOT) \n    {\n        count++;\n    }\n    for (Node child : n.getChildren()) \n    {\n        count += estimateCostOneLevel(child);\n    }\n    return count;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int count = 0;\n    if (n.getType() == Token.NOT) \n    {\n        count += 1; // for the NOT keyword\n        count += estimateCostOneLevel(n.getFirstChild()); // for the child node\n    } \n    else \n    {\n        for (Node child = n.getFirstChild(); child != null; child = child.getNext()) \n        {\n            count += estimateCostOneLevel(child);\n        }\n    }\n    return count;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.getType() == Token.NOT) \n    {\n        cost += 2; // for \"!\" and the space after it\n    } \n    else if (n.getType() == Token.LPAREN || n.getType() == Token.RPAREN) \n    {\n        cost += 1; // for \"(\" or \")\"\n    }\n    else if (n.getType() == Token.HOOK) \n    {\n        cost += 2; // for \"?\" and the space after it\n    }\n    else if (n.getType() == Token.COMMA) \n    {\n        cost += 2; // for \",\" and the space after it\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int count = 0;\n    if (n.getType() == Token.NOT) \n    {\n        count++;\n    }\n    for (Node child : n.getChildren()) \n    {\n        count += estimateCostOneLevel(child);\n    }\n    return count;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.getType() == Token.NOT) \n    {\n        cost += 2; // for the 'not' keyword\n    }\n    else \n    {\n        if (n.getFirstChild().getType() == Token.NOT) \n        {\n            cost += 1; // for the 'not' keyword\n        }\n        if (n.getFirstChild().getNext() != null && n.getFirstChild().getNext().getType() == Token.NOT) \n        {\n            cost += 1; // for the 'not' keyword\n        }\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.getType() == Token.NOT) \n    {\n        cost += 1; // for the NOT keyword\n        cost += estimateCostOneLevel(n.getFirstChild()); // for the child node\n    } \n    else \n    {\n        for (Node child = n.getFirstChild(); child != null; child = child.getNext()) \n        {\n            cost += estimateCostOneLevel(child);\n        }\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.getType() == Token.NOT) \n    {\n        cost++;\n    }\n    Node child = n.getFirstChild();\n    while (child != null) \n    {\n        cost += estimateCostOneLevel(child);\n        child = child.getNext();\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType()) \n    {\n        case Token.NOT:\n            cost = 2; // for \"!\" and the following space\n            break;\n        case Token.LPAREN:\n            cost = 1; // for \"(\"\n            break;\n        case Token.RPAREN:\n            cost = 1; // for \")\"\n            break;\n        default:\n            break;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int count = 0;\n    if(n.getType() == Token.NOT) \n    {\n        count++;\n    }\n    for(Node child : n.getChildren()) \n    {\n        count += estimateCostOneLevel(child);\n    }\n    return count;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int count = 0;\n    if (n.getType() == Token.NOT) \n    {\n        count++;\n    }\n    for (Node child : n.getChildren()) \n    {\n        count += estimateCostOneLevel(child);\n    }\n    return count;\n}"
    ],
    [
      "public StrBuilder reverse()  {\n    for(int i = 0; i < size / 2; i++) \n    {\n        char temp = buffer[i];\n        buffer[i] = buffer[size - i - 1];\n        buffer[size - i - 1] = temp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int left = 0;\n    int right = size - 1;\n    while (left < right) \n    {\n        // swap the values at the left and right indices\n        char temp = buffer[left];\n        buffer[left] = buffer[right];\n        buffer[right] = temp;\n\n        // move the left and right pointers inward\n        left++;\n        right--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    for (int left = 0, right = size - 1; left < right; left++, right--) \n    {\n        char temp = buffer[left];\n        buffer[left] = buffer[right];\n        buffer[right] = temp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int low = 0;\n    int high = size - 1;\n    while (low < high) \n    {\n        char temp = buffer[low];\n        buffer[low] = buffer[high];\n        buffer[high] = temp;\n        low++;\n        high--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int len = size;\n    for (int i = 0; i < len/2; i++) \n    {\n        char temp = buffer[i];\n        buffer[i] = buffer[len-i-1];\n        buffer[len-i-1] = temp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int len = size;\n    for (int i = 0; i < len/2; i++) \n    {\n        char temp = buffer[i];\n        buffer[i] = buffer[len-i-1];\n        buffer[len-i-1] = temp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int left = 0;\n    int right = size - 1;\n    while (left < right) \n    {\n        // swap the values at the left and right indices\n        char temp = buffer[left];\n        buffer[left] = buffer[right];\n        buffer[right] = temp;\n\n        // move the left and right pointers inward\n        left++;\n        right--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int left = 0;\n    int right = size - 1;\n\n    while (left < right) \n    {\n        // swap the values at the left and right indices\n        char temp = buffer[left];\n        buffer[left] = buffer[right];\n        buffer[right] = temp;\n\n        // move the left and right indices inward\n        left++;\n        right--;\n    }\n\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int len = size;\n    for (int i = 0; i < len / 2; i++) \n    {\n        char temp = buffer[i];\n        buffer[i] = buffer[len - i - 1];\n        buffer[len - i - 1] = temp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int left = 0;\n    int right = size - 1;\n    while (left < right) \n    {\n        // Swap the left and right characters\n        char temp = buffer[left];\n        buffer[left] = buffer[right];\n        buffer[right] = temp;\n\n        // Move towards the center\n        left++;\n        right--;\n    }\n\n    return this;\n}"
    ],
    [
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0 && offset <= getWholeText().length(), \"Invalid offset\");\n\n    String right = getWholeText().substring(offset);\n    String left = getWholeText().substring(0, offset);\n\n    TextNode newNode = new TextNode(right);\n    coreValue(left);\n\n    if (nextSibling() != null) {\n        newNode.insertBefore(nextSibling());\n    } else {\n        appendChild(newNode);\n    }\n\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0 && offset <= getWholeText().length(), \"Invalid offset\");\n\n    String right = getWholeText().substring(offset);\n    coreValue(getWholeText().substring(0, offset));\n\n    TextNode newNode = new TextNode(right);\n    newNode.parent(this.parent());\n    newNode.before(this.nextSibling());\n\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0 && offset <= getWholeText().length(), \"Invalid offset\");\n\n    String text = getWholeText();\n    String left = text.substring(0, offset);\n    String right = text.substring(offset);\n\n    TextNode newNode = new TextNode(right);\n    coreValue(left);\n    after(newNode);\n\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0 && offset <= value.length(), \"Offset must be between 0 and node length\");\n\n    String after = value.substring(offset);\n    value = value.substring(0, offset);\n\n    TextNode newNode = new TextNode(after);\n    newNode.parent = this.parent;\n    newNode.next = this.next;\n    if (this.next != null) {\n        this.next.previous = newNode;\n    }\n    this.next = newNode;\n    newNode.previous = this;\n\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0 && offset <= getWholeText().length(), \"Offset must be between 0 and text length\");\n    String text = getWholeText();\n    String left = text.substring(0, offset);\n    String right = text.substring(offset);\n    TextNode newNode = new TextNode(right);\n    coreValue(left);\n    this.after(newNode);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0 && offset <= value.length(), \"Offset must be between 0 and node length\");\n\n    String after = value.substring(offset);\n    value = value.substring(0, offset);\n\n    TextNode newNode = new TextNode(after);\n    newNode.parent = this.parent;\n    this.next = newNode;\n    newNode.previous = this;\n\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0 && offset <= value.length(), \"Offset must be between 0 and node length\");\n    String after = value.substring(offset);\n    value = value.substring(0, offset);\n    TextNode newNode = new TextNode(after);\n    this.next = newNode;\n    newNode.previous = this;\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0 && offset <= getWholeText().length(), \"Invalid offset\");\n\n    String textAfter = getWholeText().substring(offset);\n    coreValue(getWholeText().substring(0, offset));\n\n    TextNode newNode = new TextNode(textAfter);\n    this.nextSibling(newNode);\n\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0 && offset <= value.length(), \"Invalid offset\");\n\n    String after = value.substring(offset);\n    value = value.substring(0, offset);\n\n    TextNode newNode = new TextNode(after);\n    newNode.parent = this.parent;\n    this.next = newNode;\n    newNode.previous = this;\n\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0 && offset <= getWholeText().length(), \"Invalid offset\");\n    String text = getWholeText();\n    String left = text.substring(0, offset);\n    String right = text.substring(offset);\n    TextNode newNode = new TextNode(right);\n    coreValue(left);\n    this.after(newNode);\n    return newNode;\n}"
    ],
    [
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        int min = helper.min(obj);\n        int max = helper.max(obj);\n        helper.setCardinality(obj, max - min);\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        int min = helper.min(obj);\n        int max = helper.max(obj);\n        helper.setCardinality(obj, max - min);\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        int minCardinality = helper.min(obj);\n        int maxCardinality = helper.max(obj);\n        helper.setCardinality(obj, maxCardinality - minCardinality);\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        int minCard = helper.min(obj);\n        int maxCard = helper.max(obj);\n        int diff = maxCard - minCard;\n        helper.setCardinality(obj, diff);\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        int min = helper.min(obj);\n        int max = helper.max(obj);\n        helper.setCardinality(obj, max - min);\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        int min = helper.min(obj);\n        int max = helper.max(obj);\n        helper.setCardinality(obj, max - min);\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        int min = helper.min(obj);\n        int max = helper.max(obj);\n        helper.setCardinality(obj, max - min);\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        int min = helper.min(obj);\n        int max = helper.max(obj);\n        helper.setCardinality(obj, max - min);\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        int minCardinality = helper.min(obj);\n        int maxCardinality = helper.max(obj);\n        helper.setCardinality(obj, maxCardinality - minCardinality);\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        int min = helper.min(obj);\n        int max = helper.max(obj);\n        helper.setCardinality(obj, max - min);\n    }\n    return helper.list();\n}"
    ],
    [
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    if (value.signum() < 0) \n    {\n        bytes[0] = (byte) 0xFF;\n        BigInteger abs = value.abs();\n        byte[] absBytes = abs.toByteArray();\n        int length = absBytes.length;\n        for (int i = 0; i < length; i++) \n        {\n            bytes[i] = (byte) (~absBytes[length - i - 1] & 0xFF);\n        }\n    } \n    else \n    {\n        byte[] valueBytes = value.toByteArray();\n        int length = valueBytes.length;\n        for (int i = 0; i < length; i++) \n        {\n            bytes[i] = valueBytes[length - i - 1];\n        }\n    }\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    BigInteger v = value;\n    for (int i = 0; i < 8; i++) \n    {\n        int shiftAmount = (7 - i) * 8;\n        bytes[i] = (byte) ((v.shiftRight(shiftAmount).and(BigInteger.valueOf(0xFF))).intValue());\n    }\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    BigInteger v = value;\n    for (int i = 0; i < 8; i++) \n    {\n        int shift = (7 - i) * 8;\n        bytes[i] = (byte) ((v.shiftRight(shift).and(BigInteger.valueOf(0xFF))).intValue());\n    }\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    if (value.signum() < 0) \n    {\n        bytes[0] = (byte) 0xFF;\n        BigInteger abs = value.abs();\n        byte[] absBytes = abs.toByteArray();\n        int length = absBytes.length;\n        for (int i = 0; i < length; i++) \n        {\n            bytes[i] = (byte) (~absBytes[length - i - 1] & 0xFF);\n        }\n    } \n    else \n    {\n        byte[] valueBytes = value.toByteArray();\n        int length = valueBytes.length;\n        for (int i = 0; i < length; i++) \n        {\n            bytes[i] = valueBytes[length - i - 1];\n        }\n    }\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    if (value.signum() < 0) \n    {\n        bytes[0] = (byte) 0xFF;\n        BigInteger positive = value.negate();\n        byte[] temp = positive.toByteArray();\n        int length = temp.length;\n        for (int i = 0; i < length; i++) \n        {\n            bytes[i] ^= temp[length - i - 1];\n        }\n    } \n    else \n    {\n        byte[] temp = value.toByteArray();\n        int length = temp.length;\n        for (int i = 0; i < length; i++) \n        {\n            bytes[i] = temp[length - i - 1];\n        }\n    }\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    if (value.signum() >= 0) \n    {\n        bytes[BYTE_7] = (byte) ((value.byteValue() >> BYTE_7_SHIFT) & 0x7F);\n        bytes[BYTE_6] = (byte) ((value.byteValue() >> BYTE_6_SHIFT) & 0xFF);\n        bytes[BYTE_5] = (byte) ((value.byteValue() >> BYTE_5_SHIFT) & 0xFF);\n        bytes[BYTE_4] = (byte) ((value.byteValue() >> BYTE_4_SHIFT) & 0xFF);\n        bytes[BYTE_3] = (byte) ((value.byteValue() >> BYTE_3_SHIFT) & 0xFF);\n        bytes[BYTE_2] = (byte) ((value.byteValue() >> BYTE_2_SHIFT) & 0xFF);\n        bytes[BYTE_1] = (byte) (value.byteValue() & 0xFF);\n        bytes[BYTE_0] = (byte) (value.byteValue() >> 8 & 0xFF);\n    } \n    else \n    {\n        BigInteger neg = value.negate();\n        bytes[BYTE_7] = (byte) ((neg.byteValue() >> BYTE_7_SHIFT) & 0x7F);\n        bytes[BYTE_6] = (byte) ((neg.byteValue() >> BYTE_6_SHIFT) & 0xFF);\n        bytes[BYTE_5] = (byte) ((neg.byteValue() >> BYTE_5_SHIFT) & 0xFF);\n        bytes[BYTE_4] = (byte) ((neg.byteValue() >> BYTE_4_SHIFT) & 0xFF);\n        bytes[BYTE_3] = (byte) ((neg.byteValue() >> BYTE_3_SHIFT) & 0xFF);\n}\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    if (value.signum() >= 0) \n    {\n        bytes[BYTE_7] = (byte) ((value.byteValue() >> BYTE_7_SHIFT) & 0xFF);\n        bytes[BYTE_6] = (byte) ((value.byteValue() >> BYTE_6_SHIFT) & 0xFF);\n        bytes[BYTE_5] = (byte) ((value.byteValue() >> BYTE_5_SHIFT) & 0xFF);\n        bytes[BYTE_4] = (byte) ((value.byteValue() >> BYTE_4_SHIFT) & 0xFF);\n        bytes[BYTE_3] = (byte) ((value.byteValue() >> BYTE_3_SHIFT) & 0xFF);\n        bytes[BYTE_2] = (byte) ((value.byteValue() >> BYTE_2_SHIFT) & 0xFF);\n        bytes[BYTE_1] = (byte) (value.byteValue() & 0xFF);\n        bytes[BYTE_0] = (byte) ((value.byteValue() >> BYTE_0_SHIFT) & 0xFF);\n    } \n    else \n    {\n        bytes[BYTE_7] = (byte) ((value.byteValue() >> BYTE_7_SHIFT) & 0xFF);\n        bytes[BYTE_6] = (byte) ((value.byteValue() >> BYTE_6_SHIFT) & 0xFF);\n        bytes[BYTE_5] = (byte) ((value.byteValue() >> BYTE_5_SHIFT) & 0xFF);\n        bytes[BYTE_4] = (byte) ((value.byteValue() >> BYTE_4_SHIFT) & 0xFF);\n        bytes[BYTE_3] = (byte) ((value.byteValue() >> BYTE_3_SHIFT) & 0xFF);\n}\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    BigInteger val = value;\n    if (val.compareTo(BigInteger.ZERO) < 0) \n    {\n        val = val.add(BigInteger.ONE.shiftLeft(LEFTMOST_BIT_SHIFT));\n    }\n    bytes[BYTE_7] = val.and(BigInteger.valueOf(BYTE_7_MASK)).shiftRight(BYTE_7_SHIFT).byteValue();\n    bytes[BYTE_6] = val.and(BigInteger.valueOf(BYTE_6_MASK)).shiftRight(BYTE_6_SHIFT).byteValue();\n    bytes[BYTE_5] = val.and(BigInteger.valueOf(BYTE_5_MASK)).shiftRight(BYTE_5_SHIFT).byteValue();\n    bytes[BYTE_4] = val.and(BigInteger.valueOf(BYTE_4_MASK)).shiftRight(BYTE_4_SHIFT).byteValue();\n    bytes[BYTE_3] = val.and(BigInteger.valueOf(BYTE_3_MASK)).shiftRight(BYTE_3_SHIFT).byteValue();\n    bytes[BYTE_2] = val.and(BigInteger.valueOf(BYTE_2_MASK)).shiftRight(BYTE_2_SHIFT).byteValue();\n    bytes[BYTE_1] = val.and(BigInteger.valueOf(BYTE_1_MASK)).shiftRight(BYTE_1_SHIFT).byteValue();\n    bytes[BYTE_0] = val.and(BigInteger.valueOf(BYTE_0_MASK)).byteValue();\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    if (value.signum() < 0) \n    {\n        bytes[0] = (byte) 0xFF;\n        BigInteger abs = value.abs();\n        BigInteger not = abs.not();\n        BigInteger inc = not.add(BigInteger.ONE);\n        byte[] temp = inc.toByteArray();\n        System.arraycopy(temp, 0, bytes, 1, temp.length);\n        return bytes;\n    }\n    byte[] temp = value.toByteArray();\n    if (temp.length > 8) \n    {\n        throw new ArithmeticException(\"value out of range: \" + value);\n    }\n    if (temp.length < 8) \n    {\n        System.arraycopy(temp, 0, bytes, 8 - temp.length, temp.length);\n    } \n    else \n    {\n        System.arraycopy(temp, 0, bytes, 0, 8);\n    }\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    if (value.signum() < 0) \n    {\n        bytes[0] = (byte) 0xFF;\n        BigInteger abs = value.abs();\n        byte[] absBytes = abs.toByteArray();\n        int length = absBytes.length;\n        for (int i = 0; i < length; i++) \n        {\n            bytes[i] = (byte) (~absBytes[length - i - 1] & 0xFF);\n        }\n    } \n    else \n    {\n        byte[] valueBytes = value.toByteArray();\n        int length = valueBytes.length;\n        for (int i = 0; i < length; i++) \n        {\n            bytes[i] = valueBytes[length - i - 1];\n        }\n    }\n    return bytes;\n}"
    ],
    [
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return \"\";\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return \"\";\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return \"\";\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return \"\";\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return \"\";\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return \"\";\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return \"\";\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return \"\";\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return \"\";\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return \"\";\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}"
    ],
    [
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric() || !isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(\n                \"Matrix must be symmetric and positive definite\");\n    }\n\n    int n = getRowDimension();\n    double[][] sqrtMatrix = new double[n][n];\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <= i; j++) {\n            double sqrtEigenvalue = Math.sqrt(realEigenvalues[i]);\n            sqrtMatrix[i][j] = sqrtEigenvalue * eigenvectors[i].getEntry(j);\n            sqrtMatrix[j][i] = sqrtEigenvalue * eigenvectors[i].getEntry(j);\n        }\n    }\n\n    return new Array2DRowRealMatrix(sqrtMatrix);\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric() || !isPositiveDefinite()) \n    {\n        throw new MathUnsupportedOperationException(\"Matrix must be symmetric and positive definite\");\n    }\n\n    int n = getRowDimension();\n    RealMatrix sqrtMatrix = MatrixUtils.createRealMatrix(n, n);\n\n    for (int i = 0; i < n; i++) \n    {\n        for (int j = 0; j <= i; j++) \n        {\n            double sqrtValue = Math.sqrt(getRealEigenvalue(i));\n            RealVector eigenvectorI = getEigenvector(i);\n            RealVector eigenvectorJ = getEigenvector(j);\n            double dotProduct = eigenvectorI.dotProduct(eigenvectorJ);\n            sqrtMatrix.setEntry(i, j, sqrtValue * dotProduct);\n            if (i != j) \n            {\n                sqrtMatrix.setEntry(j, i, sqrtValue * dotProduct);\n            }\n        }\n    }\n\n    return sqrtMatrix;\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric() || !isPositiveDefinite()) \n    {\n        throw new MathUnsupportedOperationException(\"Matrix must be symmetric and positive definite to compute square root.\");\n    }\n\n    int n = getRowDimension();\n    double[][] sqrtMatrix = new double[n][n];\n\n    for (int i = 0; i < n; i++) \n    {\n        for (int j = 0; j <= i; j++) \n        {\n            double sqrtEigenvalue = Math.sqrt(realEigenvalues[i]);\n            sqrtMatrix[i][j] = sqrtEigenvalue * eigenvectors[i].getEntry(j);\n            sqrtMatrix[j][i] = sqrtEigenvalue * eigenvectors[j].getEntry(i);\n        }\n    }\n\n    return new Array2DRowRealMatrix(sqrtMatrix);\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric() || !isPositiveDefinite())\n    {\n        throw new MathUnsupportedOperationException(\"Matrix must be symmetric and positive definite\");\n    }\n\n    int n = getRowDimension();\n    double[][] sqrtMatrix = new double[n][n];\n\n    for (int i = 0; i < n; i++)\n    {\n        double sqrtEigenvalue = Math.sqrt(realEigenvalues[i]);\n        for (int j = 0; j < n; j++)\n        {\n            sqrtMatrix[i][j] = sqrtEigenvalue * eigenvectors[j].getEntry(i);\n        }\n    }\n\n    return new Array2DRowRealMatrix(sqrtMatrix);\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric() || !isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(\"Matrix must be symmetric and positive definite\");\n    }\n\n    int n = getRowDimension();\n    RealMatrix sqrtMatrix = MatrixUtils.createRealMatrix(n, n);\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <= i; j++) {\n            double sqrtValue = Math.sqrt(getEntry(i, i) - getEntry(j, j));\n            sqrtMatrix.setEntry(i, j, sqrtValue);\n            sqrtMatrix.setEntry(j, i, sqrtValue);\n        }\n    }\n\n    return sqrtMatrix;\n}",
      "public RealMatrix getSquareRoot()  {\n        if (!isSymmetric() || !isPositiveDefinite()) {\n            throw new MathUnsupportedOperationException(\n                    \"Matrix must be symmetric and positive definite to compute square root\");\n        }\n\n        final int n = getRowDimension();\n        final RealMatrix sqrtMatrix = MatrixUtils.createRealMatrix(n, n);\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= i; j++) {\n                double sqrtValue = Math.sqrt(getEntry(i, i) - getEntry(j, j));\n                sqrtMatrix.setEntry(i, j, sqrtValue);\n                sqrtMatrix.setEntry(j, i, sqrtValue);\n            }\n        }\n\n        return sqrtMatrix;\n    }",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric() || !isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(\n            \"Matrix must be symmetric and positive definite to compute square root\");\n    }\n\n    int n = getRowDimension();\n    double[][] sqrtMatrix = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            sqrtMatrix[i][j] = Math.sqrt(getRealEigenvalue(i)) * getEigenvector(i).getEntry(j);\n        }\n    }\n    return new Array2DRowRealMatrix(sqrtMatrix);\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric() || !isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(\"Matrix is not symmetric or not positive definite\");\n    }\n\n    int n = getRowDimension();\n    double[][] sqrtMatrix = new double[n][n];\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <= i; j++) {\n            double sqrtEigenvalue = Math.sqrt(realEigenvalues[i]);\n            sqrtMatrix[i][j] = sqrtEigenvalue * eigenvectors[i].getEntry(j);\n            sqrtMatrix[j][i] = sqrtEigenvalue * eigenvectors[i].getEntry(j);\n        }\n    }\n\n    return new Array2DRowRealMatrix(sqrtMatrix);\n}",
      "public RealMatrix getSquareRoot()  {\n        if (!isSymmetric() || !isPositiveDefinite()) {\n            throw new MathUnsupportedOperationException(LocalizedFormats.MATRIX_NOT_SPD, this);\n        }\n\n        int n = getRowDimension();\n        RealMatrix sqrtMatrix = MatrixUtils.createRealMatrix(n, n);\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= i; j++) {\n                double sqrtValue = Math.sqrt(getEntry(i, i) - getEntry(j, j));\n                sqrtMatrix.setEntry(i, j, sqrtValue);\n                sqrtMatrix.setEntry(j, i, sqrtValue);\n            }\n        }\n\n        return sqrtMatrix;\n    }",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric() || !isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(\"Matrix is not symmetric or not positive definite\");\n    }\n\n    int n = getRowDimension();\n    RealMatrix sqrtMatrix = MatrixUtils.createRealMatrix(n, n);\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <= i; j++) {\n            double sqrtValue = Math.sqrt(getEntry(i, i) - getEntry(j, j));\n            sqrtMatrix.setEntry(i, j, sqrtValue);\n            sqrtMatrix.setEntry(j, i, sqrtValue);\n        }\n    }\n\n    return sqrtMatrix;\n}"
    ],
    [
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t) {\n        case VALUE_STRING:\n            return deserializeFromString(p, ctxt);\n        case VALUE_NUMBER_INT:\n            return deserializeFromNumber(p, ctxt);\n        case VALUE_NUMBER_FLOAT:\n            return deserializeFromDouble(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT:\n            return deserializeFromEmbedded(p, ctxt);\n        case VALUE_TRUE:\n        case VALUE_FALSE:\n            return deserializeFromBoolean(p, ctxt);\n        case VALUE_NULL:\n            return deserializeFromNull(p, ctxt);\n        case START_ARRAY:\n            // these only work if there's a (delegating) creator...\n            return deserializeFromArray(p, ctxt);\n        default:\n            return ctxt.handleUnexpectedToken(handledType(), p);\n        }\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t) {\n        case VALUE_STRING:\n            return deserializeFromString(p, ctxt);\n        case VALUE_NUMBER_INT:\n            return deserializeFromNumber(p, ctxt);\n        case VALUE_NUMBER_FLOAT:\n            return deserializeFromDouble(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT:\n            return deserializeFromEmbedded(p, ctxt);\n        case VALUE_TRUE:\n        case VALUE_FALSE:\n            return deserializeFromBoolean(p, ctxt);\n        case VALUE_NULL:\n            return deserializeFromNull(p, ctxt);\n        case START_ARRAY:\n            return deserializeFromArray(p, ctxt);\n        default:\n            return ctxt.handleUnexpectedToken(handledType(), p);\n        }\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t) {\n        case VALUE_STRING:\n            return deserializeFromString(p, ctxt);\n        case VALUE_NUMBER_INT:\n            return deserializeFromNumber(p, ctxt);\n        case VALUE_NUMBER_FLOAT:\n            return deserializeFromDouble(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT:\n            return deserializeFromEmbedded(p, ctxt);\n        case VALUE_TRUE:\n        case VALUE_FALSE:\n            return deserializeFromBoolean(p, ctxt);\n        case VALUE_NULL:\n            return deserializeFromNull(p, ctxt);\n        case START_ARRAY:\n            // these only work if there's a (delegating) creator...\n            return deserializeFromArray(p, ctxt);\n        default:\n            return ctxt.handleUnexpectedToken(handledType(), p);\n        }\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t) {\n        case VALUE_STRING:\n            return deserializeFromString(p, ctxt);\n        case VALUE_NUMBER_INT:\n            return deserializeFromNumber(p, ctxt);\n        case VALUE_NUMBER_FLOAT:\n            return deserializeFromDouble(p, ctxt);\n        case VALUE_TRUE:\n        case VALUE_FALSE:\n            return deserializeFromBoolean(p, ctxt);\n        case VALUE_NULL:\n            return deserializeFromNull(p, ctxt);\n        case START_ARRAY:\n            return deserializeFromArray(p, ctxt);\n        case FIELD_NAME:\n        case END_OBJECT:\n            return deserializeFromObject(p, ctxt);\n        default:\n            return ctxt.handleUnexpectedToken(handledType(), p);\n        }\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t) {\n        case VALUE_STRING:\n            return deserializeFromString(p, ctxt);\n        case VALUE_NUMBER_INT:\n            return deserializeFromNumber(p, ctxt);\n        case VALUE_NUMBER_FLOAT:\n            return deserializeFromDouble(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT:\n            return deserializeFromEmbedded(p, ctxt);\n        case VALUE_TRUE:\n        case VALUE_FALSE:\n            return deserializeFromBoolean(p, ctxt);\n        case VALUE_NULL:\n            return deserializeFromNull(p, ctxt);\n        case START_ARRAY:\n            return deserializeFromArray(p, ctxt);\n        default:\n            return ctxt.handleUnexpectedToken(handledType(), p);\n        }\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t) {\n        case VALUE_STRING:\n            return deserializeFromString(p, ctxt);\n        case VALUE_NUMBER_INT:\n            return deserializeFromNumber(p, ctxt);\n        case VALUE_NUMBER_FLOAT:\n            return deserializeFromDouble(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT:\n            return deserializeFromEmbedded(p, ctxt);\n        case VALUE_TRUE:\n        case VALUE_FALSE:\n            return deserializeFromBoolean(p, ctxt);\n        case VALUE_NULL:\n            return deserializeFromNull(p, ctxt);\n        case START_ARRAY:\n            return deserializeFromArray(p, ctxt);\n        default:\n            return ctxt.handleUnexpectedToken(handledType(), p);\n        }\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t) {\n        case VALUE_STRING:\n            return deserializeFromString(p, ctxt);\n        case VALUE_NUMBER_INT:\n            return deserializeFromNumber(p, ctxt);\n        case VALUE_NUMBER_FLOAT:\n            return deserializeFromDouble(p, ctxt);\n        case VALUE_TRUE:\n        case VALUE_FALSE:\n            return deserializeFromBoolean(p, ctxt);\n        case VALUE_NULL:\n            return deserializeFromNull(p, ctxt);\n        default:\n            return ctxt.handleUnexpectedToken(handledType(), p);\n        }\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n         switch (t) {\n         case VALUE_STRING:\n             return deserializeFromString(p, ctxt);\n         case VALUE_NUMBER_INT:\n             return deserializeFromNumber(p, ctxt);\n         case VALUE_NUMBER_FLOAT:\n             return deserializeFromDouble(p, ctxt);\n         case VALUE_EMBEDDED_OBJECT:\n             return deserializeFromEmbedded(p, ctxt);\n         case VALUE_TRUE:\n         case VALUE_FALSE:\n             return deserializeFromBoolean(p, ctxt);\n         case VALUE_NULL:\n             return deserializeFromNull(p, ctxt);\n         case START_ARRAY:\n             return deserializeFromArray(p, ctxt);\n         default:\n             return ctxt.handleUnexpectedToken(handledType(), p);\n         }\n     }\n\n     protected Object _missingToken(JsonParser p, DeserializationContext ctxt) throws IOException {\n         throw ctxt.endOfInputException(handledType());\n     }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t) {\n        case VALUE_STRING:\n            return deserializeFromString(p, ctxt);\n        case VALUE_NUMBER_INT:\n            return deserializeFromNumber(p, ctxt);\n        case VALUE_NUMBER_FLOAT:\n            return deserializeFromDouble(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT:\n            return deserializeFromEmbedded(p, ctxt);\n        case VALUE_TRUE:\n        case VALUE_FALSE:\n            return deserializeFromBoolean(p, ctxt);\n        case VALUE_NULL:\n            return deserializeFromNull(p, ctxt);\n        case START_ARRAY:\n            return deserializeFromArray(p, ctxt);\n        default:\n            return ctxt.handleUnexpectedToken(handledType(), p);\n        }\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t) {\n        case VALUE_STRING:\n            return deserializeFromString(p, ctxt);\n        case VALUE_NUMBER_INT:\n            return deserializeFromNumber(p, ctxt);\n        case VALUE_NUMBER_FLOAT:\n            return deserializeFromDouble(p, ctxt);\n        case VALUE_TRUE:\n        case VALUE_FALSE:\n            return deserializeFromBoolean(p, ctxt);\n        case VALUE_NULL:\n            return deserializeFromNull(p, ctxt);\n        case START_ARRAY:\n            return deserializeFromArray(p, ctxt);\n        case FIELD_NAME:\n        case END_OBJECT: // added to resolve [JACKSON-319], possible related issues\n            return deserializeFromObject(p, ctxt);\n        default:\n            return ctxt.handleUnexpectedToken(handledType(), p);\n        }\n    }"
    ],
    [
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        double sum = 0.0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        double sum = 0.0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n\n        double sum = 0.0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n\n        double sum = 0.0;\n\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        double sum = 0.0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        double sum = 0.0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n\n        double sum = 0.0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        double sum = 0.0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n\n        double sum = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n\n        double sum = 0.0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }"
    ],
    [
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         // Your code here\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        // Adding to the list\n        if (_head == null) {\n            _head = _tail = new LinkedNode<>(fullChunk);\n        } else {\n            _tail.next = new LinkedNode<>(fullChunk);\n            _tail = _tail.next;\n        }\n        _size += fullChunk.length;\n\n        // Checking if we need to expand\n        if (_size >= SMALL_CHUNK) {\n            return expandChunk();\n        }\n\n        return fullChunk;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        if (_head == null) {\n            _head = _tail = new LinkedNode<Object[]>(fullChunk);\n        } else {\n            _tail.next = new LinkedNode<Object[]>(fullChunk);\n            _tail = _tail.next;\n        }\n        _size += fullChunk.length;\n\n        if (_size > MAX_CHUNK) {\n            _reset();\n        }\n\n        if (_freeBuffer == null) {\n            return (_freeBuffer = new Object[SMALL_CHUNK]);\n        }\n        return _freeBuffer;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         // TODO: Implement this method\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        // Your code goes here\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         if (fullChunk == null || fullChunk.length == 0) {\n             throw new IllegalArgumentException(\"Null or empty chunk not allowed\");\n         }\n\n         // Check if the buffer needs to be expanded\n         if (_size + fullChunk.length > _tail.data.length) {\n             expandBuffer(fullChunk.length);\n         }\n\n         // Append the chunk to the buffer\n         System.arraycopy(fullChunk, 0, _tail.data, _size, fullChunk.length);\n         _size += fullChunk.length;\n\n         // Return a new chunk buffer for the caller to fill\n         return (_freeBuffer = new Object[Math.min(fullChunk.length, SMALL_CHUNK)]);\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         // TODO: Implement this method\n         return null;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        if (fullChunk == null) {\n            throw new IllegalArgumentException(\"Null chunk not allowed\");\n        }\n        if (_head == null) {\n            _head = _tail = new LinkedNode<>(fullChunk);\n        } else {\n            _tail.next = new LinkedNode<>(fullChunk);\n            _tail = _tail.next;\n        }\n        _size += fullChunk.length;\n        _freeBuffer = null;\n        return resetAndStart();\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        // Your code here\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        // TODO: Implement this method\n     }"
    ],
    [
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  throws IllegalArgumentException {\n        StringBuilder buf = new StringBuilder();\n        int[] indexRef = new int[1];\n\n        while (indexRef[0] < pattern.length()) {\n            String token = parseToken(pattern, indexRef);\n\n            if (token.length() == 0) {\n                throw new IllegalArgumentException(\"Invalid pattern: \" + pattern);\n            }\n\n            if (isNumericToken(token)) {\n                buf.append('%');\n            }\n            buf.append(token);\n        }\n\n        return DateTimeFormatter.ofPattern(buf.toString());\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  throws IllegalArgumentException {\n        StringBuilder buf = new StringBuilder();\n        int[] indexRef = new int[1];\n        String token;\n\n        while (indexRef[0] < pattern.length()) {\n            token = parseToken(pattern, indexRef);\n            if (token.length() > 0) {\n                if (isNumericToken(token)) {\n                    buf.append('%');\n                }\n                buf.append(token);\n            }\n        }\n\n        return DateTimeFormatter.ofPattern(buf.toString());\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n        StringBuilder buf = new StringBuilder();\n        int[] indexRef = new int[1];\n        String token;\n        boolean isNumeric;\n\n        while (indexRef[0] < pattern.length()) {\n            token = parseToken(pattern, indexRef);\n            isNumeric = isNumericToken(token);\n\n            if (isNumeric) {\n                buf.append(\"{\").append(token).append(\"}\");\n            } else {\n                buf.append(token);\n            }\n        }\n\n        return DateTimeFormatter.ofPattern(buf.toString());\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n        StringBuilder buf = new StringBuilder();\n        int[] indexRef = new int[1];\n        boolean isNumeric = false;\n        boolean isLiteral = false;\n        boolean isToken = false;\n        String token = \"\";\n\n        while (indexRef[0] < pattern.length()) {\n            token = parseToken(pattern, indexRef);\n            isNumeric = isNumericToken(token);\n            isLiteral = token.startsWith(\"'\") && token.endsWith(\"'\");\n            isToken = !isNumeric && !isLiteral;\n\n            if (isNumeric) {\n                buf.append(\"%\");\n                buf.append(token.charAt(0));\n            } else if (isLiteral) {\n                buf.append(token.substring(1, token.length()-1));\n            } else if (isToken) {\n                buf.append(\"%\");\n                buf.append(token);\n            } else {\n                throw new IllegalArgumentException(\"Invalid pattern: \" + pattern);\n            }\n        }\n\n        return DateTimeFormatter.ofPattern(buf.toString());\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n        StringBuilder buf = new StringBuilder();\n        int[] indexRef = new int[1];\n        String token;\n        boolean numericToken = false;\n\n        while (indexRef[0] < pattern.length()) {\n            token = parseToken(pattern, indexRef);\n            numericToken = isNumericToken(token);\n\n            if (numericToken) {\n                buf.append(\"{\");\n                buf.append(token);\n                buf.append(\"}\");\n            } else {\n                buf.append(token);\n            }\n        }\n\n        return DateTimeFormatter.ofPattern(buf.toString());\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  throws IllegalArgumentException {\n        StringBuilder buf = new StringBuilder();\n        int[] indexRef = new int[1];\n        String token;\n        boolean numericToken = false;\n\n        while (indexRef[0] < pattern.length()) {\n            token = parseToken(pattern, indexRef);\n            numericToken = isNumericToken(token);\n\n            if (numericToken) {\n                buf.append(\"{\");\n                buf.append(token);\n                buf.append(\"}\");\n            } else {\n                buf.append(token);\n            }\n        }\n\n        return DateTimeFormatter.ofPattern(buf.toString());\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  throws IllegalArgumentException {\n        StringBuilder buf = new StringBuilder();\n        int[] indexRef = new int[1];\n\n        while (indexRef[0] < pattern.length()) {\n            String token = parseToken(pattern, indexRef);\n            if (token.length() > 0) {\n                if (isNumericToken(token)) {\n                    buf.append('%');\n                }\n                buf.append(token);\n            }\n        }\n\n        try {\n            return DateTimeFormatter.ofPattern(buf.toString());\n        } catch (DateTimeParseException ex) {\n            throw new IllegalArgumentException(\"Invalid pattern: \" + pattern, ex);\n        }\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n        StringBuilder buf = new StringBuilder();\n        int[] indexRef = new int[1];\n        indexRef[0] = 0;\n        String token;\n        boolean isNumeric = false;\n        while (indexRef[0] < pattern.length()) {\n            token = parseToken(pattern, indexRef);\n            isNumeric = isNumericToken(token);\n            if (isNumeric) {\n                buf.append(\"{\");\n                buf.append(token);\n                buf.append(\"}\");\n            } else {\n                buf.append(token);\n            }\n        }\n        return DateTimeFormatter.ofPattern(buf.toString());\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  throws IllegalArgumentException {\n        StringBuilder buf = new StringBuilder();\n        int[] indexRef = new int[1];\n\n        while (indexRef[0] < pattern.length()) {\n            String token = parseToken(pattern, indexRef);\n\n            if (token.length() > 0) {\n                if (isNumericToken(token)) {\n                    buf.append('%');\n                }\n                buf.append(token);\n            }\n        }\n\n        return DateTimeFormatter.ofPattern(buf.toString());\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n        StringBuilder buf = new StringBuilder();\n        int[] indexRef = new int[1];\n        String token;\n        boolean isNumeric;\n\n        while (indexRef[0] < pattern.length()) {\n            token = parseToken(pattern, indexRef);\n            isNumeric = isNumericToken(token);\n\n            if (isNumeric) {\n                buf.append(\"{\").append(token).append(\"}\");\n            } else {\n                buf.append(token);\n            }\n        }\n\n        return DateTimeFormatter.ofPattern(buf.toString());\n    }"
    ],
    [
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    switch (token.type) {\n      case JsDocToken.ASTERISK:\n        return newNode(Token.ANY);\n      case JsDocToken.NULL:\n        return newNode(Token.NULL);\n      case JsDocToken.UNDEFINED:\n        return newNode(Token.UNDEFINED);\n      case JsDocToken.IDENTIFIER:\n        return parseTypeName(token);\n      case JsDocToken.LB:\n        return parseFunctionType(token);\n      case JsDocToken.PIPE:\n        return parseUnionType(token);\n      case JsDocToken.LC:\n        return parseRecordType(token);\n      case JsDocToken.LBRACKET:\n        return parseArrayType(token);\n      default:\n        return null;\n    }\n  }",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    switch (token.getType()) {\n      case ASTERISK:\n        return newNode(Token.ANY);\n      case NULL:\n        return newNode(Token.NULL);\n      case UNDEFINED:\n        return newNode(Token.UNDEFINED);\n      case IDENTIFIER:\n        return parseTypeName(token);\n      case FUNCTION:\n        return parseFunctionType(token);\n      case UNION:\n        return parseUnionType(token);\n      case RECORD:\n        return parseRecordType(token);\n      case ARRAY:\n        return parseArrayType(token);\n      default:\n        return null;\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    switch (token.getType()) \n    {\n        case ASTERISK:\n            return newNode(Token.ASTERISK);\n        case NULL:\n            return newNode(Token.NULL);\n        case UNDEFINED:\n            return newNode(Token.UNDEFINED);\n        case IDENTIFIER:\n            return parseTypeName(token);\n        case LB:\n            return parseFunctionType(token);\n        case OR:\n            return parseUnionType(token);\n        case LT:\n            return parseRecordType(token);\n        case LS:\n            return parseArrayType(token);\n        default:\n            return null;\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    switch (token) \n    {\n        case JsDocToken.ASTERISK:\n            return newNode(Token.ASTERISK);\n        case JsDocToken.NULL:\n            return newNode(Token.NULL);\n        case JsDocToken.UNDEFINED:\n            return newNode(Token.UNDEFINED);\n        case JsDocToken.IDENTIFIER:\n            return parseTypeName(token);\n        case JsDocToken.LB:\n            return parseFunctionType(token);\n        case JsDocToken.PIPE:\n            return parseUnionType(token);\n        case JsDocToken.LC:\n            return parseRecordType(token);\n        case JsDocToken.LBRACKET:\n            return parseArrayType(token);\n        default:\n            return null;\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    switch (token.type) \n    {\n        case ASTERISK:\n            return newNode(Token.ASTERISK);\n        case NULL:\n            return newNode(Token.NULL);\n        case UNDEFINED:\n            return newNode(Token.UNDEFINED);\n        case IDENTIFIER:\n            return parseTypeName(token);\n        case LB:\n            return parseFunctionType(token);\n        case OR:\n            return parseUnionType(token);\n        case LT:\n            return parseRecordType(token);\n        case LS:\n            return parseArrayType(token);\n        default:\n            return null;\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    switch (token) \n    {\n        case ASTERISK:\n            return newNode(Token.ASTERISK);\n        case NULL:\n            return newNode(Token.NULL);\n        case UNDEFINED:\n            return newNode(Token.UNDEFINED);\n        default:\n            if (isTypeName(token)) \n            {\n                return parseTypeName(token);\n            } \n            else if (token == JsDocToken.LB) \n            {\n                return parseFunctionType(token);\n            } \n            else if (token == JsDocToken.PIPE) \n            {\n                return parseUnionType(token);\n            } \n            else if (token == JsDocToken.LC) \n            {\n                return parseRecordType(token);\n            } \n            else if (token == JsDocToken.LBRACKET) \n            {\n                return parseArrayType(token);\n            } \n            else \n            {\n                return null;\n            }\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    switch (token.getType()) {\n      case ASTERISK:\n        return newNode(Token.ANY);\n      case NULL:\n        return newNode(Token.NULL);\n      case UNDEFINED:\n        return newNode(Token.UNDEFINED);\n      case IDENTIFIER:\n        return parseTypeName(token);\n      case FUNCTION:\n        return parseFunctionType(token);\n      case UNION:\n        return parseUnionType(token);\n      case RECORD:\n        return parseRecordType(token);\n      case ARRAY:\n        return parseArrayType(token);\n      default:\n        return null;\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    switch (token.getType()) \n    {\n        case JsDocToken.ASTERISK:\n            return newNode(Token.ANY);\n        case JsDocToken.NULL:\n            return newNode(Token.NULL);\n        case JsDocToken.UNDEFINED:\n            return newNode(Token.UNDEFINED);\n        case JsDocToken.IDENTIFIER:\n            return parseTypeName(token);\n        case JsDocToken.LB:\n            return parseFunctionType(token);\n        case JsDocToken.OR:\n            return parseUnionType(token);\n        case JsDocToken.LC:\n            return parseRecordType(token);\n        case JsDocToken.LBRACKET:\n            return parseArrayType(token);\n        default:\n            return null;\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    switch (token.getType()) \n    {\n        case ASTERISK:\n            return newNode(Token.ANY);\n        case NULL:\n            return newNode(Token.NULL);\n        case UNDEFINED:\n            return newNode(Token.UNDEFINED);\n        case IDENTIFIER:\n            return parseTypeName(token);\n        case LB:\n            return parseFunctionType(token);\n        case OR:\n            return parseUnionType(token);\n        case RECORD:\n            return parseRecordType(token);\n        case LSQUARE:\n            return parseArrayType(token);\n        default:\n            return null;\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    switch (token.getType()) {\n      case JsDocToken.ASTERISK:\n        return newNode(Token.ANY);\n      case JsDocToken.NULL:\n        return newNode(Token.NULL);\n      case JsDocToken.UNDEFINED:\n        return newNode(Token.UNDEFINED);\n      case JsDocToken.IDENTIFIER:\n        return parseTypeName(token);\n      case JsDocToken.LB:\n        return parseFunctionType(token);\n      case JsDocToken.PIPE:\n        return parseUnionType(token);\n      case JsDocToken.LC:\n        return parseRecordType(token);\n      case JsDocToken.LBRACKET:\n        return parseArrayType(token);\n      default:\n        return null;\n    }\n  }"
    ],
    [
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new IllegalArgumentException(\"Name is null\");\n    }\n    writeDeferredName();\n    writeString(name);\n    out.write(':');\n    deferredName = null;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new IllegalArgumentException(\"Name must not be null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n    beforeValue();\n    out.write(name);\n    out.write(':');\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    writeDeferredName();\n    if (name == null) {\n      throw new IllegalArgumentException(\"Name is null\");\n    }\n    out.write(\"\\\"\" + name + \"\\\":\");\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    writeDeferredName();\n    if (name == null) {\n      throw new IllegalArgumentException(\"Name is null\");\n    }\n    out.write(\"\\\"\" + escape(name) + \"\\\":\");\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    writeDeferredName();\n    if (name == null) {\n      throw new IllegalArgumentException(\"Name is null\");\n    }\n    out.write(\"\\\"\" + name + \"\\\":\");\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    writeDeferredName();\n    if (name == null) {\n      throw new IllegalArgumentException(\"Name must not be null\");\n    }\n    out.write(\"\\\"\" + escape(name) + \"\\\":\");\n    deferredName = null;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    writeDeferredName();\n    if (name == null) {\n      throw new IllegalArgumentException(\"Name may not be null.\");\n    }\n    if (name.isEmpty()) {\n      throw new IllegalArgumentException(\"Name may not be empty.\");\n    }\n    out.write(\"\\\"\" + name + \"\\\":\");\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    writeDeferredName();\n    if (name == null) {\n      throw new IllegalArgumentException(\"Name is null\");\n    }\n    out.write(\"\\\"\" + name + \"\\\":\");\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    writeDeferredName();\n    if (name == null) {\n      throw new IllegalArgumentException(\"Name may not be null.\");\n    }\n    out.write(\"\\\"\" + escape(name) + \"\\\":\");\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    writeDeferredName();\n    if (name == null) {\n      throw new IllegalArgumentException(\"Name may not be null.\");\n    }\n    out.write(\"\\\"\" + escape(name) + \"\\\":\");\n    deferredName = null;\n    return this;\n  }"
    ],
    [
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    double minimum = Double.MAX_VALUE;\n    double maximum = -Double.MAX_VALUE;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double positive = 0.0;\n        double negative = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    positive += value;\n                }\n                if (value < 0.0) {\n                    negative += value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, negative);\n        maximum = Math.max(maximum, positive);\n    }\n    if (minimum <= maximum) {\n        return new Range(minimum, maximum);\n    }\n    return null;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    double minValue = Double.POSITIVE_INFINITY;\n    int seriesCount = dataset.getRowCount();\n    int categoryCount = dataset.getColumnCount();\n\n    for (int item = 0; item < categoryCount; item++) {\n        double sum = 0.0;\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                sum += number.doubleValue();\n            }\n        }\n        if (sum < minValue) {\n            minValue = sum;\n        }\n    }\n\n    return minValue;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n        if (dataset == null) \n        {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n\n        double minValue = Double.POSITIVE_INFINITY;\n        int seriesCount = dataset.getRowCount();\n        int categoryCount = dataset.getColumnCount();\n\n        for (int item = 0; item < categoryCount; item++) \n        {\n            double sum = 0.0;\n            for (int series = 0; series < seriesCount; series++) \n            {\n                Number number = dataset.getValue(series, item);\n                if (number != null) \n                {\n                    sum += number.doubleValue();\n                }\n            }\n            if (sum < minValue) \n            {\n                minValue = sum;\n            }\n        }\n\n        return minValue;\n    }",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n\n        boolean hasValidData = false;\n        double result = Double.NaN;\n\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double positive = 0.0;\n            double negative = 0.0;\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        positive = positive + value;\n                    }\n                    if (value < 0.0) {\n                        negative = negative + value;\n                    }\n                }\n            }\n            if (negative < result || !Double.isFinite(result)) {\n                result = negative;\n            }\n        }\n        if (hasValidData) {\n            return new Double(result);\n        }\n        return null;\n    }",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n        if (dataset == null) \n        {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n\n        boolean hasValidData = false;\n        double minimum = Double.POSITIVE_INFINITY;\n        int seriesCount = dataset.getRowCount();\n        int categoryCount = dataset.getColumnCount();\n\n        for (int item = 0; item < categoryCount; item++) \n        {\n            double positive = 0.0;\n            double negative = 0.0;\n            for (int series = 0; series < seriesCount; series++) \n            {\n                Number number = dataset.getValue(series, item);\n                if (number != null) \n                {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value > 0.0) \n                    {\n                        positive += value;\n                    }\n                    if (value < 0.0) \n                    {\n                        negative += value;\n                    }\n                }\n            }\n            minimum = Math.min(minimum, negative);\n        }\n\n        return hasValidData ? minimum : null;\n    }",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    double minValue = Double.POSITIVE_INFINITY;\n    int seriesCount = dataset.getRowCount();\n    int categoryCount = dataset.getColumnCount();\n\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double sum = 0;\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                sum += number.doubleValue();\n            }\n        }\n        if (sum < minValue) \n        {\n            minValue = sum;\n        }\n    }\n\n    return minValue;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    double minimum = Double.POSITIVE_INFINITY;\n    int seriesCount = dataset.getRowCount();\n    for (int series = 0; series < seriesCount; series++) {\n        for (int item = 0; item < dataset.getColumnCount(); item++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                double value = number.doubleValue();\n                if (value < minimum) {\n                    minimum = value;\n                }\n            }\n        }\n    }\n    return minimum;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n        if (dataset == null) \n        {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        \n        double minimum = Double.MAX_VALUE;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            for (int item = 0; item < dataset.getColumnCount(); item++) \n            {\n                Number number = dataset.getValue(series, item);\n                if (number != null) \n                {\n                    double value = number.doubleValue();\n                    if (value < minimum) \n                    {\n                        minimum = value;\n                    }\n                }\n            }\n        }\n        return minimum;\n    }",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    double minimum = Double.POSITIVE_INFINITY;\n    int seriesCount = dataset.getRowCount();\n    for (int series = 0; series < seriesCount; series++) {\n        Number number = dataset.getValue(series, 0);\n        if (number != null) {\n            double value = number.doubleValue();\n            if (value < minimum) {\n                minimum = value;\n            }\n        }\n    }\n    return minimum;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n\n        double minValue = Double.POSITIVE_INFINITY;\n        int seriesCount = dataset.getRowCount();\n        int categoryCount = dataset.getColumnCount();\n\n        for (int series = 0; series < seriesCount; series++) {\n            for (int category = 0; category < categoryCount; category++) {\n                Number value = dataset.getValue(series, category);\n                if (value != null) {\n                    double doubleValue = value.doubleValue();\n                    if (doubleValue < minValue) {\n                        minValue = doubleValue;\n                    }\n                }\n            }\n        }\n\n        return minValue;\n    }"
    ],
    [
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        try {\n            final boolean[] primitive = ArrayUtils.toPrimitive(array);\n            return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n        } catch (final NullPointerException ex) {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n    }",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        try {\n            final boolean[] primitive = ArrayUtils.toPrimitive(array);\n            return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n        } catch (final NullPointerException ex) {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n    }"
    ],
    [
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n\n    final StringBuilder sb = new StringBuilder();\n    boolean whitespace = true;\n    for (int i = 0; i < str.length(); i++) {\n        final char ch = str.charAt(i);\n        if (Character.isLetter(ch)) {\n            if (whitespace) {\n                sb.append(Character.toUpperCase(ch));\n            }\n            whitespace = false;\n        } else {\n            whitespace = true;\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.length() == 0) {\n        return \"\";\n    }\n    if (delimiters == null || delimiters.length == 0) {\n        return String.valueOf(str.charAt(0));\n    }\n\n    final StringBuilder sb = new StringBuilder();\n    final char[] chars = str.toCharArray();\n    boolean inWord = false;\n    for (char aChar : chars) {\n        if (isDelimiter(aChar, delimiters)) {\n            inWord = false;\n        } else if (!inWord) {\n            sb.append(aChar);\n            inWord = true;\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) \n    {\n        return str;\n    }\n\n    final StringBuilder sb = new StringBuilder();\n    final char[] chars = str.toCharArray();\n    boolean whitespace = true;\n\n    for (char ch : chars) \n    {\n        if (Character.isLetter(ch)) \n        {\n            if (whitespace) \n            {\n                sb.append(Character.toUpperCase(ch));\n                whitespace = false;\n            }\n        } \n        else \n        {\n            whitespace = true;\n        }\n    }\n\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    final StringBuilder sb = new StringBuilder(buffer.length);\n\n    boolean whitespace = true;\n\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (Character.isLetter(ch)) \n        {\n            if (whitespace) \n            {\n                sb.append(Character.toUpperCase(ch));\n            }\n            whitespace = false;\n        } \n        else \n        {\n            whitespace = true;\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) \n    {\n        return str;\n    }\n\n    final char[] buffer = str.toCharArray();\n    final boolean whitespace = (delimiters == null || delimiters.length == 0);\n    final boolean[] isDelimiter = (delimiters != null && delimiters.length > 0)\n        ? new boolean[Character.MAX_VALUE + 1] : null;\n\n    if (isDelimiter != null) \n    {\n        for (char ch : delimiters) \n        {\n            isDelimiter[ch] = true;\n        }\n    }\n\n    final StringBuilder sb = new StringBuilder(buffer.length);\n    char prevChar = 0;\n    for (char ch : buffer) \n    {\n        if (isDelimiter != null && isDelimiter[ch]) \n        {\n            prevChar = 0;\n        } \n        else if (whitespace && Character.isWhitespace(ch)) \n        {\n            prevChar = 0;\n        } \n        else if (prevChar == 0) \n        {\n            sb.append(Character.toUpperCase(ch));\n            prevChar = ch;\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters == null) {\n        return initials(str);\n    }\n    final StringBuilder sb = new StringBuilder();\n    final StringTokenizer st = new StringTokenizer(str, new String(delimiters));\n    while (st.hasMoreTokens()) {\n        final String token = st.nextToken();\n        if (!token.isEmpty()) {\n            sb.append(token.charAt(0));\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.length() == 0) {\n        return \"\";\n    }\n    if (delimiters == null || delimiters.length == 0) {\n        return String.valueOf(str.charAt(0));\n    }\n    final StringBuilder sb = new StringBuilder(str.length());\n    char[] chars = str.toCharArray();\n    boolean lastDelimiter = true;\n    for (char ch : chars) {\n        if (isDelimiter(ch, delimiters)) {\n            lastDelimiter = true;\n        } else if (lastDelimiter) {\n            sb.append(Character.toUpperCase(ch));\n            lastDelimiter = false;\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) \n    {\n        return str;\n    }\n\n    final char[] buffer = str.toCharArray();\n    final boolean isWhitespace = (delimiters == null || delimiters.length == 0);\n    final StringBuilder sb = new StringBuilder();\n\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isWhitespace && Character.isWhitespace(ch)) \n        {\n            continue;\n        }\n        if (!isWhitespace && ArrayUtils.contains(delimiters, ch)) \n        {\n            continue;\n        }\n        if (Character.isLetter(ch)) \n        {\n            sb.append(Character.toUpperCase(ch));\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n\n    final int len = str.length();\n    if (len == 0) {\n        return \"\";\n    }\n\n    final StringBuilder sb = new StringBuilder(len);\n    char[] cs = str.toCharArray();\n    boolean whitespace = true;\n    for (int i = 0; i < len; i++) \n    {\n        char c = cs[i];\n        if (Character.isLetter(c)) \n        {\n            if (whitespace) \n            {\n                sb.append(Character.toUpperCase(c));\n                whitespace = false;\n            }\n        } \n        else \n        {\n            whitespace = true;\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    final boolean whitespace = (delimiters == null || delimiters.length == 0);\n    final boolean[] isDelimiter = (delimiters != null)\n            ? new boolean[Character.MAX_VALUE + 1] : null;\n\n    if (isDelimiter != null) {\n        for (final char delimiter : delimiters) {\n            isDelimiter[delimiter] = true;\n        }\n    }\n\n    StringBuilder sb = new StringBuilder(buffer.length);\n\n    boolean lastDelimiter = true;\n    for (final char ch : buffer) {\n        if (isDelimiter != null && isDelimiter[ch]) {\n            lastDelimiter = true;\n        } else if (Character.isLetter(ch) && lastDelimiter) {\n            sb.append(Character.toUpperCase(ch));\n            lastDelimiter = false;\n        } else if (whitespace && Character.isWhitespace(ch)) {\n            lastDelimiter = true;\n        }\n    }\n    return sb.toString();\n}"
    ],
    [
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0.0;\n    for (int i = 0; i < data.getRowCount(); i++) \n    {\n        total += data.getValue(i, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0.0;\n    for (int i = 0; i < data.getRowCount(); i++) \n    {\n        total += data.getValue(i, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0.0;\n    for (int i = 0; i < data.getRowCount(); i++) \n    {\n        total += data.getValue(i, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0.0;\n    for (int i = 0; i < data.getRowCount(); i++) \n    {\n        total += data.getValue(i, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0.0;\n    for (int i = 0; i < data.getRowCount(); i++) \n    {\n        total += data.getValue(i, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0.0;\n    for (int i = 0; i < data.getRowCount(); i++) \n    {\n        total += data.getValue(i, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0;\n    for (int i = 0; i < data.getRowCount(); i++) \n    {\n        total += data.getValue(i, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0.0;\n    for (int i = 0; i < data.getRowCount(); i++) \n    {\n        total += data.getValue(i, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0;\n    for (int i = 0; i < data.getRowCount(); i++) \n    {\n        total += data.getValue(i, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0;\n    for (int row = 0; row < data.getRowCount(); row++) \n    {\n        total += data.getValue(row, column);\n    }\n    return total;\n}"
    ],
    [
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n        Insets insets = getInsets();\n        double x = (screenPoint.getX() - insets.left) / this.scaleX;\n        double y = (screenPoint.getY() - insets.top) / this.scaleY;\n        return new Point2D.Double(x, y);\n    }",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null screenPoint argument\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}"
    ],
    [
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        // TODO: Implement this method\n        throw new UnsupportedOperationException(\"Not implemented yet.\");\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        // TODO: Implement this method\n        throw new UnsupportedOperationException();\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        try {\n            final String[] parts = source.split(\" / \");\n            final BigInteger numerator = getNumeratorFormat().parse(parts[0]).toBigInteger();\n            final BigInteger denominator = getDenominatorFormat().parse(parts[1]).toBigInteger();\n            return new BigFraction(numerator, denominator);\n        } catch (final ArrayIndexOutOfBoundsException e) {\n            throw new MathParseException(LocalizedFormats.CANNOT_PARSE_FRACTION, source);\n        } catch (final NumberFormatException e) {\n            throw new MathParseException(LocalizedFormats.CANNOT_PARSE_FRACTION, source);\n        }\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        try {\n            String[] parts = source.split(\" / \");\n            if (parts.length != 2) {\n                throw new MathParseException(LocalizedFormats.CANNOT_PARSE_FRACTION, source);\n            }\n            BigInteger numerator = getNumeratorFormat().parse(parts[0]).toBigInteger();\n            BigInteger denominator = getDenominatorFormat().parse(parts[1]).toBigInteger();\n            return new BigFraction(numerator, denominator);\n        } catch (NumberFormatException e) {\n            throw new MathParseException(LocalizedFormats.CANNOT_PARSE_FRACTION, source, e);\n        }\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        // TODO: Implement this method\n        throw new UnsupportedOperationException(\"Not implemented yet\");\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        try {\n            final String[] parts = source.split(\" / \");\n            if (parts.length != 2) {\n                throw new MathParseException(LocalizedFormats.INVALID_FORMAT, source);\n            }\n            final BigInteger numerator = getNumeratorFormat().parse(parts[0]).toBigInteger();\n            final BigInteger denominator = getDenominatorFormat().parse(parts[1]).toBigInteger();\n            return new BigFraction(numerator, denominator);\n        } catch (final NumberFormatException e) {\n            throw new MathParseException(LocalizedFormats.CANNOT_PARSE, source, e);\n        }\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        try {\n            final String[] parts = source.split(\" / \");\n            if (parts.length != 2) {\n                throw new MathParseException(LocalizedFormats.FRACTION_PARSE_ERROR, source);\n            }\n            return new BigFraction(getNumeratorFormat().parse(parts[0]).toBigIntegerExact(),\n                                   getDenominatorFormat().parse(parts[1]).toBigIntegerExact());\n        } catch (final NumberFormatException e) {\n            throw new MathParseException(LocalizedFormats.FRACTION_PARSE_ERROR, source, e);\n        }\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        // Implement the parse method here\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        // Implement the parse method here\n        throw new UnsupportedOperationException(\"Not implemented yet\");\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        // TODO: Implement this method\n        throw new UnsupportedOperationException();\n    }"
    ],
    [
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    Set<E> set = new HashSet<>(list);\n    return new ListOrderedSet<E>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    Set<E> set = new HashSet<E>(list);\n    return new ListOrderedSet<E>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    Set<E> set = new HashSet<E>(list);\n    return new ListOrderedSet<E>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<E>(list);\n    return new ListOrderedSet<E>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    Set<E> set = new HashSet<>(list);\n    return new ListOrderedSet<>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    Set<E> set = new HashSet<>(list);\n    return new ListOrderedSet<E>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<E>(list);\n    return new ListOrderedSet<E>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<E>(list);\n    return new ListOrderedSet<E>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    Set<E> set = new HashSet<>(list);\n    return new ListOrderedSet<E>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    Set<E> set = new HashSet<>(list);\n    list.clear();\n    list.addAll(set);\n    return new ListOrderedSet<E>(set, list);\n}"
    ],
    [
      "public Range getDataRange(ValueAxis axis)  {\n    Range range = null;\n    for (int i = 0; i < this.subplots.size(); i++) \n    {\n        CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n        Range subplotRange = plot.getDataRange(axis);\n        if (range == null) \n        {\n            range = subplotRange;\n        } \n        else \n        {\n            range = range.union(subplotRange);\n        }\n    }\n    return range;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n\n    Range result = null;\n\n    Iterator iterator = this.subplots.iterator();\n    while (iterator.hasNext()) {\n        CategoryPlot plot = (CategoryPlot) iterator.next();\n        Range temp = plot.getDataRange(axis);\n        if (temp != null) {\n            if (result == null) {\n                result = temp;\n            } else {\n                result.include(temp);\n            }\n        }\n    }\n\n    return result;\n\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    for (int i = 0; i < this.subplots.size(); i++) \n    {\n        CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n        Range range = plot.getDataRange(axis);\n        if (range != null) \n        {\n            if (result == null) \n            {\n                result = range;\n            } \n            else \n            {\n                result = result.union(range);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n\n        Range range = null;\n        for (int i = 0; i < this.subplots.size(); i++) {\n            CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n            Range subplotRange = plot.getDataRange(axis);\n            if (range == null) {\n                range = subplotRange;\n            } else {\n                range = range.union(subplotRange);\n            }\n        }\n        return range;\n    }",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis == null) {\n        throw new IllegalArgumentException(\"Null 'axis' argument.\");\n    }\n\n    Range result = null;\n    Iterator iterator = this.subplots.iterator();\n    while (iterator.hasNext()) {\n        CategoryPlot plot = (CategoryPlot) iterator.next();\n        Range range = plot.getDataRange(axis);\n        if (range != null) {\n            if (result == null) {\n                result = range;\n            } else {\n                result.expandToInclude(range);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis == null) {\n        throw new IllegalArgumentException(\"Null 'axis' argument.\");\n    }\n\n    if (this.subplots.isEmpty()) {\n        return null;\n    }\n\n    Range result = null;\n    Iterator iterator = this.subplots.iterator();\n    while (iterator.hasNext()) {\n        CategoryPlot plot = (CategoryPlot) iterator.next();\n        Range range = plot.getDataRange(axis);\n        if (range != null) {\n            if (result == null) {\n                result = range;\n            } else {\n                result.expandToInclude(range);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis != getRangeAxis()) {\n        throw new IllegalArgumentException(\"Axis is not the range axis.\");\n    }\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    boolean first = true;\n    for (int i = 0; i < this.subplots.size(); i++) {\n        CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n        NumberRange range = plot.getRange(axis);\n        if (range != null) {\n            if (first) {\n                min = range.getLowerBound();\n                max = range.getUpperBound();\n                first = false;\n            } else {\n                min = Math.min(min, range.getLowerBound());\n                max = Math.max(max, range.getUpperBound());\n            }\n        }\n    }\n    if (first) {\n        return null;\n    } else {\n        return new NumberRange(min, max);\n    }\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis == null) {\n        throw new IllegalArgumentException(\"Null 'axis' argument.\");\n    }\n\n    Range result = null;\n\n    if (this.subplots.size() > 0) {\n        CategoryPlot plot = (CategoryPlot) this.subplots.get(0);\n        result = plot.getDataRange(axis);\n    }\n\n    for (int i = 1; i < this.subplots.size(); i++) {\n        CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n        Range temp = plot.getDataRange(axis);\n        if (temp != null) {\n            if (result == null) {\n                result = temp;\n            } else {\n                result = result.union(temp);\n            }\n        }\n    }\n\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n\n        Range range = null;\n\n        if (axis == getRangeAxis()) {\n            Iterator iterator = this.subplots.iterator();\n            while (iterator.hasNext()) {\n                CategoryPlot plot = (CategoryPlot) iterator.next();\n                Range subplotRange = plot.getDataRange(axis);\n                if (range == null) {\n                    range = subplotRange;\n                } else {\n                    range = range.union(subplotRange);\n                }\n            }\n        }\n\n        return range;\n\n    }",
      "public Range getDataRange(ValueAxis axis)  {\n\n        Range range = null;\n\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range subplotRange = plot.getDataRange(axis);\n            if (range == null) {\n                range = subplotRange;\n            } else {\n                range = range.union(subplotRange);\n            }\n        }\n\n        return range;\n    }"
    ],
    [
      "public double adjustedLog10(double val)  {\n    double result = 0;\n    if (val < 0) \n    {\n        result = Math.log(-val);\n    } \n    else if (val < 10) \n    {\n        result = Math.log(val) / LOG10_VALUE;\n        result += (val - 1) / 9;\n    } \n    else \n    {\n        result = Math.log10(val);\n    }\n    return result;\n}",
      "public double adjustedLog10(double val)  {\n    if (val < 0) \n    {\n        val = -val;\n    }\n    else if (val < 10) \n    {\n        val = 10 * (val - 1);\n    }\n    return Math.log10(val);\n}",
      "public double adjustedLog10(double val)  {\n    if (val < 0) \n    {\n        val = -val;\n    }\n    if (val < 10.0) \n    {\n        val = 1.0 + (val - 1.0) * (1.0 - 0.0) / (10.0 - 1.0);\n    }\n    return Math.log10(val);\n}",
      "public double adjustedLog10(double val)  {\n    double adjustedVal;\n    if (val < 0) \n    {\n        val = -val;\n        adjustedVal = Math.log10(val) - 1;\n    } \n    else if (val < 10) \n    {\n        adjustedVal = Math.log10(val) + 1;\n    } \n    else \n    {\n        adjustedVal = Math.log10(val);\n    }\n    return adjustedVal;\n}",
      "public double adjustedLog10(double val)  {\n    double adjustedVal = val;\n    if (val < 0) {\n        adjustedVal = -val;\n    }\n    if (val < 10 && val > 0) {\n        adjustedVal = val + (10 - val) * (val - 1);\n    }\n    return Math.log10(adjustedVal);\n}",
      "public double adjustedLog10(double val)  {\n    double result;\n    if (val < 0.0) \n    {\n        result = -Math.log(-val);\n    } \n    else if (val < 10.0) \n    {\n        result = Math.log(val) / LOG10_VALUE;\n        result -= (val - 1.0) / 9.0;\n    } \n    else \n    {\n        result = Math.log(val) / LOG10_VALUE;\n    }\n    return result;\n}",
      "public double adjustedLog10(double val)  {\n    double adjustedVal;\n    if (val < 0) {\n        val = -val;\n        adjustedVal = Math.log10(val);\n        return -adjustedVal;\n    } else if (val < 10) {\n        adjustedVal = Math.log10(val) + Math.log10(1 + 9.0 / val);\n        return adjustedVal;\n    } else {\n        return Math.log10(val);\n    }\n}",
      "public double adjustedLog10(double val)  {\n    if (val < 0.0) {\n        val = -val;\n    }\n    if (val < 10.0) {\n        val += (10.0 - val) * (val / 10.0);\n    }\n    return -Math.log10(val);\n}",
      "public double adjustedLog10(double val)  {\n    double adjustedVal;\n\n    // If value is negative, change it to positive and negate the result\n    if (val < 0) \n    {\n        adjustedVal = Math.log(-val);\n        return -adjustedVal;\n    }\n\n    // If value is less than 10, add a scaling factor\n    if (val < 10) \n    {\n        adjustedVal = Math.log(10 * val) / LOG10_VALUE;\n        return adjustedVal;\n    }\n\n    // Otherwise, just calculate the log10\n    return Math.log10(val);\n}",
      "public double adjustedLog10(double val)  {\n    if (val < 0) {\n        val = -val;\n    }\n    if (val < 10) {\n        val = val + (10 - val) * (val - 1);\n    }\n    return Math.log10(val);\n}"
    ],
    [
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    Node implicitReturn = cfg.getImplicitReturn();\n    for (Node node : cfg.getNodes()) \n    {\n        if (!node.isReturn() && !cfg.getOutgoingEdges(node).isEmpty()) \n        {\n            for (DiGraphEdge<Node, ControlFlowGraph.Branch> edge : cfg.getOutgoingEdges(node)) \n            {\n                if (edge.getValue() == ControlFlowGraph.Branch.ON_EX) \n                {\n                    continue;\n                }\n                Node nextNode = edge.getTarget().getValue();\n                if (nextNode != implicitReturn && !nextNode.isReturn()) \n                {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    Node returnNode = cfg.getImplicitReturn();\n    for (Node start : cfg.getEntry()) \n    {\n        if (!NodeTraversal.traverse(start, cfg, IS_RETURN, \n            GOES_THROUGH_TRUE_CONDITION_PREDICATE)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    Node returnNode = cfg.getImplicitReturn();\n    for (Node start : cfg.getNodes()) {\n        if (!NodeUtil.isReturn(start)) {\n            if (!NodeUtil.isCall(start)) {\n                continue;\n            }\n            Node call = start;\n            while (call != null) {\n                Node next = call.getNext();\n                if (next != null && NodeUtil.isReturn(next)) {\n                    return true;\n                }\n                call = next;\n            }\n        }\n    }\n    return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    for (Node node : cfg.getNodes()) \n    {\n        if (node.isReturn()) \n        {\n            continue;\n        }\n        if (!cfg.hasOutgoingEdge(node)) \n        {\n            return false;\n        }\n        for (DiGraphEdge<Node, ControlFlowGraph.Branch> edge : cfg.outgoingEdges(node)) \n        {\n            if (!IS_RETURN.apply(edge.getValue().getTarget())) \n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    for (Node node : cfg.getNodes()) \n    {\n        if (!NodeUtil.isReturn(node)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    // TODO: Implement this method.\n    return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    Node returnNode = cfg.getImplicitReturn();\n    for (Node n : cfg.getNodes()) \n    {\n        if (!n.isReturn()) \n        {\n            if (!cfg.getOutgoingEdges(n).isEmpty()) \n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    Node implicitReturn = cfg.getImplicitReturn();\n    for (Node n : cfg.getNodes()) {\n        if (!NodeUtil.isReturn(n) && !cfg.getOutgoingEdges(n).contains(implicitReturn)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    Node returnNode = cfg.getImplicitReturn();\n    for (Node n : cfg.getNodes()) \n    {\n        if (!n.isReturn()) \n        {\n            for (DiGraphEdge<Node, ControlFlowGraph.Branch> edge : cfg.outgoingEdges(n)) \n            {\n                if (edge.getValue() == ControlFlowGraph.Branch.ON_EX) \n                {\n                    continue;\n                }\n                Node target = edge.getTarget();\n                if (target == returnNode) \n                {\n                    return false;\n                }\n                if (!fastAllPathsReturnCheck(target)) \n                {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    // TODO: Implement this method.\n    return false;\n  }"
    ],
    [
      "protected static Dfp[] logInternal(final Dfp a[])  {\n\n    Dfp[] spx = a;\n    Dfp[] spz = new Dfp[2];\n\n    spz[0] = spx[0].subtract(spx[1]);\n    spz[1] = spx[1].subtract(spx[0]);\n\n    spx[0] = spx[0].multiply(spx[0]);\n    spx[1] = spx[1].multiply(spx[1]);\n\n    spz[0] = spz[0].add(spx[0]);\n    spz[1] = spz[1].add(spx[1]);\n\n    spz[0] = spz[0].add(spx[1]);\n    spz[1] = spz[1].add(spx[0]);\n\n    spz[0] = spz[0].divide(spz[1]);\n    spz[1] = spz[1].divide(spz[1]);\n\n    return spz;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    // TODO: Implement the method\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] spx = a;\n    Dfp[] spz = new Dfp[2];\n\n    spz[0] = spx[0].subtract(spx[1]);\n    spz[1] = spx[0].add(spx[1]);\n\n    spx[0] = spz[0].divide(2);\n    spx[1] = spz[1].divide(2);\n\n    return spz;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] spx = new Dfp[2];\n    spx[0] = a[0];\n    spx[1] = a[1];\n\n    Dfp[] spz = new Dfp[2];\n    spz[0] = a.getZero();\n    spz[1] = a.getZero();\n\n    Dfp x = spx[0];\n    Dfp y = spx[1];\n\n    Dfp lr = x.log10K();\n\n    x = x.divide(pow(a.newInstance(10000), lr));  /* This puts x in the range 0-10000 */\n    int ix = x.floor().intValue();\n\n    int p2 = 0;\n    while (ix > 2) {\n        ix >>= 1;\n        p2++;\n    }\n\n    Dfp[] sp = split(x);\n    spx[0] = sp[0];\n    spx[1] = sp[1];\n\n    Dfp two = a.getTwo();\n    Dfp[] spy = new Dfp[2];\n    spy[0] = pow(two, p2);          // use spy[0] temporarily as a divisor\n    spx[0] = spx[0].divide(spy[0]);\n    spx[1] = spx[1].divide(spy[0]);\n\n    Dfp onePointThree = a.newInstance(\"1.33333\");    // Use spy[0] for comparison\n    while (spx[0].add(spx[1]).greaterThan(onePointThree)) {\n        spx[0] = spx[0].divide(two);\n        spx[1] = spx[1].divide(two);\n        p2++;\n    }\n\n    // X is now in the range of 2/3 < x < 4/3\n    sp = logInternal(spx);\n\n    spz[0] = spz[0].add(sp[0]);\n    spz[1] = spz[1].add(sp[1]);\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n\n    Dfp[] spx = new Dfp[2];\n    spx[0] = a[0];\n    spx[1] = a[1];\n\n    Dfp[] spz = new Dfp[2];\n    spz[0] = a[0].add(a[1]);\n    spz[1] = a[0].multiply(a[1]);\n\n    spx[0] = spx[0].subtract(spz[0]);\n    spx[1] = spx[1].subtract(spz[1]);\n\n    spz[0] = spx[0].divide(spx[1]);\n    spz[1] = spx[0].multiply(spx[1]);\n\n    return spz;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] spx = new Dfp[2];\n    spx[0] = a[0];\n    spx[1] = a[1];\n\n    Dfp[] spz = new Dfp[2];\n    spz[0] = a.newInstance(new StringBuilder().append(4*a[0].intValue()).toString());\n    spz[1] = a.getZero();\n\n    Dfp[] spy = splitMult(a.getField().getLn2Split(), spx);\n\n    spz[0] = spz[0].subtract(spy[0]);\n    spz[1] = spz[1].subtract(spy[1]);\n\n    spy = splitMult(a.getField().getLn5Split(), spx);\n\n    spz[0] = spz[0].subtract(spy[0]);\n    spz[1] = spz[1].subtract(spy[1]);\n\n    return a.newInstance(spz[0].add(spz[1]));\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] spx = new Dfp[2];\n    spx[0] = a[0];\n    spx[1] = a[1];\n\n    Dfp[] spz = new Dfp[2];\n    spz[0] = a[0];\n    spz[1] = a[1];\n\n    Dfp x = spx[0];\n    Dfp z = spz[0];\n\n    Dfp lr = x.log10K();\n\n    x = x.divide(pow(a.newInstance(10000), lr));  /* This puts x in the range 0-10000 */\n    int ix = x.floor().intValue();\n\n    int p2 = 0;\n    while (ix > 2) {\n        ix >>= 1;\n        p2++;\n    }\n\n    Dfp[] spx1 = split(x);\n    Dfp[] spy = new Dfp[2];\n    spy[0] = pow(a.getTwo(), p2);          // use spy[0] temporarily as a divisor\n    spx1[0] = spx1[0].divide(spy[0]);\n    spx1[1] = spx1[1].divide(spy[0]);\n\n    spy[0] = a.newInstance(\"1.33333\");    // Use spy[0] for comparison\n    while (spx1[0].add(spx1[1]).greaterThan(spy[0])) {\n        spx1[0] = spx1[0].divide(2);\n        spx1[1] = spx1[1].divide(2);\n        p2++;\n    }\n\n    // X is now in the range of 2/3 < x < 4/3\n    Dfp[] spz1 = logInternal(spx1);\n\n    spx1[0] = a.newInstance(new StringBuilder().append(p2+4*lr).toString());\n    spx1[1] = a.getZero();\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    // TODO: Implement the logInternal function\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    // TODO: Implement this function\n    return null;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] spx = new Dfp[2];\n    spx[0] = a[0].subtract(a[1]);\n    spx[1] = a[1];\n\n    return spx;\n}"
    ],
    [
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        Collection<V> collection = get(key);\n        if (collection != null && collection.remove(value)) \n        {\n            if (collection.isEmpty()) \n            {\n                remove(key);\n            }\n            return true;\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        Collection<V> collection = get(key);\n        if (collection != null && collection.remove(value)) {\n            if (collection.isEmpty()) {\n                remove(key);\n            }\n            return true;\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        Collection<V> collection = get(key);\n        if (collection != null) \n        {\n            boolean removed = collection.remove(value);\n            if (collection.isEmpty()) \n            {\n                remove(key);\n            }\n            return removed;\n        } \n        else \n        {\n            return false;\n        }\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        Collection<V> collection = get(key);\n        if (collection != null) \n        {\n            boolean removed = collection.remove(value);\n            if (collection.isEmpty()) \n            {\n                remove(key);\n            }\n            return removed;\n        } \n        else \n        {\n            return false;\n        }\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        Collection<V> collection = get(key);\n        if (collection != null && collection.remove(value)) \n        {\n            if (collection.isEmpty()) \n            {\n                remove(key);\n            }\n            return true;\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        Collection<V> collection = get(key);\n        if (collection != null && collection.remove(value)) {\n            if (collection.isEmpty()) {\n                remove(key);\n            }\n            return true;\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        Collection<V> collection = get(key);\n        if (collection != null && collection.remove(value)) \n        {\n            if (collection.isEmpty()) \n            {\n                remove(key);\n            }\n            return true;\n        } \n        else \n        {\n            return false;\n        }\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        Collection<V> collection = get(key);\n        if (collection != null && collection.remove(value)) {\n            if (collection.isEmpty()) {\n                remove(key);\n            }\n            return true;\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        Collection<V> collection = get(key);\n        if (collection != null && collection.remove(value)) {\n            if (collection.isEmpty()) {\n                remove(key);\n            }\n            return true;\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        Collection<V> collection = get(key);\n        if (collection != null && collection.remove(value)) \n        {\n            if (collection.isEmpty()) \n            {\n                remove(key);\n            }\n            return true;\n        } \n        else \n        {\n            return false;\n        }\n    }"
    ],
    [
      "private Node transformAsString(AstNode n)  {\n    Node node = newNode(transformTokenType(n.getType()));\n    for (AstNode child : n) {\n        node.addChildToBack(transform(child));\n    }\n    if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n        node.setValue(\"\\\"\" + node.getValue() + \"\\\"\");\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = newNode(transformTokenType(n.getType()));\n    for (AstNode child : n) {\n        node.addChildToBack(transform(child));\n    }\n    if (n.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n        node.setValue(\"\\\"\" + n.getValue() + \"\\\"\");\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = newNode(transformTokenType(n.getType()));\n    for (AstNode child : n) \n    {\n        node.addChildToBack(transform(child));\n    }\n    if(node.getType() == Token.NAME)\n    {\n        node.setType(Token.STRING);\n        node.setValue(\"\\\"\" + node.getValue() + \"\\\"\");\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = newNode(transformTokenType(n.getType()));\n    for (AstNode child : n) \n    {\n        node.addChildToBack(transform(child));\n    }\n    if(node.getType() == Token.NAME)\n    {\n        node.setType(Token.STRING);\n        node.setValue(\"\\\"\" + node.getValue() + \"\\\"\");\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = newNode(transformTokenType(n.getType()));\n    for (AstNode child : n) \n    {\n        node.addChildToBack(transform((AstNode) child));\n    }\n    if (node.getType() == Token.NAME) \n    {\n        node.setType(Token.STRING);\n        node.setValue(\"\\\"\" + node.getValue() + \"\\\"\");\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = justTransform(n);\n    if (node.getType() == Token.NAME) \n    {\n        node.setType(Token.STRING);\n        node.setValue(\"\\\"\" + node.getValue() + \"\\\"\");\n    } \n    else if (node.getType() == Token.STRING) \n    {\n        node.setValue(\"\\\"\" + node.getValue() + \"\\\"\");\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = justTransform(n);\n    if (node.getType() == Token.NAME) \n    {\n        node.setType(Token.STRING);\n        node.setValue(\"\\\"\" + node.getValue() + \"\\\"\");\n    } \n    else if (node.getType() == Token.STRING) \n    {\n        node.setValue(\"\\\"\" + node.getValue() + \"\\\"\");\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = newNode(transformTokenType(n.getType()));\n    for (AstNode child : n) {\n        node.addChildToBack(transformAsString((AstNode) child));\n    }\n    if(n.getType() == Token.NAME){\n        node.setType(Token.STRING);\n        node.setValue(\"\\\"\" + n.getValue() + \"\\\"\");\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = newNode(transformTokenType(n.getType()));\n    for (AstNode child : n) {\n        node.addChildToBack(transform(child));\n    }\n    if (n.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n        node.setValue(\"\\\"\" + n.getValue() + \"\\\"\");\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = newNode(transformTokenType(n.getType()));\n    for (AstNode child : n) \n    {\n        node.addChildToBack(transform(child));\n    }\n    if (node.getType() == Token.NAME) \n    {\n        node.setType(Token.STRING);\n        node.setValue(\"\\\"\" + node.getValue() + \"\\\"\");\n    }\n    return node;\n}"
    ],
    [
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        List list = new ArrayList();\n        double total = 0.0;\n        for (int i = 0; i < includedRows.length; i++) {\n            double value = dataset.getValue(category, includedRows[i]).doubleValue();\n            if (!getIgnoreZeroValues() || value != 0.0) {\n                list.add(new Double(value));\n                total += value;\n            }\n        }\n        if (asPercentages && total != 0.0) {\n            for (int i = 0; i < list.size(); i++) {\n                double value = ((Double) list.get(i)).doubleValue();\n                list.set(i, new Double(value / total));\n            }\n        }\n        list.add(0, new Double(base));\n        return list;\n    }",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        List result = new ArrayList();\n        double total = 0.0;\n        for (int i = 0; i < includedRows.length; i++) \n        {\n            double value = dataset.getValue(category, includedRows[i]).doubleValue();\n            if (asPercentages) \n            {\n                value = value / 100.0;\n            }\n            total += value;\n            result.add(new Double(base + total));\n        }\n        return result;\n    }",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        List result = new ArrayList();\n        double total = 0.0;\n        for (int i = 0; i < includedRows.length; i++) {\n            double value = dataset.getValue(category, includedRows[i]).doubleValue();\n            if (!getIgnoreZeroValues() || value != 0.0) {\n                result.add(new Double(value));\n                total += value;\n            }\n        }\n        if (asPercentages && total != 0.0) {\n            for (int i = 0; i < result.size(); i++) {\n                double value = ((Double) result.get(i)).doubleValue();\n                result.set(i, new Double(value / total));\n            }\n        }\n        return result;\n    }",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        List list = new ArrayList();\n        double total = 0.0;\n        for (int i = 0; i < includedRows.length; i++) \n        {\n            double value = dataset.getValue(category, includedRows[i]).doubleValue();\n            if (!asPercentages) \n            {\n                list.add(new Double(value + base));\n            } \n            else \n            {\n                list.add(new Double(value));\n            }\n            total += value;\n        }\n        if (asPercentages && total != 0.0) \n        {\n            for (int i = 0; i < list.size(); i++) \n            {\n                double percent = ((Double) list.get(i)).doubleValue() / total;\n                list.set(i, new Double(percent));\n            }\n        }\n        return list;\n    }",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        List result = new ArrayList();\n        double total = 0.0;\n        for (int i = 0; i < includedRows.length; i++) {\n            double value = dataset.getValue(category, includedRows[i]).doubleValue();\n            if (!asPercentages) {\n                result.add(new Double(value + base));\n            }\n            else {\n                total += value;\n            }\n        }\n        if (asPercentages && total != 0.0) {\n            for (int i = 0; i < includedRows.length; i++) {\n                double value = dataset.getValue(category, includedRows[i]).doubleValue();\n                result.add(new Double(value / total + base));\n            }\n        }\n        return result;\n    }",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        List list = new ArrayList();\n        double total = 0.0;\n        for (int i = 0; i < includedRows.length; i++) {\n            double value = dataset.getValue(category, includedRows[i]).doubleValue();\n            total += value;\n            list.add(new Double(value));\n        }\n        if (asPercentages && total != 0.0) {\n            for (int i = 0; i < list.size(); i++) {\n                double value = ((Double) list.get(i)).doubleValue();\n                list.set(i, new Double(value / total));\n            }\n        }\n        return list;\n    }",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        List list = new ArrayList();\n        double total = 0.0;\n        int count = dataset.getItemCount(category);\n        for (int i = 0; i < count; i++) {\n            if (includedRows != null && Arrays.binarySearch(includedRows, i) < 0) {\n                continue;\n            }\n            double value = dataset.getValue(category, i).doubleValue();\n            list.add(new Double(value + base));\n            total += value;\n        }\n        if (asPercentages && total != 0.0) {\n            for (int i = 0; i < list.size(); i++) {\n                double value = ((Double)list.get(i)).doubleValue();\n                list.set(i, new Double(value / total));\n            }\n        }\n        return list;\n    }",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        List list = new ArrayList();\n        double total = 0.0;\n        int count = dataset.getItemCount(category);\n        for (int i = 0; i < count; i++) {\n            if (includedRows != null && Arrays.binarySearch(includedRows, i) < 0) {\n                continue;\n            }\n            double value = dataset.getStackedValue(category, i).doubleValue();\n            total += value;\n        }\n        double last = 0.0;\n        for (int i = 0; i < count; i++) {\n            if (includedRows != null && Arrays.binarySearch(includedRows, i) < 0) {\n                continue;\n            }\n            double value = dataset.getStackedValue(category, i).doubleValue();\n            double percent = 0.0;\n            if (total != 0.0) {\n                percent = value / total;\n            }\n            if (asPercentages) {\n                list.add(new Double(percent));\n            }\n            else {\n                list.add(new Double(last + percent));\n            }\n            last = (Double) list.get(i);\n        }\n        return list;\n    }",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        List list = new ArrayList();\n        double total = 0.0;\n        for (int i = 0; i < includedRows.length; i++) \n        {\n            double value = dataset.getValue(category, includedRows[i]).doubleValue();\n            if (!asPercentages) \n            {\n                list.add(new Double(value + base));\n            } \n            else \n            {\n                list.add(new Double(value));\n            }\n            total += value;\n        }\n        if (asPercentages && total != 0.0) \n        {\n            for (int i = 0; i < list.size(); i++) \n            {\n                Double d = (Double) list.get(i);\n                d = new Double(d.doubleValue() / total);\n                list.set(i, d);\n            }\n        }\n        return list;\n    }",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        List list = new ArrayList();\n        double total = 0.0;\n        for (int i = 0; i < includedRows.length; i++) \n        {\n            double value = dataset.getValue(category, includedRows[i]).doubleValue();\n            total += value;\n            list.add(new Double(value));\n        }\n        if (asPercentages && total != 0.0) \n        {\n            for (int i = 0; i < list.size(); i++) \n            {\n                Double value = (Double) list.get(i);\n                list.set(i, new Double(value.doubleValue() / total));\n            }\n        }\n        list.add(0, new Double(base));\n        return list;\n    }"
    ],
    [
      "private List<Element> childElementsList()  {\n    List<Element> childElements = new ArrayList<>();\n    for (Node node : childNodes()) {\n        if (node instanceof Element) {\n            childElements.add((Element) node);\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    List<Element> childElements = new ArrayList<>();\n    for (Node node : childNodes()) {\n        if (node instanceof Element) {\n            childElements.add((Element) node);\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    List<Element> childElements = new ArrayList<>();\n    for (Node node : childNodes()) {\n        if (node instanceof Element) {\n            childElements.add((Element) node);\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    List<Element> childElements = new ArrayList<>();\n    for (Node child : childNodes()) {\n        if (child instanceof Element) {\n            childElements.add((Element) child);\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    List<Element> childElements = new ArrayList<>();\n    for (Node child : childNodes()) {\n        if (child instanceof Element) {\n            childElements.add((Element) child);\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    List<Element> childElements = new ArrayList<>();\n    for (Node node : childNodes()) {\n        if (node instanceof Element) {\n            childElements.add((Element) node);\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    List<Element> childElements = new ArrayList<>();\n    for (Node node : childNodes()) {\n        if (node instanceof Element) {\n            childElements.add((Element) node);\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    if (childNodes().isEmpty()) {\n        return Collections.emptyList();\n    }\n\n    List<Element> childElements = new ArrayList<>();\n    for (Node node : childNodes()) {\n        if (node instanceof Element) {\n            childElements.add((Element) node);\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    if (childNodes().isEmpty()) {\n        return Collections.emptyList();\n    }\n\n    List<Element> elements = new ArrayList<>();\n    for (Node node : childNodes()) {\n        if (node instanceof Element) {\n            elements.add((Element) node);\n        }\n    }\n    return elements;\n}",
      "private List<Element> childElementsList()  {\n    List<Element> childElements = new ArrayList<>();\n    for (Node child : childNodes()) {\n        if (child instanceof Element) {\n            childElements.add((Element) child);\n        }\n    }\n    return childElements;\n}"
    ],
    [
      "private int getHash(final Object key)  {\n    int h = key.hashCode();\n    return h ^ (h >>> 16);\n}",
      "private int getHash(final Object key)  {\n    int h = key.hashCode();\n    return (h ^ (h >>> 16)) % buckets.length;\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    return (hash & 0x7FFFFFFF) % buckets.length;\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode()) % buckets.length;\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode()) % buckets.length;\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    return (hash & 0x7FFFFFFF) % buckets.length;\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode()) % buckets.length;\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    return (hash & 0x7FFFFFFF) % buckets.length;\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode()) % buckets.length;\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    int mask = buckets.length - 1;\n    return (hash & mask);\n}"
    ],
    [
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r <= c + k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r <= c + k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                if (r <= c + k) {\n                    d[r][c] = m.getEntry(r, c);\n                } else {\n                    d[r][c] = 0;\n                }\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n        double[][] data = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int i = 0; i < m.getRowDimension(); i++) {\n            for (int j = i; j < m.getColumnDimension(); j++) {\n                if (j - i <= k) {\n                    data[i][j] = m.getEntry(i, j);\n                } else {\n                    data[i][j] = 0;\n                }\n            }\n        }\n        return new Array2DRowRealMatrix(data, false);\n    }",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r <= c + k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                if (r <= c + k) {\n                    d[r][c] = m.getEntry(r, c);\n                } else {\n                    d[r][c] = 0;\n                }\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r <= c + k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                if (r <= c + k) {\n                    d[r][c] = m.getEntry(r, c);\n                } else {\n                    d[r][c] = 0;\n                }\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r <= c + k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                if (r <= c + k) {\n                    d[r][c] = m.getEntry(r, c);\n                } else {\n                    d[r][c] = 0;\n                }\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }"
    ],
    [
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.LEFT_HIGH) {\n                rotateCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } else if (right.skew == Skew.BALANCED) {\n                rotateCW();\n                skew = Skew.RIGHT_HIGH;\n                left.skew = Skew.LEFT_HIGH;\n                return false;\n            } else {\n                final Skew s = right.right.skew;\n                right.rotateCCW();\n                rotateCW();\n                switch (s) {\n                    case LEFT_HIGH:\n                        left.skew = Skew.RIGHT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.LEFT_HIGH;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            if (right.skew == Skew.LEFT_HIGH) {\n                rotateCW();\n                skew      = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            } else {\n                final Skew s = right.right.skew;\n                rotateCW();\n                skew      = Skew.RIGHT_HIGH;\n                right.skew = Skew.BALANCED;\n                switch (s) {\n                    case LEFT_HIGH:\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        right.skew = Skew.BALANCED;\n                }\n            }\n            return true;\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            if (right.skew == Skew.LEFT_HIGH) {\n                rotateCW();\n                skew      = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            } else {\n                final Skew s = right.right.skew;\n                rotateCW();\n                skew      = Skew.RIGHT_HIGH;\n                right.skew = Skew.LEFT_HIGH;\n                switch (s) {\n                    case LEFT_HIGH:\n                        right.skew = Skew.BALANCED;\n                        break;\n                    case RIGHT_HIGH:\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    default:\n                        right.skew = Skew.BALANCED;\n                }\n            }\n            return true;\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.LEFT_HIGH) {\n                right.rotateCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } else if (right.skew == Skew.BALANCED) {\n                rotateCW();\n                skew = Skew.RIGHT_HIGH;\n                left.skew = Skew.LEFT_HIGH;\n                return false;\n            } else {\n                final Skew s = right.right.skew;\n                rotateCW();\n                right.rotateCCW();\n                switch (s) {\n                    case LEFT_HIGH:\n                        left.skew = Skew.RIGHT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.LEFT_HIGH;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            if (right.skew == Skew.LEFT_HIGH) {\n                rotateCW();\n                skew      = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            } else {\n                final Skew s = right.right.skew;\n                rotateCW();\n                right.rotateCCW();\n                switch (s) {\n                    case LEFT_HIGH:\n                        right.skew = Skew.BALANCED;\n                        left.skew  = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        right.skew = Skew.BALANCED;\n                        left.skew  = Skew.LEFT_HIGH;\n                        break;\n                    default:\n                        right.skew = Skew.BALANCED;\n                        left.skew  = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n            }\n            return true;\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            if (right.skew == Skew.LEFT_HIGH) {\n                rotateCW();\n                skew      = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            } else {\n                final Skew s = right.right.skew;\n                rotateCW();\n                right.rotateCW();\n                switch (s) {\n                    case LEFT_HIGH:\n                        right.skew = Skew.BALANCED;\n                        left.skew  = Skew.LEFT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        right.skew = Skew.RIGHT_HIGH;\n                        left.skew  = Skew.BALANCED;\n                        break;\n                    default:\n                        right.skew = Skew.BALANCED;\n                        left.skew  = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n            }\n            return true;\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n        }\n}",
      "private boolean rebalanceRightShrunk()  ",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.LEFT_HIGH) {\n                rotateCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } else if (right.skew == Skew.BALANCED) {\n                rotateCW();\n                skew = Skew.RIGHT_HIGH;\n                left.skew = Skew.LEFT_HIGH;\n                return false;\n            } else {\n                final Skew s = right.right.skew;\n                right.rotateCCW();\n                rotateCW();\n                switch (s) {\n                    case LEFT_HIGH:\n                        left.skew = Skew.RIGHT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.LEFT_HIGH;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.LEFT_HIGH) {\n                rotateCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } else if (right.skew == Skew.BALANCED) {\n                rotateCW();\n                skew      = Skew.RIGHT_HIGH;\n                left.skew = Skew.LEFT_HIGH;\n                return false;\n            } else {\n                final Skew s = right.right.skew;\n                right.rotateCCW();\n                rotateCW();\n                switch (s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            if (right.skew == Skew.LEFT_HIGH) {\n                rotateCW();\n                skew      = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            } else {\n                final Skew s = right.right.skew;\n                rotateCW();\n                skew      = Skew.RIGHT_HIGH;\n                right.skew = Skew.LEFT_HIGH;\n                switch (s) {\n                    case LEFT_HIGH:\n                        right.skew = Skew.BALANCED;\n                        break;\n                    case RIGHT_HIGH:\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    default:\n                        right.skew = Skew.BALANCED;\n                }\n            }\n            return false;\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return true;\n    }\n}"
    ],
    [
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    double minValue = norm;\n    int minIdx = startIdx;\n    for (int i = startIdx - 1; i >= 0; i--) \n    {\n        double value = FastMath.abs(matrixT[i][i + 1]);\n        if (value < minValue) \n        {\n            minValue = value;\n            minIdx = i;\n        }\n    }\n    return minIdx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    double min = norm;\n    int minIdx = startIdx;\n    for (int i = startIdx - 1; i >= 0; i--) {\n        double sum = FastMath.abs(matrixT[i][i]) + FastMath.abs(matrixT[i + 1][i]);\n        if (sum <= min) {\n            min = sum;\n            minIdx = i;\n        } else {\n            break;\n        }\n    }\n    return minIdx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int il = startIdx;\n    while (il > 0) {\n        double sum = 0.0;\n        for (int i = 0; i <= il - 1; i++) {\n            sum += FastMath.abs(matrixT[i][il]);\n        }\n        if (sum <= norm * EPSILON) {\n            return il;\n        }\n        il--;\n    }\n    return 0;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int i = startIdx;\n    while (i > 0) {\n        double sum = 0.0;\n        for (int j = 0; j <= i - 1; j++) {\n            sum += FastMath.abs(matrixT[i][j]);\n        }\n        if (sum / norm <= SMALL_SUB_DIAGONAL_THRESHOLD) {\n            return i;\n        }\n        i--;\n    }\n    return 0;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int i = startIdx;\n    while (i > 0) {\n        double sum = 0.0;\n        for (int j = i - 1; j < startIdx; j++) {\n            sum += FastMath.abs(matrixT[j][i]);\n        }\n        if (sum <= norm * EPSILON) {\n            return i;\n        }\n        i--;\n    }\n    return i;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int i = startIdx;\n    while (i > 0) {\n        double sum = 0.0;\n        for (int j = i - 1; j < startIdx; j++) {\n            sum += FastMath.abs(matrixT[j][i]);\n        }\n        if (sum <= norm * EPSILON) {\n            return i;\n        }\n        i--;\n    }\n    return 0;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int iu = startIdx; iu > 0; iu--) {\n        double sum = 0.0;\n        for (int i = iu - 1; i < n; i++) {\n            sum += FastMath.abs(matrixT[i][iu]);\n        }\n        if (sum <= norm * EPSILON) {\n            return iu;\n        }\n    }\n    return 0;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int iu = startIdx; iu > 0; iu--) {\n        if (FastMath.abs(matrixT[iu - 1][iu]) <= (1.0E-12 * norm)) {\n            return iu - 1;\n        }\n    }\n    return -1;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int il = startIdx;\n    while (il > 0) {\n        double sum = 0.0;\n        for (int i = 0; i <= il - 1; i++) {\n            sum += FastMath.abs(matrixT[i][il]);\n        }\n        if (sum <= norm * EPSILON) {\n            return il;\n        }\n        il--;\n    }\n    return -1;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    double min = Double.MAX_VALUE;\n    int minIdx = -1;\n    for (int i = startIdx - 1; i >= 0; i--) \n    {\n        double sum = 0.0;\n        for (int j = i + 1; j < startIdx; j++) \n        {\n            sum += FastMath.abs(matrixT[j][i]);\n        }\n        if (sum <= norm * EPSILON && sum < min) \n        {\n            min = sum;\n            minIdx = i;\n        }\n    }\n    return minIdx;\n}"
    ],
    [
      "public Node getNotSmaller(final T reference)  {\n    // TODO: Complete the function\n}",
      "public Node getNotSmaller(final T reference)  {\n    if (top == null) \n    {\n        return null;\n    }\n    else \n    {\n        Node current = top;\n        while (current != null) \n        {\n            if (current.element.compareTo(reference) >= 0) \n            {\n                return current;\n            }\n            current = current.getNext();\n        }\n        return null;\n    }\n}",
      "public Node getNotSmaller(final T reference)  {\n    if (top == null || reference == null) {\n        return null;\n    }\n    Node current = top;\n    Node result = null;\n    while (current != null) {\n        if (current.element.compareTo(reference) >= 0) {\n            result = current;\n            current = current.left;\n        } else {\n            current = current.right;\n        }\n    }\n    return result;\n}",
      "public Node getNotSmaller(final T reference)  {\n    if (reference != null) {\n        Node node = top;\n        while (node != null) {\n            int comparison = node.element.compareTo(reference);\n            if (comparison < 0) {\n                node = node.getNext();\n            } else if (comparison > 0) {\n                return node;\n            } else {\n                return node.getNext();\n            }\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    if (top == null)\n        return null;\n\n    Node current = top;\n    Node result = null;\n\n    while (current != null) \n    {\n        if (current.element.compareTo(reference) >= 0) \n        {\n            result = current;\n            current = current.left;\n        } \n        else \n        {\n            current = current.right;\n        }\n    }\n\n    return result;\n}",
      "public Node getNotSmaller(final T reference)  {\n    if (reference != null) {\n        Node node = top;\n        Node notSmaller = null;\n        while (node != null) {\n            if (node.element.compareTo(reference) >= 0) {\n                notSmaller = node;\n                node = node.getPrevious();\n            } else {\n                node = node.getNext();\n            }\n        }\n        return notSmaller;\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    // TODO: implement this method\n}",
      "public Node getNotSmaller(final T reference)  {\n    // Your code here\n}",
      "public Node getNotSmaller(final T reference)  {\n    if (top == null || reference == null) {\n        return null;\n    }\n    Node node = top;\n    while (node != null) {\n        int compareResult = node.element.compareTo(reference);\n        if (compareResult < 0) {\n            node = node.right;\n        } else if (compareResult > 0) {\n            if (node.left != null) {\n                node = node.left;\n            } else {\n                return node;\n            }\n        } else {\n            return node;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    if (reference != null) \n    {\n        Node node = top;\n        Node notSmaller = null;\n        while (node != null) \n        {\n            if (node.element.compareTo(reference) >= 0) \n            {\n                notSmaller = node;\n                node = node.left;\n            } \n            else \n            {\n                node = node.right;\n            }\n        }\n        return notSmaller;\n    }\n    return null;\n}"
    ],
    [
      "public StrBuilder deleteAll(final String str)  {\n    if (str != null) \n    {\n        final int strLen = str.length();\n        if (strLen > 0) \n        {\n            final char firstChar = str.charAt(0);\n            int index = 0;\n            while (index < size) \n            {\n                index = indexOf(firstChar, index);\n                if (index == -1) \n                {\n                    break;\n                }\n                if (size - index >= strLen && regionMatches(index, str, 0, strLen)) \n                {\n                    deleteImpl(index, index + strLen, strLen);\n                } \n                else \n                {\n                    break;\n                }\n            }\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str != null) \n    {\n        final int strLen = str.length();\n        for (int i = 0; i < size; i++) \n        {\n            if (size - i >= strLen) \n            {\n                if (str.equals(new String(buffer, i, strLen))) \n                {\n                    final int start = i;\n                    i += strLen - 1;\n                    final int len = strLen;\n                    deleteImpl(start, i + 1, len);\n                }\n            }\n            else \n            {\n                break;\n            }\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str != null) \n    {\n        final int strLen = str.length();\n        if (strLen > 0) \n        {\n            final char[] value = buffer;\n            int index = 0;\n            while (index < size) \n            {\n                final int start = index;\n                while (index < size && value[index] == str.charAt(0)) \n                {\n                    int i = 1;\n                    while (i < strLen && index + i < size && value[index + i] == str.charAt(i)) \n                    {\n                        i++;\n                    }\n                    if (i == strLen) \n                    {\n                        final int len = i;\n                        deleteImpl(start, index + len, len);\n                        index = start;\n                    }\n                    index++;\n                }\n                index++;\n            }\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str != null) \n    {\n        final int strLen = str.length();\n        for (int i = 0; i < size; i++) \n        {\n            if (str.charAt(0) == buffer[i] && size - i >= strLen) \n            {\n                int j = 1;\n                while (j < strLen && buffer[i + j] == str.charAt(j)) \n                {\n                    j++;\n                }\n                if (j == strLen) \n                {\n                    final int len = j;\n                    deleteImpl(i, i + len, len);\n                    i -= len;\n                }\n            }\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str != null) \n    {\n        final int strLen = str.length();\n        if (strLen > 0) \n        {\n            for (int i = 0; i < size; i++) \n            {\n                if (buffer[i] == str.charAt(0)) \n                {\n                    final int start = i;\n                    int j = 1;\n                    while (++i < size && j < strLen) \n                    {\n                        if (buffer[i] != str.charAt(j)) \n                        {\n                            break;\n                        }\n                        j++;\n                    }\n                    if (j == strLen) \n                    {\n                        final int len = i - start;\n                        deleteImpl(start, i, len);\n                        i -= len;\n                    } \n                    else \n                    {\n                        i--;\n                    }\n                }\n            }\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str != null) \n    {\n        final int strLen = str.length();\n        if (strLen > 0) \n        {\n            for (int i = 0; i < size; i++) \n            {\n                if (buffer[i] == str.charAt(0)) \n                {\n                    final int start = i;\n                    int j = 1;\n                    while (++i < size && j < strLen) \n                    {\n                        if (buffer[i] != str.charAt(j)) \n                        {\n                            break;\n                        }\n                        j++;\n                    }\n                    if (j == strLen) \n                    {\n                        final int len = i - start;\n                        deleteImpl(start, i, len);\n                        i -= len;\n                    } \n                    else \n                    {\n                        i--;\n                    }\n                }\n            }\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str != null) \n    {\n        final int strLen = str.length();\n        if (strLen > 0) \n        {\n            for (int i = 0; i < size - strLen + 1; i++) \n            {\n                if (str.equals(new String(buffer, i, strLen))) \n                {\n                    final int start = i;\n                    i += strLen - 1;\n                    final int len = strLen;\n                    deleteImpl(start, i + 1, len);\n                }\n            }\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str != null) \n    {\n        final int strLen = str.length();\n        for (int i = 0; i < size; i++) \n        {\n            if (str.charAt(0) == buffer[i] && size - i >= strLen) \n            {\n                boolean isMatch = true;\n                for (int j = 1; j < strLen; j++) \n                {\n                    if (str.charAt(j) != buffer[i + j]) \n                    {\n                        isMatch = false;\n                        break;\n                    }\n                }\n                if (isMatch) \n                {\n                    final int len = strLen;\n                    deleteImpl(i, i + len, len);\n                    i -= len;\n                }\n            }\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str != null) \n    {\n        final int strLen = str.length();\n        if (strLen > 0) \n        {\n            final char[] value = buffer;\n            int index = 0;\n            while (index < size) \n            {\n                final int foundAt = indexOf(value, str, index);\n                if (foundAt == -1) \n                {\n                    break;\n                }\n                deleteImpl(foundAt, foundAt + strLen, strLen);\n                index = foundAt + strLen;\n            }\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str != null) \n    {\n        final int strLen = str.length();\n        if (strLen > 0) \n        {\n            for (int i = 0; i < size - strLen + 1; i++) \n            {\n                if (str.equals(new String(buffer, i, strLen))) \n                {\n                    final int start = i;\n                    i += strLen - 1;\n                    final int len = strLen;\n                    deleteImpl(start, i + 1, len);\n                }\n            }\n        }\n    }\n    return this;\n}"
    ],
    [
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = justTransform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) \n    {\n        irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n        irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    JSDocInfo jsDocInfo = irNode.getJSDocInfo();\n    if (jsDocInfo != null && jsDocInfo.hasType()) \n    {\n        if (node instanceof VariableInitializer) \n        {\n            Node parent = irNode.getParent();\n            if (parent instanceof FunctionNode) \n            {\n                Parameter param = ((FunctionNode) parent).getParameter(node.getLineno() - 1);\n                if (param != null) \n                {\n                    param.setType(jsDocInfo.getType());\n                }\n            }\n        }\n        else if (node instanceof ObjectProperty) \n        {\n            Node parent = irNode.getParent();\n            if (parent instanceof ObjectLiteral) \n            {\n                Property prop = ((ObjectLiteral) parent).getProperty(node.getName());\n                if (prop != null) \n                {\n                    prop.setType(jsDocInfo.getType());\n                }\n            }\n        }\n    }\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = justTransform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) \n    {\n      irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n      irNode.setJSDocInfo(jsDocInfo);\n      if (node.getType() == com.google.javascript.rhino.head.Token.NAME) \n      {\n        irNode = newNode(Token.VAR, irNode);\n      }\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    if (node instanceof VariableInitializer) {\n        VariableInitializer varInit = (VariableInitializer) node;\n        JSDocInfo jsDocInfo = getJsDocInfo(varInit.getTarget());\n        if (jsDocInfo != null && jsDocInfo.hasType()) {\n            irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n            irNode.setJSDocInfo(jsDocInfo);\n        }\n    }\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    if (irNode.hasJSDoc() && irNode.getJSDoc().hasType()) \n    {\n        if (node.getType() == com.google.javascript.rhino.head.Token.VAR) \n        {\n            irNode = maybeInjectCastNode(node, irNode.getJSDoc(), irNode);\n        } \n        else if (node instanceof VariableInitializer) \n        {\n            irNode = maybeInjectCastNode(node, irNode.getJSDoc(), irNode);\n        }\n    }\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    JSDocInfo jsDocInfo = irNode.getJSDocInfo();\n    if (jsDocInfo != null && jsDocInfo.hasType()) {\n      if (node instanceof VariableInitializer) {\n        VariableInitializer varInit = (VariableInitializer) node;\n        irNode = maybeInjectCastNode(varInit.getTarget(), jsDocInfo, irNode);\n      }\n      else if (node instanceof FunctionNode) {\n        FunctionNode fnNode = (FunctionNode) node;\n        for (VariableInitializer param : fnNode.getParameters()) {\n          irNode = maybeInjectCastNode(param.getTarget(), jsDocInfo, irNode);\n        }\n      }\n    }\n    return irNode;\n  }",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    if (node.hasJSDoc()) {\n      JSDocInfo jsDocInfo = node.getJSDocInfo();\n      if (jsDocInfo.hasType()) {\n        if (node.getType() == com.google.javascript.rhino.head.Token.VAR\n            || node.getType() == com.google.javascript.rhino.head.Token.FUNCTION) {\n          Node newNode = newNode(Token.VAR, irNode);\n          newNode.setJSDocInfo(jsDocInfo);\n          irNode = newNode;\n        } else if (node.getType() == com.google.javascript.rhino.head.Token.NAME) {\n          Node parent = node.getParent();\n          if (parent instanceof VariableInitializer \n              && node == ((VariableInitializer) parent).getTarget()) {\n            Node newNode = newNode(Token.VAR, irNode);\n            newNode.setJSDocInfo(jsDocInfo);\n            irNode = newNode;\n          } else if (parent instanceof ObjectProperty) {\n            Node newNode = newNode(Token.PROPERTY, irNode);\n            newNode.setJSDocInfo(jsDocInfo);\n            irNode = newNode;\n          }\n        }\n      }\n    }\n    return irNode;\n  }",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    JSDocInfo jsDocInfo = irNode.getJSDocInfo();\n    if (jsDocInfo != null && jsDocInfo.hasType()) \n    {\n        Node parentNode = irNode.getParent();\n        if (parentNode instanceof FunctionNode) \n        {\n            // if the parent is a function node, then it's a parameter\n            // so we need to get the parameter node from the function node\n            Parameter paramNode = ((FunctionNode) parentNode).getParameter(irNode.getName());\n            if (paramNode != null) \n            {\n                paramNode.setJSDocInfo(jsDocInfo);\n                irNode = paramNode;\n            }\n        } \n        else if (parentNode instanceof VariableInitializer) \n        {\n            // if the parent is a variable initializer, then it's a variable declaration\n            // so we need to get the variable declaration node from the parent\n            VariableDeclaration varDeclNode = (VariableDeclaration) parentNode.getParent();\n            VariableDeclarator varDeclarator = varDeclNode.getDeclarator(irNode.getName());\n            if (varDeclarator != null) \n            {\n                varDeclarator.setJSDocInfo(jsDocInfo);\n                irNode = varDeclarator;\n            }\n        }\n    }\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = justTransform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) \n    {\n        irNode = maybeInjectCastNodeWithInlineJsDoc(node, jsDocInfo, irNode);\n        irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null && jsDocInfo.hasType()) \n    {\n        irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n        irNode.setJSDocInfo(jsDocInfo);\n    }\n    return irNode;\n}"
    ],
    [
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<>(list);\n    return new SetUniqueList<>(new ArrayList<>(set), set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    return new SetUniqueList<E>(new HashSet<E>(list));\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n\n    Set<E> set = new HashSet<>(list);\n    return new SetUniqueList<>(set, list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    return new SetUniqueList<E>(new HashSet<E>(list));\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n\n    Set<E> set = new HashSet<E>(list);\n    return new SetUniqueList<E>(new ArrayList<E>(set), set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n\n    Set<E> set = new HashSet<E>(list);\n    return new SetUniqueList<E>(set, list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n\n    Set<E> set = new HashSet<>(list);\n    return new SetUniqueList<>(set, list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<>(list);\n    return new SetUniqueList<>(new ArrayList<>(set), set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n\n    Set<E> set = new HashSet<>(list);\n    return new SetUniqueList<>(new ArrayList<>(set), set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n\n    Set<E> set = new HashSet<E>(list);\n    return new SetUniqueList<E>(set, list);\n}"
    ],
    [
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.ARRAY);\n    if (!match(JsDocToken.LB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n    }\n    next();\n\n    // ElementTypeList := <empty> | TypeExpression | '...' TypeExpression\n    //     | TypeExpression ',' ElementTypeList\n    Node elementType = null;\n    do {\n      if (elementType != null) {\n        skipEOLs();\n        token = next();\n        Preconditions.checkState(\n            token == JsDocToken.RB || token == JsDocToken.COMMA || token == JsDocToken.ELLIPSIS);\n        if (token == JsDocToken.COMMA) {\n          next();\n          skipEOLs();\n          token = next();\n        }\n      }\n      if (token == JsDocToken.ELLIPSIS) {\n        next();\n        skipEOLs();\n        token = next();\n        Node typeExpr = parseTypeExpression(token);\n        if (typeExpr == null) {\n          return null;\n        }\n        arrayType.addChildToBack(newNode(Token.ELLIPSIS, typeExpr));\n      } else {\n        elementType = parseTypeExpression(token);\n        if (elementType == null) {\n          return null;\n        }\n        arrayType.addChildToBack(elementType);\n      }\n    } while (match(JsDocToken.COMMA));\n\n    if (!match(JsDocToken.RB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n    return arrayType;\n  }",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.ARRAY);\n    if (!match(JsDocToken.LB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n    }\n    next();\n    skipEOLs();\n    token = next();\n    if (token == JsDocToken.RB) {\n      return arrayType;\n    }\n\n    Node elementType = parseTypeExpression(token);\n    if (elementType == null) {\n      return null;\n    }\n    arrayType.addChildToBack(elementType);\n\n    while (true) {\n      skipEOLs();\n      token = next();\n      if (token == JsDocToken.RB) {\n        break;\n      }\n      if (token != JsDocToken.ELLIPSIS) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.array.element\");\n      }\n      next();\n      elementType = parseTypeExpression(next());\n      if (elementType == null) {\n        return null;\n      }\n      arrayType.addChildToBack(newNode(Token.ELLIPSIS));\n      arrayType.addChildToBack(elementType);\n      if (!match(JsDocToken.COMMA)) {\n        break;\n      }\n    }\n\n    if (!match(JsDocToken.RB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n    return arrayType;\n  }",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.ARRAY);\n\n    if (!match(JsDocToken.LB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n    }\n    next();\n\n    while (true) {\n      skipEOLs();\n      token = next();\n      if (token == JsDocToken.RB) {\n        break;\n      }\n\n      Node elementType = parseTypeExpression(token);\n      if (elementType == null) {\n        return null;\n      }\n\n      arrayType.addChildToBack(elementType);\n\n      if (!match(JsDocToken.COMMA)) {\n        if (match(JsDocToken.ELLIPSIS)) {\n          next();\n          if (!match(JsDocToken.RB)) {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n          }\n          break;\n        } else {\n          return reportTypeSyntaxWarning(\"msg.jsdoc.missing.comma\");\n        }\n      }\n    }\n\n    next();\n    return arrayType;\n  }",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.ARRAY);\n    if (!match(JsDocToken.LB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n    }\n    next();\n\n    boolean isVarArgs = false;\n    Node elementType = null;\n    while (true) {\n      skipEOLs();\n      if (match(JsDocToken.RB)) {\n        next();\n        break;\n      }\n\n      if (match(JsDocToken.ELLIPSIS)) {\n        next();\n        isVarArgs = true;\n        elementType = parseTypeExpression(next());\n      } else {\n        elementType = parseTypeExpression(next());\n      }\n\n      if (elementType == null) {\n        return null;\n      }\n\n      if (isVarArgs) {\n        arrayType.addChildToBack(newNode(Token.VAR_ARGS));\n        arrayType.addChildToBack(elementType);\n        break;\n      } else {\n        arrayType.addChildToBack(elementType);\n      }\n\n      if (!match(JsDocToken.COMMA)) {\n        break;\n      }\n      next();\n    }\n\n    return arrayType;\n  }",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.ARRAY);\n    if (!match(JsDocToken.LB)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n    }\n    next();\n\n    skipEOLs();\n    token = next();\n    if (match(JsDocToken.RB)) {\n        return arrayType;\n    }\n\n    Node elementType = parseTypeExpression(token);\n    if (elementType == null) {\n        return null;\n    }\n    arrayType.addChildToBack(elementType);\n\n    while (match(JsDocToken.COMMA)) {\n        token = next();\n        skipEOLs();\n        elementType = parseTypeExpression(token);\n        if (elementType == null) {\n            return null;\n        }\n        arrayType.addChildToBack(elementType);\n    }\n\n    if (match(JsDocToken.ELLIPSIS)) {\n        token = next();\n        Node ellipsisType = parseTypeExpression(token);\n        if (ellipsisType == null) {\n            return null;\n        }\n        arrayType.addChildToBack(ellipsisType);\n    }\n\n    if (!match(JsDocToken.RB)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.ARRAY);\n\n    if (!match(JsDocToken.LB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n    }\n    next();\n\n    if (!match(JsDocToken.RB)) {\n      Node elementType = parseTypeExpression(next());\n      if (elementType == null) {\n        return null;\n      }\n      arrayType.addChildToBack(elementType);\n\n      while (match(JsDocToken.COMMA)) {\n        elementType = parseTypeExpression(next());\n        if (elementType == null) {\n          return null;\n        }\n        arrayType.addChildToBack(elementType);\n      }\n\n      if (!match(JsDocToken.RB)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n      }\n    }\n    next();\n\n    return arrayType;\n  }",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.ARRAY);\n    if (!match(JsDocToken.LB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n    }\n    next();\n\n    if (match(JsDocToken.RB)) {\n      // Empty array type.\n      next();\n      return arrayType;\n    }\n\n    Node elementType = parseTypeExpression(next());\n    if (elementType == null) {\n      return null;\n    }\n    arrayType.addChildToBack(elementType);\n\n    while (match(JsDocToken.COMMA)) {\n      elementType = parseTypeExpression(next());\n      if (elementType == null) {\n        return null;\n      }\n      arrayType.addChildToBack(elementType);\n    }\n\n    if (match(JsDocToken.ELLIPSIS)) {\n      next();\n      elementType = parseTypeExpression(next());\n      if (elementType == null) {\n        return null;\n      }\n      arrayType.addChildToBack(elementType);\n    }\n\n    if (!match(JsDocToken.RB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.ARRAY);\n    if (!match(JsDocToken.LB)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n    }\n    next();\n\n    // Empty array type\n    if (match(JsDocToken.RB)) {\n        next();\n        return arrayType;\n    }\n\n    Node elementType = parseTypeExpression(next());\n    if (elementType == null) {\n        return null;\n    }\n    arrayType.addChildToBack(elementType);\n\n    while (match(JsDocToken.COMMA)) {\n        next();\n        elementType = parseTypeExpression(next());\n        if (elementType == null) {\n            return null;\n        }\n        arrayType.addChildToBack(elementType);\n    }\n\n    if (match(JsDocToken.ELLIPSIS)) {\n        next();\n        elementType = parseTypeExpression(next());\n        if (elementType == null) {\n            return null;\n        }\n        arrayType.addChildToBack(elementType);\n    }\n\n    if (!match(JsDocToken.RB)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.ARRAY);\n    if (!match(JsDocToken.LB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n    }\n    next();\n\n    // ElementTypeList := <empty> | TypeExpression | '...' TypeExpression\n    //     | TypeExpression ',' ElementTypeList\n    Node elementType = parseTypeExpression(next());\n    if (elementType == null) {\n      return null;\n    }\n    arrayType.addChildToBack(elementType);\n\n    while (match(JsDocToken.COMMA)) {\n      next();\n      elementType = parseTypeExpression(next());\n      if (elementType == null) {\n        return null;\n      }\n      arrayType.addChildToBack(elementType);\n    }\n\n    if (match(JsDocToken.ELLIPSIS)) {\n      next();\n      elementType = parseTypeExpression(next());\n      if (elementType == null) {\n        return null;\n      }\n      arrayType.addChildToBack(elementType);\n    }\n\n    if (!match(JsDocToken.RB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n\n    return arrayType;\n  }",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.ARRAY);\n    if (!match(JsDocToken.LB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n    }\n    next();\n\n    boolean isVarArgs = false;\n    Node elementType = null;\n    do {\n      if (elementType != null) {\n        skipEOLs();\n        token = next();\n        Preconditions.checkState(\n            token == JsDocToken.COMMA || token == JsDocToken.RB);\n        if (token == JsDocToken.COMMA) {\n          next();\n        } else {\n          break;\n        }\n      }\n      if (match(JsDocToken.ELLIPSIS)) {\n        isVarArgs = true;\n        next();\n        elementType = parseTypeExpression(next());\n      } else {\n        elementType = parseTypeExpression(next());\n      }\n      if (elementType == null) {\n        return null;\n      }\n      arrayType.addChildToBack(elementType);\n    } while (true);\n\n    if (!match(JsDocToken.RB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n    if (isVarArgs) {\n      arrayType.addChildToBack(newNode(Token.VARARGS));\n    }\n    return arrayType;\n  }"
    ],
    [
      "public Vector3D getAxis()  {\n    double norm = Math.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    if (norm == 0.0)\n        throw new IllegalStateException(\"Cannot compute axis for null rotation\");\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n}",
      "public Vector3D getAxis()  {\n    double norm = Math.sqrt(q1*q1 + q2*q2 + q3*q3);\n    if (norm == 0.0) {\n        throw new IllegalStateException(\"Zero norm for quaternion axis\");\n    }\n    return new Vector3D(q1/norm, q2/norm, q3/norm);\n}",
      "public Vector3D getAxis()  {\n    double norm = Math.sqrt(q1*q1 + q2*q2 + q3*q3);\n    if (norm == 0.0) {\n        return new Vector3D(0, 0, 0);\n    }\n    return new Vector3D(q1/norm, q2/norm, q3/norm);\n}",
      "public Vector3D getAxis()  {\n    double norm = Math.sqrt(q1*q1 + q2*q2 + q3*q3);\n    if (norm == 0.0) {\n        return new Vector3D(0, 0, 0);\n    } else {\n        return new Vector3D(q1/norm, q2/norm, q3/norm);\n    }\n}",
      "public Vector3D getAxis()  {\n    double norm = Math.sqrt(q1*q1 + q2*q2 + q3*q3);\n    if (norm == 0.0) {\n        throw new IllegalStateException(\"Quaternion is not normalized\");\n    }\n    return new Vector3D(q1/norm, q2/norm, q3/norm);\n}",
      "public Vector3D getAxis()  {\n    double norm = Math.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    if (norm == 0.0) {\n        throw new IllegalStateException(\"Quaternion is not normalized\");\n    }\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n}",
      "public Vector3D getAxis()  {\n    double norm = Math.sqrt(q1*q1 + q2*q2 + q3*q3);\n    if (norm == 0.0)\n        return new Vector3D(0,0,0);\n    else\n        return new Vector3D(q1/norm, q2/norm, q3/norm);\n}",
      "public Vector3D getAxis()  {\n    double norm = Math.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    if (norm == 0.0) {\n        return new Vector3D(0.0, 0.0, 0.0);\n    } else {\n        return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n    }\n}",
      "public Vector3D getAxis()  {\n    double norm = Math.sqrt(q1*q1 + q2*q2 + q3*q3);\n    if (norm == 0.0)\n        return new Vector3D(0.0, 0.0, 0.0);\n    else\n        return new Vector3D(q1/norm, q2/norm, q3/norm);\n}",
      "public Vector3D getAxis()  {\n    double norm = Math.sqrt(q1*q1 + q2*q2 + q3*q3);\n    if (norm == 0.0) {\n        return new Vector3D(0.0, 0.0, 0.0);\n    }\n    return new Vector3D(q1/norm, q2/norm, q3/norm);\n}"
    ],
    [
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n        if (bytes == null) {\n            return null;\n        }\n\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            byte b = bytes[i];\n            if (b == ESCAPE_CHAR) {\n                if (i + 2 >= bytes.length) {\n                    throw new DecoderException(\"Invalid escape sequence at end of byte array\");\n                }\n                final char hex1 = (char) bytes[++i];\n                final char hex2 = (char) bytes[++i];\n                final int value = Character.digit(hex1, RADIX) << 4 | Character.digit(hex2, RADIX);\n                if (value < 0) {\n                    throw new DecoderException(\"Invalid escape sequence at end of byte array\");\n                }\n                buffer.write(value);\n            } else if (b == '+') {\n                buffer.write(' ');\n            } else {\n                buffer.write(b);\n            }\n        }\n        return buffer.toByteArray();\n    }",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n        if (bytes == null) {\n            return null;\n        }\n\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            int b = bytes[i];\n            if (b == '+') {\n                b = ' ';\n            } else if (b == '%') {\n                if (i + 2 >= bytes.length) {\n                    throw new DecoderException(\"Invalid URL encoding (%)\");\n                }\n                final int d1 = Character.digit(bytes[i + 1], RADIX);\n                final int d2 = Character.digit(bytes[i + 2], RADIX);\n                if (d1 < 0 || d2 < 0) {\n                    throw new DecoderException(\"Invalid URL encoding (%)\");\n                }\n                b = (d1 << 4) + d2;\n                i += 2;\n            }\n            buffer.write(b);\n        }\n        return buffer.toByteArray();\n    }",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n        if (bytes == null) {\n            return null;\n        }\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            byte b = bytes[i];\n            if (b == ESCAPE_CHAR) {\n                if (i + 2 >= bytes.length) {\n                    throw new DecoderException(\"Invalid escape sequence at end of byte array\");\n                }\n                final char hex1 = (char) bytes[++i];\n                final char hex2 = (char) bytes[++i];\n                final int hex = Character.digit(hex1, RADIX) << 4 | Character.digit(hex2, RADIX);\n                if (hex < 0 || hex > 255) {\n                    throw new DecoderException(\"Invalid escape sequence at index \" + i);\n                }\n                buffer.write(hex);\n            } else if (b == '+') {\n                buffer.write(' ');\n            } else {\n                buffer.write(b);\n            }\n        }\n        return buffer.toByteArray();\n    }",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n        if (bytes == null) {\n            return null;\n        }\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            byte b = bytes[i];\n            if (b == ESCAPE_CHAR) {\n                if (i + 2 >= bytes.length) {\n                    throw new DecoderException(\"Invalid escape sequence at end of byte array\");\n                }\n                final char hex1 = (char) bytes[++i];\n                final char hex2 = (char) bytes[++i];\n                final int value = Character.digit(hex1, RADIX) << 4 | Character.digit(hex2, RADIX);\n                if (value < 0 || value > 255) {\n                    throw new DecoderException(\"Invalid URL encoding (not in 0-255 range): \" + hex1 + hex2);\n                }\n                buffer.write(value);\n            } else if (b == '+') {\n                buffer.write(' ');\n            } else {\n                buffer.write(b);\n            }\n        }\n        return buffer.toByteArray();\n    }",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n        if (bytes == null) {\n            return null;\n        }\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            byte b = bytes[i];\n            if (b == ESCAPE_CHAR) {\n                if (i + 2 >= bytes.length) {\n                    throw new DecoderException(\"Invalid escape sequence at end of byte array\");\n                }\n                final char hex1 = (char) bytes[++i];\n                final char hex2 = (char) bytes[++i];\n                final int value = Character.digit(hex1, RADIX) << 4 | Character.digit(hex2, RADIX);\n                buffer.write(value);\n            } else if (b == '+') {\n                buffer.write(' ');\n            } else {\n                buffer.write(b);\n            }\n        }\n        return buffer.toByteArray();\n    }",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n        if (bytes == null) {\n            return null;\n        }\n\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            byte b = bytes[i];\n            if (b == ESCAPE_CHAR) {\n                if (i + 2 >= bytes.length) {\n                    throw new DecoderException(\"Invalid URL encoding: not enough data\");\n                }\n                final char hex1 = (char) bytes[++i];\n                final char hex2 = (char) bytes[++i];\n                final int value = Character.digit(hex1, RADIX) << 4 | Character.digit(hex2, RADIX);\n                buffer.write(value);\n            } else if (b == '+') {\n                buffer.write(' ');\n            } else {\n                buffer.write(b);\n            }\n        }\n        return buffer.toByteArray();\n    }",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n        if (bytes == null) {\n            return null;\n        }\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            byte b = bytes[i];\n            if (b == ESCAPE_CHAR) {\n                if (i + 2 >= bytes.length) {\n                    throw new DecoderException(\"Invalid escape sequence at end of byte array\");\n                }\n                final char hex1 = (char) bytes[++i];\n                final char hex2 = (char) bytes[++i];\n                int value = Character.digit(hex1, RADIX) << 4;\n                value += Character.digit(hex2, RADIX);\n                buffer.write(value);\n            } else if (b == '+') {\n                buffer.write(' ');\n            } else {\n                buffer.write(b);\n            }\n        }\n        return buffer.toByteArray();\n    }",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n        if (bytes == null) {\n            return null;\n        }\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            byte b = bytes[i];\n            if (b == ESCAPE_CHAR) {\n                if (i + 2 >= bytes.length) {\n                    throw new DecoderException(\"Invalid escape sequence at end of byte array\");\n                }\n                final byte hex1 = bytes[++i];\n                final byte hex2 = bytes[++i];\n                if ((hex1 < '0' || hex1 > '9' && hex1 < 'A' || hex1 > 'F' && hex1 < 'a' || hex1 > 'f')\n                        || (hex2 < '0' || hex2 > '9' && hex2 < 'A' || hex2 > 'F' && hex2 < 'a' || hex2 > 'f')) {\n                    throw new DecoderException(\"Invalid escape sequence at index \" + i);\n                }\n                b = (byte) ((Character.digit(hex1, RADIX) << 4) + Character.digit(hex2, RADIX));\n            }\n            buffer.write(b);\n        }\n        return buffer.toByteArray();\n    }",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n        if (bytes == null) {\n            return null;\n        }\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            byte b = bytes[i];\n            if (b == ESCAPE_CHAR) {\n                if (i + 2 >= bytes.length) {\n                    throw new DecoderException(\"Invalid escape sequence at end of byte array\");\n                }\n                final byte hex1 = bytes[++i];\n                final byte hex2 = bytes[++i];\n                int value;\n                try {\n                    value = Integer.parseInt(new String(new byte[] { hex1, hex2 }), RADIX);\n                } catch (NumberFormatException e) {\n                    throw new DecoderException(\"Invalid escape sequence: \" + new String(new byte[] { hex1, hex2 }));\n                }\n                if (value < 0 || value > 255) {\n                    throw new DecoderException(\"Invalid escape sequence: \" + new String(new byte[] { hex1, hex2 }));\n                }\n                buffer.write(value);\n            } else if (b == '+') {\n                buffer.write(' ');\n            } else {\n                buffer.write(b);\n            }\n        }\n        return buffer.toByteArray();\n    }",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n        if (bytes == null) {\n            return null;\n        }\n\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            byte b = bytes[i];\n            if (b == ESCAPE_CHAR) {\n                if (i + 2 >= bytes.length) {\n                    throw new DecoderException(\"Invalid escape sequence at end of byte array\");\n                }\n                final byte hex1 = bytes[++i];\n                final byte hex2 = bytes[++i];\n                int value;\n                try {\n                    value = (Character.digit(hex1, RADIX) << 4) + Character.digit(hex2, RADIX);\n                } catch (NumberFormatException e) {\n                    throw new DecoderException(\"Invalid escape sequence at index \" + i, e);\n                }\n                buffer.write(value);\n            } else if (b == '+') {\n                buffer.write(' ');\n            } else {\n                buffer.write(b);\n            }\n        }\n        return buffer.toByteArray();\n    }"
    ],
    [
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    FieldType[] fields = partial.getFieldTypes();\n    for (int i = 0; i < fields.length - 1; i++) {\n        if (fields[i].getRange() != fields[i + 1].getUnit().getRange()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  throws IllegalArgumentException {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"Partial cannot be null\");\n        }\n        FieldType[] fields = partial.getFieldTypes();\n        for (int i = 0; i < fields.length - 1; i++) {\n            if (!fields[i].getRange().isEqual(fields[i + 1].getUnit())) {\n                return false;\n            }\n        }\n        return true;\n    }",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) \n    {\n        throw new IllegalArgumentException(\"The partial must not be null\");\n    }\n\n    FieldType[] fields = partial.getFieldTypes();\n    for (int i = 0; i < fields.length - 1; i++) \n    {\n        if (fields[i].getRange().getMaximum() != fields[i + 1].getRange().getMinimum()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    FieldType[] fields = partial.getFieldTypes();\n    for (int i = 0; i < fields.length - 1; i++) {\n        if (fields[i].getRange().getMaximum() != fields[i + 1].getRange().getMinimum()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  throws IllegalArgumentException {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"Partial must not be null\");\n        }\n        // Your code goes here\n    }",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    FieldType[] fields = partial.getFieldTypes();\n    for (int i = 0; i < fields.length - 1; i++) {\n        if (fields[i].getRange() != fields[i + 1].getPreviousRange()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  throws IllegalArgumentException {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"Partial cannot be null\");\n        }\n        FieldType[] fields = partial.getFieldTypes();\n        for (int i = 0; i < fields.length - 1; i++) {\n            if (!fields[i].getRange().isEqual(fields[i + 1].getUnit())) {\n                return false;\n            }\n        }\n        return true;\n    }",
      "public static final boolean isContiguous(ReadablePartial partial)  throws IllegalArgumentException {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"Partial cannot be null\");\n        }\n        FieldType[] fields = partial.getFieldTypes();\n        for (int i = 0; i < fields.length - 1; i++) {\n            if (fields[i].getRange().getMaximum() != fields[i + 1].getRange().getMinimum()) {\n                return false;\n            }\n        }\n        return true;\n    }",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) \n    {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    FieldType[] fields = partial.getFieldTypes();\n    for (int i = 0; i < fields.length - 1; i++) \n    {\n        if (fields[i].getRange().getMaximum() != fields[i + 1].getRange().getMinimum()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  throws IllegalArgumentException {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"Partial cannot be null\");\n        }\n        FieldType[] fields = partial.getFieldTypes();\n        for (int i = 0; i < fields.length - 1; i++) {\n            if (!fields[i].getRange().isEqual(fields[i + 1].getUnit())) {\n                return false;\n            }\n        }\n        return true;\n    }"
    ],
    [
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n        SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n        for (O obj : a) {\n            int countA = count(a, obj);\n            int countB = count(b, obj);\n            helper.setCardinality(obj, Math.max(countA, countB));\n        }\n        return helper.list();\n    }",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n        SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n        for (O obj : helper) {\n            int countA = count(a, obj);\n            int countB = count(b, obj);\n            helper.setCardinality(obj, Math.max(countA, countB));\n        }\n        return helper.list();\n    }",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n        SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n        for (O obj : a) {\n            int countA = 0;\n            for (O objA : a) {\n                if (obj.equals(objA)) {\n                    countA++;\n                }\n            }\n            int countB = 0;\n            for (O objB : b) {\n                if (obj.equals(objB)) {\n                    countB++;\n                }\n            }\n            helper.setCardinality(obj, Math.max(countA, countB));\n        }\n        for (O obj : b) {\n            int countB = 0;\n            for (O objB : b) {\n                if (obj.equals(objB)) {\n                    countB++;\n                }\n            }\n            int countA = 0;\n            for (O objA : a) {\n                if (obj.equals(objA)) {\n                    countA++;\n                }\n            }\n            if (countB > countA) {\n                helper.setCardinality(obj, countB);\n            }\n        }\n        return helper.list();\n    }",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n        SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n        for (O obj : helper) {\n            int countA = count(a, obj);\n            int countB = count(b, obj);\n            helper.setCardinality(obj, Math.max(countA, countB));\n        }\n        return helper.list();\n    }",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    if (a == null || b == null) {\n        throw new IllegalArgumentException(\"Inputs must not be null\");\n    }\n    SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (O obj : a) {\n        int count = countOccurrences(a, obj);\n        int count2 = countOccurrences(b, obj);\n        helper.setCardinality(obj, Math.max(count, count2));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n        SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n        for (O obj : helper) {\n            int countA = count(a, obj);\n            int countB = count(b, obj);\n            helper.setCardinality(obj, Math.max(countA, countB));\n        }\n        return helper.list();\n    }",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    if (a == null || b == null)\n        throw new IllegalArgumentException(\"Inputs must not be null\");\n\n    SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n\n    int maxCardinality = 0;\n    for (O obj : helper) {\n        int countA = count(a, obj);\n        int countB = count(b, obj);\n        int cardinality = Math.max(countA, countB);\n        if (cardinality > maxCardinality) {\n            maxCardinality = cardinality;\n        }\n        helper.setCardinality(obj, cardinality);\n    }\n\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n        SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n        for (O obj : a) {\n            int countA = count(a, obj);\n            int countB = count(b, obj);\n            helper.setCardinality(obj, Math.max(countA, countB));\n        }\n        return helper.list();\n    }",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n        SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n        for (O obj : helper) {\n            int count = Math.max(Collections.frequency(a, obj), Collections.frequency(b, obj));\n            helper.setCardinality(obj, count);\n        }\n        return helper.list();\n    }",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    if (a == null || b == null) \n    {\n        throw new IllegalArgumentException(\"Inputs must not be null\");\n    }\n\n    SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n\n    Iterator<? extends O> ai = a.iterator();\n    while (ai.hasNext()) \n    {\n        O obj = ai.next();\n        int count = 0;\n        Iterator<? extends O> bi = b.iterator();\n        while (bi.hasNext()) \n        {\n            if (Objects.equals(obj, bi.next())) \n            {\n                count++;\n                bi.remove();\n            }\n        }\n        helper.setCardinality(obj, Math.max(count, ai.nextIndex()));\n    }\n\n    // remaining elements in b are unique, so add them to the result\n    helper.setCardinality(b, b.iterator());\n\n    return helper.list();\n}"
    ],
    [
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    for (Node param : params.getChildren()) {\n        if (param.isIdentifier()) {\n            result.add(IR.string(param.getFirstChild().getFirstChild().getFirstChild().getText()));\n        }\n    }\n    return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    for (Node child = params.getFirstChild(); child != null; child = child.getNext()) \n    {\n        if (child.is(J.IDENT)) \n        {\n            result.add(IR.string(child.getString()));\n        } \n        else \n        {\n            throw new IllegalArgumentException(\"Unexpected node type: \" + child.getClass().getName());\n        }\n    }\n    return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<Node>();\n    for (Node param : params.getChildren()) \n    {\n        result.add(IR.string(param.getFirstChild().getFirstChild().getFirstChild().getFirstChild()));\n    }\n    return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<Node>();\n    for (Node param : NodeUtil.getChildNodes(params)) \n    {\n        if (param.isIdentifier()) \n        {\n            result.add(IR.string(param.getFirstChild().getFirstChild().getToken().getStringValue()));\n        }\n    }\n    return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<Node>();\n    for (Node child = params.getFirstChild(); child != null; child = child.getNext()) \n    {\n        if (child.is(J.P)) \n        {\n            result.add(IR.string(child.getFirstChild().getString()));\n        } \n        else \n        {\n            result.add(IR.string(child.getString()));\n        }\n    }\n    return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    for (Node child = params.getFirstChild(); child != null; child = child.getNext()) \n    {\n        if (child.isIdentifier()) \n        {\n            result.add(IR.string(child.getFirstChild().getString()));\n        }\n    }\n    return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    for (Node param : NodeUtil.getChildNodes(params)) \n    {\n        if (param.is(J.P)) \n        {\n            result.add(IR.string(param.getFirstChild().getFirstChild().getFirstChild().getString()));\n        }\n    }\n    return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<Node>();\n    for (Node child = params.getFirstChild(); child != null; child = child.getNext()) \n    {\n        if (child.is(J.ID)) \n        {\n            result.add(IR.string(child.getFirstChild().getString()));\n        }\n    }\n    return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<Node>();\n    for (Node child = params.getFirstChild(); child != null; child = child.getNext()) \n    {\n        if (child.isIdentifier()) \n        {\n            result.add(IR.string(child.getFirstChild().getString()));\n        } \n        else \n        {\n            result.add(IR.string(child.getFirstChild().getFirstChild().getString()));\n        }\n    }\n    return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    for (Node child = params.getFirstChild(); child != null; child = child.getNext()) \n    {\n        if (child.is(J.P)) \n        {\n            result.add(IR.string(child.getFirstChild().getString()));\n        } \n        else \n        {\n            result.add(IR.string(child.getString()));\n        }\n    }\n    return result;\n}"
    ],
    [
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}"
    ],
    [
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (str.length() == 0 || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } \n        else \n        {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n        else \n        {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null) \n    {\n        return null;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (str.length() == 0 || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } \n        else \n        {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (str.isEmpty() || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n        else \n        {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null || str.isEmpty()) \n    {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) \n    {\n        return str.substring(0, 1).toUpperCase() + str.substring(1).toLowerCase();\n    }\n\n    StringBuilder result = new StringBuilder();\n    String[] words = str.split(\"[^a-zA-Z0-9\" + new String(delimiters) + \"]\");\n    for (String word : words) \n    {\n        if (!word.isEmpty()) \n        {\n            result.append(word.substring(0, 1).toUpperCase());\n            result.append(word.substring(1).toLowerCase());\n        }\n    }\n    return result.toString();\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (str.length() == 0 || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext && Character.isLetter(ch)) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } \n        else \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n        else \n        {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (str.isEmpty()) \n    {\n        return \"\";\n    }\n    if (delimiters == null || delimiters.length == 0) \n    {\n        return str.substring(0, 1).toUpperCase() + str.substring(1).toLowerCase();\n    }\n    StringBuilder result = new StringBuilder();\n    String[] words = str.split(\"[^\\\\p{L}]\");\n    for (int i = 0; i < words.length; i++) \n    {\n        if (i > 0) \n        {\n            result.append(delimiters[0]);\n        }\n        result.append(capitalize(words[i], delimiters));\n    }\n    return result.toString();\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null) \n    {\n        return null;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (str.length() == 0 || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n        else \n        {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n        else \n        {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}"
    ],
    [
      "private static synchronized String getConvertedId(String id)  {\n    SecurityManager sm = System.getSecurityManager();\n    if (sm != null) \n    {\n        sm.checkPermission(new JodaTimePermission(\"DateTimeZone.getConvertedId\"));\n    }\n\n    String convertedId = null;\n\n    if (id != null && id.length() > 0) \n    {\n        convertedId = cIdConverter.convert(id);\n    }\n\n    return convertedId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) \n    {\n        return null;\n    }\n\n    // 1. Check the cache\n    String convertedId = cIdCache.get(id);\n    if (convertedId != null) \n    {\n        return convertedId;\n    }\n\n    // 2. Check the provider\n    convertedId = getProvider().getID(id);\n    if (convertedId != null) \n    {\n        // Add to cache\n        cIdCache.put(id, convertedId);\n        return convertedId;\n    }\n\n    // 3. Check the system property\n    String sysPropId = System.getProperty(\"org.joda.time.DateTimeZone.\" + id);\n    if (sysPropId != null) \n    {\n        // Add to cache\n        cIdCache.put(id, sysPropId);\n        return sysPropId;\n    }\n\n    // 4. Check the default name provider\n    sysPropId = getNameProvider().getID(id);\n    if (sysPropId != null) \n    {\n        // Add to cache\n        cIdCache.put(id, sysPropId);\n        return sysPropId;\n    }\n\n    // 5. Check the old style ids\n    if (id.length() == 3) \n    {\n        // Add to cache\n        cIdCache.put(id, id);\n        return id;\n    }\n\n    // Not found\n    return null;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    // Your code goes here\n}",
      "private static synchronized String getConvertedId(String id)  {\n    SecurityManager sm = System.getSecurityManager();\n    if (sm != null) \n    {\n        sm.checkPermission(new JodaTimePermission(\"DateTimeZone.getConvertedId\"));\n    }\n\n    String convertedId = null;\n\n    if (id != null) \n    {\n        // Check for known old ids\n        if (id.equals(\"WET\")) \n        {\n            convertedId = \"WET\";\n        } \n        else if (id.equals(\"WEST\")) \n        {\n            convertedId = \"WET\";\n        } \n        else if (id.equals(\"CET\")) \n        {\n            convertedId = \"CEST\";\n        } \n        else if (id.equals(\"EET\")) \n        {\n            convertedId = \"EEST\";\n        } \n        else if (id.equals(\"MET\")) \n        {\n            convertedId = \"MET\";\n        } \n        else if (id.equals(\"MEZ\")) \n        {\n            convertedId = \"MET\";\n        } \n        else if (id.equals(\"PST\")) \n        {\n            convertedId = \"PST\";\n        } \n        else if (id.equals(\"PWT\")) \n        {\n            convertedId = \"PWT\";\n        } \n        else if (id.equals(\"CVT\")) \n        {\n            convertedId = \"CVT\";\n        } \n        else if (id.equals(\"AST\")) \n        {\n            convertedId = \"AST\";\n        } \n        else if (id.equals(\"ART\")) \n        {\n            convertedId = \"ART\";\n        } \n        else if (id.equals(\"BRT\")) \n        {\n            convertedId = \"BRT\";\n        } \n        else if (id.equals(\"CCT\")) \n        {\n            convertedId = \"CCT\";\n        } \n        else if (id.equals(\"GFT\")) \n        {\n            convertedId = \"GFT\";\n        } \n        else if (id.equals(\"IET\")) \n        {\n            convertedId = \"IET\";\n}\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) \n    {\n        return null;\n    }\n    String convertedId = null;\n    try \n    {\n        convertedId = cNameProvider.getZoneText(id);\n    } \n    catch (IllegalArgumentException ex) \n    {\n        // Ignore, id not found\n    }\n    return convertedId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) \n    {\n        return null;\n    }\n    if (cIdConversion == null) \n    {\n        cIdConversion = new HashMap<String, String>();\n        cIdConversion.put(\"GMT\", \"UTC\");\n        cIdConversion.put(\"Greenwich\", \"UTC\");\n        cIdConversion.put(\"CET\", \"CentralEuropeanStandardTime\");\n        cIdConversion.put(\"EET\", \"EasternEuropeanStandardTime\");\n        cIdConversion.put(\"EST\", \"EasternStandardTime\");\n        cIdConversion.put(\"MST\", \"MountainStandardTime\");\n        cIdConversion.put(\"PST\", \"PacificStandardTime\");\n        cIdConversion.put(\"WAT\", \"CentralAfricanStandardTime\");\n        cIdConversion.put(\"CST\", \"CentralStandardTime\");\n        cIdConversion.put(\"WET\", \"WesternEuropeanStandardTime\");\n        cIdConversion.put(\"WST\", \"WesternStandardTime\");\n        cIdConversion.put(\"JST\", \"JapanStandardTime\");\n        cIdConversion.put(\"AEDT\", \"AustralianEasternStandardTime\");\n        cIdConversion.put(\"ACST\", \"AustralianCentralStandardTime\");\n        cIdConversion.put(\"AEST\", \"AustralianEasternStandardTime\");\n        cIdConversion.put(\"AFT\", \"AfghanStandardTime\");\n        cIdConversion.put(\"ALMT\", \"Alma-AtollStandardTime\");\n        cIdConversion.put(\"AMST\", \"AmazonStandardTime\");\n        cIdConversion.put(\"ANAT\", \"AnadyrStandardTime\");\n        cIdConversion.put(\"AoE\", \"AustralianEasternStandardTime\");\n        cIdConversion.put(\"AQTT\", \"AqtobeStandardTime\");\n        cIdConversion.put(\"ART\", \"ArgentinaStandardTime\");\n        cIdConversion.put(\"Asia/Aden\", \"AdenStandardTime\");\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    // Code goes here\n}",
      "private static synchronized String getConvertedId(String id)  {\n    SecurityManager sm = System.getSecurityManager();\n    if (sm != null) \n    {\n        sm.checkPermission(new JodaTimePermission(\"DateTimeZone.getConvertedId\"));\n    }\n\n    if (id == null) \n    {\n        return null;\n    }\n\n    String convertedId = cIdConversionMap.get(id);\n    if (convertedId == null) \n    {\n        convertedId = getDefaultIdConversionMap().get(id);\n        if (convertedId == null) \n        {\n            return id;\n        }\n    }\n\n    return convertedId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) \n    {\n        return null;\n    }\n    String convertedId = idMap.get(id);\n    if (convertedId == null) \n    {\n        convertedId = id;\n    }\n    return convertedId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) \n    {\n        return null;\n    }\n\n    String convertedId = null;\n\n    // Add your code here\n    // ...\n\n    return convertedId;\n}"
    ],
    [
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    // Check that the dimensions match\n    if (params.length != point.length) {\n        throw new DimensionMismatchException(params.length, point.length);\n    }\n\n    // Compute the Jacobian matrix\n    weightedResiduals = jF.gradient(params);\n\n    // Compute the square-root of the weight matrix\n    if (weightMatrixSqrt == null) {\n        weightMatrixSqrt = MatrixUtils.createRealMatrix(rows, cols);\n    }\n\n    // Multiply the weighted residuals by the square-root of the weight matrix\n    weightedResiduals = weightMatrixSqrt.preMultiply(weightedResiduals).getData();\n\n    return MatrixUtils.createColumnRealMatrix(weightedResiduals);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    if (weightMatrixSqrt == null) {\n        throw new IllegalStateException(\"Weight matrix not initialized\");\n    }\n    // Increment the Jacobian evaluation counter\n    jacobianEvaluations++;\n    // Compute the Jacobian matrix\n    RealMatrix jacobian = jF.gradient(params);\n    // Return the weighted Jacobian\n    return weightMatrixSqrt.multiply(jacobian);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    if (jF == null) {\n        throw new IllegalStateException(\"Function not set\");\n    }\n    if (weightMatrixSqrt == null) {\n        throw new IllegalStateException(\"Weight matrix not set\");\n    }\n\n    final double[] values = jF.value(params);\n    final double[][] jacobian = jF.jacobian(params);\n\n    weightedResiduals = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        weightedResiduals[i] = values[i] * weightMatrixSqrt.getEntry(i, i);\n    }\n\n    final RealMatrix weightedJacobian = MatrixUtils.createRealMatrix(jacobian);\n    weightedJacobian.scalarMultiply(weightMatrixSqrt);\n\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n        if (weightMatrixSqrt == null) {\n            throw new IllegalStateException(\"Weight matrix is not initialized.\");\n        }\n        final RealVector r = jF.gradient(params);\n        weightedResiduals = r.toArray();\n        final double[][] weightedResidualsArray = new double[weightedResiduals.length][1];\n        for (int i = 0; i < weightedResiduals.length; i++) {\n            weightedResidualsArray[i][0] = weightedResiduals[i];\n        }\n        final RealMatrix weightedResidualsMatrix = MatrixUtils.createRealMatrix(weightedResidualsArray);\n        return weightMatrixSqrt.multiply(weightedResidualsMatrix);\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n        if (weightMatrixSqrt == null) {\n            weightMatrixSqrt = MatrixUtils.createRealMatrix(getCovariances(params)).scalarMultiply(0.5).choleskyDecomposition().getSolver().getInverse();\n        }\n        weightedResiduals = getResiduals(params);\n        RealMatrix jacobian = jF.gradient(params);\n        return weightMatrixSqrt.multiply(jacobian);\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n        if (jF == null) {\n            throw new IllegalStateException(\"Function not set\");\n        }\n        final double[] values = jF.value(params);\n        final double[][] jacobian = jF.jacobian(params);\n        weightedResiduals = new double[values.length];\n        for (int i = 0; i < values.length; ++i) {\n            weightedResiduals[i] = values[i] * weightMatrixSqrt.getEntry(i, i);\n        }\n        final RealMatrix weightedJacobian = MatrixUtils.createRealMatrix(jacobian)\n                .scalarMultiply(weightMatrixSqrt);\n        weightedResidualJacobian = weightedJacobian.getData();\n        return weightedJacobian;\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n        // Check if the weight matrix square root is initialized\n        if (weightMatrixSqrt == null) {\n            throw new IllegalStateException(\"Weight matrix square root is not initialized\");\n        }\n\n        // Initialize the Jacobian matrix\n        weightedResiduals = new double[rows];\n        weightedResidualJacobian = new double[rows][cols];\n\n        // Compute the weighted residuals\n        for (int i = 0; i < rows; i++) {\n            weightedResiduals[i] = objective[i] / Math.sqrt(weightMatrixSqrt.getEntry(i, i));\n        }\n\n        // Compute the weighted Jacobian\n        jF.gradient(params, weightedResiduals, weightedResidualJacobian);\n\n        // Return the weighted Jacobian\n        return weightMatrixSqrt.multiply(MatrixUtils.createRealMatrix(weightedResidualJacobian));\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    // TODO: Implement the method\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n        // Increment the counter for the number of Jacobian evaluations\n        jacobianEvaluations++;\n\n        // Compute the objective function value at the current point\n        objective = jF.value(params);\n\n        // Compute the weighted residuals\n        weightedResiduals = new double[objective.length];\n        for (int i = 0; i < objective.length; i++) {\n            weightedResiduals[i] = objective[i] * weightMatrixSqrt.getEntry(i, i);\n        }\n\n        // Compute the Jacobian matrix\n        double[][] jacobian = jF.gradient(params);\n\n        // Compute the weighted Jacobian\n        RealMatrix weightedJacobian = MatrixUtils.createRealMatrix(jacobian);\n        weightedJacobian = weightedJacobian.scalarMultiply(weightMatrixSqrt);\n\n        return weightedJacobian;\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n        // Your code here\n        return null;\n    }"
    ],
    [
      "private int least()  {\n        if (comparator == null) {\n            throw new NullPointerException(\"No comparator set\");\n        }\n        int leastIndex = -1;\n        E leastValue = null;\n        for (int i = 0; i < values.size(); i++) {\n            if (valueSet.get(i)) {\n                E value = values.get(i);\n                if (leastIndex == -1 || comparator.compare(value, leastValue) < 0) {\n                    leastIndex = i;\n                    leastValue = value;\n                }\n            }\n        }\n        return leastIndex;\n    }",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int leastIndex = -1;\n    E leastValue = null;\n    for (int i = 0; i < values.size(); i++) {\n        if (!valueSet.get(i)) {\n            if (!set(i)) {\n                return -1;\n            }\n        }\n        final E val = values.get(i);\n        if (leastIndex == -1 || comparator.compare(val, leastValue) < 0) {\n            leastIndex = i;\n            leastValue = val;\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n        if (comparator == null) {\n            throw new NullPointerException(\"No comparator set\");\n        }\n        int leastIndex = -1;\n        E leastValue = null;\n        for (int i = 0; i < values.size(); i++) {\n            if (valueSet.get(i)) {\n                if (leastIndex == -1 || comparator.compare(values.get(i), leastValue) < 0) {\n                    leastIndex = i;\n                    leastValue = values.get(i);\n                }\n            }\n        }\n        return leastIndex;\n    }",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int leastIndex = -1;\n    E leastValue = null;\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i)) {\n            E value = values.get(i);\n            if (leastIndex == -1 || comparator.compare(value, leastValue) < 0) {\n                leastIndex = i;\n                leastValue = value;\n            }\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n\n    int leastIndex = -1;\n    E leastValue = null;\n    for (int i = 0; i < values.size(); i++) {\n        if (!valueSet.get(i)) {\n            if (!set(i)) {\n                return -1;\n            }\n        }\n        final E val = values.get(i);\n        if (leastIndex == -1 || comparator.compare(val, leastValue) < 0) {\n            leastIndex = i;\n            leastValue = val;\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int leastIndex = -1;\n    E leastValue = null;\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i)) {\n            E value = values.get(i);\n            if (leastIndex == -1 || comparator.compare(value, leastValue) < 0) {\n                leastIndex = i;\n                leastValue = value;\n            }\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int leastIndex = -1;\n    E leastValue = null;\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i)) {\n            if (leastIndex == -1 || comparator.compare(values.get(i), leastValue) < 0) {\n                leastIndex = i;\n                leastValue = values.get(i);\n            }\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int leastIndex = -1;\n    E leastValue = null;\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i)) {\n            E value = values.get(i);\n            if (leastIndex == -1 || comparator.compare(value, leastValue) < 0) {\n                leastIndex = i;\n                leastValue = value;\n            }\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n        if (comparator == null) {\n            throw new NullPointerException(\"No comparator set\");\n        }\n        int leastIndex = -1;\n        E leastValue = null;\n        for (int i = 0; i < values.size(); i++) {\n            if (!valueSet.get(i)) {\n                if (!set(i)) {\n                    return -1;\n                }\n            }\n            final E val = values.get(i);\n            if (leastIndex == -1 || comparator.compare(val, leastValue) < 0) {\n                leastIndex = i;\n                leastValue = val;\n            }\n        }\n        return leastIndex;\n    }",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int leastIndex = -1;\n    E leastValue = null;\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i)) {\n            if (leastIndex == -1 || comparator.compare(values.get(i), leastValue) < 0) {\n                leastIndex = i;\n                leastValue = values.get(i);\n            }\n        }\n    }\n    if (leastIndex != -1 && !set(leastIndex)) {\n        leastIndex = -1;\n    }\n    return leastIndex;\n}"
    ],
    [
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        NodePointer childPointer;\n        if (step.getAxis() == Compiler.AXIS_SELF) {\n            childPointer = parentPointer;\n        } else {\n            childPointer = parentPointer.getChildPointer(step.getName());\n        }\n        return childPointer;\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        NodePointer childPointer;\n        if (step.getAxis() == Compiler.AXIS_SELF) {\n            childPointer = parentPointer;\n        } else {\n            childPointer = parentPointer.getChildPointer(step.getNodeType());\n        }\n        return childPointer;\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    NodePointer childPointer;\n    String propertyName = step.getPropertyName();\n\n    if (step.getAxis() == Compiler.AXIS_SELF) {\n        childPointer = parentPointer;\n    } else {\n        childPointer = parentPointer.getChild(propertyName);\n    }\n\n    return childPointer;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        if (step.getAxis() == Compiler.AXIS_SELF) {\n            return parentPointer;\n        }\n        if (step.getAxis() == Compiler.AXIS_CHILD) {\n            return parentPointer.getFirstChild();\n        }\n        if (step.getAxis() == Compiler.AXIS_DESCENDANT) {\n            return parentPointer.getFirstChild();\n        }\n        if (step.getAxis() == Compiler.AXIS_ATTRIBUTE) {\n            return parentPointer.getAttribute(step.getName());\n        }\n        if (step.getAxis() == Compiler.AXIS_NAMESPACE) {\n            return parentPointer.getNamespace(step.getName());\n        }\n        return null;\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        if (step.getAxis() == Compiler.AXIS_SELF) {\n            return parentPointer;\n        }\n        if (step.getAxis() == Compiler.AXIS_CHILD) {\n            return parentPointer.getFirstChild();\n        }\n        if (step.getAxis() == Compiler.AXIS_DESCENDANT) {\n            return parentPointer.getFirstChild();\n        }\n        if (step.getAxis() == Compiler.AXIS_ATTRIBUTE) {\n            return parentPointer.getAttributeNode(step.getName());\n        }\n        if (step.getAxis() == Compiler.AXIS_NAMESPACE) {\n            return parentPointer.getNamespaceNode(step.getName());\n        }\n        return null;\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        NodePointer childPointer;\n        String propertyName = step.getProperty();\n        if (step.getAxis() == Compiler.AXIS_SELF) {\n            childPointer = parentPointer;\n        } else {\n            childPointer = parentPointer.getChildPointer(propertyName);\n        }\n        return childPointer;\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    // TODO: Implement this method\n    return null;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        // Your code here\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    NodePointer childPointer = null;\n    if (step.getAxis() == Compiler.AXIS_SELF) {\n        childPointer = parentPointer;\n    } else if (step.getAxis() == Compiler.AXIS_CHILD) {\n        childPointer = parentPointer.getFirstChild();\n    } else if (step.getAxis() == Compiler.AXIS_DESCENDANT) {\n        childPointer = parentPointer.getFirstChild();\n        if (childPointer == null) {\n            childPointer = parentPointer.getFirstAttribute();\n        }\n    } else if (step.getAxis() == Compiler.AXIS_ANCESTOR) {\n        childPointer = parentPointer.getParent();\n    } else if (step.getAxis() == Compiler.AXIS_FOLLOWING_SIBLING) {\n        childPointer = parentPointer.getNextSibling();\n    } else if (step.getAxis() == Compiler.AXIS_PRECEDING_SIBLING) {\n        childPointer = parentPointer.getPreviousSibling();\n    }\n    return childPointer;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        NodePointer childPointer;\n        String propertyName = step.getPropertyName();\n        if (step.getAxis() == Compiler.AXIS_SELF) {\n            childPointer = parentPointer;\n        } else {\n            childPointer = parentPointer.getChild(propertyName);\n        }\n        return childPointer;\n    }"
    ],
    [
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        return Double.NEGATIVE_INFINITY;\n    } else {\n        return ((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation().get(0);\n    }\n}",
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    if (getTree(false).getLeft().getCut() == null) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    return ((OrientedPoint) getTree(false).getLeft().getCut().getHyperplane()).getLocation().get(0);\n}",
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        return Double.POSITIVE_INFINITY;\n    }\n    return ((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation().get(0);\n}",
      "public double getInf()  {\n    if (getTree(false).getCut() == null) \n    {\n        return Double.NEGATIVE_INFINITY;\n    } \n    else \n    {\n        return ((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation().get(0);\n    }\n}",
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        return Double.POSITIVE_INFINITY;\n    } \n    else \n    {\n        return ((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation().get(0);\n    }\n}",
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        return Double.POSITIVE_INFINITY;\n    }\n    if (getTree(false).getLeft().getCut() == null) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    return ((OrientedPoint) getTree(false).getLeft().getCut().getHyperplane()).getLocation().get(0);\n}",
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    else if (getTree(false).getAttribute() == Boolean.TRUE) {\n        return Double.POSITIVE_INFINITY;\n    }\n    else {\n        return ((OrientedPoint) getTree(false).getCut().getHyperplane().getVertex(0).getPoint()).getLocation().get(0);\n    }\n}",
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        return Double.POSITIVE_INFINITY;\n    }\n    if (getTree(false).getLeft().getCut() == null) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    return ((OrientedPoint) getTree(false).getLeft().getCut().getHyperplane()).getLocation().get(0);\n}",
      "public double getInf()  {\n    if (getTree(false).getCut() == null) \n    {\n        return Double.NEGATIVE_INFINITY;\n    } \n    else \n    {\n        return ((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation().get(0);\n    }\n}",
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        return Double.NEGATIVE_INFINITY;\n    } else {\n        return ((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation().get(0);\n    }\n}"
    ],
    [
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    return cache.computeIfAbsent(definingCalendar.getLocale(), new Function<Locale, Strategy>() {\n}\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    Locale locale= definingCalendar.getLocale();\n    Strategy strategy= cache.get(locale);\n    if(strategy==null) {\n        strategy= new TextStrategy(field, definingCalendar);\n        cache.putIfAbsent(locale, strategy);\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    return cache.computeIfAbsent(definingCalendar.getLocale(), new Function<Locale, Strategy>() {\n}\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n        ConcurrentMap<Locale, Strategy> cache= getCache(field);\n        Locale locale= definingCalendar.getLocale();\n        Strategy strategy= cache.get(locale);\n        if(strategy==null) {\n            strategy= new TextStrategy(field, definingCalendar);\n            cache.putIfAbsent(locale, strategy);\n        }\n        return strategy;\n    }",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    Locale locale= definingCalendar.getLocale();\n    Strategy strategy= cache.get(locale);\n    if(strategy==null) {\n        strategy= new TextStrategy(field, definingCalendar);\n        cache.putIfAbsent(locale, strategy);\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    return cache.computeIfAbsent(definingCalendar.getLocale(), new Function<Locale, Strategy>() {\n}\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n        ConcurrentMap<Locale, Strategy> cache= getCache(field);\n        Locale locale= definingCalendar.getLocale();\n        Strategy strategy= cache.get(locale);\n        if(strategy==null) {\n            strategy= new TextStrategy(field, definingCalendar);\n            cache.putIfAbsent(locale, strategy);\n        }\n        return strategy;\n    }",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n        ConcurrentMap<Locale, Strategy> cache= getCache(field);\n        Locale locale= definingCalendar.getLocale();\n        Strategy strategy= cache.get(locale);\n        if(strategy==null) {\n            strategy= new TextStrategy(field, definingCalendar);\n            cache.putIfAbsent(locale, strategy);\n            strategy= cache.get(locale);\n        }\n        return strategy;\n    }",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    final Locale locale= definingCalendar.getLocale();\n    Strategy strategy= cache.get(locale);\n    if(strategy==null) {\n        strategy= new TextStrategy(field, definingCalendar);\n        cache.putIfAbsent(locale, strategy);\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n        ConcurrentMap<Locale, Strategy> cache= getCache(field);\n        Locale locale= definingCalendar.getLocale();\n        Strategy strategy= cache.get(locale);\n        if(strategy==null) {\n            strategy= new TextStrategy(field, definingCalendar);\n            cache.putIfAbsent(locale, strategy);\n        }\n        return strategy;\n    }"
    ],
    [
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        nextObject = iterator.next();\n        if (predicate.test(nextObject)) {\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        nextObject = iterator.next();\n        if (predicate.test(nextObject)) {\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) \n    {\n        nextObject = iterator.next();\n        if (predicate.test(nextObject)) \n        {\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) \n    {\n        nextObject = iterator.next();\n        if (predicate.test(nextObject)) \n        {\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        nextObject = iterator.next();\n        if (predicate.test(nextObject)) {\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        nextObject = iterator.next();\n        if (predicate.test(nextObject)) {\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        nextObject = iterator.next();\n        if (predicate.test(nextObject)) {\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) \n    {\n        nextObject = iterator.next();\n        if (predicate.test(nextObject)) \n        {\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) \n    {\n        nextObject = iterator.next();\n        if (predicate.test(nextObject)) \n        {\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) \n    {\n        nextObject = iterator.next();\n        if (predicate.test(nextObject)) \n        {\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}"
    ],
    [
      "private double[] repair(final double[] x)  {\n            final double[] lB = CMAESOptimizer.this.getLowerBound();\n            final double[] uB = CMAESOptimizer.this.getUpperBound();\n            double[] repaired = new double[x.length];\n\n            for (int i = 0; i < x.length; i++) {\n                repaired[i] = Math.max(lB[i], Math.min(x[i], uB[i]));\n            }\n\n            return repaired;\n        }",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    for (int i = 0; i < x.length; i++) \n    {\n        repaired[i] = Math.max(lB[i], Math.min(x[i], uB[i]));\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n            final double[] lB = CMAESOptimizer.this.getLowerBound();\n            final double[] uB = CMAESOptimizer.this.getUpperBound();\n            double[] repaired = new double[x.length];\n\n            for (int i = 0; i < x.length; i++) {\n                repaired[i] = Math.max(lB[i], Math.min(x[i], uB[i]));\n            }\n\n            return repaired;\n        }",
      "private double[] repair(final double[] x)  {\n            final double[] lB = CMAESOptimizer.this.getLowerBound();\n            final double[] uB = CMAESOptimizer.this.getUpperBound();\n            double[] repaired = new double[x.length];\n\n            for (int i = 0; i < x.length; i++) {\n                repaired[i] = Math.max(lB[i], Math.min(uB[i], x[i]));\n            }\n            return repaired;\n        }",
      "private double[] repair(final double[] x)  {\n            final double[] lB = CMAESOptimizer.this.getLowerBound();\n            final double[] uB = CMAESOptimizer.this.getUpperBound();\n            double[] repaired = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                repaired[i] = Math.max(lB[i], Math.min(uB[i], x[i]));\n            }\n            return repaired;\n        }",
      "private double[] repair(final double[] x)  {\n            final double[] lB = CMAESOptimizer.this.getLowerBound();\n            final double[] uB = CMAESOptimizer.this.getUpperBound();\n            double[] repaired = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                repaired[i] = Math.max(lB[i], Math.min(uB[i], x[i]));\n            }\n            return repaired;\n        }",
      "private double[] repair(final double[] x)  {\n            final double[] lB = CMAESOptimizer.this.getLowerBound();\n            final double[] uB = CMAESOptimizer.this.getUpperBound();\n            double[] repaired = new double[x.length];\n\n            for (int i = 0; i < x.length; i++) {\n                repaired[i] = Math.max(lB[i], Math.min(x[i], uB[i]));\n            }\n            return repaired;\n        }",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n            final double[] lB = CMAESOptimizer.this.getLowerBound();\n            final double[] uB = CMAESOptimizer.this.getUpperBound();\n            double[] repaired = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                repaired[i] = Math.max(lB[i], Math.min(uB[i], x[i]));\n            }\n            return repaired;\n        }",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    for (int i = 0; i < x.length; i++) \n    {\n        repaired[i] = Math.max(lB[i], Math.min(x[i], uB[i]));\n    }\n    return repaired;\n}"
    ],
    [
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final int n = matrix.getRowDimension();\n    final double[][] z = new double[n][n];\n    final double[] realEigenvalues = new double[n];\n    final double[][] a = matrix.getData();\n\n    // Copy input matrix to z\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            z[i][j] = a[i][j];\n        }\n    }\n\n    // Transform to Schur form\n    for (int k = 0; k < n; k++) {\n        double scale = 0.0;\n        double h = 0.0;\n        for (int i = k; i < n; i++) {\n            double f = scale * a[i][k];\n            if (f != 0.0) {\n                h += f * f;\n            }\n            scale = a[i][k];\n        }\n        double g = Math.sqrt(h);\n        if (scale < 0.0) {\n            g = -g;\n        }\n        realEigenvalues[k] = h = a[k][k] - g;\n        if (k != 0) {\n            realEigenvalues[k - 1] = a[k - 1][k - 1];\n        }\n        double f = 0.0;\n        for (int j = k; j < n; j++) {\n            a[j][k] = f;\n            f = 0.0;\n            for (int i = k; i < n; i++) {\n                f += a[j][i] * a[i][k];\n            }\n            f = (f / h) + g;\n            for (int i = k; i < n; i++) {\n                a[j][i] -= f * a[k][i];\n            }\n        }\n        for (int i = k; i < n; i++) {\n            a[i][k] = a[k][i] = 0.0;\n        }\n    }\n\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    int n = matrix.getRowDimension();\n    double[][] a = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            a[i][j] = matrix.getEntry(i, j);\n        }\n    }\n    return new SchurTransformer(a, n);\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    int n = matrix.getRowDimension();\n    double[][] a = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            a[i][j] = matrix.getEntry(i, j);\n        }\n    }\n    return new SchurTransformer(a, n);\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n        // Your code here\n        return new SchurTransformer(matrix);\n    }",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    int n = matrix.getRowDimension();\n    double[][] z = new double[n][n];\n    double[] realEigenvalues = new double[n];\n    double[][] a = matrix.getData();\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            z[i][j] = a[i][j];\n        }\n        realEigenvalues[i] = a[i][i];\n    }\n\n    //Transform to Schur form\n    transformToSchur(z, realEigenvalues, n);\n\n    return new SchurTransformer(realEigenvalues, z);\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // Your code here\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final int n = matrix.getRowDimension();\n    final double[][] a = matrix.getData();\n    final double[][] z = new double[n][n];\n    final double[] realEigenvalues = new double[n];\n    final double[][] t = new double[n][n];\n    final double[][] y = new double[n][n];\n\n    // Copy matrix to t\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            t[i][j] = a[i][j];\n        }\n    }\n\n    // Initialize y to identity matrix\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            y[i][j] = (i == j) ? 1.0 : 0.0;\n        }\n    }\n\n    // Transform to Schur form\n    for (int k = 0; k < n; k++) {\n        // Find largest off-diagonal element\n        double max = 0.0;\n        int l = 0;\n        int m = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                double abs = FastMath.abs(t[i][j]);\n                if (abs > max) {\n                    max = abs;\n                    l = i;\n                    m = j;\n                }\n            }\n        }\n\n        // If max is zero, matrix is already in Schur form\n        if (max == 0.0) {\n            break;\n        }\n\n        // Compute rotation angle\n        double theta;\n        if (t[l][l] == t[m][m]) {\n            theta = FastMath.PI / 4;\n        } else {\n            double tau = (t[m][m] - t[l][l]) / (2.0 * t[l][m]);\n            theta = FastMath.atan(tau) / 2.0;\n        }\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final int n = matrix.getRowDimension();\n    final double[][] z = new double[n][n];\n    final double[] realEigenvalues = new double[n];\n    double maxAbsoluteValue;\n    RealVector[] eigenvectors;\n\n    // Initialize the Schur form and the eigenvalues\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            z[i][j] = matrix.getEntry(i, j);\n        }\n        realEigenvalues[i] = matrix.getEntry(i, i);\n    }\n\n    // Transform to Schur form\n    // ...\n\n    return new SchurTransformer(realEigenvalues, eigenvectors);\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final int n = matrix.getRowDimension();\n    final double[][] z = new double[n][n];\n    final double[] realEigenvalues = new double[n];\n    double maxAbsoluteValue;\n    RealVector[] eigenvectors;\n\n    // Initialize Z with the identity matrix\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            z[i][j] = (i == j) ? 1.0 : 0.0;\n        }\n    }\n\n    // Copy the matrix to a new array\n    final double[][] a = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            a[i][j] = matrix.getEntry(i, j);\n        }\n    }\n\n    // Transform to Schur form\n    final double[] e = new double[n];\n    for (int k = 0; k < n; k++) {\n        int m = n - 1;\n        while (m >= k) {\n            int j = m;\n            double scale = 0.0;\n            for (int i = k; i <= m; i++) {\n                scale = Math.max(scale, Math.abs(a[i][j]));\n            }\n            if (scale == 0.0) {\n                e[j] = a[j][j];\n                for (int i = k; i < j; i++) {\n                    a[i][j] = 0.0;\n                }\n                m--;\n                continue;\n            }\n            for (int i = k; i <= m; i++) {\n                a[i][j] /= scale;\n            }\n            e[j] = scale * scale;\n            for (int i = k; i <= m; i++) {\n                if (i == j) {\n                    continue;\n                }\n                double s = 0.0;\n                for (int l = k; l <= m; l++) {\n}\n}\n}\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // TODO: Implement this method\n    return new SchurTransformer(matrix);\n}"
    ],
    [
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    final E[] constants = enumClass.getEnumConstants();\n    for (int i = 0; i < constants.length; i++) {\n        if ((values[i / Long.SIZE] & (1 << (i % Long.SIZE))) != 0) {\n            result.add(constants[i]);\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    E[] constants = enumClass.getEnumConstants();\n    for (int i = 0; i < values.length; i++) {\n        long vector = values[i];\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((vector & (1 << j)) != 0) {\n                result.add(constants[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    E[] constants = enumClass.getEnumConstants();\n    for (int i = 0; i < values.length; i++) {\n        long vector = values[i];\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((vector & (1 << j)) != 0) {\n                result.add(constants[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n        asEnum(enumClass);\n        Validate.notNull(values);\n        final EnumSet<E> result = EnumSet.noneOf(enumClass);\n        final E[] constants = enumClass.getEnumConstants();\n        ArrayUtils.reverse(values);\n        for (int i = 0; i < values.length; i++) {\n            long vector = values[i];\n            for (int j = 0; j < Long.SIZE; j++) {\n                if ((vector & (1 << j)) != 0) {\n                    result.add(constants[i * Long.SIZE + j]);\n                }\n            }\n        }\n        return result;\n    }",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n        asEnum(enumClass);\n        Validate.notNull(values);\n        final EnumSet<E> result = EnumSet.noneOf(enumClass);\n        final E[] constants = enumClass.getEnumConstants();\n        ArrayUtils.reverse(values);\n        for (int i = 0; i < constants.length; i++) {\n            if ((values[i / Long.SIZE] & (1 << (i % Long.SIZE))) != 0) {\n                result.add(constants[i]);\n            }\n        }\n        return result;\n    }",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n        asEnum(enumClass);\n        Validate.notNull(values);\n        EnumSet<E> result = EnumSet.noneOf(enumClass);\n        E[] constants = enumClass.getEnumConstants();\n        for (int i = 0; i < constants.length; i++) {\n            if ((values[i / Long.SIZE] & (1 << (i % Long.SIZE))) != 0) {\n                result.add(constants[i]);\n            }\n        }\n        return result;\n    }",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    final E[] constants = enumClass.getEnumConstants();\n    for (int i = 0; i < constants.length; i++) {\n        if ((values[i / Long.SIZE] & (1 << (i % Long.SIZE))) != 0) {\n            result.add(constants[i]);\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n        asEnum(enumClass);\n        Validate.notNull(values);\n        final EnumSet<E> result = EnumSet.noneOf(enumClass);\n        final E[] constants = enumClass.getEnumConstants();\n        for (int i = 0; i < constants.length; i++) {\n            if ((values[i / Long.SIZE] & (1 << (i % Long.SIZE))) != 0) {\n                result.add(constants[i]);\n            }\n        }\n        return result;\n    }",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    final E[] constants = enumClass.getEnumConstants();\n    for (int i = 0; i < constants.length; i++) {\n        if ((values[i / Long.SIZE] & (1 << (i % Long.SIZE))) != 0) {\n            result.add(constants[i]);\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n        asEnum(enumClass);\n        Validate.notNull(values);\n        final EnumSet<E> result = EnumSet.noneOf(enumClass);\n        final E[] constants = enumClass.getEnumConstants();\n        for (int i = 0; i < constants.length; i++) {\n            if ((values[i / Long.SIZE] & (1 << (i % Long.SIZE))) != 0) {\n                result.add(constants[i]);\n            }\n        }\n        return result;\n    }"
    ],
    [
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = DateTimeZone.getDefault();\n    }\n    long newInstant = convertLocalToUTC(oldInstant, true);\n    return newZone.convertUTCToLocal(newInstant);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    // Convert old instant to local instant\n    long localInstant = convertUTCToLocal(oldInstant);\n\n    // Convert local instant to UTC instant in new zone\n    long newInstant = convertLocalToUTC(localInstant, false);\n\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    // Convert the old instant to local time in the current zone\n    long localInstant = convertUTCToLocal(oldInstant);\n\n    // Convert the local instant to UTC in the new zone\n    long newInstant = convertLocalToUTC(localInstant, false);\n\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    // Convert old instant to local instant\n    long localInstant = convertUTCToLocal(oldInstant);\n\n    // Convert local instant to UTC instant in new zone\n    long newInstant = convertLocalToUTC(localInstant, false);\n\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = DateTimeZone.getDefault();\n    }\n\n    long newInstant = convertLocalToUTC(oldInstant, true);\n    newInstant = newZone.convertUTCToLocal(newInstant);\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = DateTimeZone.getDefault();\n    }\n    long newInstant = convertLocalToUTC(oldInstant, true);\n    return newZone.convertUTCToLocal(newInstant);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    // Convert the old instant to the old zone.\n    long oldInstantLocal = convertUTCToLocal(oldInstant);\n\n    // Convert the old local instant to the new zone.\n    long newInstantLocal = convertLocalToLocal(oldInstantLocal, newZone);\n\n    // Convert the new local instant back to UTC.\n    long newInstantUTC = convertLocalToUTC(newInstantLocal, true);\n\n    return newInstantUTC;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    // Convert old instant to local instant\n    long localInstant = convertUTCToLocal(oldInstant);\n\n    // Convert local instant to UTC instant in new zone\n    long newInstant = convertLocalToUTC(localInstant, true);\n\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = DateTimeZone.getDefault();\n    }\n    long newInstant = convertLocalToUTC(oldInstant, true);\n    return newZone.convertUTCToLocal(newInstant);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = DateTimeZone.getDefault();\n    }\n    long newInstant = convertLocalToUTC(oldInstant, true);\n    return newZone.convertUTCToLocal(newInstant);\n}"
    ],
    [
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    // Your code goes here\n    Calendar calendar = Calendar.getInstance();\n    calendar.setTime(date);\n\n    DateTickUnitType t = unit.getType();\n    int value = unit.getValue();\n    int years, months, days, hours;\n\n    if (t.equals(DateTickUnitType.DAY)) {\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, months, value, 0, 0, 0);\n        Date d1 = calendar.getTime();\n        if (d1.getTime() >= date.getTime()) {\n            calendar.set(Calendar.DATE, value + 1);\n            d1 = calendar.getTime();\n        }\n        return d1;\n    }\n    else if (t.equals(DateTickUnitType.HOUR)) {\n        hours = value;\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, months, days, hours, 0, 0);\n        Date d2 = calendar.getTime();\n        if (d2.getTime() >= date.getTime()) {\n            calendar.set(Calendar.HOUR_OF_DAY, value + 1);\n            d2 = calendar.getTime();\n        }\n        return d2;\n    }\n    else if (t.equals(DateTickUnitType.MINUTE)) {\n        int minutes = value;\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, months, days, hours, minutes, 0);\n        Date d3 = calendar.getTime();\n        if (d3.getTime() >= date.getTime()) {\n            calendar.set(Calendar.MINUTE, value + 1);\n            d3 = calendar.getTime();\n        }\n        return d3;\n    }\n    else if (t.equals(DateTickUnitType.SECOND)) {\n        int seconds = value;\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, months, days, hours, minutes, seconds);\n        Date d4 = calendar.getTime();\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n        // Your code goes here\n        // You can use the provided context and referential code snippet to help you\n    }",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    // Get the Calendar instance associated with the given date\n    Calendar calendar = Calendar.getInstance();\n    calendar.setTime(date);\n\n    // Get the unit type and value\n    DateTickUnitType t = unit.getType();\n    int value = unit.getValue();\n\n    // Initialize variables\n    int years, months, days, hours = 0, minutes = 0, seconds = 0;\n\n    if (t.equals(DateTickUnitType.DAY)) \n    {\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, months, value, hours, minutes, seconds);\n        Date d1 = calendar.getTime();\n        if (d1.getTime() <= date.getTime()) \n        {\n            calendar.set(Calendar.DATE, value + 1);\n            d1 = calendar.getTime();\n        }\n        return d1;\n    } \n    else if (t.equals(DateTickUnitType.HOUR)) \n    {\n        if (value < 24) \n        {\n            calendar.clear(Calendar.MILLISECOND);\n            calendar.set(years, months, days, value, minutes, seconds);\n            Date d2 = calendar.getTime();\n            if (d2.getTime() <= date.getTime()) \n            {\n                calendar.set(Calendar.HOUR_OF_DAY, value + 1);\n                d2 = calendar.getTime();\n            }\n            return d2;\n        } \n        else \n        {\n            hours = value / 24;\n            value = value % 24;\n        }\n    } \n    else if (t.equals(DateTickUnitType.MINUTE)) \n    {\n        if (value < 60) \n        {\n            calendar.clear(Calendar.MILLISECOND);\n            calendar.set(years, months, days, hours, value, seconds);\n            Date d3 = calendar.getTime();\n            if (d3.getTime() <= date.getTime()) \n            {\n                calendar.set(Calendar.MINUTE, value + 1);\n}\n}\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance();\n    calendar.setTime(date);\n\n    DateTickUnitType t = unit.getType();\n    int value = unit.getValue();\n    int years, months, days, hours;\n\n    if (t.equals(DateTickUnitType.DAY)) \n    {\n        if (this.tickMarkPosition == DateTickMarkPosition.START) \n        {\n            hours = 0;\n        } \n        else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) \n        {\n            hours = 12;\n        } \n        else \n        {\n            hours = 23;\n        }\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, months, value, hours, 0, 0);\n        Date d1 = calendar.getTime();\n        if (d1.getTime() <= date.getTime()) \n        {\n            calendar.set(Calendar.DATE, value + 1);\n            d1 = calendar.getTime();\n        }\n        return d1;\n    } \n    else if (t.equals(DateTickUnitType.HOUR)) \n    {\n        if (this.tickMarkPosition == DateTickMarkPosition.START) \n        {\n            minutes = 0;\n        } \n        else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) \n        {\n            minutes = 30;\n        } \n        else \n        {\n            minutes = 59;\n        }\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, months, value, hours, minutes, 0);\n        Date d2 = calendar.getTime();\n        if (d2.getTime() <= date.getTime()) \n        {\n            calendar.set(Calendar.HOUR_OF_DAY, value + 1);\n            d2 = calendar.getTime();\n        }\n        return d2;\n    } \n    else if (t.equals(DateTickUnitType.MINUTE)) \n    {\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n        if (date == null || unit == null) {\n            throw new IllegalArgumentException(\"Null arguments are not allowed.\");\n        }\n\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(date);\n\n        DateTickUnitType t = unit.getType();\n        int value = unit.getValue();\n        int years, months, days, hours;\n\n        if (t.equals(DateTickUnitType.DAY)) {\n            if (this.tickMarkPosition == DateTickMarkPosition.START) {\n                hours = 0;\n            }\n            else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {\n                hours = 12;\n            }\n            else {\n                hours = 23;\n            }\n            calendar.clear(Calendar.MILLISECOND);\n            calendar.set(years, months, value, hours, 0, 0);\n            Date d1 = calendar.getTime();\n            if (d1.getTime() <= date.getTime()) {\n                calendar.set(Calendar.DATE, value + 1);\n                d1 = calendar.getTime();\n            }\n            return d1;\n        }\n        else if (t.equals(DateTickUnitType.HOUR)) {\n            if (this.tickMarkPosition == DateTickMarkPosition.START) {\n                minutes = 0;\n            }\n            else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {\n                minutes = 30;\n            }\n            else {\n                minutes = 59;\n            }\n            calendar.clear(Calendar.MILLISECOND);\n            calendar.set(years, months, value, hours, minutes, 0);\n            Date d2 = calendar.getTime();\n            if (d2.getTime() <= date.getTime()) {\n                calendar.set(Calendar.HOUR_OF_DAY, hours + 1);\n                d2 = calendar.getTime();\n            }\n            return d2;\n        }\n        else if (t.equals(DateTickUnitType.MINUTE)) {\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n        // your code here\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(date);\n        DateTickUnitType t = unit.getType();\n        int years = calendar.get(Calendar.YEAR);\n        int months = calendar.get(Calendar.MONTH);\n        int value = calendar.get(Calendar.DAY_OF_MONTH);\n        int hours = calendar.get(Calendar.HOUR_OF_DAY);\n        int days = 0;\n        if (t.equals(DateTickUnitType.DAY)) {\n            calendar.clear(Calendar.MILLISECOND);\n            calendar.set(years, months, value, hours, 0, 0);\n            Date d1 = calendar.getTime();\n            if (d1.getTime() >= date.getTime()) {\n                calendar.set(Calendar.DATE, value + 1);\n                d1 = calendar.getTime();\n            }\n            return d1;\n        }\n        else if (t.equals(DateTickUnitType.HOUR)) {\n            if (this.tickMarkPosition == DateTickMarkPosition.START) {\n                hours = 0;\n            }\n            else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {\n                hours = 12;\n            }\n            else {\n                hours = 23;\n            }\n            calendar.clear(Calendar.MILLISECOND);\n            calendar.set(years, months, value, hours, 0, 0);\n            Date d2 = calendar.getTime();\n            if (d2.getTime() >= date.getTime()) {\n                calendar.set(Calendar.HOUR_OF_DAY, hours + 1);\n                d2 = calendar.getTime();\n            }\n            return d2;\n        }\n        else if (t.equals(DateTickUnitType.MINUTE)) {\n            if (this.tickMarkPosition == DateTickMarkPosition.START) {\n                hours = 0;\n                value = 0;\n            }\n            else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {\n}\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n        // Your code goes here\n    }",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n        // TODO: Implement your code here\n    }",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    // Your code goes here\n    // You can use the provided context to complete the function\n    // The function should return a Date object\n    // The DateTickUnit class and its subclasses are not provided in the context\n    // You can assume that the DateTickUnit object passed in will be an instance of one of the subclasses of DateTickUnit\n    // You can assume that the Date object passed in will not be null\n    // You can assume that the DateTickUnit object passed in will not be null\n    // You can assume that the DateTickUnit object passed in will be an instance of one of the subclasses of DateTickUnit\n    // You can assume that the Date object passed in will not be null\n    // You can assume that the DateTickUnit object passed in will not be null\n    // You can assume that the DateTickUnit object passed in will be an instance of one of the subclasses of DateTickUnit\n    // You can assume that the Date object passed in will not be null\n    // You can assume that the DateTickUnit object passed in will not be null\n    // You can assume that the DateTickUnit object passed in will be an instance of one of the subclasses of DateTickUnit\n    // You can assume that the Date object passed in will not be null\n    // You can assume that the DateTickUnit object passed in will not be null\n    // You can assume that the DateTickUnit object passed in will be an instance of one of the subclasses of DateTickUnit\n    // You can assume that the Date object passed in will not be null\n    // You can assume that the DateTickUnit object passed in will not be null\n    // You can assume that the DateTickUnit object passed in will be an instance of one of the subclasses of DateTickUnit\n    // You can assume that the Date object passed in will not be null\n    // You can assume that the DateTickUnit object passed in will not be null\n    // You can assume that the DateTickUnit object passed in will be an instance of one of the subclasses of DateTickUnit\n    // You can assume that the Date object passed in will not be null\n    // You can assume that the DateTickUnit object passed in will not be null\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n        // Your code goes here\n        // ...\n    }"
    ],
    [
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    // Get the resolver\n    VariableResolver resolver = getVariableResolver();\n    if (resolver == null) {\n        return null;\n    }\n    // Resolve the variable\n    return resolver.resolveVariable(variableName);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n        // get the variable resolver\n        final VariableResolver resolver = getVariableResolver();\n        if (resolver != null) {\n            // get the variable value\n            final String value = resolver.resolveVariable(variableName);\n            if (value != null) {\n                return value;\n            }\n        }\n        return null;\n    }",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    // Get the resolver from the context\n    VariableResolver resolver = getVariableResolver();\n\n    // Resolve the variable\n    String variableValue = resolver.resolveVariable(variableName);\n\n    // Return the variable value\n    return variableValue;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n        return getVariableResolver().resolve(variableName);\n    }",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (getVariableResolver() == null) {\n        return null;\n    }\n    return getVariableResolver().resolveVariable(variableName);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    // Call the variable resolver and return the resolved variable value\n    return getVariableResolver().resolveVariable(variableName);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    return getVariableResolver().resolve(variableName);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n        if (getVariableResolver() == null) {\n            return null;\n        }\n        return getVariableResolver().resolveVariable(variableName, buf, startPos, endPos);\n    }",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n        return getVariableResolver().resolveVariable(variableName);\n    }",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n        // get the variable resolver\n        VariableResolver resolver = getVariableResolver();\n        if (resolver == null) \n        {\n            return null;\n        }\n\n        // resolve the variable\n        String value = resolver.resolveVariable(variableName);\n        if (value == null) \n        {\n            return null;\n        }\n\n        // if substitution in variables is enabled, substitute the variable value\n        if (isEnableSubstitutionInVariables()) \n        {\n            StrBuilder bufValue = new StrBuilder(value);\n            substitute(bufValue, 0, bufValue.length());\n            value = bufValue.toString();\n        }\n\n        return value;\n    }"
    ],
    [
      "public String soundex(String str)  {\n        StringBuilder code = new StringBuilder();\n        char[] mapping = getSoundexMapping();\n\n        // Convert to upper case\n        str = str.toUpperCase();\n\n        // Handle first character\n        char firstChar = str.charAt(0);\n        code.append(firstChar);\n\n        // Handle remaining characters\n        for (int i = 1; i < str.length(); i++) {\n            char currentChar = str.charAt(i);\n            char previousCharCode = code.charAt(code.length() - 1);\n\n            // Ignore non-alphabetic characters and h, w, and vowels\n            if (Character.isLetter(currentChar) && currentChar != 'H' && currentChar != 'W' && \"AEIOUY\".indexOf(currentChar) == -1) {\n                // Map the character to its Soundex code\n                char currentCharCode = mapping[currentChar - 'A'];\n\n                // Only append the code if it's different from the previous code and not a vowel or '0'\n                if (currentCharCode != previousCharCode && currentCharCode != '0') {\n                    code.append(currentCharCode);\n                }\n            }\n        }\n\n        // Pad with zeros if necessary\n        while (code.length() < maxLength) {\n            code.append('0');\n        }\n\n        return code.toString();\n    }",
      "public String soundex(String str)  {\n    if (str == null || str.length() == 0) {\n        return \"\";\n    }\n\n    StringBuilder code = new StringBuilder();\n    char[] input = str.toCharArray();\n    char lastMapping = map(input[0]);\n    code.append(input[0]);\n\n    for (int i = 1; i < input.length; i++) {\n        char mapping = map(input[i]);\n        if (mapping != lastMapping) {\n            code.append(mapping);\n            lastMapping = mapping;\n        }\n    }\n\n    while (code.length() < maxLength) {\n        code.append('0');\n    }\n\n    return code.toString();\n}",
      "public String soundex(String str)  {\n        StringBuilder code = new StringBuilder();\n        char[] input = str.toCharArray();\n        char last = ' ';\n        for (char c : input) {\n            if (Character.isLetter(c)) {\n                char mapped = map(c);\n                if (mapped != last) {\n                    code.append(mapped);\n                    last = mapped;\n                }\n            } else {\n                last = ' ';\n            }\n        }\n        return code.toString();\n    }",
      "public String soundex(String str)  {\n        StringBuilder soundex = new StringBuilder();\n        char[] chars = str.toCharArray();\n        char last = ' ';\n        for (char c : chars) {\n            if (Character.isLetter(c)) {\n                char mapped = map(c);\n                if (mapped != last) {\n                    soundex.append(mapped);\n                    last = mapped;\n                }\n            }\n        }\n        while (soundex.length() < maxLength) {\n            soundex.append('0');\n        }\n        return soundex.toString();\n    }",
      "public String soundex(String str)  {\n        StringBuilder code = new StringBuilder();\n        char[] chars = str.toCharArray();\n        code.append(chars[0]);\n\n        for (int i = 1; i < chars.length; i++) {\n            char c = chars[i];\n            if (c == ' ') {\n                continue;\n            }\n            char last = code.charAt(code.length() - 1);\n            char mapped = map(c);\n            if (mapped != last) {\n                code.append(mapped);\n            }\n            if (code.length() == this.maxLength) {\n                break;\n            }\n        }\n\n        while (code.length() < this.maxLength) {\n            code.append('0');\n        }\n\n        return code.toString();\n    }",
      "public String soundex(String str)  {\n        StringBuilder code = new StringBuilder();\n        char[] chars = str.toCharArray();\n        char last = 0;\n\n        for (char c : chars) {\n            if (Character.isLetter(c)) {\n                char mapped = map(c);\n                if (mapped != last) {\n                    code.append(mapped);\n                    last = mapped;\n                }\n            }\n        }\n\n        while (code.length() < maxLength) {\n            code.append('0');\n        }\n\n        return code.toString();\n    }",
      "public String soundex(String str)  {\n    if (str == null || str.length() == 0) {\n        return \"\";\n    }\n\n    str = str.toUpperCase();\n\n    char[] soundex = new char[4];\n    soundex[0] = str.charAt(0);\n\n    int count = 1;\n    for (int i = 1; i < str.length() && count < 4; i++) {\n        char c = map(str.charAt(i));\n        if (c != '0' && c != soundex[count - 1]) {\n            soundex[count++] = c;\n        }\n    }\n\n    while (count < 4) {\n        soundex[count++] = '0';\n    }\n\n    return new String(soundex);\n}",
      "public String soundex(String str)  {\n        if (str == null || str.length() == 0) {\n            return \"\";\n        }\n\n        char[] soundex = new char[4];\n        soundex[0] = str.charAt(0);\n\n        int count = 1;\n        for (int i = 1; i < str.length(); i++) {\n            char c = str.charAt(i);\n            if (count >= soundex.length) {\n                break;\n            }\n            char mapped = map(c);\n            if (mapped != soundex[count - 1]) {\n                soundex[count++] = mapped;\n            }\n        }\n\n        while (count < soundex.length) {\n            soundex[count++] = '0';\n        }\n\n        return new String(soundex);\n    }",
      "public String soundex(String str)  {\n        if (str == null) {\n            return null;\n        }\n        str = str.toUpperCase();\n        StringBuilder code = new StringBuilder();\n        code.append(str.charAt(0));\n        for (int i = 1; i < str.length(); i++) {\n            char c = str.charAt(i);\n            if (c == ' ') {\n                continue;\n            }\n            char prev = code.charAt(code.length() - 1);\n            if (prev == '0') {\n                code.append(map(c));\n            } else if (map(c) != prev) {\n                code.append(map(c));\n            }\n        }\n        while (code.length() < maxLength) {\n            code.append('0');\n        }\n        return code.toString();\n    }",
      "public String soundex(String str)  {\n        StringBuilder code = new StringBuilder();\n        code.append(str.charAt(0)); // first letter\n        for (int i = 1; i < str.length(); i++) {\n            char c = str.charAt(i);\n            if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' || c == 'Y') {\n                continue;\n            }\n            char mapped = map(c);\n            if (mapped != code.charAt(code.length() - 1)) {\n                code.append(mapped);\n            }\n            if (code.length() == this.maxLength) {\n                break;\n            }\n        }\n        while (code.length() < this.maxLength) {\n            code.append('0');\n        }\n        return code.toString();\n    }"
    ],
    [
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == Integer.class) {\n        return CORE_TYPE_INTEGER;\n    } else if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    } else if (clz == Boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    } else if (clz == Float.class) {\n        return CORE_TYPE_FLOAT;\n    } else if (clz == Double.class) {\n        return CORE_TYPE_DOUBLE;\n    } else if (clz == Void.class) {\n        return CORE_TYPE_VOID;\n    } else if (clz == List.class) {\n        return CORE_TYPE_LIST;\n    } else if (clz == Map.class) {\n        return CORE_TYPE_MAP;\n    } else if (clz == Set.class) {\n        return CORE_TYPE_SET;\n    } else if (clz == Iterable.class) {\n        return CORE_TYPE_ITERABLE;\n    } else if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    } else {\n        return null;\n    }\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == Integer.class) {\n        return CORE_TYPE_INTEGER;\n    } else if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    } else if (clz == Double.class) {\n        return CORE_TYPE_DOUBLE;\n    } else if (clz == Boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    } else if (clz == Void.class) {\n        return CORE_TYPE_VOID;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    }\n    else if (clz == Integer.class) {\n        return CORE_TYPE_INTEGER;\n    }\n    else if (clz == Boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    }\n    else if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    }\n    else if (clz == Double.class) {\n        return CORE_TYPE_DOUBLE;\n    }\n    else if (clz == Float.class) {\n        return CORE_TYPE_FLOAT;\n    }\n    else if (clz == Short.class) {\n        return CORE_TYPE_SHORT;\n    }\n    else if (clz == Byte.class) {\n        return CORE_TYPE_BYTE;\n    }\n    else if (clz == Character.class) {\n        return CORE_TYPE_CHARACTER;\n    }\n    else if (clz == Void.class) {\n        return CORE_TYPE_VOID;\n    }\n    else if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    }\n    else {\n        return null;\n    }\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == int.class) {\n        return CORE_TYPE_INT;\n    }\n    else if (clz == long.class) {\n        return CORE_TYPE_LONG;\n    }\n    else if (clz == double.class) {\n        return CORE_TYPE_DOUBLE;\n    }\n    else if (clz == float.class) {\n        return CORE_TYPE_FLOAT;\n    }\n    else if (clz == boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    }\n    else if (clz == byte.class) {\n        return CORE_TYPE_BYTE;\n    }\n    else if (clz == short.class) {\n        return CORE_TYPE_SHORT;\n    }\n    else if (clz == char.class) {\n        return CORE_TYPE_CHAR;\n    }\n    else if (clz == void.class) {\n        return CORE_TYPE_VOID;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == Integer.class) {\n        return CORE_TYPE_INTEGER;\n    } else if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    } else if (clz == Double.class) {\n        return CORE_TYPE_DOUBLE;\n    } else if (clz == Boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    } else if (clz == Character.class) {\n        return CORE_TYPE_CHARACTER;\n    } else if (clz == Float.class) {\n        return CORE_TYPE_FLOAT;\n    } else if (clz == Byte.class) {\n        return CORE_TYPE_BYTE;\n    } else if (clz == Short.class) {\n        return CORE_TYPE_SHORT;\n    } else if (clz == Void.class) {\n        return CORE_TYPE_VOID;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == Integer.class) {\n        return CORE_TYPE_INTEGER;\n    } else if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    } else if (clz == Double.class) {\n        return CORE_TYPE_DOUBLE;\n    } else if (clz == Boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    } else if (clz == Character.class) {\n        return CORE_TYPE_CHARACTER;\n    } else if (clz == Float.class) {\n        return CORE_TYPE_FLOAT;\n    } else if (clz == Short.class) {\n        return CORE_TYPE_SHORT;\n    } else if (clz == Byte.class) {\n        return CORE_TYPE_BYTE;\n    } else if (clz == Void.class) {\n        return CORE_TYPE_VOID;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == Integer.class) {\n        return CORE_TYPE_INTEGER;\n    } else if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    } else if (clz == Double.class) {\n        return CORE_TYPE_DOUBLE;\n    } else if (clz == Boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    } else if (clz == Character.class) {\n        return CORE_TYPE_CHARACTER;\n    } else if (clz == Float.class) {\n        return CORE_TYPE_FLOAT;\n    } else if (clz == Short.class) {\n        return CORE_TYPE_SHORT;\n    } else if (clz == Byte.class) {\n        return CORE_TYPE_BYTE;\n    } else if (clz == Void.class) {\n        return CORE_TYPE_VOID;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == Integer.class) {\n        return CORE_TYPE_INTEGER;\n    } else if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    } else if (clz == Double.class) {\n        return CORE_TYPE_DOUBLE;\n    } else if (clz == Boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    } else if (clz == Void.class) {\n        return CORE_TYPE_VOID;\n    } else if (clz == List.class) {\n        return CORE_TYPE_LIST;\n    } else if (clz == Map.class) {\n        return CORE_TYPE_MAP;\n    } else if (clz == Set.class) {\n        return CORE_TYPE_SET;\n    } else if (clz == Iterable.class) {\n        return CORE_TYPE_ITERABLE;\n    } else if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == Integer.class) {\n        return CORE_TYPE_INTEGER;\n    } else if (clz == Boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    } else if (clz == List.class) {\n        return CORE_TYPE_LIST;\n    } else if (clz == Map.class) {\n        return CORE_TYPE_MAP;\n    } else if (clz == Collection.class) {\n        return CORE_TYPE_COLLECTION;\n    } else if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    } else {\n        return null;\n    }\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == int.class) {\n        return CORE_TYPE_INT;\n    } else if (clz == long.class) {\n        return CORE_TYPE_LONG;\n    } else if (clz == double.class) {\n        return CORE_TYPE_DOUBLE;\n    } else if (clz == float.class) {\n        return CORE_TYPE_FLOAT;\n    } else if (clz == boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    } else if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == void.class) {\n        return CORE_TYPE_VOID;\n    } else if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    } else if (clz == byte.class) {\n        return CORE_TYPE_BYTE;\n    } else if (clz == char.class) {\n        return CORE_TYPE_CHAR;\n    } else if (clz == short.class) {\n        return CORE_TYPE_SHORT;\n    }\n    return null;\n}"
    ],
    [
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isAssignment() && n.getLeft().isPrototypeProperty()) \n    {\n        return new PrototypeMemberDeclaration(n.getLeft(), n);\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isAssignment() && n.getRhs().isPrototypeMember()) {\n      return new PrototypeMemberDeclaration(n.getLhs(), n);\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isAssignment() && n.getLeft().isPrototypeProperty()) \n    {\n        return new PrototypeMemberDeclaration(n.getLeft(), n);\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isAssignment() && n.getLeft().isPrototypeProperty()) {\n      return new PrototypeMemberDeclaration(n.getLeft(), n);\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isAssignment() && NodeUtil.isPrototypeProperty(n)) \n    {\n        return new PrototypeMemberDeclaration(n.getLeft(), n);\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isPrototypeMember()) \n    {\n        return new PrototypeMemberDeclaration(n.getLeftHandSide(), n);\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isAssignment() && n.getLeft().isPrototypeProperty()) \n    {\n        return new PrototypeMemberDeclaration(n.getLeft(), n);\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isPrototypeMember()) \n    {\n        return new PrototypeMemberDeclaration(n.getLeftHandSide(), n);\n    }\n    else \n    {\n        return null;\n    }\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isAssignment() && n.getLeftmostChild().isPrototypeProperty()) \n    {\n        return new PrototypeMemberDeclaration(n.getLeftmostChild(), n);\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isAssignment() && NodeUtil.isPrototypeMember(n)) \n    {\n        return new PrototypeMemberDeclaration(n.getLHS(), n);\n    }\n    return null;\n}"
    ],
    [
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    double[][] d = new double[n*mat.getRowDimension()][m*mat.getColumnDimension()];\n    for(int i=0; i<n; i++)\n    {\n        for(int j=0; j<m; j++)\n        {\n            for(int k=0; k<mat.getRowDimension(); k++)\n            {\n                System.arraycopy(mat.getRow(k), 0, d[i*mat.getRowDimension()+k], j*mat.getColumnDimension(), mat.getColumnDimension());\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[n * mat.getRowDimension()][m * mat.getColumnDimension()];\n    for (int i = 0; i < n; i++) \n    {\n        for (int j = 0; j < m; j++) \n        {\n            copyBlock(mat, d, i * mat.getRowDimension(), j * mat.getColumnDimension(), mat.getRowDimension(), mat.getColumnDimension());\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    double[][] d = new double[n * mat.getRowDimension()][m * mat.getColumnDimension()];\n    for (int i = 0; i < n; i++) \n    {\n        for (int j = 0; j < m; j++) \n        {\n            for (int r = 0; r < mat.getRowDimension(); r++) \n            {\n                System.arraycopy(mat.getRow(r), 0, d[i * mat.getRowDimension() + r], j * mat.getColumnDimension(), mat.getColumnDimension());\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final int originalRows = mat.getRowDimension();\n    final int originalCols = mat.getColumnDimension();\n\n    final double[][] d = new double[originalRows * n][originalCols * m];\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int r = 0; r < originalRows; r++) {\n                System.arraycopy(mat.getRow(r), 0, d[originalCols * i + j], originalCols * r, originalCols);\n            }\n        }\n    }\n\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final int originalRows = mat.getRowDimension();\n    final int originalColumns = mat.getColumnDimension();\n\n    final double[][] d = new double[originalRows * n][originalColumns * m];\n\n    for (int i = 0; i < n; i++) \n    {\n        for (int j = 0; j < m; j++) \n        {\n            for (int r = 0; r < originalRows; r++) \n            {\n                System.arraycopy(mat.getRow(r), 0, d[i * originalRows + r], j * originalColumns, originalColumns);\n            }\n        }\n    }\n\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    double[][] d = new double[n * mat.getRowDimension()][m * mat.getColumnDimension()];\n    for (int i = 0; i < n; i++) \n    {\n        for (int j = 0; j < m; j++) \n        {\n            for (int r = 0; r < mat.getRowDimension(); r++) \n            {\n                System.arraycopy(mat.getRow(r), 0, d[i * mat.getRowDimension() + r], j * mat.getColumnDimension(), mat.getColumnDimension());\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    double[][] d = new double[n*mat.getRowDimension()][m*mat.getColumnDimension()];\n    for(int i=0; i<n; i++)\n    {\n        for(int j=0; j<m; j++)\n        {\n            for(int k=0; k<mat.getRowDimension(); k++)\n            {\n                System.arraycopy(mat.getRow(k), 0, d[i*mat.getRowDimension()+k], j*mat.getColumnDimension(), mat.getColumnDimension());\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[mat.getRowDimension() * n][mat.getColumnDimension() * m];\n    for (int i = 0; i < n; i++) \n    {\n        for (int j = 0; j < m; j++) \n        {\n            copyMatrix(mat, d, i * mat.getRowDimension(), j * mat.getColumnDimension());\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    double[][] d = new double[mat.getRowDimension()*n][mat.getColumnDimension()*m];\n    for(int i=0; i<n; i++)\n    {\n        for(int j=0; j<m; j++)\n        {\n            for(int r=0; r<mat.getRowDimension(); r++)\n            {\n                System.arraycopy(mat.getRow(r), 0, d[i*mat.getRowDimension()+r], j*mat.getColumnDimension(), mat.getColumnDimension());\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[n * mat.getRowDimension()][m * mat.getColumnDimension()];\n    for (int i = 0; i < n; i++) \n    {\n        for (int j = 0; j < m; j++) \n        {\n            for (int r = 0; r < mat.getRowDimension(); r++) \n            {\n                System.arraycopy(mat.getRow(r), 0, d[i * mat.getRowDimension() + r], j * mat.getColumnDimension(), mat.getColumnDimension());\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}"
    ],
    [
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}"
    ],
    [
      "private long getBytesInflated()  {\n    long bytesInflated = current.bytesReadFromStream - inf.getBytesRead();\n    if (bytesInflated < 0 || bytesInflated > current.bytesReadFromStream) {\n        // We've read more than we should have, or the value is too large\n        // to be a valid count.  In either case, we can't trust the value.\n        // Assume the value is close enough to the actual value.\n        bytesInflated = current.bytesReadFromStream;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long inflated = inf.getBytesInflated();\n    if (inflated < 0 || inflated > current.bytesReadFromStream) {\n        inflated = current.bytesReadFromStream;\n    }\n    return inflated;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesInflated();\n    if (bytesInflated > current.bytesReadFromStream) {\n        bytesInflated = current.bytesReadFromStream;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = current.bytesReadFromStream - inf.getBytesRead();\n    if (bytesInflated < 0 || bytesInflated > current.bytesReadFromStream) {\n        // The inflater's bytes read must be between the total number\n        // of bytes read for the entry and the total number minus the\n        // last read operation.  If it's not, then something is wrong.\n        // We'll just return the total number of bytes read for the\n        // entry, which is as close as we can get.\n        bytesInflated = current.bytesReadFromStream;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesInflated();\n    if (bytesInflated > current.bytesReadFromStream) {\n        bytesInflated = current.bytesReadFromStream;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long inflated = inf.getBytesInflated();\n    if (inflated > current.bytesReadFromStream) {\n        inflated = current.bytesReadFromStream;\n    }\n    return inflated;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = current.bytesReadFromStream - inf.getBytesRead();\n    if (bytesInflated < 0) {\n        bytesInflated = 0;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = current.bytesReadFromStream - inf.getBytesRead();\n    if (bytesInflated < 0 || bytesInflated > current.bytesReadFromStream) {\n        // If the value is out of range, we assume that the Inflater\n        // has processed all bytes.  This is a reasonable assumption\n        // because the Inflater should not be used for more than one\n        // entry in the stream.\n        bytesInflated = current.bytesReadFromStream;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesInflated();\n    if (bytesInflated > current.bytesReadFromStream) {\n        bytesInflated = current.bytesReadFromStream;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = current.bytesReadFromStream - inf.getBytesRead();\n    if (bytesInflated < 0 || bytesInflated > current.bytesReadFromStream) {\n        bytesInflated = current.bytesReadFromStream;\n    }\n    return bytesInflated;\n}"
    ],
    [
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null || size(object) == 0) {\n        return true;\n    }\n    return false;\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null || (object instanceof String && ((String) object).isEmpty())) \n    {\n        return true;\n    }\n    int total = 0;\n    if (object instanceof Map<?,?>) \n    {\n        total = ((Map<?, ?>) object).size();\n    } \n    else if (object instanceof Collection<?>) \n    {\n        total = ((Collection<?>) object).size();\n    } \n    else if (object instanceof Iterable<?>) \n    {\n        total = IterableUtils.size((Iterable<?>) object);\n    } \n    else if (object instanceof Object[]) \n    {\n        total = ((Object[]) object).length;\n    } \n    else if (object instanceof Iterator<?>) \n    {\n        total = IteratorUtils.size((Iterator<?>) object);\n    } \n    else if (object instanceof Enumeration<?>) \n    {\n        final Enumeration<?> it = (Enumeration<?>) object;\n        while (it.hasMoreElements()) \n        {\n            total++;\n            it.nextElement();\n        }\n    } \n    else \n    {\n        try \n        {\n            total = Array.getLength(object);\n        } \n        catch (final IllegalArgumentException ex) \n        {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n    return total == 0;\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return !((Iterable<?>) object).iterator().hasNext();\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null || size(object) == 0) \n    {\n        return true;\n    }\n    return false;\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return !((Iterable<?>) object).iterator().hasNext();\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null || size(object) == 0) \n    {\n        return true;\n    }\n    return false;\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n        if (object == null) {\n            return true;\n        }\n        if (object instanceof Map<?,?>) {\n            return ((Map<?, ?>) object).isEmpty();\n        } else if (object instanceof Collection<?>) {\n            return ((Collection<?>) object).isEmpty();\n        } else if (object instanceof Iterable<?>) {\n            return !((Iterable<?>) object).iterator().hasNext();\n        } else if (object instanceof Object[]) {\n            return ((Object[]) object).length == 0;\n        } else if (object instanceof Iterator<?>) {\n            return !((Iterator<?>) object).hasNext();\n        } else if (object instanceof Enumeration<?>) {\n            return !((Enumeration<?>) object).hasMoreElements();\n        } else {\n            try {\n                return Array.getLength(object) == 0;\n            } catch (final IllegalArgumentException ex) {\n                throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n            }\n        }\n    }",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null || size(object) == 0) \n    {\n        return true;\n    }\n    return false;\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null || (object instanceof String && ((String)object).isEmpty())) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return !((Iterable<?>) object).iterator().hasNext();\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n        if (object == null || size(object) == 0) {\n            return true;\n        }\n        return false;\n    }"
    ],
    [
      "public static boolean isValidQualifiedName(String name)  {\n    int dotIndex = name.indexOf('.');\n    if (dotIndex == -1) \n    {\n        return isValidSimpleName(name);\n    } \n    else \n    {\n        String firstPart = name.substring(0, dotIndex);\n        String secondPart = name.substring(dotIndex + 1);\n        return isValidSimpleName(firstPart) && isValidQualifiedName(secondPart);\n    }\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    if (name.isEmpty()) {\n      return false;\n    }\n    String[] parts = name.split(\"\\\\.\");\n    for (String part : parts) {\n      if (!isValidSimpleName(part)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    int dotIndex = name.indexOf('.');\n    if (dotIndex == -1) \n    {\n        return isValidSimpleName(name);\n    } \n    else \n    {\n        String prefix = name.substring(0, dotIndex);\n        String suffix = name.substring(dotIndex + 1);\n        return isValidSimpleName(prefix) && isValidQualifiedName(suffix);\n    }\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    if (name.isEmpty()) \n    {\n        return false;\n    }\n    String[] parts = name.split(\"\\\\.\");\n    for (String part : parts) \n    {\n        if (!isValidSimpleName(part)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    if (name.contains(\".\")) \n    {\n        String[] parts = name.split(\"\\\\.\");\n        for (String part : parts) \n        {\n            if (!isValidSimpleName(part)) \n            {\n                return false;\n            }\n        }\n        return true;\n    } \n    else \n    {\n        return isValidSimpleName(name);\n    }\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    if (name.isEmpty()) {\n      return false;\n    }\n    String[] parts = name.split(\"\\\\.\");\n    for (String part : parts) {\n      if (!isValidSimpleName(part)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    if (name.contains(\".\")) {\n        String[] parts = name.split(\"\\\\.\");\n        for (String part : parts) {\n            if (!isValidSimpleName(part)) {\n                return false;\n            }\n        }\n        return true;\n    } else {\n        return isValidSimpleName(name);\n    }\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    int dotIndex = name.indexOf('.');\n    if (dotIndex == -1) {\n      return isValidSimpleName(name);\n    }\n    String firstPart = name.substring(0, dotIndex);\n    String secondPart = name.substring(dotIndex + 1);\n    return isValidSimpleName(firstPart) && isValidQualifiedName(secondPart);\n  }\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    return name.contains(\".\") && isValidSimpleName(name.substring(name.lastIndexOf(\".\") + 1));\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    int dotIndex = name.indexOf('.');\n    if (dotIndex == -1) \n    {\n        return isValidSimpleName(name);\n    } \n    else \n    {\n        return isValidSimpleName(name.substring(0, dotIndex)) &&\n               isValidQualifiedName(name.substring(dotIndex + 1));\n    }\n}"
    ],
    [
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int m = iu - 1;\n    double z = 0.0;\n    if (il > 0) {\n        m = iu;\n        z = matrixT[m][m - 1];\n    }\n\n    double norm = getNorm();\n    int l = findSmallSubDiagonalElement(iu, norm);\n    computeShift(l, iu, 0, shift);\n\n    double x = matrixT[iu][iu];\n    double y = 0.0;\n    double w = 0.0;\n    if (l < iu) {\n        y = matrixT[iu - 1][iu - 1];\n        w = matrixT[iu][iu - 1] * matrixT[iu - 1][iu];\n    }\n\n    // Initialize vector h\n    for (int j = 0; j < m; j++) {\n        hVec[j] = matrixT[j][iu];\n    }\n\n    // Apply the transformation\n    double r = 0.0;\n    for (int j = 0; j < m; j++) {\n        r = r + hVec[j] * hVec[j];\n    }\n    r = FastMath.sqrt(r);\n    if (x > 0) {\n        r = -r;\n    }\n    hVec[iu] = x + r;\n    double s = 1.0;\n    if (r != 0.0) {\n        s = 1.0 / r;\n    }\n    for (int j = 0; j < m; j++) {\n        hVec[j] *= s;\n    }\n\n    // Update T\n    for (int j = 0; j <= m; j++) {\n        double hj = hVec[j];\n        for (int i = 0; i <= j; i++) {\n            matrixT[i][j] -= 2.0 * hj * hVec[i];\n        }\n    }\n\n    // Update T\n    for (int i = 0; i <= m; i++) {\n        double hj = hVec[i];\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int m = iu - 1;\n    double scale = 0.0;\n    double h = 0.0;\n\n    if (il > 0) \n    {\n        // Compute the norm of the vector to be used in the householder transformation\n        for (int i = il - 1; i <= iu - 1; i++) \n        {\n            scale += FastMath.abs(matrixT[i][iu - 1]);\n        }\n        if (scale == 0.0) \n        {\n            hVec[iu - 1] = matrixT[iu - 1][iu - 1];\n            return iu;\n        }\n\n        // Compute the householder transformation\n        for (int i = max(0, il - 2); i <= iu - 1; i++) \n        {\n            hVec[i] = matrixT[i][iu - 1];\n        }\n        hVec[iu - 1] = 0.0;\n\n        // Apply the householder transformation\n        for (int j = iu - 1; j >= il; j--) \n        {\n            double temp = 0.0;\n            for (int i = j; i >= il; i--) \n            {\n                temp += hVec[i] * matrixT[i][j];\n            }\n            temp = (temp / hVec[j]) / scale;\n            h += temp * matrixT[j][j];\n            for (int i = j; i >= il; i--) \n            {\n                matrixT[i][j] -= temp * hVec[i];\n            }\n        }\n    } \n    else \n    {\n        h = matrixT[iu - 1][iu - 1];\n    }\n\n    // Store the shift information\n    shift.x = h;\n    shift.y = scale;\n    shift.w = 0.0;\n\n    return m;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int m = iu - 1;\n    double scale = 0.0;\n    double h = 0.0;\n\n    if (il > 0) \n    {\n        for (int i = il - 1; i <= iu - 1; i++) \n        {\n            scale += FastMath.abs(matrixT[i][i - 1]);\n        }\n        if (scale != 0.0) \n        {\n            double s = (matrixT[iu - 1][iu - 1] - ((shift.y - shift.x) / 2.0)) / scale;\n            h = s * s;\n            for (int i = il - 1; i <= iu - 1; i++) \n            {\n                h += matrixT[i][i - 1] * matrixT[i][i - 1];\n            }\n            h = scale * scale + h;\n            if (h != 0.0) \n            {\n                for (int i = il - 1; i <= iu - 1; i++) \n                {\n                    hVec[i] = matrixT[i][i - 1];\n                    matrixT[i][i - 1] = 0.0;\n                }\n                hVec[iu - 1] = 0.0;\n                for (int i = il - 1; i <= iu - 1; i++) \n                {\n                    if (hVec[i] != 0.0) \n                    {\n                        double norm = FastMath.sqrt(hVec[i] * hVec[i] + h * matrixT[i][i] * matrixT[i][i]);\n                        hVec[i] = hVec[i] / norm;\n                        matrixT[i][i] -= h;\n                    }\n                }\n                m = iu;\n            }\n        }\n    }\n    return m;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // Initialize householder vector\n    final int n = matrixT.length;\n    double hh = 0.0;\n    for (int i = il; i <= iu; i++) {\n        hVec[i] = matrixT[i][i];\n        hh += hVec[i] * hVec[i];\n    }\n    double norm = FastMath.sqrt(hh);\n    final double[] c = new double[n];\n    final double[] d = new double[n];\n    hVec[iu] += norm;\n    c[iu] = 0.0;\n    d[iu] = norm;\n    for (int i = iu - 1; i >= il; i--) {\n        double wr = hVec[i];\n        hh = hh + wr * wr;\n        final double w = hVec[i + 1];\n        final double g = d[i + 1];\n        final double p = (wr * wr + g * g) / 2.0;\n        final double r = FastMath.sqrt(p);\n        final double dx = norm / (wr + Math.signum(wr) * r);\n        final double da = dx * w / (norm + Math.signum(w) * r);\n        c[i] = dx;\n        d[i] = da;\n        hh = p + dx * da * norm / (norm + Math.signum(w) * r);\n    }\n    // Accumulate transformations\n    for (int i = il; i < n; i++) {\n        final double h = hVec[i];\n        hVec[i] = h + hh;\n        if (i > il) {\n            matrixT[i - 1][i - 1] = matrixT[i][i];\n            for (int j = i - 1; j >= il; j--) {\n                matrixT[j][i] = matrixT[j][i] + h * (c[j] * matrixT[j][i] + d[j] * matrixT[i][i]);\n            }\n        }\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int m = iu - 1;\n    int n = iu - il;\n    hVec[m] = matrixT[iu][iu];\n    if (il == iu) \n    {\n        return il;\n    }\n    hVec[m - 1] = 0.0;\n    double scale = 0.0;\n    double h1 = 0.0;\n    for (int i = il; i <= iu; i++) \n    {\n        hVec[i] = matrixT[i][iu];\n        scale += Math.abs(hVec[i]);\n    }\n    if (scale == 0.0) \n    {\n        return il;\n    }\n    for (int i = il; i <= iu; i++) \n    {\n        hVec[i] = hVec[i] / scale;\n        h1 += hVec[i] * hVec[i];\n    }\n    double f = hVec[il];\n    double g = -FastMath.sign(f) * FastMath.sqrt(h1);\n    hVec[il] = f - g;\n    h1 = g - f;\n    for (int i = il + 1; i <= iu; i++) \n    {\n        hVec[i] = hVec[i] / h1;\n    }\n    for (int j = 0; j < n; j++) \n    {\n        double s = 0.0;\n        for (int i = il; i <= iu; i++) \n        {\n            s += matrixT[i][j + il] * hVec[i];\n        }\n        s = s / h1;\n        for (int i = il; i <= iu; i++) \n        {\n            matrixT[i][j + il] += s * hVec[i];\n        }\n    }\n    for (int i = 0; i <= m; i++) \n    {\n        double s = 0.0;\n        for (int j = 0; j < n; j++) \n        {\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int m = iu - 1;\n    if (il > 0) {\n        m = iu;\n    }\n\n    // Compute householder vector\n    double[] x = new double[m - il + 1];\n    double n = 0.0;\n    for (int i = il; i <= iu; i++) {\n        x[i - il] = matrixT[i][i - 1];\n        n += x[i - il] * x[i - il];\n    }\n    n = FastMath.sqrt(n);\n    if (x[0] > 0) {\n        n = -n;\n    }\n    x[0] = x[0] - n;\n    double r = 0.0;\n    for (int i = 0; i < m - il + 1; i++) {\n        r += x[i] * x[i];\n    }\n    r = FastMath.sqrt(r);\n    for (int i = 0; i < m - il + 1; i++) {\n        hVec[i] = x[i] / r;\n    }\n\n    // Compute QR step\n    for (int j = il; j <= iu; j++) {\n        double s = 0.0;\n        for (int i = 0; i < m - il + 1; i++) {\n            s += hVec[i] * matrixT[i + il][j];\n        }\n        s = 2.0 * s / (hVec[0] * hVec[0] + r * r);\n        for (int i = 0; i < m - il + 1; i++) {\n            matrixT[i + il][j] -= hVec[i] * s;\n        }\n    }\n\n    // Update T\n    for (int i = 0; i < m - il + 1; i++) {\n        for (int j = 0; j <= i; j++) {\n            matrixT[i + il][j + il] = matrixT[j + il][i + il];\n        }\n    }\n\n    // Update shift\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // Initialize householder vector\n    double h = 0.0;\n    for (int i = il; i <= iu; i++) \n    {\n        hVec[i] = matrixT[i][i - 1];\n        h += hVec[i] * hVec[i];\n    }\n\n    // Compute shift\n    shift.x = matrixT[iu][iu];\n    shift.y = shift.w = 0.0;\n    if (il > 0) \n    {\n        shift.y = matrixT[il - 1][il - 1];\n        shift.w = matrixT[il][il - 1] * matrixT[il - 1][il];\n    }\n\n    // Form shift\n    double f = (shift.y - shift.x) / 2.0;\n    double g = f * f + shift.w;\n    if (g > 0.0) \n    {\n        g = FastMath.sqrt(g);\n        if (shift.y < shift.x) \n        {\n            g = -g;\n        }\n        f = shift.x - shift.w / ((shift.y - shift.x) / 2.0 + g);\n        h += f * f;\n        shift.x = f;\n        shift.y = 0.0;\n        shift.w = 0.0;\n    }\n\n    // Compute QR step\n    double r = FastMath.sqrt(h);\n    double f2 = shift.x - r;\n    if (f2 > 0.0) \n    {\n        h = h + shift.x * (f2 - shift.x);\n    }\n    else \n    {\n        h = h + shift.x * (f2 + shift.x);\n    }\n\n    // Return QR step\n    return il;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int m = iu - 1;\n    double scale = 0.0;\n    double h = 0.0;\n\n    if (il > 0) \n    {\n        for (int i = il - 1; i <= iu - 1; i++) \n        {\n            scale += FastMath.abs(matrixT[i][i - 1]);\n        }\n        if (scale != 0.0) \n        {\n            double s = 0.0;\n            for (int i = il - 1; i <= iu - 1; i++) \n            {\n                matrixT[i][i - 1] /= scale;\n                s += FastMath.abs(matrixT[i][i - 1]);\n            }\n            h = scale * s / 2.0;\n        }\n    }\n\n    for (int i = 0; i < hVec.length; i++) \n    {\n        hVec[i] = matrixT[i][m];\n    }\n\n    if (il > 0) \n    {\n        for (int i = il - 1; i <= iu - 1; i++) \n        {\n            hVec[i] /= h;\n        }\n    }\n\n    return m;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int m = iu - 1;\n    int l = iu;\n    double z = 0.0;\n    if (il > 0) {\n        l = il;\n        m = il - 1;\n        z = matrixT[m][m];\n    }\n\n    double norm = getNorm();\n    int idx = findSmallSubDiagonalElement(l, norm);\n    computeShift(idx, iu, 0, shift);\n\n    // Initialize householder vector\n    double h = 0.0;\n    for (int i = idx; i <= iu; i++) {\n        hVec[i] = matrixT[i][i] - shift.x;\n        h += hVec[i] * hVec[i];\n    }\n    h = FastMath.sqrt(h);\n    if (hVec[idx] > 0.0) {\n        hVec[idx] += h;\n    } else {\n        hVec[idx] -= h;\n    }\n    h = 1.0 / (FastMath.abs(hVec[idx]) + norm);\n    for (int i = idx; i <= iu; i++) {\n        hVec[i] *= h;\n    }\n\n    // Apply householder transformation to matrix T\n    for (int i = 0; i <= iu; i++) {\n        for (int j = 0; j <= Math.min(i, idx); j++) {\n            double temp = matrixT[i][j] + (matrixT[j][i] -= shift.x * hVec[j] * hVec[i]);\n            matrixT[j][i] = matrixT[i][j] + hVec[j] * hVec[i] * temp;\n        }\n    }\n\n    // Apply householder transformation to matrix T\n    for (int i = 0; i <= iu; i++) {\n        for (int j = 0; j <= Math.min(i, idx); j++) {\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // Initialize householder vector\n    int m = iu;\n    for (int i = il; i <= iu + 1; i++) {\n        hVec[i] = matrixT[i][i];\n    }\n    double hh = 0.0;\n    for (int i = il; i <= iu; i++) {\n        double h = hVec[i];\n        if (i > il) {\n            hVec[i - 1] = h;\n        }\n        if (i < iu) {\n            hh += h * h;\n        }\n    }\n    hVec[iu] = 0.0;\n\n    // Compute shift\n    double scale = 0.0;\n    if (hh != 0.0) {\n        double norm = getNorm();\n        double shiftSq = shift.getShiftSq();\n        double t = (matrixT[iu][iu] - shift.x - shiftSq) / 2.0;\n        if (t > 0.0) {\n            double s = Math.sqrt(t);\n            if (matrixT[iu][iu] < shift.x) {\n                s = -s;\n            }\n            scale = s * (Math.abs(s) + Math.sqrt(hh));\n        } else {\n            scale = Math.abs(matrixT[iu][iu] - shift.x) + Math.sqrt(hh);\n        }\n    }\n\n    // Scale householder vector\n    for (int i = il; i <= iu; i++) {\n        hVec[i] /= scale;\n        hVec[i] *= -1;\n    }\n    hVec[iu] += scale;\n\n    // Perform QR step\n    performQRStep(il, iu, shift, hVec);\n\n    // Find new sub-diagonal element\n    int l = findSmallSubDiagonalElement(iu - 1, norm);\n\n    return l;\n}"
    ],
    [
      "public List<TextNode> textNodes()  {\n        List<TextNode> textNodes;\n        if (shadowTextNodesRef == null || (textNodes = shadowTextNodesRef.get()) == null) {\n            final int size = childNodes.size();\n            textNodes = new ArrayList<>(size);\n            //noinspection ForLoopReplaceableByForEach (beacause it allocates an Iterator which is wasteful here)\n            for (int i = 0; i < size; i++) {\n                final Node node = childNodes.get(i);\n                if (node instanceof TextNode)\n                    textNodes.add((TextNode) node);\n            }\n            shadowTextNodesRef = new WeakReference<>(textNodes);\n        }\n        return textNodes;\n    }",
      "public List<TextNode> textNodes()  {\n        List<TextNode> textNodes;\n        if (shadowTextNodesRef == null || (textNodes = shadowTextNodesRef.get()) == null) {\n            final int size = childNodes.size();\n            textNodes = new ArrayList<>(size);\n            //noinspection ForLoopReplaceableByForEach (beacause it allocates an Iterator which is wasteful here)\n            for (int i = 0; i < size; i++) {\n                final Node node = childNodes.get(i);\n                if (node instanceof TextNode)\n                    textNodes.add((TextNode) node);\n            }\n            shadowTextNodesRef = new WeakReference<>(textNodes);\n        }\n        return textNodes;\n    }",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes;\n    if (shadowTextNodesRef == null || (textNodes = shadowTextNodesRef.get()) == null) {\n        final int size = childNodes.size();\n        textNodes = new ArrayList<>(size);\n        //noinspection ForLoopReplaceableByForEach (beacause it allocates an Iterator which is wasteful here)\n        for (int i = 0; i < size; i++) {\n            final Node node = childNodes.get(i);\n            if (node instanceof TextNode)\n                textNodes.add((TextNode) node);\n        }\n        shadowTextNodesRef = new WeakReference<>(textNodes);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes;\n    if (shadowTextNodesRef == null || (textNodes = shadowTextNodesRef.get()) == null) {\n        final int size = childNodes.size();\n        textNodes = new ArrayList<>(size);\n        //noinspection ForLoopReplaceableByForEach (beacause it allocates an Iterator which is wasteful here)\n        for (int i = 0; i < size; i++) {\n            final Node node = childNodes.get(i);\n            if (node instanceof TextNode)\n                textNodes.add((TextNode) node);\n        }\n        shadowTextNodesRef = new WeakReference<>(textNodes);\n    }\n    return textNodes;\n}",
      "public List<TextNode> textNodes()  {\n        List<TextNode> textNodes;\n        if (shadowTextNodesRef == null || (textNodes = shadowTextNodesRef.get()) == null) {\n            final int size = childNodes.size();\n            textNodes = new ArrayList<>(size);\n            //noinspection ForLoopReplaceableByForEach (beacause it allocates an Iterator which is wasteful here)\n            for (int i = 0; i < size; i++) {\n                final Node node = childNodes.get(i);\n                if (node instanceof TextNode)\n                    textNodes.add((TextNode) node);\n            }\n            shadowTextNodesRef = new WeakReference<>(textNodes);\n        }\n        return Collections.unmodifiableList(textNodes);\n    }",
      "public List<TextNode> textNodes()  {\n        List<TextNode> textNodes;\n        if (shadowTextNodesRef == null || (textNodes = shadowTextNodesRef.get()) == null) {\n            final int size = childNodes.size();\n            textNodes = new ArrayList<>(size);\n            //noinspection ForLoopReplaceableByForEach (beacause it allocates an Iterator which is wasteful here)\n            for (int i = 0; i < size; i++) {\n                final Node node = childNodes.get(i);\n                if (node instanceof TextNode)\n                    textNodes.add((TextNode) node);\n            }\n            shadowTextNodesRef = new WeakReference<>(textNodes);\n        }\n        return textNodes;\n    }",
      "public List<TextNode> textNodes()  {\n        List<TextNode> textNodes;\n        if (shadowTextNodesRef == null || (textNodes = shadowTextNodesRef.get()) == null) {\n            final int size = childNodes.size();\n            textNodes = new ArrayList<>(size);\n            //noinspection ForLoopReplaceableByForEach (beacause it allocates an Iterator which is wasteful here)\n            for (int i = 0; i < size; i++) {\n                final Node node = childNodes.get(i);\n                if (node instanceof TextNode)\n                    textNodes.add((TextNode) node);\n            }\n            shadowTextNodesRef = new WeakReference<>(textNodes);\n        }\n        return textNodes;\n    }",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes;\n    if (shadowTextNodesRef == null || (textNodes = shadowTextNodesRef.get()) == null) {\n        final int size = childNodes.size();\n        textNodes = new ArrayList<>(size);\n        //noinspection ForLoopReplaceableByForEach (beacause it allocates an Iterator which is wasteful here)\n        for (int i = 0; i < size; i++) {\n            final Node node = childNodes.get(i);\n            if (node instanceof TextNode)\n                textNodes.add((TextNode) node);\n        }\n        shadowTextNodesRef = new WeakReference<>(textNodes);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n        List<TextNode> textNodes;\n        if (shadowTextNodesRef == null || (textNodes = shadowTextNodesRef.get()) == null) {\n            final int size = childNodes.size();\n            textNodes = new ArrayList<>(size);\n            //noinspection ForLoopReplaceableByForEach (beacause it allocates an Iterator which is wasteful here)\n            for (int i = 0; i < size; i++) {\n                final Node node = childNodes.get(i);\n                if (node instanceof TextNode)\n                    textNodes.add((TextNode) node);\n            }\n            shadowTextNodesRef = new WeakReference<>(textNodes);\n        }\n        return textNodes;\n    }",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes;\n    if (shadowTextNodesRef == null || (textNodes = shadowTextNodesRef.get()) == null) {\n        final int size = childNodes.size();\n        textNodes = new ArrayList<>(size);\n        //noinspection ForLoopReplaceableByForEach (beacause it allocates an Iterator which is wasteful here)\n        for (int i = 0; i < size; i++) {\n            final Node node = childNodes.get(i);\n            if (node instanceof TextNode)\n                textNodes.add((TextNode) node);\n        }\n        shadowTextNodesRef = new WeakReference<>(textNodes);\n    }\n    return Collections.unmodifiableList(textNodes);\n}"
    ],
    [
      "public boolean inIncludeSegments()  {\n    // Your code goes here\n}",
      "public boolean inIncludeSegments()  {\n    if (this.segmentCount == this.segmentNumber) \n    {\n        return true;\n    }\n    else \n    {\n        return false;\n    }\n}",
      "public boolean inIncludeSegments()  {\n    // check if all segments are included\n    for (long i = this.segmentStart; i <= this.segmentEnd; i++) \n    {\n        if (!getSegment(i).isIncluded()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    if (this.segmentCount == this.segmentCount)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}",
      "public boolean inIncludeSegments()  {\n    for (long i = this.segmentStart; i <= this.segmentEnd; i++) \n    {\n        if (!getSegment(i).isException()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    if(this.segmentCount == this.segmentCount)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}",
      "public boolean inIncludeSegments()  {\n    for (long i = this.segmentNumber; i < this.segmentNumber + this.segmentCount; i++) \n    {\n        if (isException(i)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (long i = this.segmentNumber; i < this.segmentNumber + this.segmentCount; i++) \n    {\n        if (!isException(i)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    // TODO: Implement this method\n    return false;\n}",
      "public boolean inIncludeSegments()  {\n    // Check if all segments are included in the segment range\n    for (long i = this.segmentStart; i <= this.segmentEnd; i++) \n    {\n        if (!getSegment(i).isIncluded()) \n        {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null || zeroInstance == null) \n    {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n\n    MutablePeriod mutablePeriod = new MutablePeriod(zeroInstance);\n    mutablePeriod.setPeriod(start, end);\n    return mutablePeriod.get(zeroInstance.getFieldType());\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null || zeroInstance == null) \n        {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        // get the chronology of the start partial date\n        Chronology chrono = DateTimeUtils.getPartialChronology(start);\n        // get the duration field for the period type\n        DurationField field = zeroInstance.getFieldType().getField(chrono);\n        // calculate the difference between the two partials\n        int amount = field.getDifference(end.get(zeroInstance.getFieldType()), start.get(zeroInstance.getFieldType()));\n        return amount;\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null || zeroInstance == null) \n        {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        long startMillis = start.getChronology().getInstant(start);\n        long endMillis = end.getChronology().getInstant(end);\n        if (startMillis > endMillis) \n        {\n            throw new IllegalArgumentException(\"Start instant is after end instant\");\n        }\n        int period = 0;\n        for (DurationField field : zeroInstance.getDurationFields()) \n        {\n            long diff = field.getDifference(endMillis, startMillis);\n            period += field.getAsLong(diff);\n        }\n        return period;\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null || zeroInstance == null) \n    {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    // TODO: Implement this method\n    return 0;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null || zeroInstance == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        long startMillis = start.getChronology().getInstant(start.getChronology().getZone(), start).getMillis();\n        long endMillis = end.getChronology().getInstant(end.getChronology().getZone(), end).getMillis();\n        int period = zeroInstance.getClass().cast(zeroInstance).getPeriodType().getDifference(endMillis, startMillis);\n        return period;\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null || zeroInstance == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        long startMillis = start.getChronology().getInstant(start.getChronology().getZone(), start).getMillis();\n        long endMillis = end.getChronology().getInstant(end.getChronology().getZone(), end).getMillis();\n        int period = (int) ((endMillis - startMillis) / zeroInstance.getMillis());\n        return period;\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null || zeroInstance == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (!start.getChronology().equals(end.getChronology())) {\n            throw new IllegalArgumentException(\"Chronologies must be equal\");\n        }\n        int period = 0;\n        for (DurationField field : zeroInstance.getDurationFields()) {\n            period += field.getDifference(end.get(field), start.get(field));\n        }\n        return period;\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null || zeroInstance == null) \n        {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (!start.getChronology().equals(end.getChronology())) \n        {\n            throw new IllegalArgumentException(\"The chronologies of the partials must match\");\n        }\n        int startMillis = (int) (start.getChronology().getInstant(start) / 1000);\n        int endMillis = (int) (end.getChronology().getInstant(end) / 1000);\n        int periodMillis = endMillis - startMillis;\n        return (int) (periodMillis / zeroInstance.getMillis());\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null || zeroInstance == null) \n        {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        // TODO: Implement the logic here\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null || zeroInstance == null) \n        {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        Chronology chrono = DateTimeUtils.getPartialChronology(start);\n        int amount = zeroInstance.getField(chrono).getDifference(end.get(zeroInstance.getField(chrono).getType()), start.get(zeroInstance.getField(chrono).getType()));\n        return amount;\n    }"
    ],
    [
      "public LegendTitle getLegend(int index)  {\n    List<SubTitle> subtitles = getSubtitles();\n    if (index < subtitles.size()) {\n        return (LegendTitle) subtitles.get(index);\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    List<SubTitle> subtitles = getSubtitles();\n    if (index < subtitles.size()) {\n        return (LegendTitle) subtitles.get(index);\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    if (this.subtitles == null) {\n        return null;\n    }\n    if (index < 0 || index >= this.subtitles.size()) {\n        throw new IllegalArgumentException(\"Index out of bounds.\");\n    }\n    return (LegendTitle) this.subtitles.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (this.subtitles == null) {\n        return null;\n    }\n    else if (index < 0 || index >= this.subtitles.size()) {\n        throw new IllegalArgumentException(\"Legend index out of range.\");\n    }\n    else {\n        return (LegendTitle) this.subtitles.get(index);\n    }\n}",
      "public LegendTitle getLegend(int index)  {\n    if (this.subtitles == null) {\n        return null;\n    }\n    else if (index < 0 || index >= this.subtitles.size()) {\n        throw new IllegalArgumentException(\"Index out of bounds.\");\n    }\n    return (LegendTitle) this.subtitles.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= subtitleList.size()) {\n        return null;\n    }\n    return (LegendTitle) subtitleList.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (this.subtitles == null) {\n        return null;\n    }\n    else if (index < 0 || index >= this.subtitles.size()) {\n        throw new IllegalArgumentException(\"Legend index out of range.\");\n    }\n    else {\n        return (LegendTitle) this.subtitles.get(index);\n    }\n}",
      "public LegendTitle getLegend(int index)  {\n    List<Title> subtitles = getSubtitles();\n    if (index < subtitles.size()) \n    {\n        return (LegendTitle) subtitles.get(index);\n    }\n    else \n    {\n        return null;\n    }\n}",
      "public LegendTitle getLegend(int index)  {\n    List<SubTitle> subtitles = getSubtitles();\n    if (subtitles.size() > index) {\n        return (LegendTitle) subtitles.get(index);\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= getSubtitleCount()) {\n        return null;\n    }\n    return (LegendTitle) getSubtitle(index);\n}"
    ],
    [
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    // Sort the entries by their physical offset in the file\n    List<ZipArchiveEntry> sortedEntries = new ArrayList<>(entries);\n    Collections.sort(sortedEntries, new Comparator<ZipArchiveEntry>() {\n}\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    List<ZipArchiveEntry> list = new ArrayList<ZipArchiveEntry>(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    // sort the entries by their physical offset in the archive\n    List<ZipArchiveEntry> sortedEntries = new ArrayList<>(entries);\n    Collections.sort(sortedEntries, new Comparator<ZipArchiveEntry>() {\n}\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    // Create a new list to hold the entries in physical order\n    List<ZipArchiveEntry> physicalOrderEntries = new ArrayList<>();\n\n    // Iterate through the original entries\n    for (ZipArchiveEntry entry : entries) \n    {\n        // If the entry's local header offset is less than the size of the central directory,\n        // it's in physical order\n        if (entry.getLocalHeaderOffset() < centralDirectorySize) \n        {\n            // Add it to the list\n            physicalOrderEntries.add(entry);\n        }\n    }\n\n    // Return the enumeration of the list\n    return Collections.enumeration(physicalOrderEntries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    List<ZipArchiveEntry> entriesInPhysicalOrder = new ArrayList<>(entries);\n    entriesInPhysicalOrder.sort(Comparator.comparing(ZipArchiveEntry::getLocalHeaderOffset));\n    return Collections.enumeration(entriesInPhysicalOrder);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    // Create a list of entries in physical order\n    List<ZipArchiveEntry> physicalOrderEntries = new ArrayList<>(entries);\n    Collections.sort(physicalOrderEntries, new Comparator<ZipArchiveEntry>() {\n}\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    // Create a new list to hold the entries in physical order\n    List<ZipArchiveEntry> physicalOrderEntries = new ArrayList<>();\n\n    // Iterate through the original entries list\n    for (ZipArchiveEntry entry : entries) \n    {\n        // If the entry is not a directory and its local header offset is not -1\n        // (which means it has not been processed yet)\n        if (!entry.isDirectory() && entry.getLocalHeaderOffset() != -1) \n        {\n            // Add the entry to the new list\n            physicalOrderEntries.add(entry);\n\n            // Set the local header offset of the entry to -1\n            // to mark it as processed\n            entry.setLocalHeaderOffset(-1);\n        }\n    }\n\n    // Return the new list as an enumeration\n    return Collections.enumeration(physicalOrderEntries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    // Create a list of entries in the order they appear in the archive\n    List<ZipArchiveEntry> orderedEntries = new ArrayList<>(entries);\n    Collections.sort(orderedEntries, new Comparator<ZipArchiveEntry>() \n    {\n}\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    // sort the entries by their offset in the file\n    List<ZipArchiveEntry> sortedEntries = new ArrayList<>(entries);\n    Collections.sort(sortedEntries, new Comparator<ZipArchiveEntry>() \n    {\n}\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n        // Sort the entries by their offset in the archive.\n        List<ZipArchiveEntry> sortedEntries = new ArrayList<>(entries);\n        Collections.sort(sortedEntries, new Comparator<ZipArchiveEntry>() {\n}\n}"
    ],
    [
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        JsDocToken nextToken = next();\n        if (nextToken == JsDocToken.ELLIPSIS) \n        {\n            next();\n            Node typeNode = parseTopLevelTypeExpression(next());\n            if (typeNode != null) \n            {\n                skipEOLs();\n                if (!match(JsDocToken.RC)) \n                {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } \n                else \n                {\n                    next();\n                }\n                return new SpreadNode(typeNode);\n            }\n        } \n        else \n        {\n            Node typeNode = parseTopLevelTypeExpression(nextToken);\n            if (typeNode != null) \n            {\n                skipEOLs();\n                if (!match(JsDocToken.RC)) \n                {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } \n                else \n                {\n                    next();\n                }\n                return typeNode;\n            }\n        }\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n    return null;\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) \n  {\n    skipEOLs();\n    JsDocToken nextToken = next();\n    if (nextToken == JsDocToken.ELLIPSIS) \n    {\n      next();\n      Node typeNode = parseTopLevelTypeExpression(next());\n      if (typeNode != null) \n      {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) \n        {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } \n        else \n        {\n          next();\n        }\n      }\n\n      return typeNode;\n    } \n    else if (nextToken == JsDocToken.IDENTIFIER) \n    {\n      Node typeNode = parseOptionalParameterType(nextToken);\n      if (typeNode != null) \n      {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) \n        {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } \n        else \n        {\n          next();\n        }\n      }\n\n      return typeNode;\n    } \n    else \n    {\n      Node typeNode = parseTopLevelTypeExpression(nextToken);\n      if (typeNode != null) \n      {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) \n        {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } \n        else \n        {\n          next();\n        }\n      }\n\n      return typeNode;\n    }\n  } \n  else \n  {\n    return null;\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        token = next();\n        if (token == JsDocToken.ELLIPSIS) \n        {\n            token = next();\n            Node typeNode = parseTopLevelTypeExpression(token);\n            if (typeNode != null) \n            {\n                skipEOLs();\n                if (!match(JsDocToken.RC)) \n                {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } \n                else \n                {\n                    token = next();\n                }\n            }\n            return typeNode;\n        } \n        else \n        {\n            Node typeNode = parseTopLevelTypeExpression(token);\n            if (typeNode != null) \n            {\n                skipEOLs();\n                if (!match(JsDocToken.RC)) \n                {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } \n                else \n                {\n                    token = next();\n                }\n            }\n            return typeNode;\n        }\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) \n  {\n    skipEOLs();\n    JsDocToken nextToken = next();\n    if (nextToken == JsDocToken.ELLIPSIS) \n    {\n      next();\n      Node typeNode = parseTopLevelTypeExpression(next());\n      if (typeNode != null) \n      {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) \n        {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } \n        else \n        {\n          next();\n        }\n      }\n      return typeNode;\n    } \n    else \n    {\n      Node typeNode = parseTopLevelTypeExpression(nextToken);\n      if (typeNode != null) \n      {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) \n        {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } \n        else \n        {\n          next();\n        }\n      }\n      return typeNode;\n    }\n  } \n  else \n  {\n    return null;\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        JsDocToken nextToken = next();\n        if (nextToken == JsDocToken.ELLIPSIS) \n        {\n            next();\n            Node typeNode = parseTopLevelTypeExpression(next());\n            if (typeNode != null) \n            {\n                skipEOLs();\n                if (!match(JsDocToken.RC)) \n                {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } \n                else \n                {\n                    next();\n                }\n                return new SpreadNode(typeNode);\n            }\n        } \n        else if (nextToken == JsDocToken.IDENTIFIER && nextToken.value().equals(\"...\")) \n        {\n            next();\n            Node typeNode = parseTopLevelTypeExpression(next());\n            if (typeNode != null) \n            {\n                skipEOLs();\n                if (!match(JsDocToken.RC)) \n                {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } \n                else \n                {\n                    next();\n                }\n                return new SpreadNode(typeNode);\n            }\n        } \n        else \n        {\n            Node typeNode = parseTypeExpression(nextToken);\n            if (typeNode != null) \n            {\n                skipEOLs();\n                if (!match(JsDocToken.RC)) \n                {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } \n                else \n                {\n                    next();\n                }\n                return typeNode;\n            }\n        }\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n    return null;\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        JsDocToken nextToken = next();\n        if (nextToken == JsDocToken.ELLIPSIS) \n        {\n            next();\n            Node typeNode = parseTopLevelTypeExpression(next());\n            if (typeNode != null) \n            {\n                skipEOLs();\n                if (!match(JsDocToken.RC)) \n                {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } \n                else \n                {\n                    next();\n                }\n            }\n\n            return typeNode;\n        } \n        else if (nextToken == JsDocToken.IDENTIFIER) \n        {\n            Node typeNode = parseOptionalParameterType(nextToken);\n            if (typeNode != null) \n            {\n                skipEOLs();\n                if (!match(JsDocToken.RC)) \n                {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } \n                else \n                {\n                    next();\n                }\n            }\n\n            return typeNode;\n        } \n        else \n        {\n            Node typeNode = parseTopLevelTypeExpression(nextToken);\n            if (typeNode != null) \n            {\n                skipEOLs();\n                if (!match(JsDocToken.RC)) \n                {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } \n                else \n                {\n                    next();\n                }\n            }\n\n            return typeNode;\n        }\n    } \n    else \n    {\n        return null;\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        JsDocToken nextToken = next();\n        if (nextToken == JsDocToken.ELLIPSIS) \n        {\n            next();\n            Node typeNode = parseTopLevelTypeExpression(next());\n            if (typeNode != null) \n            {\n                skipEOLs();\n                if (!match(JsDocToken.RC)) \n                {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } \n                else \n                {\n                    next();\n                }\n            }\n            return typeNode;\n        } \n        else \n        {\n            Node typeNode = parseTopLevelTypeExpression(nextToken);\n            if (typeNode != null) \n            {\n                skipEOLs();\n                if (!match(JsDocToken.RC)) \n                {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } \n                else \n                {\n                    next();\n                }\n            }\n            return typeNode;\n        }\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) \n  {\n    skipEOLs();\n    JsDocToken nextToken = next();\n    if (nextToken == JsDocToken.ELLIPSIS) \n    {\n      nextToken = next();\n      if (nextToken != JsDocToken.LC) \n      {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.lc\");\n      }\n      Node typeNode = parseTopLevelTypeExpression(next());\n      if (typeNode != null) \n      {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) \n        {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } \n        else \n        {\n          next();\n        }\n      }\n      return typeNode;\n    } \n    else if (nextToken == JsDocToken.IDENTIFIER && nextToken.image.equals(\"...\")) \n    {\n      nextToken = next();\n      if (nextToken != JsDocToken.LC) \n      {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.lc\");\n      }\n      Node typeNode = parseTopLevelTypeExpression(next());\n      if (typeNode != null) \n      {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) \n        {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } \n        else \n        {\n          next();\n        }\n      }\n      return typeNode;\n    } \n    else \n    {\n      Node typeNode = parseTopLevelTypeExpression(nextToken);\n      if (typeNode != null) \n      {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) \n        {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } \n        else \n        {\n          next();\n        }\n      }\n      return typeNode;\n    }\n  } \n  else \n  {\n    return null;\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        JsDocToken nextToken = next();\n        if (nextToken == JsDocToken.ELLIPSIS) \n        {\n            next();\n            Node typeNode = parseTopLevelTypeExpression(next());\n            if (typeNode != null) \n            {\n                skipEOLs();\n                if (!match(JsDocToken.RC)) \n                {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } \n                else \n                {\n                    next();\n                }\n            }\n\n            return typeNode;\n        } \n        else \n        {\n            Node typeNode = parseTopLevelTypeExpression(nextToken);\n            if (typeNode != null) \n            {\n                skipEOLs();\n                if (!match(JsDocToken.RC)) \n                {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } \n                else \n                {\n                    next();\n                }\n            }\n\n            return typeNode;\n        }\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        JsDocToken nextToken = next();\n        if (nextToken == JsDocToken.ELLIPSIS) \n        {\n            next();\n            Node typeNode = parseTopLevelTypeExpression(next());\n            if (typeNode != null) \n            {\n                skipEOLs();\n                if (!match(JsDocToken.RC)) \n                {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } \n                else \n                {\n                    next();\n                }\n            }\n            return typeNode;\n        } \n        else if (nextToken == JsDocToken.IDENTIFIER) \n        {\n            Node typeNode = parseOptionalParameterType(nextToken);\n            if (typeNode != null) \n            {\n                skipEOLs();\n                if (!match(JsDocToken.RC)) \n                {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } \n                else \n                {\n                    next();\n                }\n            }\n            return typeNode;\n        } \n        else \n        {\n            Node typeNode = parseTopLevelTypeExpression(nextToken);\n            if (typeNode != null) \n            {\n                skipEOLs();\n                if (!match(JsDocToken.RC)) \n                {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } \n                else \n                {\n                    next();\n                }\n            }\n            return typeNode;\n        }\n    } \n    else \n    {\n        return null;\n    }\n}"
    ],
    [
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> stackFrames = new ArrayList<String>(Arrays.asList(getStackFrames(t)));\n    removeCommonFrames(stackFrames, Arrays.asList(getStackFrames(t.getCause())));\n    return stackFrames;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    if (t == null) {\n        return new ArrayList<String>();\n    }\n    List<String> causeFrames = Arrays.asList(getStackFrames(t));\n    List<String> wrapperFrames = Arrays.asList(getStackFrames(t.getCause()));\n    removeCommonFrames(causeFrames, wrapperFrames);\n    return causeFrames;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> causeFrames = Arrays.asList(getStackFrames(t));\n    List<String> wrapperFrames = Arrays.asList(getStackFrames(new Exception(t)));\n    removeCommonFrames(causeFrames, wrapperFrames);\n    return causeFrames;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> causeFrames = Arrays.asList(getStackFrames(t));\n    List<String> wrapperFrames = Arrays.asList(getStackFrames(new Exception(t)));\n    removeCommonFrames(causeFrames, wrapperFrames);\n    return causeFrames;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    if (t == null) \n    {\n        return new ArrayList<String>();\n    }\n\n    final List<String> causeFrames = new ArrayList<String>(Arrays.asList(getStackFrames(t)));\n    final List<String> wrapperFrames = new ArrayList<String>(Arrays.asList(getStackFrames(t.getCause())));\n\n    removeCommonFrames(causeFrames, wrapperFrames);\n\n    return causeFrames;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> stackFrames = new ArrayList<String>(Arrays.asList(getStackFrames(t)));\n    // Remove the first frame as it is the method getStackFrames(Throwable t)\n    stackFrames.remove(0);\n    return stackFrames;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> stackFrames = new ArrayList<String>(Arrays.asList(getStackFrames(t)));\n    // remove common frames from cause trace\n    if (t.getCause() != null) {\n        removeCommonFrames(stackFrames, Arrays.asList(getStackFrames(t.getCause())));\n    }\n    return stackFrames;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> stackFrames = new ArrayList<String>(Arrays.asList(getStackFrames(t)));\n    if (t.getCause() != null) \n    {\n        stackFrames.addAll(getStackFrameList(t.getCause()));\n    }\n    return stackFrames;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> causeFrames = Arrays.asList(getStackFrames(t));\n    List<String> wrapperFrames = Arrays.asList(getStackFrames(new Exception(t)));\n    removeCommonFrames(causeFrames, wrapperFrames);\n    return causeFrames;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> stackFrames = new ArrayList<String>(Arrays.asList(getStackFrames(t)));\n    // remove the first line which is the exception message\n    stackFrames.remove(0);\n    return stackFrames;\n}"
    ],
    [
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    boolean result;\n    if (p == PEEKED_BOOLEAN) {\n      result = peekedBoolean;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n    return result;\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    boolean result;\n    if (p == PEEKED_TRUE) {\n      result = true;\n      pos += 4;\n    } else if (p == PEEKED_FALSE) {\n      result = false;\n      pos += 5;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_BOOLEAN) {\n      boolean result = peekedBoolean;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_BOOLEAN) {\n      boolean result = peekedBoolean;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_BOOLEAN) {\n      boolean result = peekedBoolean;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_BOOLEAN) {\n      boolean result = peekedBoolean;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_BOOLEAN) {\n      boolean result = peekedBoolean;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_BOOLEAN) {\n      boolean result = peekedBoolean;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    boolean result;\n    if (p == PEEKED_BOOLEAN) {\n      result = peekedBoolean;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n    return result;\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_BOOLEAN) {\n      boolean result = peekedBoolean;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }"
    ],
    [
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    final char[] padding = new char[pads];\n    Arrays.fill(padding, padChar);\n    return new String(padding).concat(str.concat(new String(padding)));\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    final char[] padding = new char[pads];\n    Arrays.fill(padding, padChar);\n    return new String(padding).concat(str.concat(new String(padding)));\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    final char[] padChars = new char[pads];\n    Arrays.fill(padChars, padChar);\n    final StringBuilder sb = new StringBuilder(size);\n    sb.append(padChars);\n    sb.append(str);\n    sb.append(padChars);\n    return sb.toString();\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    if (strLen > size) {\n        return str;\n    }\n\n    final StringBuilder sb = new StringBuilder(size);\n    final int pads = size - strLen;\n    for (int i = 0; i < pads / 2; i++) {\n        sb.append(padChar);\n    }\n    sb.append(str);\n    while (sb.length() < size) {\n        sb.append(padChar);\n    }\n    return sb.toString();\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    if (strLen > size) {\n        return str;\n    }\n\n    final StringBuilder sb = new StringBuilder(size);\n    final int pads = size - strLen;\n    final int padStart = pads / 2;\n    final int padEnd = pads - padStart;\n\n    for (int i = 0; i < padStart; i++) {\n        sb.append(padChar);\n    }\n    sb.append(str);\n    for (int i = 0; i < padEnd; i++) {\n        sb.append(padChar);\n    }\n\n    return sb.toString();\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    final char[] padding = new char[pads];\n    Arrays.fill(padding, padChar);\n    return new String(padding).concat(str).concat(new String(padding));\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    final char[] padding = new char[pads];\n    Arrays.fill(padding, padChar);\n    return new String(padding).concat(str).concat(new String(padding));\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    if (strLen > size) {\n        return str;\n    }\n\n    final StringBuilder sb = new StringBuilder(size);\n    final int pads = size - strLen;\n    final int padStart = pads / 2;\n    final int padEnd = pads - padStart;\n\n    for (int i = 0; i < padStart; i++) {\n        sb.append(padChar);\n    }\n    sb.append(str);\n    for (int i = 0; i < padEnd; i++) {\n        sb.append(padChar);\n    }\n\n    return sb.toString();\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    final char[] padding = new char[pads];\n    Arrays.fill(padding, padChar);\n    return new String(padding).concat(str.concat(new String(padding)));\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    if (strLen > size) {\n        return str;\n    }\n\n    final StringBuilder sb = new StringBuilder(size);\n    final int pads = size - strLen;\n    final int padStart = pads / 2;\n    final int padEnd = pads - padStart;\n\n    for (int i = 0; i < padStart; i++) {\n        sb.append(padChar);\n    }\n    sb.append(str);\n    for (int i = 0; i < padEnd; i++) {\n        sb.append(padChar);\n    }\n\n    return sb.toString();\n}"
    ],
    [
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node methodName = call.getFirstChild();\n    Node args = getLastChild(call);\n\n    if (args == null || args.getChildCount() == 0) \n    {\n        return false;\n    }\n\n    for (int i = 0; i < args.getChildCount(); i++) \n    {\n        Node arg = args.getChild(i);\n        if (compiler.hasSideEffects(arg)) \n        {\n            return true;\n        }\n    }\n\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node fn = call.getFirstChild();\n    if (!fn.isName()) {\n      return false;\n    }\n\n    Node methodName = fn.getFirstChild();\n    if (!methodName.isString()) {\n      return false;\n    }\n\n    String name = methodName.getString();\n    if (name.equals(\"equals\") || name.equals(\"hashCode\")) {\n      return false;\n    }\n\n    Node args = call.getLastChild();\n    if (!args.hasChildren()) {\n      return false;\n    }\n\n    for (Node arg : args.getChildren()) {\n      if (!arg.isName()) {\n        return true;\n      }\n\n      String argName = arg.getFirstChild().getString();\n      if (argName.equals(\"this\") || argName.equals(\"super\")) {\n        return true;\n      }\n    }\n\n    return false;\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node methodName = call.getFirstChild();\n    Node args = call.getLastChild();\n    Node obj = methodName.getFirstChild();\n\n    // If the method is a getter, the object reference has side effects.\n    if (isGetter(methodName)) {\n      return true;\n    }\n\n    // If the method is a setter, the object reference and arguments have side effects.\n    if (isSetter(methodName)) {\n      return true;\n    }\n\n    // If the method is a constructor, the arguments have side effects.\n    if (isConstructor(methodName)) {\n      return true;\n    }\n\n    // If the method is a call to a method on the object reference,\n    // the object reference has side effects.\n    if (isMethodCall(obj)) {\n      return true;\n    }\n\n    // If the method is a call to a property on the object reference,\n    // the object reference has side effects.\n    if (isPropertyCall(obj)) {\n      return true;\n    }\n\n    // If the method is a call to a function,\n    // the arguments have side effects.\n    if (isFunctionCall(methodName)) {\n      return true;\n    }\n\n    // If the method is a call to a method on the object reference or a property on the object reference,\n    // the object reference has side effects.\n    if (isMethodOrPropertyCall(methodName)) {\n      return true;\n    }\n\n    // If the method is a call to a method on the object reference or a property on the object reference,\n    // the object reference and arguments have side effects.\n    if (isMethodOrPropertyCallWithArgs(methodName)) {\n      return true;\n    }\n\n    // If the method is a call to a method on the object reference or a property on the object reference,\n    // the object reference and arguments have side effects.\n    if (isMethodOrPropertyCallWithArgs(methodName)) {\n      return true;\n    }\n\n    // If the method is a call to a method on the object reference or a property on the object reference,\n    // the object reference and arguments have side effects.\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node methodName = call.getFirstChild();\n    Node argList = call.getLastChild();\n    for (int i = 0; i < argList.getChildCount(); i++) \n    {\n        Node arg = argList.getChild(i);\n        if (compiler.mayHaveSideEffects(arg)) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node method = call.getFirstChild();\n    for (Node arg : NodeUtil.getArguments(call)) \n    {\n        if (NodeUtil.hasSideEffects(arg)) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node method = call.getFirstChild();\n    for (Node arg : NodeUtil.getArguments(call)) \n    {\n        if (NodeUtil.isExprCall(arg) || NodeUtil.isPropertyCall(arg)) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node methodName = call.getFirstChild();\n    Node argList = getLastChild(call);\n    if (argList == null || argList.getChildCount() == 0) {\n      return false;\n    }\n\n    Node firstArg = argList.getFirstChild();\n    Node lastArg = argList.getLastChild();\n\n    if (firstArg.isLiteral() && lastArg.isLiteral()) {\n      return false;\n    }\n\n    if (methodName.isLiteral() &&\n        compiler.getLiteralValue(methodName) == null) {\n      return false;\n    }\n\n    if (compiler.isMethodName(methodName)) {\n      return true;\n    }\n\n    if (compiler.isPropertyName(methodName)) {\n      return false;\n    }\n\n    return true;\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node method = call.getFirstChild();\n    Node args = method.getNextSibling();\n    Node arg = args.getFirstChild();\n\n    while (arg != null) \n    {\n        if (compiler.hasSideEffects(arg)) \n        {\n            return true;\n        }\n        arg = arg.getNextSibling();\n    }\n\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node fn = call.getFirstChild();\n    if (!fn.isName()) {\n      return false;\n    }\n\n    Node methodName = fn.getFirstChild();\n    Node obj = call.getLastChild();\n\n    // Check if the method is empty\n    Node methodBlock = getMethodBlock(fn);\n    if (methodBlock != null && NodeUtil.isEmptyBlock(methodBlock)) {\n      return false;\n    }\n\n    // Check if the method is a getter\n    if (methodName.getLastChild().isStringLiteral() &&\n        compiler.isGetter(methodName.getLastChild().getStringValue())) {\n      return false;\n    }\n\n    // Check if the object is a constant\n    if (obj.isLiteral() || (obj.isName() && compiler.isConst(obj.getFirstChild()))) {\n      return false;\n    }\n\n    // Check if the method is a setter\n    if (compiler.isSetter(methodName.getLastChild().getStringValue())) {\n      return true;\n    }\n\n    // Check if the method has a side effect\n    return compiler.hasSideEffects(methodName.getLastChild().getStringValue(), obj);\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node methodName = call.getFirstChild();\n    Node methodObj = call.getSecondChild();\n    Node args = call.getLastChild();\n\n    // If the method name is a string literal, it's a call to a property.\n    if (methodName.isStringLiteral()) {\n      return false;\n    }\n\n    // If the method object is a constant, it's a call to a constant method.\n    if (methodObj.isConst()) {\n      return false;\n    }\n\n    // If the method object is a variable, it's a call to a variable method.\n    if (methodObj.isVariable()) {\n      return true;\n    }\n\n    // If the method object is a call to a function, it's a call to a function method.\n    if (methodObj.isCall()) {\n      return argsMayHaveSideEffects(methodObj);\n    }\n\n    // If the method object is a field access, it's a call to a field method.\n    if (methodObj.isFieldAccess()) {\n      return false;\n    }\n\n    // If the method object is a method access, it's a call to a method method.\n    if (methodObj.isMethodAccess()) {\n      return argsMayHaveSideEffects(methodObj);\n    }\n\n    // If the method object is a new expression, it's a call to a constructor.\n    if (methodObj.isNewExpr()) {\n      return true;\n    }\n\n    // If the method object is a this expression, it's a call to a method on 'this'.\n    if (methodObj.isThisExpr()) {\n      return true;\n    }\n\n    // If the method object is a super expression, it's a call to a method on 'super'.\n    if (methodObj.isSuperExpr()) {\n      return true;\n    }\n\n    // If the method object is a static field access, it's a call to a static field method.\n    if (methodObj.isStaticFieldAccess()) {\n      return false;\n    }\n\n    // If the method object is a static method access, it's a call to a static method method.\n}"
    ],
    [
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(pivot[i], i, field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(pivot[i], i, field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(pivot[i], i, field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(pivot[i], i, field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(pivot[i], i, field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(pivot[i], i, field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}"
    ],
    [
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  throws ZipException {\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        for (final ZipExtraField ze : data) {\n            baos.write(ze.getHeaderId().getValue());\n            baos.write(ze.getDataLength().getValue());\n            baos.write(ze.getData());\n        }\n        return baos.toByteArray();\n    }",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  throws ZipException {\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        for (final ZipExtraField ze : data) {\n            final byte[] b = ze.getLocalFileDataData();\n            baos.write(b, 0, b.length);\n        }\n        return baos.toByteArray();\n    }",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        for (final ZipExtraField ze : data) {\n            final byte[] b = ze.getLocalFileDataData();\n            baos.write(b, 0, b.length);\n        }\n        return baos.toByteArray();\n    }",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        for (final ZipExtraField ze : data) {\n            baos.write(ze.getHeaderId().getBytes(), 0, WORD);\n            final byte[] extra = ze.getLocalFileDataData();\n            baos.write(new ZipShort(extra.length).getBytes(), 0, WORD);\n            baos.write(extra, 0, extra.length);\n        }\n        return baos.toByteArray();\n    }",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  throws ZipException {\n    final ByteArrayOutputStream out = new ByteArrayOutputStream();\n    for (final ZipExtraField ze : data) {\n        final byte[] localData = ze.getLocalFileDataData();\n        if (localData == null) {\n            throw new ZipException(\"ZipExtraField has no local file data\");\n        }\n        out.write(localData, 0, localData.length);\n    }\n    return out.toByteArray();\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  throws ZipException {\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        for (final ZipExtraField ze : data) {\n            final byte[] b = ze.getLocalFileDataData();\n            baos.write(b.length / 256);\n            baos.write(b.length % 256);\n            baos.write(b);\n        }\n        return baos.toByteArray();\n    }",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        for (final ZipExtraField ze : data) {\n            final byte[] localFileData = ze.getLocalFileDataData();\n            baos.write(localFileData, 0, localFileData.length);\n        }\n        return baos.toByteArray();\n    }",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n        int size = 0;\n        for (ZipExtraField field : data) {\n            size += field.getLocalFileDataLength();\n        }\n\n        byte[] result = new byte[size];\n        int pos = 0;\n        for (ZipExtraField field : data) {\n            byte[] fieldData = field.getLocalFileDataData();\n            System.arraycopy(fieldData, 0, result, pos, fieldData.length);\n            pos += fieldData.length;\n        }\n        return result;\n    }",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  throws ZipException {\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        for (final ZipExtraField ze : data) {\n            final byte[] b = ze.getLocalFileDataData();\n            out.write(b, 0, b.length);\n        }\n        return out.toByteArray();\n    }",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  throws ZipException {\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    for (final ZipExtraField ze : data) {\n        final byte[] b = ze.getLocalFileDataData();\n        baos.write(b, 0, b.length);\n    }\n    return baos.toByteArray();\n}"
    ],
    [
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n        BSPTree<Euclidean1D> node = getTree(false);\n        double sup = Double.NEGATIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n            sup = op.getLocation().getX();\n            node = op.isDirect() ? node.getPlus() : node.getMinus();\n        }\n        return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n    }",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n        BSPTree<Euclidean1D> node = getTree(false);\n        double sup = Double.NEGATIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n            sup = op.getLocation().getX();\n            node = op.isDirect() ? node.getPlus() : node.getMinus();\n        }\n        return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n    }",
      "public double getSup()  {\n        BSPTree<Euclidean1D> node = getTree(false);\n        double sup = Double.NEGATIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n            sup = op.getLocation().getX();\n            node = op.isDirect() ? node.getPlus() : node.getMinus();\n        }\n        return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n    }"
    ],
    [
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (token.type == INVALID) {\n        if (isEndOfFile(ch)) {\n            token.type = EOF;\n            return token;\n        }\n        if (isEndOfLine(ch)) {\n            token.type = EORECORD;\n            return token;\n        }\n        if (isDelimiter(ch)) {\n            token.type = TOKEN;\n            return token;\n        }\n        token.content.append((char) ch);\n        ch = reader.read();\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (true) \n    {\n        if (isEndOfFile(ch)) \n        {\n            token.type = EOF;\n            return token;\n        } \n        else if (isEndOfLine(ch)) \n        {\n            token.type = EORECORD;\n            return token;\n        } \n        else if (isDelimiter(ch)) \n        {\n            token.type = TOKEN;\n            return token;\n        } \n        else \n        {\n            token.content.append((char) ch);\n            ch = reader.read();\n        }\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // TODO: implement this method\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // TODO: Implement the method\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // TODO: Implement this method\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // TODO: Implement this method\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // your code here\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // Your code goes here\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (token.type == INVALID) {\n        // ignore whitespaces at beginning of a token\n        if (ignoreSurroundingSpaces) {\n            while (isWhitespace(ch) && !eol) {\n                ch = reader.read();\n                eol = readEndOfLine(ch);\n            }\n        }\n\n        // ok, start of token reached: encapsulated, or token\n        if (isDelimiter(ch)) {\n            // empty token return TOKEN(\"\")\n            token.type = TOKEN;\n        } else if (eol) {\n            // empty token return EORECORD(\"\")\n            token.content.append(\"\");\n            token.type = EORECORD;\n        } else if (isQuoteChar(ch)) {\n            // consume encapsulated token\n            parseEncapsulatedToken(token);\n        } else if (isEndOfFile(ch)) {\n            // end of file return EOF()\n            token.content.append(\"\");\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n        } else {\n            // next token must be a simple token\n            // add removed blanks when not ignoring whitespace chars...\n            token.content.append((char) ch);\n            ch = reader.read();\n        }\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // TODO: implement this method\n    return token;\n}"
    ],
    [
      "public int[] getCounts(int index) throws OutOfRangeException  {\n        if (index < 0 || index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize);\n        }\n\n        int[] counts = new int[dimension];\n        int tI = index;\n        for (int i = last; i >= 0; i--) {\n            counts[i] = tI / uniCounterOffset[i];\n            tI %= uniCounterOffset[i];\n        }\n\n        return counts;\n    }",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n\n    int[] counts = new int[dimension];\n    int tI = index;\n    for (int i = 0; i < last; i++) {\n        counts[i] = tI / uniCounterOffset[i];\n        tI %= uniCounterOffset[i];\n    }\n    counts[last] = tI;\n\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n\n    int[] counts = new int[dimension];\n    int tI = index;\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = tI / uniCounterOffset[i];\n        tI %= uniCounterOffset[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n\n    int[] counts = new int[dimension];\n    int tI = index;\n    for (int i = last; i >= 0; i--) {\n        counts[i] = tI / uniCounterOffset[i];\n        tI %= uniCounterOffset[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n\n    int[] counts = new int[dimension];\n    int tI = index;\n    for (int i = last; i >= 0; i--) {\n        counts[i] = tI / uniCounterOffset[i];\n        tI %= uniCounterOffset[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n        if (index < 0 || index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize);\n        }\n\n        int[] counts = new int[dimension];\n        int tI = index;\n        for (int i = 0; i < last; i++) {\n            counts[i] = tI / uniCounterOffset[i];\n            tI %= uniCounterOffset[i];\n        }\n        counts[last] = tI;\n\n        return counts;\n    }",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n        if (index < 0 || index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize);\n        }\n\n        int[] counts = new int[dimension];\n        int tI = index;\n        for (int i = 0; i < last; i++) {\n            counts[i] = tI / uniCounterOffset[i];\n            tI %= uniCounterOffset[i];\n        }\n        counts[last] = tI;\n\n        return counts;\n    }",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n        if (index < 0 || index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize);\n        }\n\n        int[] counts = new int[dimension];\n        int tI = index;\n        for (int i = 0; i < dimension; i++) {\n            counts[i] = tI / uniCounterOffset[i];\n            tI %= uniCounterOffset[i];\n        }\n\n        return counts;\n    }",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n\n    int[] counts = new int[dimension];\n    int tI = index;\n    for (int i = 0; i < last; i++) {\n        counts[i] = tI / uniCounterOffset[i];\n        tI %= uniCounterOffset[i];\n    }\n    counts[last] = tI;\n\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n        if (index < 0 || index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize);\n        }\n\n        int[] counts = new int[dimension];\n        int tI = index;\n        for (int i = 0; i < dimension; i++) {\n            counts[i] = tI / uniCounterOffset[i];\n            tI %= uniCounterOffset[i];\n        }\n        return counts;\n    }"
    ],
    [
      "public JsonPointer last()  {\n    JsonPointer tail = this;\n    for (; tail != null; tail = tail.next) \n    {\n        if (tail.next == null) \n        {\n            break;\n        }\n    }\n    return tail;\n}",
      "public JsonPointer last()  {\n    JsonPointer tail = this;\n    while (tail._nextSegment != null) {\n        tail = tail._nextSegment;\n    }\n    return tail;\n}",
      "public JsonPointer last()  {\n    JsonPointer tail = this;\n    for (; tail != null; tail = tail.next) \n    {\n        if (tail.next == null)\n            break;\n    }\n    return tail;\n}",
      "public JsonPointer last()  {\n    JsonPointer tail = this;\n    for (; tail != null; tail = tail._parent) {\n        if (tail._nextSegment != null) {\n            break;\n        }\n    }\n    return tail;\n}",
      "public JsonPointer last()  {\n    JsonPointer tail = this;\n    while (tail._next != null) {\n        tail = tail._next;\n    }\n    return tail;\n}",
      "public JsonPointer last()  {\n    JsonPointer tail = this;\n    while (tail._next != null) \n    {\n        tail = tail._next;\n    }\n    return tail;\n}",
      "public JsonPointer last()  {\n    JsonPointer tail = this;\n    while (tail._nextSegment != null) {\n        tail = tail._nextSegment;\n    }\n    return tail;\n}",
      "public JsonPointer last()  {\n    JsonPointer tail = this;\n    for (; tail._nextSegment != null; tail = tail._nextSegment) {\n    }\n    return tail;\n}",
      "public JsonPointer last()  {\n    JsonPointer tail = this;\n    for (; tail._nextSegment != null; tail = tail._nextSegment) {\n        // loop until we reach the end\n    }\n    return tail;\n}",
      "public JsonPointer last()  {\n    JsonPointer tail = this;\n    while (tail._next != null) \n    {\n        tail = tail._next;\n    }\n    return tail;\n}"
    ],
    [
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[8192];\n    int read;\n    while ((read = data.read(buffer)) > 0) {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[8192];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[8192];\n    int read;\n    while ((read = data.read(buffer)) > 0) \n    {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    byte[] buffer = new byte[8192];\n    int read;\n    while ((read = data.read(buffer)) > 0) {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[8192];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) \n    {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[8192];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) \n    {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    byte[] buffer = new byte[8192];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[8192];\n    int read;\n    while ((read = data.read(buffer)) > 0) \n    {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[1024];\n    int read;\n    while ((read = data.read(buffer)) != -1) {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[1024];\n    int read;\n    while ((read = data.read(buffer)) != -1) {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}"
    ],
    [
      "public static <T> T clone(final T obj)  {\n        if (obj instanceof Cloneable) {\n            try {\n                @SuppressWarnings(\"unchecked\")\n                T result = (T) ((Cloneable) obj).clone();\n                return result;\n            } catch (CloneNotSupportedException e) {\n                // should never happen\n                throw new CloneFailedException(\"Clone operation failed\", e);\n            }\n        }\n        return null;\n    }",
      "public static <T> T clone(final T obj)  {\n        if (obj instanceof Cloneable) {\n            try {\n                @SuppressWarnings(\"unchecked\")\n                final T result = (T) ((Cloneable) obj).clone();\n                return result;\n            } catch (final CloneNotSupportedException e) {\n                throw new CloneFailedException(\"Clone operation failed\", e);\n            }\n        }\n        return null;\n    }",
      "public static <T> T clone(final T obj)  {\n    if (obj instanceof Cloneable) {\n        try {\n            @SuppressWarnings(\"unchecked\")\n            final T result = (T) ((Cloneable) obj).clone();\n            return result;\n        } catch (final CloneNotSupportedException e) {\n            // should never happen\n            throw new CloneFailedException(\"Clone operation failed\", e);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  {\n        if (obj instanceof Cloneable) {\n            try {\n                @SuppressWarnings(\"unchecked\")\n                T result = (T) ((Cloneable) obj).clone();\n                return result;\n            } catch (CloneNotSupportedException e) {\n                throw new CloneFailedException(\"Clone operation failed for \" + obj, e);\n            }\n        }\n        return null;\n    }",
      "public static <T> T clone(final T obj)  {\n    if (obj instanceof Cloneable) {\n        try {\n            @SuppressWarnings(\"unchecked\")\n            final T result = (T) ((Cloneable) obj).clone();\n            return result;\n        } catch (final CloneNotSupportedException e) {\n            // this should never happen, since we know obj is cloneable\n            throw new CloneFailedException(\"Cloneable.clone() method failed\", e);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  {\n        if (obj instanceof Cloneable) {\n            try {\n                @SuppressWarnings(\"unchecked\")\n                T result = (T) ((Cloneable) obj).clone();\n                return result;\n            } catch (CloneNotSupportedException e) {\n                // should not happen as Cloneable is a marker interface\n                throw new CloneFailedException(\"Cloneable said it was cloneable but threw CloneNotSupportedException\", e);\n            }\n        }\n        return null;\n    }",
      "public static <T> T clone(final T obj)  {\n    if (obj instanceof Cloneable) {\n        try {\n            @SuppressWarnings(\"unchecked\")\n            final T result = (T) ((Cloneable) obj).clone();\n            return result;\n        } catch (final CloneNotSupportedException e) {\n            // this should never happen, as Cloneable objects are expected to support the clone operation\n            throw new CloneFailedException(\"Clone operation failed for \" + obj, e);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  {\n        if (obj instanceof Cloneable) {\n            try {\n                @SuppressWarnings(\"unchecked\")\n                T result = (T) ((Cloneable) obj).clone();\n                return result;\n            } catch (CloneNotSupportedException e) {\n                throw new CloneFailedException(\"Clone operation failed\", e);\n            }\n        }\n        return null;\n    }",
      "public static <T> T clone(final T obj)  {\n        if (obj instanceof Cloneable) {\n            try {\n                @SuppressWarnings(\"unchecked\")\n                T result = (T) ((Cloneable) obj).clone();\n                return result;\n            } catch (CloneNotSupportedException e) {\n                throw new CloneFailedException(\"Clone operation failed\", e);\n            }\n        }\n        return null;\n    }",
      "public static <T> T clone(final T obj)  {\n    if (obj instanceof Cloneable) {\n        try {\n            @SuppressWarnings(\"unchecked\")\n            T result = (T) ((Cloneable) obj).clone();\n            return result;\n        } catch (CloneNotSupportedException e) {\n            throw new CloneFailedException(\"Clone operation failed\", e);\n        }\n    }\n    return null;\n}"
    ],
    [
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (!(sym instanceof FunctionSymbol)) \n    {\n        return null;\n    }\n\n    FunctionSymbol functionSymbol = (FunctionSymbol) sym;\n    for (Symbol parameter : functionSymbol.getParameters()) \n    {\n        if (parameter.getName().equals(paramName)) \n        {\n            return parameter;\n        }\n    }\n\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.getKind() != Symbol.Kind.FUNCTION) {\n        return null;\n    }\n\n    for (Symbol parameter : sym.getParameters()) {\n        if (parameter.getName().equals(paramName)) {\n            return parameter;\n        }\n    }\n\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.getKind() != Symbol.Kind.FUNCTION) \n    {\n        return null;\n    }\n\n    FunctionSymbol functionSymbol = (FunctionSymbol) sym;\n    List<Symbol> parameters = functionSymbol.getParameters();\n    for (Symbol parameter : parameters) \n    {\n        if (parameter.getName().equals(paramName)) \n        {\n            return parameter;\n        }\n    }\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.getKind() != Symbol.Kind.FUNCTION) \n    {\n        return null;\n    }\n\n    SymbolScope scope = sym.getScope();\n    for (Symbol s : scope.getDeclaredSymbols()) \n    {\n        if (s.getKind() == Symbol.Kind.PARAMETER && s.getName().equals(paramName)) \n        {\n            return s;\n        }\n    }\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (!(sym instanceof FunctionSymbol)) {\n        return null;\n    }\n    FunctionSymbol functionSymbol = (FunctionSymbol) sym;\n    for (Symbol parameter : functionSymbol.getParameters()) {\n        if (parameter.getName().equals(paramName)) {\n            return parameter;\n        }\n    }\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.getKind() != Symbol.Kind.FUNCTION) {\n        return null;\n    }\n\n    for (Symbol parameter : sym.getParameters()) {\n        if (parameter.getName().equals(paramName)) {\n            return parameter;\n        }\n    }\n\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.getKind() != Symbol.Kind.FUNCTION) {\n        return null;\n    }\n\n    FunctionSymbol functionSymbol = (FunctionSymbol) sym;\n    for (Symbol parameter : functionSymbol.getParameters()) {\n        if (parameter.getName().equals(paramName)) {\n            return parameter;\n        }\n    }\n\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.getKind() != Symbol.Kind.FUNCTION) \n    {\n        return null;\n    }\n\n    FunctionSymbol functionSymbol = (FunctionSymbol) sym;\n    List<Symbol> parameters = functionSymbol.getParameters();\n\n    for (Symbol parameter : parameters) \n    {\n        if (parameter.getName().equals(paramName)) \n        {\n            return parameter;\n        }\n    }\n\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (!sym.isFunction()) {\n      return null;\n    }\n\n    for (Symbol parameter : sym.getParameters()) {\n      if (parameter.getName().equals(paramName)) {\n        return parameter;\n      }\n    }\n\n    return null;\n  }",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.getKind() != Symbol.Kind.FUNCTION) {\n        return null;\n    }\n\n    for (Symbol s : sym.getParameters()) {\n        if (s.getName().equals(paramName)) {\n            return s;\n        }\n    }\n\n    return null;\n}"
    ],
    [
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        // Check if the matrix has sufficient data\n        checkSufficientData(matrix);\n\n        // Compute the mean vector\n        double[] meanVector = new double[matrix.getColumnDimension()];\n        for (int i = 0; i < matrix.getColumnDimension(); i++) {\n            meanVector[i] = ArrayMath.mean(matrix.getColumn(i));\n        }\n\n        // Subtract the mean from each column\n        RealMatrix centeredMatrix = new Array2DRowRealMatrix(matrix.getData()).subtract(new Array2DRowRealMatrix(meanVector));\n\n        // Compute the covariance matrix\n        RealMatrix covarianceMatrix = centeredMatrix.multiply(centeredMatrix.transpose());\n\n        // Bias correction\n        if (biasCorrected) {\n            covarianceMatrix = covarianceMatrix.scalarMultiply(1.0 / (n - 1));\n        } else {\n            covarianceMatrix = covarianceMatrix.scalarMultiply(1.0 / n);\n        }\n\n        return covarianceMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        int n = matrix.getRowDimension();\n        int p = matrix.getColumnDimension();\n\n        if (n < 2) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.INSUFFICIENT_DATA, p, 2);\n        }\n\n        double[][] data = matrix.getData();\n        double[][] covariance = new double[p][p];\n\n        // Compute means\n        double[] means = new double[p];\n        for (int j = 0; j < p; j++) {\n            means[j] = ArrayMath.mean(data[0], data[1], null);\n        }\n\n        // Compute covariance\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < p; j++) {\n                for (int k = 0; k < p; k++) {\n                    covariance[j][k] += (data[i][j] - means[j]) * (data[i][k] - means[k]);\n                }\n            }\n        }\n\n        for (int j = 0; j < p; j++) {\n            for (int k = 0; k < p; k++) {\n                covariance[j][k] /= (n - (biasCorrected ? 1 : 0));\n            }\n        }\n\n        return new Array2DRowRealMatrix(covariance);\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        if (matrix.getColumnDimension() < 1 || matrix.getRowDimension() < 2) {\n            throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA, matrix.getRowDimension(), matrix.getColumnDimension());\n        }\n        int n = matrix.getRowDimension();\n        int p = matrix.getColumnDimension();\n        double[][] data = matrix.getData();\n        double[] mean = new double[p];\n        double[][] covariance = new double[p][p];\n\n        // Compute mean\n        for (int j = 0; j < p; j++) {\n            for (int i = 0; i < n; i++) {\n                mean[j] += data[i][j];\n            }\n            mean[j] /= n;\n        }\n\n        // Compute covariance\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < p; j++) {\n                for (int k = 0; k < p; k++) {\n                    covariance[j][k] += (data[i][j] - mean[j]) * (data[i][k] - mean[k]);\n                }\n            }\n        }\n        for (int j = 0; j < p; j++) {\n            for (int k = 0; k < p; k++) {\n                covariance[j][k] /= (n - (biasCorrected ? 1 : 0));\n            }\n        }\n\n        return new Array2DRowRealMatrix(covariance);\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n\n    // Check if the matrix is rectangular\n    if (matrix.getColumnDimension() < 1 || matrix.getRowDimension() < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NOT_RECTANGULAR, matrix.getRowDimension(), matrix.getColumnDimension());\n    }\n\n    // Compute the mean vector\n    double[] meanVector = new double[matrix.getColumnDimension()];\n    for (int i = 0; i < matrix.getColumnDimension(); i++) {\n        meanVector[i] = ArrayMath.mean(matrix.getColumn(i));\n    }\n\n    // Subtract the mean from each column\n    RealMatrix centeredMatrix = MatrixUtils.createRealMatrix(matrix.getData()).scalarSubtract(new Array2DRowRealMatrix(1, matrix.getColumnDimension(), meanVector));\n\n    // Compute the covariance matrix\n    RealMatrix covarianceMatrix = centeredMatrix.multiply(centeredMatrix.transpose()).getArray();\n\n    // If bias correction is required, divide by (n-1) instead of n\n    if (biasCorrected) {\n        covarianceMatrix = covarianceMatrix.scalarDivide(n - 1);\n    } else {\n        covarianceMatrix = covarianceMatrix.scalarDivide(n);\n    }\n\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        if (matrix.getRowDimension() < 2 || matrix.getColumnDimension() < 1) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NOT_SUFFICIENT_DATA, matrix.getRowDimension(), matrix.getColumnDimension());\n        }\n\n        double[][] data = matrix.getData();\n        double[][] covariance = new double[matrix.getColumnDimension()][matrix.getColumnDimension()];\n\n        // Compute mean\n        double[] mean = new double[matrix.getColumnDimension()];\n        for (int i = 0; i < matrix.getColumnDimension(); i++) {\n            for (int j = 0; j < matrix.getRowDimension(); j++) {\n                mean[i] += data[j][i];\n            }\n            mean[i] /= matrix.getRowDimension();\n        }\n\n        // Compute covariance\n        for (int i = 0; i < matrix.getColumnDimension(); i++) {\n            for (int j = 0; j <= i; j++) {\n                for (int k = 0; k < matrix.getRowDimension(); k++) {\n                    covariance[i][j] += (data[k][i] - mean[i]) * (data[k][j] - mean[j]);\n                }\n                covariance[i][j] /= matrix.getRowDimension() - (biasCorrected ? 1 : 0);\n                covariance[j][i] = covariance[i][j]; // Symmetry\n            }\n        }\n\n        return new Array2DRowRealMatrix(covariance);\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n\n    // Check if the matrix is rectangular\n    if (matrix.getRowDimension() < 2 || matrix.getColumnDimension() < 1) {\n        throw new MathIllegalArgumentException(\n            \"The input matrix must have at least two rows and one column.\");\n    }\n\n    // Compute the mean vector\n    double[] meanVector = new double[matrix.getColumnDimension()];\n    for (int i = 0; i < matrix.getColumnDimension(); i++) {\n        meanVector[i] = ArrayMath.mean(matrix.getColumn(i));\n    }\n\n    // Subtract the mean from each column\n    RealMatrix centeredMatrix = new Array2DRowRealMatrix(\n        matrix.getData()).subtract(new Array2DRowRealMatrix(meanVector));\n\n    // Compute the covariance matrix\n    RealMatrix covarianceMatrix = centeredMatrix.transpose().multiply(centeredMatrix);\n\n    // If bias correction is required, divide by (n-1) instead of n\n    if (biasCorrected) {\n        covarianceMatrix = covarianceMatrix.scalarMultiply(1.0 / (n - 1));\n    } else {\n        covarianceMatrix = covarianceMatrix.scalarMultiply(1.0 / n);\n    }\n\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n\n    // Check if the matrix is rectangular\n    if (matrix.getRowDimension() < 2 || matrix.getColumnDimension() < 1) {\n        throw new MathIllegalArgumentException(\n            \"Input matrix must have at least two rows and one column\");\n    }\n\n    // Compute the mean vector\n    double[] meanVector = new double[matrix.getColumnDimension()];\n    for (int i = 0; i < matrix.getColumnDimension(); i++) {\n        meanVector[i] = ArrayMath.mean(matrix.getColumn(i));\n    }\n\n    // Subtract the mean from each column\n    RealMatrix centeredMatrix = new Array2DRowRealMatrix(\n        matrix.getData()).subtract(new Array2DRowRealMatrix(meanVector));\n\n    // Compute the covariance matrix\n    RealMatrix covarianceMatrix = centeredMatrix.multiply(centeredMatrix.transpose());\n\n    // If bias correction is required, divide by (n-1)\n    if (biasCorrected) {\n        covarianceMatrix = covarianceMatrix.scalarMultiply(1.0 / (n - 1));\n    } else {\n        covarianceMatrix = covarianceMatrix.scalarMultiply(1.0 / n);\n    }\n\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        // Check if the matrix has sufficient data\n        checkSufficientData(matrix);\n\n        // Compute the mean vector\n        double[] meanVector = new double[matrix.getColumnDimension()];\n        for (int i = 0; i < matrix.getColumnDimension(); i++) {\n            meanVector[i] = ArrayMath.mean(matrix.getColumn(i));\n        }\n\n        // Subtract the mean from each column\n        RealMatrix centeredMatrix = new Array2DRowRealMatrix(matrix.getData()).subtract(new Array2DRowRealMatrix(meanVector));\n\n        // Compute the covariance matrix\n        RealMatrix covarianceMatrix = centeredMatrix.transpose().multiply(centeredMatrix);\n\n        // Divide by (n - 1) if bias correction is required\n        if (biasCorrected) {\n            covarianceMatrix = covarianceMatrix.scalarMultiply(1.0 / (n - 1));\n        } else {\n            covarianceMatrix = covarianceMatrix.scalarMultiply(1.0 / n);\n        }\n\n        return covarianceMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        if (matrix.getColumnDimension() < 1 || matrix.getRowDimension() < 2) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.INSUFFICIENT_DATA, matrix.getRowDimension(), matrix.getColumnDimension());\n        }\n        double[][] data = matrix.getData();\n        double[][] covariance = new double[matrix.getColumnDimension()][matrix.getColumnDimension()];\n        for (int i = 0; i < matrix.getColumnDimension(); i++) {\n            for (int j = 0; j <= i; j++) {\n                double sum1 = 0;\n                double sum2 = 0;\n                double sum3 = 0;\n                for (int k = 0; k < matrix.getRowDimension(); k++) {\n                    sum1 += data[k][i];\n                    sum2 += data[k][j];\n                    sum3 += data[k][i] * data[k][j];\n                }\n                double mean1 = sum1 / matrix.getRowDimension();\n                double mean2 = sum2 / matrix.getRowDimension();\n                double mean3 = sum3 / matrix.getRowDimension();\n                covariance[i][j] = mean3 - mean1 * mean2;\n                if (biasCorrected && matrix.getRowDimension() > 1) {\n                    covariance[i][j] *= (matrix.getRowDimension() - 1) / (matrix.getRowDimension() - 2);\n                }\n                covariance[j][i] = covariance[i][j];\n            }\n        }\n        return new Array2DRowRealMatrix(covariance, false);\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        // Check if the input matrix has at least two rows and one column\n        if (matrix.getRowDimension() < 2 || matrix.getColumnDimension() < 1) {\n            throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA, matrix.getRowDimension(), 2, matrix.getColumnDimension(), 1);\n        }\n\n        // Compute the mean vector\n        double[] mean = new double[matrix.getColumnDimension()];\n        for (int j = 0; j < matrix.getColumnDimension(); j++) {\n            mean[j] = matrix.getColumnVector(j).getMean();\n        }\n\n        // Subtract the mean from each column\n        RealMatrix centeredMatrix = matrix.subtract(new Array2DRowRealMatrix(mean));\n\n        // Compute the covariance matrix\n        RealMatrix covarianceMatrix = centeredMatrix.multiply(centeredMatrix.transpose());\n\n        // If bias correction is required, divide the covariance matrix by (n-1)\n        if (biasCorrected) {\n            covarianceMatrix = covarianceMatrix.scalarMultiply(1.0 / (n - 1));\n        }\n\n        return covarianceMatrix;\n    }"
    ],
    [
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 1 and \" + MAXIMUM_CACHE_SIZE);\n    }\n\n    while (bitsCachedSize < count) {\n        final int nextByte = in.read();\n        if (nextByte == -1) {\n            return -1;\n        }\n        bitsCached = (bitsCached << 8) | (nextByte & 0xFF);\n        bitsCachedSize += 8;\n    }\n\n    final long result;\n    if (byteOrder == ByteOrder.BIG_ENDIAN) {\n        result = bitsCached >>> (bitsCachedSize - count);\n    } else {\n        final int shiftAmount = bitsCachedSize - count;\n        result = (bitsCached & MASKS[count]) >> shiftAmount;\n    }\n\n    bitsCachedSize -= count;\n    bitsCached &= MASKS[bitsCachedSize];\n\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"Bit count out of range: \" + count);\n    }\n\n    while (bitsCachedSize < count) {\n        final int b = in.read();\n        if (b == -1) {\n            return -1;\n        }\n        bitsCached = (bitsCached << 8) | (b & 0xFF);\n        bitsCachedSize += 8;\n    }\n\n    final long result;\n    if (byteOrder == ByteOrder.BIG_ENDIAN) {\n        result = bitsCached >>> (bitsCachedSize - count);\n    } else {\n        final int shiftAmt = bitsCachedSize - count;\n        result = ((bitsCached & MASKS[count]) << shiftAmt) >> (63 - count);\n    }\n    bitsCachedSize -= count;\n    bitsCached &= MASKS[bitsCachedSize];\n\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 1 and \" + MAXIMUM_CACHE_SIZE);\n    }\n\n    while (bitsCachedSize < count) {\n        final int nextByte = in.read();\n        if (nextByte == -1) {\n            return -1;\n        }\n        bitsCached = (bitsCached << 8) | (nextByte & 0xFF);\n        bitsCachedSize += 8;\n    }\n\n    final long result;\n    if (byteOrder == ByteOrder.BIG_ENDIAN) {\n        result = bitsCached >>> (bitsCachedSize - count);\n    } else {\n        final int shiftAmount = bitsCachedSize - count;\n        result = (bitsCached & MASKS[count]) >> shiftAmount;\n    }\n    bitsCachedSize -= count;\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 0 and \" + MAXIMUM_CACHE_SIZE);\n    }\n\n    while (bitsCachedSize < count) {\n        final int b = in.read();\n        if (b == -1) {\n            return -1;\n        }\n        bitsCached = (bitsCached << 8) | (b & 0xFF);\n        bitsCachedSize += 8;\n    }\n\n    final long result;\n    if (byteOrder == ByteOrder.BIG_ENDIAN) {\n        result = bitsCached >>> (bitsCachedSize - count);\n    } else {\n        final int shiftAmount = bitsCachedSize - count;\n        result = (bitsCached & MASKS[count]) >> shiftAmount;\n    }\n\n    bitsCachedSize -= count;\n    bitsCached &= MASKS[bitsCachedSize];\n\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 1 and \" + MAXIMUM_CACHE_SIZE);\n    }\n\n    while (bitsCachedSize < count) {\n        final int nextByte = in.read();\n        if (nextByte == -1) {\n            return -1;\n        }\n        bitsCached = (bitsCached << 8) | (nextByte & 0xFF);\n        bitsCachedSize += 8;\n    }\n\n    final long result;\n    if (byteOrder == ByteOrder.BIG_ENDIAN) {\n        result = bitsCached >>> (bitsCachedSize - count);\n    } else {\n        final int shiftAmount = bitsCachedSize - count;\n        result = (bitsCached & MASKS[count]) >> shiftAmount;\n        if (shiftAmount != 0) {\n            bitsCached = (bitsCached & ((1 << shiftAmount) - 1)) | (bitsCached >>> count);\n        } else {\n            bitsCached = bitsCached & MASKS[count];\n        }\n    }\n    bitsCachedSize -= count;\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 0 and \" + MAXIMUM_CACHE_SIZE);\n    }\n\n    while (bitsCachedSize < count) {\n        final int b = in.read();\n        if (b == -1) {\n            return -1;\n        }\n        bitsCached = (bitsCached << 8) | (b & 0xFF);\n        bitsCachedSize += 8;\n    }\n\n    final long result;\n    if (byteOrder == ByteOrder.BIG_ENDIAN) {\n        result = bitsCached >>> (bitsCachedSize - count);\n    } else {\n        final int shiftAmount = bitsCachedSize - count;\n        result = ((bitsCached & MASKS[count]) >>> shiftAmount) | (bitsCached >>> (32 + shiftAmount) << 32);\n    }\n\n    bitsCachedSize -= count;\n    bitsCached &= MASKS[bitsCachedSize];\n\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 0 and \" + MAXIMUM_CACHE_SIZE);\n    }\n\n    while (bitsCachedSize < count) {\n        final int nextByte = in.read();\n        if (nextByte == -1) {\n            return -1;\n        }\n        bitsCached = (bitsCached << 8) | (nextByte & 0xFF);\n        bitsCachedSize += 8;\n    }\n\n    final long result;\n    if (byteOrder == ByteOrder.BIG_ENDIAN) {\n        result = bitsCached >>> (bitsCachedSize - count);\n    } else {\n        final int shiftAmount = bitsCachedSize - count;\n        result = (bitsCached & MASKS[count]) >> shiftAmount;\n        if (shiftAmount != 0) {\n            bitsCached = (bitsCached & MASKS[shiftAmount]) << count;\n        }\n    }\n\n    bitsCachedSize -= count;\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 1 and \" + MAXIMUM_CACHE_SIZE);\n    }\n\n    while (bitsCachedSize < count) {\n        final int nextByte = in.read();\n        if (nextByte == -1) {\n            return -1;\n        }\n        bitsCached = (bitsCached << 8) | (nextByte & 0xFF);\n        bitsCachedSize += 8;\n    }\n\n    final long result;\n    if (byteOrder == ByteOrder.BIG_ENDIAN) {\n        result = bitsCached >>> (bitsCachedSize - count);\n    } else {\n        final int shiftAmount = bitsCachedSize - count;\n        result = (bitsCached & MASKS[count]) >> shiftAmount;\n    }\n\n    bitsCachedSize -= count;\n    bitsCached &= MASKS[bitsCachedSize];\n\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 1 and \" + MAXIMUM_CACHE_SIZE);\n    }\n\n    while (bitsCachedSize < count) {\n        final int nextByte = in.read();\n        if (nextByte == -1) {\n            return -1;\n        }\n        bitsCached = (bitsCached << 8) | (nextByte & 0xFF);\n        bitsCachedSize += 8;\n    }\n\n    final long result;\n    if (byteOrder == ByteOrder.BIG_ENDIAN) {\n        result = bitsCached >>> (bitsCachedSize - count);\n    } else {\n        final int shiftAmount = bitsCachedSize - count;\n        result = (bitsCached & MASKS[count]) >> shiftAmount;\n    }\n\n    bitsCachedSize -= count;\n    bitsCached &= MASKS[bitsCachedSize];\n\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 1 and \" + MAXIMUM_CACHE_SIZE);\n    }\n\n    while (bitsCachedSize < count) {\n        final int b = in.read();\n        if (b == -1) {\n            return -1;\n        }\n        bitsCached = (bitsCached << 8) | (b & 0xFF);\n        bitsCachedSize += 8;\n    }\n\n    final long result;\n    if (byteOrder == ByteOrder.BIG_ENDIAN) {\n        result = bitsCached >>> (bitsCachedSize - count);\n    } else {\n        final int shiftAmount = bitsCachedSize - count;\n        result = ((bitsCached & MASKS[count]) << shiftAmount) >> (64 - count - shiftAmount);\n    }\n\n    bitsCachedSize -= count;\n    bitsCached &= MASKS[bitsCachedSize];\n\n    return result;\n}"
    ],
    [
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n        final int m = data.length;\n        final int n = v.getDimension();\n        final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n        for (int i = 0; i < m; i++) \n        {\n            for (int j = 0; j < n; j++) \n            {\n                out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n            }\n        }\n        return out;\n    }",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n        final int m = data.length;\n        final int n = v.getDimension();\n        final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n        for (int i = 0; i < m; i++) \n        {\n            for (int j = 0; j < n; j++) \n            {\n                out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n            }\n        }\n        return out;\n    }",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n        final int m = data.length;\n        final int n = v.getDimension();\n        final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n            }\n        }\n        return out;\n    }",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) \n    {\n        for (int j = 0; j < n; j++) \n        {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  throws DimensionMismatchException {\n        checkVectorDimensions(v.data.length);\n        final int m = data.length;\n        final int n = v.getDimension();\n        final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n            }\n        }\n        return out;\n    }",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  throws DimensionMismatchException {\n        checkVectorDimensions(v.data.length);\n        final int m = data.length;\n        final int n = v.getDimension();\n        final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n            }\n        }\n        return out;\n    }",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) \n    {\n        for (int j = 0; j < n; j++) \n        {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}"
    ],
    [
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) \n    {\n        return true;\n    }\n    Node labelNode = getNextSiblingOfType(target, Token.LABEL);\n    return labelNode != null && label.equals(labelNode.getText());\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    Node labelNode = getNextSiblingOfType(target, Token.LABEL);\n    return labelNode != null && label.equals(labelNode.getText());\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    Node labelNode = getNextSiblingOfType(target, Token.LABEL);\n    return labelNode != null && label.equals(labelNode.getText());\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    Node labelNode = getNextSiblingOfType(target, Token.LABEL);\n    return labelNode != null && label.equals(labelNode.getText());\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) \n    {\n        return true;\n    }\n    Node labelNode = getNextSiblingOfType(target, Token.LABEL);\n    return labelNode != null && labelNode.getLabel().equals(label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) \n    {\n        return true;\n    }\n    Node labelNode = getNextSiblingOfType(target, Token.LABEL);\n    return labelNode != null && labelNode.getLabel().equals(label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) \n    {\n        return true;\n    }\n    else \n    {\n        Node labelNode = getNextSiblingOfType(target, Token.LABEL);\n        if (labelNode == null) \n        {\n            return false;\n        }\n        else \n        {\n            return label.equals(labelNode.getText());\n        }\n    }\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) \n    {\n        return true;\n    }\n    else \n    {\n        Node labelNode = getNextSiblingOfType(target, Token.LABEL);\n        return labelNode != null && labelNode.getLabel().equals(label);\n    }\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) \n    {\n        return true;\n    }\n    Node labelNode = getNextSiblingOfType(target, Token.LABEL);\n    if (labelNode == null) \n    {\n        return false;\n    }\n    return label.equals(labelNode.getText());\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) \n    {\n        return true;\n    }\n    Node labelNode = getNextSiblingOfType(target, Token.LABEL);\n    return labelNode != null && labelNode.getFirstChild().getText().equals(label);\n}"
    ],
    [
      "public String getURL(int series, int item)  {\n    String url = null;\n    List urlList = (List) this.urlSeries.get(series);\n    if (urlList != null && urlList.size() > item) \n    {\n        url = (String) urlList.get(item);\n    }\n    return url;\n}",
      "public String getURL(int series, int item)  {\n    String url = null;\n    List urlList = (List) this.urlSeries.get(series);\n    if (urlList != null && item < urlList.size()) \n    {\n        url = (String) urlList.get(item);\n    }\n    return url;\n}",
      "public String getURL(int series, int item)  {\n    List urlList = (List) this.urlSeries.get(series);\n    if (urlList != null) \n    {\n        return (String) urlList.get(item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    List urlList = (List) this.urlSeries.get(series);\n    if (urlList != null && item < urlList.size()) \n    {\n        return (String) urlList.get(item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) \n    {\n        return (String) urls.get(item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    String url = null;\n    List urlList = (List) this.urlSeries.get(series);\n    if (urlList != null && urlList.size() > item) \n    {\n        url = (String) urlList.get(item);\n    }\n    return url;\n}",
      "public String getURL(int series, int item)  {\n    String url = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null && item < urls.size()) \n    {\n        url = (String) urls.get(item);\n    }\n    return url;\n}",
      "public String getURL(int series, int item)  {\n    String url = null;\n    List urlList = (List) this.urlSeries.get(series);\n    if (urlList != null && item < urlList.size()) \n    {\n        url = (String) urlList.get(item);\n    }\n    return url;\n}",
      "public String getURL(int series, int item)  {\n    String url = null;\n    List urlList = (List) this.urlSeries.get(series);\n    if (urlList != null && urlList.size() > item) \n    {\n        url = (String) urlList.get(item);\n    }\n    return url;\n}",
      "public String getURL(int series, int item)  {\n    String url = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null && item < urls.size()) \n    {\n        url = (String) urls.get(item);\n    }\n    return url;\n}"
    ],
    [
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    int value = 0;\n    int start = 0;\n    if (str.charAt(0) == '-') {\n        start = 1;\n    }\n    for (int i = start; i < len; ++i) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            throw new IllegalArgumentException(\"Invalid array index: \"+str);\n        }\n        value = (value << 3) + (value << 1) + (c - '0');\n    }\n    if (start != 0) {\n        value = -value;\n    }\n    return value;\n}",
      "private final static int _parseIndex(String str)  {\n        int index = 0;\n        for (int i = 0, len = str.length(); i < len; ++i) {\n            char c = str.charAt(i);\n            if (c < '0' || c > '9') {\n                throw new IllegalArgumentException(\"Invalid index: \" + str);\n            }\n            index = (index << 3) + (index << 1) + (c - '0');\n        }\n        return index;\n    }",
      "private final static int _parseIndex(String str)  {\n    int index = -1;\n    try {\n        index = Integer.parseInt(str);\n    } catch (NumberFormatException nfe) {\n        // Okay, not a number, but might be a negative number\n        if (str.startsWith(\"-\")) {\n            try {\n                index = Integer.parseInt(str.substring(1));\n                index = -index;\n            } catch (NumberFormatException nfe2) {\n                // Not a number at all\n                index = -1;\n            }\n        }\n    }\n    return index;\n}",
      "private final static int _parseIndex(String str)  {\n        int len = str.length();\n        int value = 0;\n        for (int i = 0; i < len; i++) {\n            char c = str.charAt(i);\n            if (c < '0' || c > '9') {\n                return -1;\n            }\n            value = (value << 3) + (value << 1) + (c - '0');\n        }\n        return value;\n    }",
      "private final static int _parseIndex(String str)  {\n    if (str.length() == 0) {\n        throw new IllegalArgumentException(\"Empty index\");\n    }\n    if (str.charAt(0) == '-') {\n        throw new IllegalArgumentException(\"Negative index\");\n    }\n    int idx = 0;\n    for (int i = 0, len = str.length(); i < len; ++i) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            throw new IllegalArgumentException(\"Invalid index: \" + str);\n        }\n        idx = (idx << 3) + (idx << 1) + (c - '0');\n    }\n    return idx;\n}",
      "private final static int _parseIndex(String str)  {\n    int index = Integer.parseInt(str);\n    if (index < 0) {\n        throw new IllegalArgumentException(\"Negative array index: \"+index);\n    }\n    return index;\n}",
      "private final static int _parseIndex(String str)  {\n        if (str.length() == 0) {\n            return -1;\n        }\n        int index = 0;\n        for (int i = 0, len = str.length(); i < len; i++) {\n            char c = str.charAt(i);\n            if (c < '0' || c > '9') {\n                return -1;\n            }\n            index = (index << 3) + (index << 1) + (c - '0');\n        }\n        return index;\n    }",
      "private final static int _parseIndex(String str)  {\n    int index = Integer.parseInt(str);\n    if (index < 0) {\n        throw new IllegalArgumentException(\"Negative array index: \"+index);\n    }\n    return index;\n}",
      "private final static int _parseIndex(String str)  {\n    int index = 0;\n    for (int i = 0, len = str.length(); i < len; ++i) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            throw new IllegalArgumentException(\"Invalid index: \"+str);\n        }\n        index = (index << 3) + (index << 1) + (c - '0');\n    }\n    return index;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    int value = 0;\n    int start = 0;\n    if (str.charAt(0) == '-') {\n        start = 1;\n    }\n    for (int i = start; i < len; ++i) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            throw new IllegalArgumentException(\"Invalid index: \" + str);\n        }\n        value = (value << 3) + (value << 1) + (c - '0');\n    }\n    if (start == 1) {\n        value = -value;\n    }\n    return value;\n}"
    ],
    [
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_EXCEEDS_N,\n                                                k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                                                   k);\n    }\n\n    int[] index = nextPermutation(c.size(), k);\n    Object[] sample = new Object[k];\n    int i = 0;\n    for (Object o : c) {\n        if (ArrayUtils.indexOf(index, i) > -1) {\n            sample[ArrayUtils.indexOf(index, i)] = o;\n        }\n        i++;\n    }\n\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n        if (k > c.size()) {\n            throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_EXCEEDS_N,\n                                                k, c.size(), true);\n        }\n        if (k <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                                                   k);\n        }\n\n        int[] index = nextPermutation(c.size(), k);\n        Object[] sample = new Object[k];\n        int i = 0;\n        for (Object o : c) {\n            if (ArrayUtils.indexOf(index, i) > -1) {\n                sample[ArrayUtils.indexOf(index, i)] = o;\n            }\n            i++;\n        }\n\n        return sample;\n    }",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n        if (k > c.size()) {\n            throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_EXCEEDS_N,\n                                                k, c.size(), true);\n        }\n        if (k <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                                                   k);\n        }\n\n        int[] permutation = nextPermutation(c.size(), k);\n        Object[] sample = new Object[k];\n        int i = 0;\n        for (int index : permutation) {\n            sample[i++] = new ArrayList<>(c).get(index);\n        }\n        return sample;\n    }",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n        if (k > c.size()) {\n            throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_EXCEEDS_N,\n                                                k, c.size(), true);\n        }\n        if (k <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                                                   k);\n        }\n\n        int[] permutation = nextPermutation(c.size(), k);\n        Object[] sample = new Object[k];\n        int i = 0;\n        for (Object o : c) {\n            if (ArrayUtils.indexOf(permutation, i) != -1) {\n                sample[ArrayUtils.indexOf(permutation, i)] = o;\n            }\n            i++;\n        }\n        return sample;\n    }",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_EXCEEDS_N,\n                                                k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                                                   k);\n    }\n\n    int[] index = nextPermutation(c.size(), k);\n    Object[] sample = new Object[k];\n    int i = 0;\n    for (Object o : c) {\n        if (ArrayUtils.indexOf(index, i) > -1) {\n            sample[ArrayUtils.indexOf(index, i)] = o;\n        }\n        i++;\n    }\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n        if (k > c.size()) {\n            throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_EXCEEDS_N,\n                                                k, c.size(), true);\n        }\n        if (k <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                                                   k);\n        }\n\n        int[] permutation = nextPermutation(c.size(), k);\n        Object[] sample = new Object[k];\n        int i = 0;\n        for (int index : permutation) {\n            sample[i++] = c.toArray()[index];\n        }\n        return sample;\n    }",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_EXCEEDS_COLLECTION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                                               k);\n    }\n\n    int[] permutation = nextPermutation(c.size(), k);\n    Object[] sample = new Object[k];\n    int i = 0;\n    for (Iterator<?> iter = c.iterator(); iter.hasNext(); ++i) {\n        sample[i] = iter.next();\n    }\n\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_EXCEEDS_N,\n                                                k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                                                   k);\n    }\n\n    int[] index = nextPermutation(c.size(), k);\n    Object[] sample = new Object[k];\n    int i = 0;\n    for (Object o : c) {\n        if (ArrayUtils.indexOf(index, i) > -1) {\n            sample[ArrayUtils.indexOf(index, i)] = o;\n        }\n        i++;\n    }\n\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_EXCEEDS_N, k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE, k);\n    }\n\n    int[] permutation = nextPermutation(c.size(), k);\n    Object[] sample = new Object[k];\n    int i = 0;\n    for (Iterator<?> iter = c.iterator(); iter.hasNext(); ++i) {\n        sample[i] = iter.next();\n    }\n\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_EXCEEDS_COLLECTION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                                               k);\n    }\n\n    int[] permutation = nextPermutation(c.size(), k);\n    Object[] sample = new Object[k];\n    int i = 0;\n    for (Object o : c) {\n        if (ArrayUtils.indexOf(permutation, i) > -1) {\n            sample[ArrayUtils.indexOf(permutation, i)] = o;\n        }\n        i++;\n    }\n\n    return sample;\n}"
    ],
    [
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      MethodCallNode methodCallNode = new MethodCallNode(srcref,\n          compiler.getCurrentFile(),\n          methodName,\n          argumentNode,\n          argumentNode.getType(),\n          false,\n          false,\n          false,\n          false);\n      return methodCallNode;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node method = NodeUtil.newNameRef(methodName, srcref);\n      Node call = NodeUtil.newCall(method, srcref);\n      call.addChild(argumentNode);\n      return call;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      return Node.makeMethodCall(\n          Node.makeName(methodName, srcref),\n          ImmutableList.of(argumentNode),\n          srcref);\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      MethodCallNode callNode = new MethodCallNode(methodName,\n                                                    argumentNode,\n                                                    srcref);\n      callNode.setProperty(Node.PROP_IS_INLINABLE, Boolean.TRUE);\n      return callNode;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node methodNode = compiler.newNode(Node.METHOD_CALL, srcref);\n      Node nameNode = compiler.newNode(Node.IDENTIFIER, methodName, srcref);\n      Node argListNode = compiler.newNode(Node.ARGUMENT_LIST, srcref);\n      methodNode.addChild(nameNode);\n      argListNode.addChild(argumentNode);\n      methodNode.addChild(argListNode);\n      return methodNode;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node callNode = Node.makeMethodCall(methodName, argumentNode, srcref);\n      callNode.setProperty(Node.HAS_SIDE_EFFECTS, Boolean.TRUE);\n      return callNode;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Method method = compiler.getMethod(methodName);\n      if (method == null) {\n        throw new CompilerException(srcref, \"Unknown method: \" + methodName);\n      }\n      return new MethodCall(method, argumentNode, srcref);\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node methodCall = NodeUtil.makeMethodCall(methodName, argumentNode, srcref);\n      methodCall.setFlags(Node.FLAG_INLINE_CANDIDATE);\n      return methodCall;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      return Node.call(srcref, methodName,\n          Node.list(argumentNode));\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      return new MethodCall(new Name(methodName),\n                            new Arguments(argumentNode),\n                            srcref);\n    }"
    ],
    [
      "private int[] sortedIndices(final double[] doubles)  {\n    Integer[] idx = new Integer[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        idx[i] = i;\n    }\n    Arrays.sort(idx, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    Integer[] indices = new Integer[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    Integer[] indices = new Integer[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    Integer[] idx = new Integer[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        idx[i] = i;\n    }\n    Arrays.sort(idx, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    Integer[] indices = new Integer[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    Integer[] indices = new Integer[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    Integer[] idx = new Integer[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        idx[i] = i;\n    }\n    Arrays.sort(idx, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    Integer[] indices = new Integer[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    Integer[] indices = new Integer[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    Integer[] indices = new Integer[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() {\n}\n}"
    ],
    [
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        final int m = main.length;\n        double[][] data = new double[m][m];\n        for (int i = 0; i < m; i++) {\n            data[i][i] = 1.0;\n            for (int j = i + 1; j < m; j++) {\n                data[i][j] = householderVectors[j][i];\n                data[j][i] = -householderVectors[i][j];\n            }\n        }\n        cachedQt = MatrixUtils.createRealMatrix(data);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        final int m = main.length;\n        cachedQt = new Array2DRowRealMatrix(m, m);\n        double[][] data = cachedQt.getData();\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < m; j++) {\n                data[i][j] = householderVectors[i][j];\n            }\n            data[i][i] += 1.0;\n        }\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        final int m = main.length;\n        double[][] data = new double[m][m];\n        for (int i = 0; i < m; i++) {\n            data[i][i] = 1.0;\n        }\n        for (int i = 0; i < m - 1; i++) {\n            data[i + 1][i] = secondary[i];\n        }\n        cachedQt = MatrixUtils.createRealMatrix(data);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        final int m = main.length;\n        RealMatrix qt = new Array2DRowRealMatrix(m, m);\n        double[][] data = qt.getData();\n        for (int i = 0; i < m; i++) \n        {\n            for (int j = 0; j < m; j++) \n            {\n                if (i == j) \n                {\n                    data[i][j] = 1.0;\n                } \n                else \n                {\n                    data[i][j] = householderVectors[j][i];\n                }\n            }\n        }\n        cachedQt = qt;\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        final int m = main.length;\n        double[][] data = new double[m][m];\n        for (int i = 0; i < m; i++) \n        {\n            Arrays.fill(data[i], 0.0);\n            data[i][i] = 1.0;\n        }\n        for (int i = 0; i < m - 1; i++) \n        {\n            for (int j = 0; j < m - i - 1; j++) \n            {\n                data[i + j + 1][i] = householderVectors[i + j + 1][i];\n                data[i][i + j + 1] = householderVectors[i + j + 1][i];\n            }\n        }\n        cachedQt = MatrixUtils.createRealMatrix(data);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        int m = main.length;\n        RealMatrix qt = new Array2DRowRealMatrix(m, m);\n        double[][] data = qt.getData();\n        for (int i = 0; i < m; i++) \n        {\n            for (int j = 0; j < m; j++) \n            {\n                if (i == j) \n                {\n                    data[i][j] = 1.0;\n                } \n                else if (i < j) \n                {\n                    data[i][j] = householderVectors[j][i];\n                } \n                else \n                {\n                    data[i][j] = householderVectors[i][j];\n                }\n            }\n        }\n        cachedQt = qt;\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        final int m = main.length;\n        RealMatrix qt = MatrixUtils.createRealMatrix(m, m);\n        double[][] data = qt.getData();\n\n        // Initialize QT to the identity matrix\n        for (int i = 0; i < m; i++) {\n            data[i][i] = 1.0;\n        }\n\n        // Apply Householder transformations to QT\n        for (int i = 0; i < m - 1; i++) {\n            for (int j = i + 1; j < m; j++) {\n                data[j][i] = householderVectors[j][i];\n            }\n            HouseholderVectorTransform.transformInPlace(data[i], data, i, m, m);\n        }\n\n        cachedQt = qt;\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        final int m = main.length;\n        RealMatrix qt = new Array2DRowRealMatrix(m, m);\n        double[][] data = qt.getData();\n        for (int i = 0; i < m; i++) \n        {\n            data[i][i] = 1.0;\n        }\n        for (int i = 0; i < m - 1; i++) \n        {\n            for (int j = 0; j < m; j++) \n            {\n                if (j == i + 1) \n                {\n                    data[j][i] = secondary[i];\n                } \n                else if (j > i + 1) \n                {\n                    data[j][i] = householderVectors[j][i + 1];\n                } \n                else \n                {\n                    data[j][i] = householderVectors[i + 1][j];\n                }\n            }\n        }\n        cachedQt = qt;\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        final int m = main.length;\n        RealMatrix qt = new Array2DRowRealMatrix(m, m);\n        double[][] data = qt.getData();\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (i == j) {\n                    data[i][j] = 1;\n                } else if (i < j) {\n                    data[i][j] = householderVectors[j][i];\n                } else {\n                    data[i][j] = -householderVectors[i][j];\n                }\n            }\n        }\n        cachedQt = qt;\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        final int m = main.length;\n        RealMatrix qt = new Array2DRowRealMatrix(m, m);\n        double[][] data = qt.getData();\n        // Initialize QT as the identity matrix\n        for (int i = 0; i < m; i++) \n        {\n            for (int j = 0; j < m; j++) \n            {\n                data[i][j] = (i == j) ? 1.0 : 0.0;\n            }\n        }\n        // Apply Householder transformations to QT\n        for (int k = 0; k < m - 1; k++) \n        {\n            double[] vector = Arrays.copyOfRange(householderVectors[k], k, m);\n            double norm = FastMath.sqrt(vector[0] * vector[0] + Arrays.stream(vector, 1, vector.length).map(x -> x * x).sum());\n            vector[0] += (vector[0] < 0) ? -norm : norm;\n            double s = norm * vector[0];\n            for (int i = 0; i < vector.length; i++) \n            {\n                vector[i] /= s;\n            }\n            for (int i = 0; i < m; i++) \n            {\n                for (int j = k; j < m; j++) \n                {\n                    double temp = data[i][j];\n                    data[i][j] -= vector[i] * vector[j];\n                    data[j][i] = data[i][j];\n                }\n            }\n        }\n        cachedQt = qt;\n    }\n    return cachedQt;\n}"
    ],
    [
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) \n    {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) \n    {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) \n    {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}"
    ],
    [
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n        return new TransformedSet<E>(set, transformer);\n    }",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n        return new TransformedSet<E>(set, transformer);\n    }",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n        return new TransformedSet<E>(set, transformer);\n    }",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n        return new TransformedSet<E>(set, transformer);\n    }",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n        return new TransformedSet<E>(set, transformer);\n    }",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    if (set == null || transformer == null) {\n        throw new NullPointerException();\n    }\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n        return new TransformedSet<E>(set, transformer);\n    }"
    ],
    [
      "public StrBuilder ensureCapacity(final int capacity)  {\n    // If the current capacity is less than the required capacity\n    if (capacity > buffer.length) \n    {\n        // Double the current capacity\n        int newCapacity = buffer.length * 2;\n\n        // If the new capacity is still less than the required capacity, set it to the required capacity\n        if (newCapacity < capacity) \n        {\n            newCapacity = capacity;\n        }\n\n        // Create a new buffer with the new capacity\n        char[] newBuffer = new char[newCapacity];\n\n        // Copy the characters from the old buffer to the new buffer\n        System.arraycopy(buffer, 0, newBuffer, 0, size);\n\n        // Set the buffer to the new buffer\n        buffer = newBuffer;\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] newBuffer = new char[capacity];\n        System.arraycopy(buffer, 0, newBuffer, 0, size);\n        buffer = newBuffer;\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    // If the capacity is already large enough, do nothing\n    if (capacity > buffer.length) \n    {\n        char[] newBuffer = new char[capacity];\n        System.arraycopy(buffer, 0, newBuffer, 0, size);\n        buffer = newBuffer;\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] newBuffer = new char[capacity];\n        System.arraycopy(buffer, 0, newBuffer, 0, size);\n        buffer = newBuffer;\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] newBuffer = new char[capacity];\n        System.arraycopy(buffer, 0, newBuffer, 0, size);\n        buffer = newBuffer;\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] newBuffer = new char[capacity];\n        System.arraycopy(buffer, 0, newBuffer, 0, size);\n        buffer = newBuffer;\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    // If the new capacity is less than the old one, no changes are made\n    if (capacity < buffer.length) \n    {\n        return this;\n    }\n\n    // Create a new buffer of the required size\n    char[] newBuffer = new char[capacity];\n\n    // Copy the old buffer to the new one\n    System.arraycopy(buffer, 0, newBuffer, 0, size);\n\n    // Replace the old buffer with the new one\n    buffer = newBuffer;\n\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] newBuffer = new char[capacity];\n        System.arraycopy(buffer, 0, newBuffer, 0, size);\n        buffer = newBuffer;\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] newBuffer = new char[capacity];\n        System.arraycopy(buffer, 0, newBuffer, 0, size);\n        buffer = newBuffer;\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] newBuffer = new char[capacity];\n        System.arraycopy(buffer, 0, newBuffer, 0, size);\n        buffer = newBuffer;\n    }\n    return this;\n}"
    ],
    [
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    boolean hasValidData = false;\n    for (int item = 0; item < dataset.getItemCount(); item++) {\n        double total = 0.0;\n        for (int series = 0; series < dataset.getSeriesCount(); series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                total += number.doubleValue();\n                hasValidData = true;\n            }\n        }\n        minimum = Math.min(minimum, total);\n        maximum = Math.max(maximum, total);\n    }\n    if (hasValidData) {\n        return new Range(minimum, maximum);\n    }\n    else {\n        return null;\n    }\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        boolean hasValidData = false;\n        for (int itemNo = 0; itemNo < dataset.getItemCount(); itemNo++) \n        {\n            double total = 0.0;\n            for (int seriesNo = 0; seriesNo < dataset.getSeriesCount(); seriesNo++) \n            {\n                double value = dataset.getCategory(seriesNo, itemNo).doubleValue();\n                if (!Double.isNaN(value)) \n                {\n                    total += value;\n                    hasValidData = true;\n                }\n            }\n            minimum = Math.min(minimum, total);\n            maximum = Math.max(maximum, total);\n        }\n        if (hasValidData) \n        {\n            return new Range(minimum, maximum);\n        }\n        else \n        {\n            return null;\n        }\n    }",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        boolean hasValidData = false;\n\n        for (int item = 0; item < dataset.getItemCount(); item++) \n        {\n            double total = 0.0;\n            for (int series = 0; series < dataset.getSeriesCount(); series++) \n            {\n                Number number = dataset.getValue(series, item);\n                if (number != null) \n                {\n                    total += number.doubleValue();\n                    hasValidData = true;\n                }\n            }\n            minimum = Math.min(minimum, total);\n            maximum = Math.max(maximum, total);\n        }\n\n        if (hasValidData) \n        {\n            return new Range(minimum, maximum);\n        }\n        else \n        {\n            return null;\n        }\n    }",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    boolean hasValidData = false;\n\n    for (int item = 0; item < dataset.getItemCount(); item++) \n    {\n        double total = 0.0;\n        for (int series = 0; series < dataset.getSeriesCount(); series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                total += number.doubleValue();\n                hasValidData = true;\n            }\n        }\n        minimum = Math.min(minimum, total);\n        maximum = Math.max(maximum, total);\n    }\n\n    if (hasValidData) \n    {\n        return new Range(minimum, maximum);\n    }\n    else \n    {\n        return null;\n    }\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    boolean hasValidData = false;\n\n    for (int itemNo = 0; itemNo < dataset.getItemCount(); itemNo++) \n    {\n        double total = 0.0;\n        for (int seriesNo = 0; seriesNo < dataset.getSeriesCount(); seriesNo++) \n        {\n            double value = dataset.getValue(seriesNo, itemNo).doubleValue();\n            if (!Double.isNaN(value)) \n            {\n                total += value;\n                hasValidData = true;\n            }\n        }\n        minimum = Math.min(minimum, total);\n        maximum = Math.max(maximum, total);\n    }\n\n    if (hasValidData) \n    {\n        return new Range(minimum, maximum);\n    } \n    else \n    {\n        return null;\n    }\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    boolean hasValidData = false;\n\n    for (int itemNo = 0; itemNo < dataset.getItemCount(); itemNo++) \n    {\n        double total = 0.0;\n        for (int seriesNo = 0; seriesNo < dataset.getSeriesCount(); seriesNo++) \n        {\n            double value = dataset.getCategory(seriesNo, itemNo).doubleValue();\n            if (!Double.isNaN(value)) \n            {\n                total += value;\n                hasValidData = true;\n            }\n        }\n        minimum = Math.min(minimum, total);\n        maximum = Math.max(maximum, total);\n    }\n\n    if (hasValidData) \n    {\n        return new Range(minimum, maximum);\n    }\n    else \n    {\n        return null;\n    }\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    boolean hasValidData = false;\n\n    for (int item = 0; item < dataset.getItemCount(); item++) \n    {\n        double total = 0.0;\n        for (int series = 0; series < dataset.getSeriesCount(); series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                total += number.doubleValue();\n                hasValidData = true;\n            }\n        }\n        minimum = Math.min(minimum, total);\n        maximum = Math.max(maximum, total);\n    }\n\n    if (hasValidData) \n    {\n        return new Range(minimum, maximum);\n    } \n    else \n    {\n        return null;\n    }\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    boolean hasValidData = false;\n\n    for (int item = 0; item < dataset.getItemCount(); item++) \n    {\n        double total = 0.0;\n        for (int series = 0; series < dataset.getSeriesCount(); series++) \n        {\n            double value = dataset.getCategory(series, item).doubleValue();\n            if (!Double.isNaN(value)) \n            {\n                total += value;\n                hasValidData = true;\n            }\n        }\n        minimum = Math.min(minimum, total);\n        maximum = Math.max(maximum, total);\n    }\n\n    if (hasValidData) \n    {\n        return new Range(minimum, maximum);\n    }\n    else \n    {\n        return null;\n    }\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    boolean hasValidData = false;\n    for (int itemNo = 0; itemNo < dataset.getItemCount(); itemNo++) \n    {\n        double total = 0.0;\n        for (int seriesNo = 0; seriesNo < dataset.getSeriesCount(); seriesNo++) \n        {\n            double value = dataset.getValue(seriesNo, itemNo).doubleValue();\n            if (!Double.isNaN(value)) \n            {\n                total += value;\n                hasValidData = true;\n            }\n        }\n        minimum = Math.min(minimum, total);\n        maximum = Math.max(maximum, total);\n    }\n    if (hasValidData) {\n        return new Range(minimum, maximum);\n    }\n    else {\n        return null;\n    }\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    boolean hasValidData = false;\n\n    for (int item = 0; item < dataset.getItemCount(); item++) \n    {\n        double total = 0.0;\n        for (int series = 0; series < dataset.getSeriesCount(); series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                total += number.doubleValue();\n                hasValidData = true;\n            }\n        }\n        minimum = Math.min(minimum, total);\n        maximum = Math.max(maximum, total);\n    }\n\n    if (hasValidData) \n    {\n        return new Range(minimum, maximum);\n    }\n    else \n    {\n        return null;\n    }\n}"
    ],
    [
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours offset must be in the range -23 to +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes offset must be in the range -59 to +59\");\n    }\n    if (minutesOffset < 0 && hoursOffset > 0) {\n        throw new IllegalArgumentException(\"Minutes offset cannot be negative when hours offset is positive\");\n    }\n    int totalMinutes = hoursOffset * 60 + minutesOffset;\n    if (totalMinutes < -1439 || totalMinutes > 1439) {\n        throw new IllegalArgumentException(\"Resulting offset exceeds +/- 23:59:59.000\");\n    }\n    String id = String.format(\"%02d:%02d\", hoursOffset, minutesOffset);\n    return fixedOffsetZone(id, totalMinutes * 60 * 1000);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n        if (hoursOffset < -23 || hoursOffset > 23) {\n            throw new IllegalArgumentException(\"The hours offset must be in the range -23 to +23\");\n        }\n        if (minutesOffset < -59 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"The minutes offset must be in the range -59 to +59\");\n        }\n        if (minutesOffset < 0 && hoursOffset > 0) {\n            throw new IllegalArgumentException(\"The minutes offset cannot be negative when the hours offset is positive\");\n        }\n        int offset = hoursOffset * 60 + minutesOffset;\n        if (offset < -1440 || offset > 1440) {\n            throw new IllegalArgumentException(\"The resulting offset exceeds +/- 23:59:59.000\");\n        }\n        return fixedOffsetZone(hoursOffset + \":\" + minutesOffset, offset);\n    }",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours offset out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes offset out of range: \" + minutesOffset);\n    }\n    if (minutesOffset < 0 && hoursOffset > 0) {\n        throw new IllegalArgumentException(\"Minutes offset cannot be negative when hours offset is positive\");\n    }\n    int totalMinutes = hoursOffset * 60 + minutesOffset;\n    if (totalMinutes < -1440 || totalMinutes > 1440) {\n        throw new IllegalArgumentException(\"Resulting offset exceeds +/- 23:59:59.000\");\n    }\n    return fixedOffsetZone(hoursOffset + \":\" + (minutesOffset < 0 ? \"0\" + -minutesOffset : minutesOffset), totalMinutes);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hour offset out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minute offset out of range: \" + minutesOffset);\n    }\n    if (minutesOffset < 0 && hoursOffset > 0) {\n        throw new IllegalArgumentException(\"Minutes cannot be negative when hours are positive\");\n    }\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return DateTimeZone.UTC;\n    }\n    int totalMinutes = hoursOffset * 60 + minutesOffset;\n    if (totalMinutes < -1439 || totalMinutes > 1439) {\n        throw new IllegalArgumentException(\"Total offset exceeds +/- 23:59:59.000\");\n    }\n    return fixedOffsetZone(hoursOffset + \":\" + (minutesOffset < 0 ? \"0\" : \"\") + minutesOffset, totalMinutes);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n        if (hoursOffset < -23 || hoursOffset > 23) {\n            throw new IllegalArgumentException(\"The hours offset must be in the range -23 to +23\");\n        }\n        if (minutesOffset < -59 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"The minutes offset must be in the range -59 to +59\");\n        }\n        if (minutesOffset < 0 && hoursOffset > 0) {\n            throw new IllegalArgumentException(\"The minutes offset must not be negative when the hours offset is positive\");\n        }\n        int offset = hoursOffset * 60 + minutesOffset;\n        if (offset < -1440 || offset > 1440) {\n            throw new IllegalArgumentException(\"The resulting offset exceeds +/- 23:59:59.000\");\n        }\n        return fixedOffsetZone(hoursOffset + \":\" + minutesOffset, offset);\n    }",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n        if (hoursOffset < -23 || hoursOffset > 23) {\n            throw new IllegalArgumentException(\"The hours offset must be in the range -23 to +23\");\n        }\n        if (minutesOffset < -59 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"The minutes offset must be in the range -59 to +59\");\n        }\n        if (minutesOffset < 0 && hoursOffset > 0) {\n            throw new IllegalArgumentException(\"The minutes offset must not be negative when the hours offset is positive\");\n        }\n        if (minutesOffset > 0 && hoursOffset < 0) {\n            throw new IllegalArgumentException(\"The minutes offset must not be positive when the hours offset is negative\");\n        }\n        int offset = hoursOffset * 60 + minutesOffset;\n        if (offset < -1440 || offset > 1440) {\n            throw new IllegalArgumentException(\"The resulting offset exceeds +/- 23:59:59.000\");\n        }\n        return fixedOffsetZone(hoursOffset + \":\" + minutesOffset, offset);\n    }",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"The hours offset must be in the range -23 to +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"The minutes offset must be in the range -59 to +59\");\n    }\n    if (minutesOffset < 0 && hoursOffset > 0) {\n        throw new IllegalArgumentException(\"The minutes offset cannot be negative when the hours offset is positive\");\n    }\n    int totalMinutes = hoursOffset * 60 + minutesOffset;\n    if (totalMinutes < -1439 || totalMinutes > 1439) {\n        throw new IllegalArgumentException(\"The resulting offset exceeds +/- 23:59:59.000\");\n    }\n    return fixedOffsetZone(hoursOffset + \":\" + minutesOffset, totalMinutes);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours offset out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes offset out of range: \" + minutesOffset);\n    }\n    if (minutesOffset < 0 && hoursOffset > 0) {\n        throw new IllegalArgumentException(\"Minutes offset cannot be negative when hours offset is positive\");\n    }\n    int offset = hoursOffset * 60 + minutesOffset;\n    if (offset < -1440 || offset > 1440) {\n        throw new IllegalArgumentException(\"Resulting offset exceeds +/- 23:59:59.000\");\n    }\n    return fixedOffsetZone(hoursOffset + \":\" + minutesOffset, offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"The hours offset must be in the range -23 to +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"The minutes offset must be in the range -59 to +59\");\n    }\n    if (minutesOffset < 0 && hoursOffset > 0) {\n        throw new IllegalArgumentException(\"The minutes offset must not be negative when the hours offset is positive\");\n    }\n    int offset = hoursOffset * 60 + minutesOffset;\n    if (offset < -1440 || offset > 1440) {\n        throw new IllegalArgumentException(\"The resulting offset exceeds +/- 23:59:59.000\");\n    }\n    return fixedOffsetZone(hoursOffset + \":\" + minutesOffset, offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"The hours offset must be in the range -23 to +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"The minutes offset must be in the range -59 to +59\");\n    }\n    if (minutesOffset < 0 && hoursOffset > 0) {\n        throw new IllegalArgumentException(\"The minutes offset must not be negative when the hours offset is positive\");\n    }\n    int offset = hoursOffset * 60 + minutesOffset;\n    if (offset < -1440 || offset > 1440) {\n        throw new IllegalArgumentException(\"The resulting offset exceeds +/- 23:59:59.000\");\n    }\n    return fixedOffsetZone(hoursOffset + \":\" + minutesOffset, offset);\n}"
    ],
    [
      "public String chompBalanced(char open, char close)  {\n        int level = 0;\n        int start = pos;\n        while (!isEmpty()) {\n            if (queue.charAt(pos) == open) {\n                level++;\n            } else if (queue.charAt(pos) == close) {\n                level--;\n                if (level == 0)\n                    break;\n            }\n            pos++;\n        }\n\n        if (level != 0)\n            throw new IllegalStateException(\"Unbalanced brackets\");\n\n        return queue.substring(start, pos);\n    }",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder openSeq = new StringBuilder();\n    StringBuilder closeSeq = new StringBuilder();\n    openSeq.append(open);\n    closeSeq.append(close);\n    return chompBalanced(openSeq.toString(), closeSeq.toString());\n}",
      "public String chompBalanced(char open, char close)  {\n        int level = 0;\n        int start = pos;\n        while (!isEmpty()) {\n            if (queue.charAt(pos) == open) {\n                level++;\n            } else if (queue.charAt(pos) == close) {\n                level--;\n                if (level == 0)\n                    break;\n            }\n            pos++;\n        }\n        if (level != 0)\n            throw new IllegalStateException(\"Queue not balanced\");\n        return queue.substring(start, pos + 1);\n    }",
      "public String chompBalanced(char open, char close)  {\n        int level = 0;\n        int start = pos;\n        while (!isEmpty()) {\n            if (queue.charAt(pos) == open) {\n                level++;\n            } else if (queue.charAt(pos) == close) {\n                if (level == 0)\n                    break;\n                level--;\n            }\n            pos++;\n        }\n        if (level != 0)\n            throw new IllegalStateException(\"Unbalanced parentheses\");\n        return queue.substring(start, pos);\n    }",
      "public String chompBalanced(char open, char close)  {\n    int start = pos;\n    int depth = 0;\n    while (!isEmpty()) {\n        char c = queue.charAt(pos);\n        if (c == open) {\n            depth++;\n        } else if (c == close) {\n            if (depth == 0) {\n                break;\n            }\n            depth--;\n        }\n        pos++;\n    }\n    if (depth != 0) {\n        throw new IllegalStateException(\"Queue not balanced\");\n    }\n    return queue.substring(start, pos);\n}",
      "public String chompBalanced(char open, char close)  {\n    int level = 0;\n    int start = pos;\n    while (!isEmpty()) {\n        char c = queue.charAt(pos);\n        if (c == open) {\n            level++;\n        } else if (c == close) {\n            if (level == 0)\n                break;\n            level--;\n        }\n        pos++;\n    }\n\n    if (level != 0)\n        throw new IllegalStateException(\"Unbalanced brackets\");\n\n    return queue.substring(start, pos);\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = pos;\n    int depth = 0;\n    while (!isEmpty()) \n    {\n        char c = queue.charAt(pos);\n        if (c == open) \n        {\n            depth++;\n        } \n        else if (c == close) \n        {\n            if (depth == 0) \n            {\n                break;\n            }\n            depth--;\n        }\n        pos++;\n    }\n    if (depth != 0) \n    {\n        throw new IllegalStateException(\"Unbalanced parentheses\");\n    }\n    return queue.substring(start, pos);\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder sb = new StringBuilder();\n    int balance = 0;\n    while (!isEmpty()) \n    {\n        char c = queue.charAt(pos);\n        sb.append(c);\n        if (c == open) \n        {\n            balance++;\n        } \n        else if (c == close) \n        {\n            balance--;\n            if (balance == 0) \n            {\n                pos++;\n                return sb.toString();\n            }\n        }\n        pos++;\n    }\n    return sb.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    int openCount = 0;\n    int start = pos;\n    while (!isEmpty()) \n    {\n        char c = queue.charAt(pos);\n        if (c == open) \n        {\n            openCount++;\n        } \n        else if (c == close) \n        {\n            if (openCount == 0) \n            {\n                break;\n            }\n            openCount--;\n        }\n        pos++;\n    }\n    if (openCount != 0) \n    {\n        throw new IllegalStateException(\"Queue not balanced\");\n    }\n    return queue.substring(start, pos);\n}",
      "public String chompBalanced(char open, char close)  {\n        int level = 0;\n        int start = pos;\n        while (!isEmpty()) {\n            if (queue.charAt(pos) == open) {\n                level++;\n            } else if (queue.charAt(pos) == close) {\n                level--;\n                if (level == 0)\n                    break;\n            }\n            pos++;\n        }\n\n        if (level != 0)\n            throw new IllegalStateException(\"Unbalanced brackets\");\n\n        return queue.substring(start, pos + 1);\n    }"
    ],
    [
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        int p = getX().getColumnDimension();\n        double[][] r = qr.getR().getData();\n        double[][] rt = new double[p][p];\n        for (int i = 0; i < p; i++) {\n            for (int j = 0; j < p; j++) {\n                rt[i][j] = r[j][i];\n            }\n        }\n        RealMatrix rMatrix = MatrixUtils.createRealMatrix(rt);\n        RealMatrix rtR = rMatrix.transpose().multiply(rMatrix);\n        try {\n            return rtR.inverse();\n        } catch (NonSingularMatrixException e) {\n            throw new MathIllegalStateException(LocalizedFormats.MATH_SINGULAR_MATRIX, e);\n        }\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        int p = getX().getColumnDimension();\n        double[][] r = qr.getR().getData();\n        double[][] rt = new double[p][p];\n        for (int i = 0; i < p; i++) {\n            for (int j = 0; j < p; j++) {\n                rt[i][j] = r[j][i];\n            }\n        }\n        RealMatrix rT = MatrixUtils.createRealMatrix(rt);\n        RealMatrix rTR = rT.multiply(MatrixUtils.createRealMatrix(r));\n        try {\n            return rTR.inverse();\n        } catch (NonInvertibleMatrixException e) {\n            throw new MathIllegalStateException(LocalizedFormats.MATRIX_NOT_INVERTIBLE, e);\n        }\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final int p = getBeta().getDimension();\n        final double[][] r = qr.getR().getData();\n        final double[][] rt = new double[p][p];\n        for (int i = 0; i < p; i++) {\n            for (int j = 0; j < p; j++) {\n                rt[i][j] = r[j][i];\n            }\n        }\n        final DenseMatrixCholesky decomp = new DenseMatrixCholesky(rt, true);\n        return decomp.solve(new Array2DRowRealMatrix(rt)).transpose();\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final int p = getX().getColumnDimension();\n        final RealMatrix r = qr.getR();\n        final RealMatrix rr = r.transpose().multiply(r);\n        final LUDecomposition lu = new LUDecomposition(rr);\n        final RealMatrix inverse = lu.getSolver().getInverse();\n        return r.getSubMatrix(0, p - 1, 0, p - 1).multiply(inverse);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        int p = getX().getColumnDimension();\n        RealMatrix r = qr.getR();\n        RealMatrix rt = r.transpose();\n        RealMatrix rtr = rt.multiply(r);\n        try {\n            return rtr.inverse().getSubMatrix(0, p - 1, 0, p - 1);\n        } catch (NonInvertibleMatrixException e) {\n            throw new MathIllegalStateException(\"Matrix is not invertible\", e);\n        }\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        int p = getX().getColumnDimension();\n        RealMatrix r = qr.getR();\n        RealMatrix rt = r.transpose();\n        RealMatrix rtr = rt.multiply(r);\n        RealMatrix invRtr = new LUDecomposition(rtr).getSolver().getInverse();\n        return invRtr.multiply(MatrixUtils.identityMatrix(p));\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        int p = getX().getColumnDimension();\n        double[][] r = qr.getR().getData();\n        double[][] rt = new double[p][p];\n        for (int i = 0; i < p; i++) {\n            for (int j = 0; j < p; j++) {\n                rt[i][j] = r[j][i];\n            }\n        }\n        RealMatrix rtMatrix = MatrixUtils.createRealMatrix(rt);\n        RealMatrix rtr = rtMatrix.multiply(MatrixUtils.createRealMatrix(r));\n        try {\n            return rtr.inverse();\n        } catch (NonInvertibleMatrixException e) {\n            throw new MathIllegalStateException(LocalizedFormats.MATRIX_NOT_INVERTIBLE, e);\n        }\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        int p = getX().getColumnDimension();\n        RealMatrix r = qr.getR();\n        RealMatrix rrInverse = r.transpose().scalarMultiply(1.0 / r.normF()).multiply(r);\n        return rrInverse.getSubMatrix(0, p - 1, 0, p - 1).inverse();\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final int p = getX().getColumnDimension();\n        final double[][] r = qr.getR().getData();\n        final double[][] rt = new double[p][p];\n        for (int i = 0; i < p; i++) {\n            for (int j = 0; j < p; j++) {\n                rt[i][j] = r[j][i];\n            }\n        }\n        final DenseMatrixCholesky solver = new DenseMatrixCholesky(rt, true);\n        return solver.getSolver().getInverse();\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final int p = getBeta().getDimension();\n        final RealMatrix r = qr.getR();\n        final RealMatrix rt = r.transpose();\n        final RealMatrix rtr = rt.multiply(r);\n        final LUDecomposition lu = new LUDecomposition(rtr);\n        final RealMatrix invRtr = lu.getSolver().getInverse();\n        return invRtr.getSubMatrix(0, p - 1, 0, p - 1);\n    }"
    ],
    [
      "private static String printOffset(int offset)  {\n        // Can't use a real chronology if called during class\n        // initialization. Offset parser doesn't need it anyhow.\n}",
      "private static String printOffset(int offset)  {\n        // Can't use a real chronology if called during class\n        // initialization. Offset parser doesn't need it anyhow.\n}",
      "private static String printOffset(int offset)  {\n}",
      "private static String printOffset(int offset)  {\n    // Can't use a real chronology if called during class\n    // initialization. Offset parser doesn't need it anyhow.\n}",
      "private static String printOffset(int offset)  {\n    // Can't use a real chronology if called during class\n    // initialization. Offset parser doesn't need it anyhow.\n}",
      "private static String printOffset(int offset)  {\n    // Can't use a real chronology if called during class\n    // initialization. Offset parser doesn't need it anyhow.\n}",
      "private static String printOffset(int offset)  {\n    // Can't use a real chronology if called during class\n    // initialization. Offset printer doesn't need it anyhow.\n}",
      "private static String printOffset(int offset)  {\n    // Can't use a real chronology if called during class\n    // initialization. Offset parser doesn't need it anyhow.\n}",
      "private static String printOffset(int offset)  {\n        // Can't use a real chronology if called during class\n        // initialization. Offset printer doesn't need it anyhow.\n}",
      "private static String printOffset(int offset)  {\n}"
    ],
    [
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Integer index = (Integer) this.indexMap.get(key);\n    return (index != null) ? index : -1;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Integer index = (Integer) this.indexMap.get(key);\n    return (index != null) ? index.intValue() : -1;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Integer index = (Integer) this.indexMap.get(key);\n    return (index != null) ? index.intValue() : -1;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Integer index = (Integer) this.indexMap.get(key);\n    return (index != null) ? index.intValue() : -1;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Integer index = (Integer) this.indexMap.get(key);\n    return (index != null) ? index.intValue() : -1;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Integer index = (Integer) this.indexMap.get(key);\n    if (index == null) \n    {\n        return -1;\n    } \n    else \n    {\n        return index.intValue();\n    }\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Integer index = (Integer) this.indexMap.get(key);\n    return (index != null) ? index.intValue() : -1;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Integer index = (Integer) this.indexMap.get(key);\n    if (index == null) \n    {\n        return -1;\n    } \n    else \n    {\n        return index.intValue();\n    }\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Integer index = (Integer) this.indexMap.get(key);\n    if (index == null) \n    {\n        return -1;\n    } \n    else \n    {\n        return index.intValue();\n    }\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Integer index = (Integer) this.indexMap.get(key);\n    return (index != null) ? index.intValue() : -1;\n}"
    ],
    [
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> flowSlots = new HashMap<>();\n  FlowScope current = this;\n  while (current != null) {\n    for (StaticSlot<JSType> slot : current.getSlots()) {\n      flowSlots.put(slot.getName(), slot);\n    }\n    current = current.getParent();\n  }\n  return flowSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> allFlowSlots = new HashMap<>();\n    FlowScope currentScope = this;\n    while (currentScope != null) {\n        allFlowSlots.putAll(currentScope.getSlots());\n        currentScope = currentScope.getParent();\n    }\n    return allFlowSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  // TODO: Implement this function\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> allFlowSlots = new HashMap<>();\n    for (FlowScope scope = this; scope != null; scope = scope.getParent()) {\n        for (StaticSlot<JSType> slot : scope.getSlots()) {\n            allFlowSlots.put(slot.getName(), slot);\n        }\n    }\n    return allFlowSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> allFlowSlots = new HashMap<>();\n  for (FlowScope scope = this; scope != null; scope = scope.getParent()) {\n    if (scope instanceof LinkedFlowScope) {\n      LinkedFlowScope linkedScope = (LinkedFlowScope) scope;\n      if (linkedScope.frozen) {\n        allFlowSlots.putAll(linkedScope.getFlowSlots());\n      }\n    }\n  }\n  return allFlowSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    // TODO: Implement this function\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    // TODO: Implement this function.\n    return null;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  // TODO: Implement this method.\n  return null;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    // TODO: Implement this function\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    // TODO: Implement this function.\n    return null;\n}"
    ],
    [
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    if (columnData.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    if (columnData.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    if (columnData.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}"
    ],
    [
      "public static double atanh(double a)  {\n    if (a <= -1 || a >= 1) {\n        throw new IllegalArgumentException(\"atanh: argument out of domain\");\n    }\n\n    boolean negate = false;\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n\n    double result;\n    if (a < 0.16666666666666666) {\n        double x = a * a;\n        result = a * (1 - x * (F_1_3 - x * (F_1_5 - x * (F_1_7 - x * (F_1_9 - x * (F_1_11 - x * (F_1_13 - x * (F_1_15 - x * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2;\n    } else {\n        double x = a * a;\n        double temp = x * (F_1_3 - x * (F_1_5 - x * (F_1_7 - x * (F_1_9 - x * (F_1_11 - x * (F_1_13 - x * (F_1_15 - x * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2;\n        result = a + a * temp / (1 - x * temp);\n    }\n\n    return negate ? -result : result;\n}",
      "public static double atanh(double a)  {\n    if (a <= -1 || a >= 1) {\n        throw new IllegalArgumentException(\"Argument out of range: \" + a);\n    }\n\n    double result;\n    if (a == 1.0) {\n        return 0.0;\n    } else if (a == -1.0) {\n        return Constants.PI;\n    } else if (Math.abs(a) < 0.1) {\n        double a2 = a * a;\n        result = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2;\n    } else {\n        double temp = FastMath.expm1(2 * a);\n        result = FastMath.log1p(temp / (1 + temp));\n    }\n\n    return result;\n}",
      "public static double atanh(double a)  {\n    if (a > 1.0 || a < -1.0) {\n        throw new IllegalArgumentException(\"atanh: argument out of domain\");\n    }\n\n    boolean negate = false;\n    if (a < 0) {\n        a = -a;\n        negate = true;\n    }\n\n    if (a < 0.16666666666666666) {\n        double a2 = a * a;\n        double result = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2;\n        return negate ? -result : result;\n    } else {\n        double temp = FastMath.log1p(a);\n        return negate ? -temp : temp;\n    }\n}",
      "public static double atanh(double a)  {\n    if (a > 1.0 || a < -1.0) {\n        throw new IllegalArgumentException(\"Argument out of range: \" + a);\n    }\n\n    boolean negate = false;\n    if (a < 0) {\n        a = -a;\n        negate = true;\n    }\n\n    if (a < 0.167) {\n        double a2 = a * a;\n        if (a > 0.097) {\n            a = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2;\n        } else if (a > 0.036) {\n            a = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.0036) {\n            a = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else {\n}\n}\n}",
      "public static double atanh(double a)  {\n    if (a <= -1 || a >= 1) {\n        throw new IllegalArgumentException(\"atanh: argument out of domain\");\n    }\n\n    boolean negate = false;\n    if (a < 0) {\n        a = -a;\n        negate = true;\n    }\n\n    if (a < 0.04) {\n        double a2 = a * a;\n        double a4 = a2 * a2;\n        double a6 = a4 * a2;\n        double a8 = a6 * a2;\n        double a10 = a8 * a2;\n        double a12 = a10 * a2;\n        double a14 = a12 * a2;\n        double a16 = a14 * a2;\n        double a18 = a16 * a2;\n        double a20 = a18 * a2;\n        double a22 = a20 * a2;\n        double a24 = a22 * a2;\n        double a26 = a24 * a2;\n        double a28 = a26 * a2;\n        double a30 = a28 * a2;\n        double a32 = a30 * a2;\n        double a34 = a32 * a2;\n        double a36 = a34 * a2;\n        double a38 = a36 * a2;\n        double a40 = a38 * a2;\n        double a42 = a40 * a2;\n        double a44 = a42 * a2;\n        double a46 = a44 * a2;\n        double a48 = a46 * a2;\n        double a50 = a48 * a2;\n        double a52 = a50 * a2;\n        double a54 = a52 * a2;\n        double a56 = a54 * a2;\n        double a58 = a56 * a2;\n        double a60 = a58 * a2;\n        double a62 = a60 * a2;\n}\n}",
      "public static double atanh(double a)  {\n    if (a > 1.0 || a < -1.0) {\n        throw new IllegalArgumentException(\"The argument must be between -1 and 1\");\n    }\n\n    boolean negate = false;\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n\n    double result;\n    if (a == 1.0) {\n        result = Double.POSITIVE_INFINITY;\n    }\n    else if (a == -1.0) {\n        result = Double.NEGATIVE_INFINITY;\n    }\n    else {\n        double x = (1 - a) / (1 + a);\n\n        double hiPrec[] = new double[2];\n        // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n        expm1(x*2.0, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        /* Numerator */\n        double na = ya;\n        double nb = yb;\n\n        /* Denominator */\n        double da = 2.0 + ya;\n        double db = -(da - 2.0 - ya);\n        double temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n\n        temp = da * HEX_40000000;\n        double daa = da + temp - temp;\n        double dab = da - daa;\n\n        // ratio = na/da\n        double ratio = na/da;\n        temp = ratio * HEX_40000000;\n        double ratioa = ratio + temp - temp;\n        double ratiob = ratio - ratioa;\n\n        // Correct for rounding in division\n        ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n        // Account for nb\n}\n}",
      "public static double atanh(double a)  {\n    if (a <= -1 || a >= 1) {\n        throw new IllegalArgumentException(\"Argument out of domain\");\n    }\n\n    boolean negate = false;\n    if (a < 0) {\n        a = -a;\n        negate = true;\n    }\n\n    if (a < 0.16666666666666666) {\n        double a2 = a * a;\n        double result = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2;\n        return negate ? -result : result;\n    } else {\n        double temp = FastMath.log((1 + a) / (1 - a));\n        return negate ? -temp : temp;\n    }\n}",
      "public static double atanh(double a)  {\n    if (a > 1.0 || a < -1.0) {\n        throw new IllegalArgumentException(\"Argument out of range. Must be in the range (-1, 1)\");\n    }\n\n    boolean negate = false;\n    if (a < 0) {\n        a = -a;\n        negate = true;\n    }\n\n    double result;\n    if (a < 0.097) {\n        double a2 = a * a;\n        result = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2;\n    } else {\n        double hiPrec[] = new double[2];\n        // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n        expm1(a*2.0, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        /* Numerator */\n        double na = ya;\n        double nb = yb;\n\n        /* Denominator */\n        double da = 2.0 + ya;\n        double db = -(da - 2.0 - ya);\n        double temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n\n        temp = da * HEX_40000000;\n        double daa = da + temp - temp;\n        double dab = da - daa;\n\n        // ratio = na/da\n        double ratio = na/da;\n}\n}",
      "public static double atanh(double a)  {\n        if (a > 1 || a < -1) {\n            throw new IllegalArgumentException(\"Argument out of range: \" + a);\n        }\n\n        if (a == 1.0) {\n            return Double.POSITIVE_INFINITY;\n        }\n        if (a == -1.0) {\n            return Double.NEGATIVE_INFINITY;\n        }\n\n        double negate = false;\n        if (a < 0) {\n            a = -a;\n            negate = true;\n        }\n\n        final double a2 = a * a;\n        double result;\n        if (a > 0.167) {\n            result = FastMath.log((a + 1) / (1 - a));\n        } else {\n            if (a > 0.097) {\n                result = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2;\n            } else if (a > 0.036) {\n                result = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2;\n            } else if (a > 0.0036) {\n}\n}\n}",
      "public static double atanh(double a)  {\n    if (a > 1.0 || a < -1.0) {\n        throw new IllegalArgumentException(\"Argument out of range. Must be in the range (-1, 1)\");\n    }\n\n    boolean negate = false;\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n\n    double result;\n    if (a < 0.167) {\n        double a2 = a * a;\n        if (a > 0.097) {\n            result = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2;\n        } else if (a > 0.036) {\n            result = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.0036) {\n            result = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else {\n}\n}\n}"
    ],
    [
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_INVALID, normalizedSum);\n    }\n    double sum = 0.0;\n    int nonNaNCount = 0;\n    for (double value : values) {\n        if (!Double.isNaN(value)) {\n            sum += value;\n            ++nonNaNCount;\n        }\n    }\n    if (sum == 0.0) {\n        throw new MathArithmeticException(LocalizedFormats.SUM_ZERO);\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; ++i) {\n        if (Double.isNaN(values[i])) {\n            result[i] = values[i];\n        } else {\n            result[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n        if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_INVALID, normalizedSum);\n        }\n        double sum = 0.0;\n        int nonNaNCount = 0;\n        for (double value : values) {\n            if (!Double.isNaN(value)) {\n                sum += value;\n                ++nonNaNCount;\n            }\n        }\n        if (sum == 0.0) {\n            throw new MathArithmeticException(LocalizedFormats.SUM_ZERO);\n        }\n        double[] result = new double[values.length];\n        for (int i = 0; i < values.length; ++i) {\n            if (Double.isNaN(values[i])) {\n                result[i] = values[i];\n            } else {\n                result[i] = values[i] * normalizedSum / sum;\n            }\n        }\n        return result;\n    }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_INVALID, normalizedSum);\n    }\n\n    double sum = 0.0;\n    int nonNaNCount = 0;\n    for (double value : values) {\n        if (!Double.isNaN(value)) {\n            sum += value;\n            ++nonNaNCount;\n        }\n    }\n\n    if (sum == 0.0) {\n        throw new MathArithmeticException(LocalizedFormats.SUM_ZERO);\n    }\n\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; ++i) {\n        if (Double.isNaN(values[i])) {\n            result[i] = values[i];\n        } else {\n            result[i] = values[i] * normalizedSum / sum;\n        }\n    }\n\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    // TODO: Implement this method\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_INVALID, normalizedSum);\n    }\n\n    double sum = 0.0;\n    int nonNaNCount = 0;\n    for (double value : values) {\n        if (!Double.isNaN(value)) {\n            sum += value;\n            ++nonNaNCount;\n        }\n    }\n\n    if (sum == 0.0) {\n        throw new MathArithmeticException(LocalizedFormats.SUM_ZERO);\n    }\n\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; ++i) {\n        if (Double.isNaN(values[i])) {\n            result[i] = values[i];\n        } else {\n            result[i] = values[i] * normalizedSum / sum;\n        }\n    }\n\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n        // TODO: implement this method\n        return new double[0];\n    }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n        if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM, normalizedSum);\n        }\n\n        double sum = 0.0;\n        int count = 0;\n        for (double value : values) {\n            if (!Double.isNaN(value)) {\n                sum += value;\n                count++;\n            }\n        }\n\n        if (sum == 0.0) {\n            throw new MathArithmeticException(LocalizedFormats.SUM_ZERO);\n        }\n\n        double[] result = new double[values.length];\n        for (int i = 0; i < values.length; i++) {\n            if (Double.isNaN(values[i])) {\n                result[i] = values[i];\n            } else {\n                result[i] = values[i] * normalizedSum / sum;\n            }\n        }\n\n        return result;\n    }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    // check if the normalizedSum is NaN or infinite\n    if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM, normalizedSum);\n    }\n\n    // calculate the sum of the values array\n    double sum = 0.0;\n    for (double value : values) {\n        if (!Double.isNaN(value) && !Double.isInfinite(value)) {\n            sum += value;\n        }\n    }\n\n    // check if the sum is 0 or infinite\n    if (sum == 0.0 || Double.isInfinite(sum)) {\n        throw new MathArithmeticException(LocalizedFormats.SUM_ZERO_OR_INFINITE);\n    }\n\n    // normalize the values array\n    double[] normalizedValues = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i]) && !Double.isInfinite(values[i])) {\n            normalizedValues[i] = values[i] * normalizedSum / sum;\n        } else {\n            normalizedValues[i] = values[i];\n        }\n    }\n\n    return normalizedValues;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n        if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_INVALID, normalizedSum);\n        }\n\n        double sum = 0.0;\n        int nonNaNCount = 0;\n        for (double value : values) {\n            if (!Double.isNaN(value)) {\n                sum += value;\n                ++nonNaNCount;\n            }\n        }\n\n        if (sum == 0.0) {\n            throw new MathArithmeticException(LocalizedFormats.SUM_ZERO);\n        }\n\n        double[] result = new double[values.length];\n        for (int i = 0; i < values.length; ++i) {\n            if (Double.isNaN(values[i])) {\n                result[i] = values[i];\n            } else {\n                result[i] = values[i] * normalizedSum / sum;\n            }\n        }\n\n        return result;\n    }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n    if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM, normalizedSum);\n    }\n\n    double sum = 0.0;\n    int nonNaNCount = 0;\n    for (double value : values) {\n        if (!Double.isNaN(value)) {\n            sum += value;\n            nonNaNCount++;\n        }\n    }\n\n    if (sum == 0.0) {\n        throw new MathArithmeticException(LocalizedFormats.SUM_ZERO);\n    }\n\n    double[] normalizedValues = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            normalizedValues[i] = values[i];\n        } else {\n            normalizedValues[i] = values[i] * normalizedSum / sum;\n        }\n    }\n\n    return normalizedValues;\n}"
    ],
    [
      "public static String capitalize(final String str, final char... delimiters)  {\n    // your code here\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.length() == 0) {\n        return str;\n    }\n\n    final StringBuilder sb = new StringBuilder(str.length());\n    boolean capitalizeNext = true;\n    for (int i = 0; i < str.length(); i++) {\n        final char c = str.charAt(i);\n        if (isDelimiter(c, delimiters)) {\n            capitalizeNext = true;\n            sb.append(c);\n        } else if (capitalizeNext) {\n            sb.append(Character.toTitleCase(c));\n            capitalizeNext = false;\n        } else {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    // your code here\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n\n    if (delimiters == null || delimiters.length == 0) {\n        return Character.toTitleCase(str.charAt(0)) + str.substring(1).toLowerCase();\n    }\n\n    final StringBuilder sb = new StringBuilder(str.length());\n    boolean capitalizeNext = true;\n    for (int i = 0; i < str.length(); i++) {\n        final char c = str.charAt(i);\n        if (capitalizeNext && Character.isLetter(c)) {\n            sb.append(Character.toTitleCase(c));\n            capitalizeNext = false;\n        } else if (isDelimiter(c, delimiters)) {\n            sb.append(c);\n            capitalizeNext = true;\n        } else {\n            sb.append(c);\n        }\n    }\n\n    return sb.toString();\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    // Your code here\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    // Your code here\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n\n    if (delimiters == null || delimiters.length == 0) {\n        return Character.toTitleCase(str.charAt(0)) + str.substring(1).toLowerCase();\n    }\n\n    final StringBuilder sb = new StringBuilder(str.length());\n    boolean capitalizeNext = true;\n    for (int i = 0; i < str.length(); i++) {\n        char c = str.charAt(i);\n        if (capitalizeNext && Character.isLetter(c)) {\n            sb.append(Character.toTitleCase(c));\n            capitalizeNext = false;\n        } else if (isDelimiter(c, delimiters)) {\n            sb.append(c);\n            capitalizeNext = true;\n        } else {\n            sb.append(Character.toLowerCase(c));\n        }\n    }\n\n    return sb.toString();\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n\n    final int size = str.length();\n\n    if (size == 0) {\n        return str;\n    }\n\n    if (delimiters == null || delimiters.length == 0) {\n        return Character.toTitleCase(str.charAt(0)) + str.substring(1).toLowerCase();\n    }\n\n    final StringBuilder sb = new StringBuilder(size);\n    boolean capitalizeNext = true;\n    for (int i = 0; i < size; i++) {\n        char c = str.charAt(i);\n        if (capitalizeNext && Character.isLetter(c)) {\n            sb.append(Character.toTitleCase(c));\n            capitalizeNext = false;\n        } else if (!isDelimiter(c, delimiters)) {\n            sb.append(c);\n            capitalizeNext = false;\n        } else {\n            sb.append(c);\n            capitalizeNext = true;\n        }\n    }\n\n    return sb.toString();\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n\n    final int strLen = str.length();\n    final StringBuilder sb = new StringBuilder(strLen);\n    boolean capitalizeNext = true;\n\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n            sb.append(ch);\n        } else if (capitalizeNext) {\n            sb.append(Character.toTitleCase(ch));\n            capitalizeNext = false;\n        } else {\n            sb.append(ch);\n        }\n    }\n\n    return sb.toString();\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    // Your code goes here\n}"
    ],
    [
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n        \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n        \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n        \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  throws UnsupportedOperationException, IllegalArgumentException {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(null);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                MutableDateTime dt = new MutableDateTime(millis, chrono);\n                if (iZone != null) {\n                    dt = dt.withZone(iZone);\n                }\n                return dt;\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  throws UnsupportedOperationException, IllegalArgumentException {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(null);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                MutableDateTime dt = new MutableDateTime(millis, chrono);\n                if (iZone != null) {\n                    dt = dt.withZone(iZone);\n                }\n                return dt;\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n        \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  throws UnsupportedOperationException, IllegalArgumentException {\n    DateTimeParser parser = requireParser();\n        \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}"
    ],
    [
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix X = getX();\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealVector y = getY();\n\n        RealMatrix XTransposeTimesOmegaInverseX = X.transpose().multiply(OmegaInverse.multiply(X));\n        RealMatrix XTransposeTimesOmegaInverse = X.transpose().multiply(OmegaInverse);\n\n        try {\n            return XTransposeTimesOmegaInverseX.solve(XTransposeTimesOmegaInverse.multiply(y));\n        } catch (NonInvertibleMatrixException e) {\n            throw new MathIllegalStateException(\"The matrix (X' * Omega^-1 * X) is not invertible.\", e);\n        }\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix X = getX();\n        RealVector y = getY();\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealMatrix XTransposeTimesOmegaInverse = X.transpose().multiply(OmegaInverse);\n        RealMatrix XTransposeTimesOmegaInverseXT = XTransposeTimesOmegaInverse.multiply(X);\n        RealVector beta = XTransposeTimesOmegaInverse.multiply(y).subtract(XTransposeTimesOmegaInverseXT.getInverse().multiply(y));\n        return beta;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix X = getX();\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealVector y = getY();\n        RealMatrix XTransposeTimesOmegaInverse = X.transpose().multiply(OmegaInverse);\n        RealMatrix XTransposeTimesOmegaInverseXT = XTransposeTimesOmegaInverse.multiply(X);\n        RealVector beta = XTransposeTimesOmegaInverse.multiply(X.transpose().multiply(y));\n        return beta;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix X = getXMatrix();\n        RealVector y = getYVector();\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealMatrix XTransposeTimesOmegaInverse = X.transpose().multiply(OmegaInverse);\n        RealMatrix XTransposeTimesOmegaInverseXT = XTransposeTimesOmegaInverse.multiply(X);\n        RealVector beta = XTransposeTimesOmegaInverse.multiply(y).subtract(XTransposeTimesOmegaInverseXT.getSolve(y));\n        return beta;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix X = getXMatrix();\n        RealVector y = getYVector();\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealMatrix XTransposeTimesOmegaInverse = X.transpose().multiply(OmegaInverse);\n        RealMatrix XTransposeTimesOmegaInverseXT = XTransposeTimesOmegaInverse.multiply(X);\n        RealVector beta = XTransposeTimesOmegaInverse.multiply(y).subtract(XTransposeTimesOmegaInverseXT.getSolve(y));\n        return beta;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix X = getX();\n        RealVector Y = getY();\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealMatrix XTranspose = X.transpose();\n        RealMatrix product1 = XTranspose.multiply(OmegaInverse);\n        RealMatrix product2 = product1.multiply(X);\n        RealMatrix inverseProduct2 = product2.solve(XTranspose);\n        RealVector beta = inverseProduct2.multiply(OmegaInverse).multiply(Y);\n        return beta;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix X = getXMatrix();\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealVector y = getYVector();\n        RealMatrix term1 = X.transpose().multiply(OmegaInverse).multiply(X);\n        RealMatrix term2 = X.transpose().multiply(OmegaInverse).multiply(y);\n        try {\n            return term1.solve(term2);\n        } catch (NonInvertibleMatrixException e) {\n            throw new MathIllegalStateException(\"Covariance matrix is not invertible\", e);\n        }\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix X = getXMatrix();\n        RealVector y = getYVector();\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealMatrix XTransposeTimesOmegaInverse = X.transpose().multiply(OmegaInverse);\n        RealMatrix XTransposeTimesOmegaInverseXT = XTransposeTimesOmegaInverse.multiply(X);\n        RealVector beta = XTransposeTimesOmegaInverse.multiply(y).subtract(XTransposeTimesOmegaInverseXT.getSolve(y));\n        return beta;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix X = getXMatrix();\n        RealMatrix XTranspose = X.transpose();\n        RealVector y = getYVector();\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealMatrix temp = XTranspose.multiply(OmegaInverse).multiply(X);\n        RealMatrix betaMatrix = temp.solve(XTranspose.multiply(OmegaInverse).multiply(y));\n        return betaMatrix.getRowVector(0);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix X = getXMatrix();\n        RealVector y = getYVector();\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealMatrix XTransposeTimesOmegaInverse = X.transpose().multiply(OmegaInverse);\n        RealMatrix XTransposeTimesOmegaInverseXT = XTransposeTimesOmegaInverse.multiply(X);\n        RealVector beta = XTransposeTimesOmegaInverse.multiply(y).subtract(XTransposeTimesOmegaInverseXT.getInverse().multiply(y));\n        return beta;\n    }"
    ],
    [
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    return Collector.collect(new Evaluator.Id(normalize(id)), this).first();\n}",
      "public Element getElementById(String id)  {\n        Validate.notEmpty(id);\n        return Collector.collect(new Evaluator.Id(normalize(id)), this).get(0);\n    }",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    return getElementsByAttributeValue(\"id\", id).first();\n}",
      "public Element getElementById(String id)  {\n        Validate.notEmpty(id);\n        return Collector.collect(new Evaluator.Id(id), this).first();\n    }",
      "public Element getElementById(String id)  {\n        Validate.notEmpty(id);\n        return Collector.collect(new Evaluator.Id(id), this).first();\n    }",
      "public Element getElementById(String id)  {\n        Validate.notEmpty(id);\n        return Collector.collect(new Evaluator.Id(normalize(id)), this).first();\n    }",
      "public Element getElementById(String id)  {\n        Validate.notEmpty(id);\n        return Collector.collect(new Evaluator.Id(normalize(id)), this).first();\n    }",
      "public Element getElementById(String id)  {\n        Validate.notEmpty(id);\n        return Collector.collect(new Evaluator.Id(id), this).first();\n    }",
      "public Element getElementById(String id)  {\n        Validate.notEmpty(id);\n        return Collector.collect(new Evaluator.Id(id), this).first();\n    }",
      "public Element getElementById(String id)  {\n        Validate.notEmpty(id);\n        return Collector.collect(new Evaluator.Id(id), this).first();\n    }"
    ],
    [
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder();\n    ParsePosition pos = new ParsePosition(0);\n    while (pos.getIndex() < pattern.length()) \n    {\n        result.append(pattern.substring(pos.getIndex()));\n        if (pattern.charAt(pos.getIndex()) == START_FMT) \n        {\n            pos.setIndex(pos.getIndex() + 1);\n            int index = readArgumentIndex(pattern, pos);\n            String formatDesc = parseFormatDescription(pattern, pos);\n            if (index < customPatterns.size()) \n            {\n                result.append(customPatterns.get(index));\n            }\n            else \n            {\n                result.append(formatDesc);\n            }\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder();\n    ParsePosition pos = new ParsePosition(0);\n    while (pos.getIndex() < pattern.length()) \n    {\n        result.append(parseFormatDescription(pattern, pos));\n        pos.setIndex(pos.getIndex() + 1);\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder();\n    ParsePosition pos = new ParsePosition(0);\n    while (pos.getIndex() < pattern.length()) \n    {\n        if (pattern.charAt(pos.getIndex()) == START_FMT) \n        {\n            pos.setIndex(pos.getIndex() + 1);\n            int argIndex = readArgumentIndex(pattern, pos);\n            String formatDesc = parseFormatDescription(pattern, pos);\n            if (argIndex < customPatterns.size()) \n            {\n                result.append(customPatterns.get(argIndex));\n            } \n            else \n            {\n                result.append(formatDesc);\n            }\n        } \n        else \n        {\n            result.append(pattern.charAt(pos.getIndex()));\n            pos.setIndex(pos.getIndex() + 1);\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder();\n    ParsePosition pos = new ParsePosition(0);\n    while (pos.getIndex() < pattern.length()) \n    {\n        int start = pos.getIndex();\n        seekNonWs(pattern, pos);\n        if (pos.getIndex() < pattern.length() && pattern.charAt(pos.getIndex()) == START_FMT) \n        {\n            int index = readArgumentIndex(pattern, pos);\n            if (index < customPatterns.size()) \n            {\n                result.append(customPatterns.get(index));\n            } \n            else \n            {\n                throw new IllegalArgumentException(\"Invalid format argument index: \" + index);\n            }\n        } \n        else \n        {\n            result.append(pattern.substring(start, pos.getIndex()));\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder();\n    ParsePosition pos = new ParsePosition(0);\n    while (pos.getIndex() < pattern.length()) \n    {\n        int start = pos.getIndex();\n        seekNonWs(pattern, pos);\n        if (pattern.charAt(pos.getIndex()) == START_FMT) \n        {\n            int argIndex = readArgumentIndex(pattern, pos);\n            if (argIndex < customPatterns.size()) \n            {\n                result.append(customPatterns.get(argIndex));\n            } \n            else \n            {\n                throw new IllegalArgumentException(\"Invalid format argument index at position \" + start + \": \" + pattern.substring(start, pos.getIndex()));\n            }\n        } \n        else \n        {\n            result.append(pattern.substring(start, pos.getIndex()));\n            next(pos);\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder();\n    ParsePosition pos = new ParsePosition(0);\n    while (pos.getIndex() < pattern.length()) \n    {\n        int start = pos.getIndex();\n        if (pattern.charAt(start) != '%') \n        {\n            result.append(pattern.charAt(start));\n            pos.setIndex(start + 1);\n            continue;\n        }\n        int end = pattern.indexOf(\"%\", start + 1);\n        if (end < 0) \n        {\n            result.append('%');\n            pos.setIndex(start + 1);\n            continue;\n        }\n        String element = pattern.substring(start + 1, end);\n        if (element.isEmpty()) \n        {\n            result.append('%');\n            pos.setIndex(end + 1);\n            continue;\n        }\n        if (element.charAt(0) == '#') \n        {\n            int index = readArgumentIndex(element, pos);\n            if (index < customPatterns.size()) \n            {\n                result.append(customPatterns.get(index));\n                pos.setIndex(end + 1);\n                continue;\n            }\n        }\n        result.append('%').append(element);\n        pos.setIndex(end + 1);\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder();\n    ParsePosition pos = new ParsePosition(0);\n    while (pos.getIndex() < pattern.length()) \n    {\n        result.append(pattern.substring(pos.getIndex()));\n        if (pos.getErrorIndex() != -1) \n        {\n            throw new IllegalArgumentException(\"Invalid format at position \" + pos.getErrorIndex());\n        }\n        if (pos.getIndex() >= pattern.length()) \n        {\n            break;\n        }\n        char c = pattern.charAt(pos.getIndex());\n        if (c != START_FMT) \n        {\n            pos.setIndex(pos.getIndex() + 1);\n            continue;\n        }\n        pos.setIndex(pos.getIndex() + 1);\n        String formatDesc = parseFormatDescription(pattern, pos);\n        int argIndex = readArgumentIndex(pattern, pos);\n        if (argIndex >= customPatterns.size()) \n        {\n            throw new IllegalArgumentException(\"Invalid format argument index \" + argIndex);\n        }\n        result.append(customPatterns.get(argIndex));\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder fullPattern = new StringBuilder(pattern);\n    if (customPatterns != null) \n    {\n        for (int i = 0; i < customPatterns.size(); i++) \n        {\n            fullPattern.insert(pattern.length() + i, customPatterns.get(i));\n        }\n    }\n    return fullPattern.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder();\n    ParsePosition pos = new ParsePosition(0);\n    while (pos.getIndex() < pattern.length()) \n    {\n        int start = pos.getIndex();\n        if (pattern.charAt(start) == START_FMT) \n        {\n            int argIndex = readArgumentIndex(pattern, pos);\n            if (argIndex < customPatterns.size()) \n            {\n                result.append(customPatterns.get(argIndex));\n            } \n            else \n            {\n                throw new IllegalArgumentException(\"Invalid format argument index \" + argIndex);\n            }\n        } \n        else \n        {\n            result.append(pattern.substring(start));\n            break;\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder fullPattern = new StringBuilder();\n    int index = 0;\n    int customIndex = 0;\n    while (index < pattern.length()) \n    {\n        if (pattern.charAt(index) == '%') \n        {\n            if (customIndex < customPatterns.size()) \n            {\n                fullPattern.append(customPatterns.get(customIndex));\n                customIndex++;\n            }\n            else \n            {\n                fullPattern.append('%');\n            }\n            index++;\n        } \n        else \n        {\n            fullPattern.append(pattern.charAt(index));\n            index++;\n        }\n    }\n    return fullPattern.toString();\n}"
    ],
    [
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n      if (fromArg instanceof TypeVariable<?>) {\n        fromArg = typeVarMap.get(fromArg.getTypeName());\n      }\n      if (toArg instanceof TypeVariable<?>) {\n        toArg = typeVarMap.get(toArg.getTypeName());\n      }\n      if (!isAssignableFrom(fromArg, toArg)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n\n      if (fromArg instanceof TypeVariable<?>) {\n        Type replacement = typeVarMap.get(fromArg.getTypeName());\n        if (replacement != null) {\n          fromArg = replacement;\n        }\n      }\n\n      if (toArg instanceof TypeVariable<?>) {\n        Type replacement = typeVarMap.get(toArg.getTypeName());\n        if (replacement != null) {\n          toArg = replacement;\n        }\n      }\n\n      if (!fromArg.equals(toArg)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n\n      if (!isAssignableFrom(fromArg, toArg, typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from == null || to == null) {\n      return false;\n    }\n\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n\n      while (fromArg instanceof TypeVariable<?>) {\n        fromArg = typeVarMap.get(fromArg.getTypeName());\n      }\n\n      while (toArg instanceof TypeVariable<?>) {\n        toArg = typeVarMap.get(toArg.getTypeName());\n      }\n\n      if (!isAssignableFrom(fromArg, toArg)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n        return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n\n    if (fromArgs.length != toArgs.length) {\n        return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n        Type fromArg = fromArgs[i];\n        Type toArg = toArgs[i];\n\n        if (fromArg instanceof TypeVariable<?>) {\n            fromArg = typeVarMap.get(fromArg.getTypeName());\n        }\n\n        if (toArg instanceof TypeVariable<?>) {\n            toArg = typeVarMap.get(toArg.getTypeName());\n        }\n\n        if (!fromArg.equals(toArg)) {\n            return false;\n        }\n    }\n\n    return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from == to) {\n        return true;\n    }\n\n    if (from.getRawType() != to.getRawType()) {\n        return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n\n    if (fromArgs.length != toArgs.length) {\n        return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n        Type fromArg = fromArgs[i];\n        Type toArg = toArgs[i];\n\n        while (fromArg instanceof TypeVariable<?>) {\n            fromArg = typeVarMap.get(fromArg.getTypeName());\n        }\n\n        while (toArg instanceof TypeVariable<?>) {\n            toArg = typeVarMap.get(toArg.getTypeName());\n        }\n\n        if (!isAssignableFrom(fromArg, toArg)) {\n            return false;\n        }\n    }\n\n    return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n      while (fromArg instanceof TypeVariable<?>) {\n        fromArg = typeVarMap.get(fromArg.getTypeName());\n      }\n      while (toArg instanceof TypeVariable<?>) {\n        toArg = typeVarMap.get(toArg.getTypeName());\n      }\n      if (!isAssignableFrom(fromArg, toArg)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n\n      while (fromArg instanceof TypeVariable<?>) {\n        fromArg = typeVarMap.get(fromArg.getTypeName());\n      }\n\n      while (toArg instanceof TypeVariable<?>) {\n        toArg = typeVarMap.get(toArg.getTypeName());\n      }\n\n      if (!fromArg.equals(toArg)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from == null || to == null) {\n        return false;\n    }\n\n    if (from.getRawType() != to.getRawType()) {\n        return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n\n    if (fromArgs.length != toArgs.length) {\n        return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n        Type fromArg = fromArgs[i];\n        Type toArg = toArgs[i];\n\n        while (fromArg instanceof TypeVariable<?>) {\n            fromArg = typeVarMap.get(fromArg.getTypeName());\n        }\n\n        while (toArg instanceof TypeVariable<?>) {\n            toArg = typeVarMap.get(toArg.getTypeName());\n        }\n\n        if (!fromArg.equals(toArg)) {\n            return false;\n        }\n    }\n\n    return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from == to) {\n        return true;\n    }\n\n    if (from.getRawType() != to.getRawType()) {\n        return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n\n    if (fromArgs.length != toArgs.length) {\n        return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n        Type fromArg = fromArgs[i];\n        Type toArg = toArgs[i];\n\n        while (fromArg instanceof TypeVariable<?>) {\n            fromArg = typeVarMap.get(fromArg.getTypeName());\n        }\n\n        while (toArg instanceof TypeVariable<?>) {\n            toArg = typeVarMap.get(toArg.getTypeName());\n        }\n\n        if (!typeEquals((ParameterizedType) fromArg, (ParameterizedType) toArg, typeVarMap)) {\n            return false;\n        }\n    }\n\n    return true;\n}"
    ],
    [
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) \n    {\n        return iterator;\n    } \n    else \n    {\n        return new UnmodifiableIterator<E>(iterator);\n    }\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) \n    {\n        return iterator;\n    } \n    else \n    {\n        return new UnmodifiableIterator<E>(iterator);\n    }\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) \n    {\n        return iterator;\n    } \n    else \n    {\n        return new UnmodifiableIterator<>(iterator);\n    }\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) \n    {\n        return iterator;\n    } \n    else \n    {\n        return new UnmodifiableIterator<E>(iterator);\n    }\n}"
    ],
    [
      "public N getPartitionSuperNode(N node)  {\n    Preconditions.checkArgument(graph.containsNode(node), \"Node not in graph.\");\n    return colorToNodeMap[node.getAnnotation().getColor()];\n  }",
      "public N getPartitionSuperNode(N node)  {\n    Preconditions.checkArgument(graph.containsNode(node), \"Node is not in the graph.\");\n    N[] colorToNodeMap = this.colorToNodeMap;\n    for (int i = 0; i < colorToNodeMap.length; i++) {\n        if (colorToNodeMap[i] == node) {\n            return colorToNodeMap[i];\n        }\n    }\n    return null;\n}",
      "public N getPartitionSuperNode(N node)  {\n    Preconditions.checkArgument(graph.containsNode(node), \"Node not in graph\");\n    return colorToNodeMap[node.getColor()];\n  }",
      "public N getPartitionSuperNode(N node)  {\n    Preconditions.checkArgument(graph.containsNode(node), \"Node not in graph.\");\n    N superNode = colorToNodeMap[(int) graph.getNode(node).getAnnotation()];\n    return superNode;\n  }",
      "public N getPartitionSuperNode(N node)  {\n    Preconditions.checkArgument(graph.containsNode(node), \"Node does not exist in graph.\");\n    GraphNode<N, E> graphNode = graph.getNode(node);\n    Annotation<N> annotation = graphNode.getAnnotation();\n    if (annotation == null) {\n      throw new IllegalStateException(\"Node has not been annotated.\");\n    }\n    return annotation.getColor();\n  }",
      "public N getPartitionSuperNode(N node)  {\n    return colorToNodeMap[graph.getNode(node).getAnnotation()];\n  }",
      "public N getPartitionSuperNode(N node)  {\n    Preconditions.checkArgument(graph.containsNode(node), \"Node not in graph\");\n    GraphNode<N, E> graphNode = graph.getNode(node);\n    Annotation colorAnnotation = graphNode.getAnnotation();\n    if (colorAnnotation instanceof Color) {\n      Color color = (Color) colorAnnotation;\n      return colorToNodeMap[color.ordinal()];\n    } else {\n      throw new IllegalStateException(\"Node not colored: \" + node);\n    }\n  }",
      "public N getPartitionSuperNode(N node)  {\n    return colorToNodeMap[graph.getNode(node).getAnnotation().getColor()];\n}",
      "public N getPartitionSuperNode(N node)  {\n    N superNode = null;\n    for (GraphNode<N, E> graphNode : graph.nodes()) {\n        if (graphNode.getData().equals(node)) {\n            superNode = (N) graphNode.getAnnotation();\n            break;\n        }\n    }\n    return superNode;\n}",
      "public N getPartitionSuperNode(N node)  {\n    return colorToNodeMap[graph.getNode(node).getAnnotation()];\n}"
    ],
    [
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n        List<Integer> nanPositions = new ArrayList<>();\n        for (int i = 0; i < ranks.length; i++) {\n            if (Double.isNaN(ranks[i].getValue())) {\n                nanPositions.add(i);\n            }\n        }\n        return nanPositions;\n    }",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n        List<Integer> nanPositions = new ArrayList<>();\n        for (int i = 0; i < ranks.length; i++) {\n            if (Double.isNaN(ranks[i].getValue())) {\n                nanPositions.add(i);\n            }\n        }\n        return nanPositions;\n    }",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n        List<Integer> nanPositions = new ArrayList<>();\n        for (int i = 0; i < ranks.length; i++) {\n            if (Double.isNaN(ranks[i].getValue())) {\n                nanPositions.add(i);\n            }\n        }\n        return nanPositions;\n    }",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n        List<Integer> nanPositions = new ArrayList<>();\n        for (int i = 0; i < ranks.length; i++) {\n            if (Double.isNaN(ranks[i].getValue())) {\n                nanPositions.add(i);\n            }\n        }\n        return nanPositions;\n    }",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n        List<Integer> nanPositions = new ArrayList<>();\n        for (int i = 0; i < ranks.length; i++) {\n            if (Double.isNaN(ranks[i].getValue())) {\n                nanPositions.add(i);\n            }\n        }\n        return nanPositions;\n    }",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n        List<Integer> nanPositions = new ArrayList<>();\n        for (int i = 0; i < ranks.length; i++) {\n            if (Double.isNaN(ranks[i].getValue())) {\n                nanPositions.add(i);\n            }\n        }\n        return nanPositions;\n    }",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n        List<Integer> nanPositions = new ArrayList<>();\n        for (int i = 0; i < ranks.length; i++) {\n            if (Double.isNaN(ranks[i].getValue())) {\n                nanPositions.add(i);\n            }\n        }\n        return nanPositions;\n    }",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n        List<Integer> nanPositions = new ArrayList<>();\n        for (int i = 0; i < ranks.length; i++) {\n            if (Double.isNaN(ranks[i].getValue())) {\n                nanPositions.add(i);\n            }\n        }\n        return nanPositions;\n    }",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}"
    ],
    [
      "public double integrate(UnivariateFunction f)  {\n    double result = 0.0;\n    for (int i = 0; i < points.length; i++) {\n        result += weights[i] * f.value(points[i]);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0.0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0.0;\n    for (int i = 0; i < points.length; i++) {\n        result += weights[i] * f.value(points[i]);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0.0;\n    for (int i = 0; i < points.length; i++) {\n        result += weights[i] * f.value(points[i]);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0.0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0.0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0.0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0.0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0.0;\n    for (int i = 0; i < points.length; i++) {\n        result += weights[i] * f.value(points[i]);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0.0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}"
    ],
    [
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) {\n        return true;\n    }\n    if ((map1 == null) || (map2 == null)) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Iterator iterator = map1.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Comparable key = (Comparable) entry.getKey();\n        Paint value1 = (Paint) entry.getValue();\n        Paint value2 = (Paint) map2.get(key);\n        if ((value1 == null) || (value2 == null)) {\n            return false;\n        }\n        if (!value1.equals(value2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size())\n        return false;\n\n    Iterator iterator1 = map1.entrySet().iterator();\n    while (iterator1.hasNext()) \n    {\n        Map.Entry pair = (Map.Entry)iterator1.next();\n        Comparable key = (Comparable) pair.getKey();\n        Paint value1 = (Paint) pair.getValue();\n        Paint value2 = (Paint) map2.get(key);\n        if (value1 == null || value2 == null || !value1.equals(value2))\n            return false;\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) {\n        return true;\n    }\n    if ((map1 == null) || (map2 == null)) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n\n    Iterator iterator = map1.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Comparable key = (Comparable) entry.getKey();\n        Paint value1 = (Paint) entry.getValue();\n        Paint value2 = (Paint) map2.get(key);\n        if (value2 == null || !value1.equals(value2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) \n    {\n        return true;\n    }\n\n    if ((map1 == null) || (map2 == null)) \n    {\n        return false;\n    }\n\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n\n    Iterator iterator = map1.entrySet().iterator();\n    while (iterator.hasNext()) \n    {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Comparable key = (Comparable) entry.getKey();\n        Paint value1 = (Paint) entry.getValue();\n        Paint value2 = (Paint) map2.get(key);\n\n        if (value2 == null || !value1.equals(value2)) \n        {\n            return false;\n        }\n    }\n\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) {\n        return true;\n    }\n    if ((map1 == null) || (map2 == null)) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Iterator iterator = map1.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Comparable key = (Comparable) entry.getKey();\n        Paint value1 = (Paint) entry.getValue();\n        Paint value2 = (Paint) map2.get(key);\n        if (value2 == null || !value1.equals(value2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if(map1.size() != map2.size())\n        return false;\n\n    Iterator iterator1 = map1.entrySet().iterator();\n    while(iterator1.hasNext()) \n    {\n        Map.Entry pair1 = (Map.Entry)iterator1.next();\n        Comparable key1 = (Comparable)pair1.getKey();\n        Paint value1 = (Paint)pair1.getValue();\n\n        Paint value2 = (Paint)map2.get(key1);\n        if(value2 == null || !value1.equals(value2))\n            return false;\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) {\n        return true;\n    }\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n\n    Iterator iterator = map1.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Comparable key = (Comparable) entry.getKey();\n        Paint value1 = (Paint) entry.getValue();\n        Paint value2 = (Paint) map2.get(key);\n        if (value1 == null || value2 == null || !value1.equals(value2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) \n    {\n        return true;\n    }\n    if (map1 == null || map2 == null) \n    {\n        return false;\n    }\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n\n    Iterator iterator1 = map1.entrySet().iterator();\n    while (iterator1.hasNext()) \n    {\n        Map.Entry entry1 = (Map.Entry) iterator1.next();\n        Comparable key1 = (Comparable) entry1.getKey();\n        Paint value1 = (Paint) entry1.getValue();\n\n        Paint value2 = (Paint) map2.get(key1);\n        if (value2 == null || !value1.equals(value2)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size())\n        return false;\n\n    Iterator iterator = map1.entrySet().iterator();\n    while (iterator.hasNext()) \n    {\n        Map.Entry pair = (Map.Entry)iterator.next();\n        Comparable key = (Comparable) pair.getKey();\n        Paint value1 = (Paint) pair.getValue();\n        Paint value2 = (Paint) map2.get(key);\n        if (value1 == null || value2 == null || !value1.equals(value2))\n            return false;\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) {\n        return true;\n    }\n    if ((map1 == null) || (map2 == null)) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Iterator iterator = map1.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Comparable key = (Comparable) entry.getKey();\n        Paint value1 = (Paint) entry.getValue();\n        Paint value2 = (Paint) map2.get(key);\n        if (value1 == null) {\n            if (value2 != null) {\n                return false;\n            }\n        }\n        else if (!value1.equals(value2)) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) \n    {\n        String str = expr.getString();\n        String replacement = shortenString(str);\n        if (replacement != null) \n        {\n            Node newExpr = t.getNode(replacement);\n            t.replaceChild(parent, expr, newExpr);\n            return newExpr;\n        }\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) \n    {\n        String str = expr.getString();\n        String replacement = encodeString(str);\n        Node newNode = t.getNodeFactory().newString(replacement);\n        replaceChild(t, parent, expr, newNode);\n        return newNode;\n    } \n    else \n    {\n        return expr;\n    }\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) \n    {\n        String str = expr.getString();\n        String replacement = encode(str);\n        Node replacementNode = t.getNodeFactory().newStringLiteral(replacement);\n        t.replace(parent, expr, replacementNode);\n        return replacementNode;\n    } \n    else \n    {\n        return expr;\n    }\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) \n    {\n        String originalString = expr.getString();\n        String encodedString = encodeString(originalString);\n        Node newExpr = t.getNodeFactory().newStringLiteral(encodedString);\n        t.replaceChild(parent, expr, newExpr);\n        return newExpr;\n    } \n    else \n    {\n        return expr;\n    }\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) \n    {\n        String str = expr.getString();\n        String encoded = encode(str);\n        Node replacement = t.getNodeFactory().newStringLiteral(encoded);\n        parent.replaceChild(expr, replacement);\n        return replacement;\n    } \n    else \n    {\n        return expr;\n    }\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) \n    {\n        String str = expr.getString();\n        String replacement = encodeString(str);\n        Node replacementNode = t.getNodeFactory().newStringLiteral(replacement);\n        t.replace(parent, expr, replacementNode);\n        return replacementNode;\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) \n    {\n        String originalString = expr.getString();\n        String newString = shortenString(originalString);\n        if (!originalString.equals(newString)) \n        {\n            t.replace(parent, expr, t.createStringLiteral(newString));\n        }\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) \n    {\n        String str = expr.getString();\n        String encodedStr = encodeString(str);\n        Node replacement = t.getNodeFactory().newString(encodedStr);\n        t.replace(parent, expr, replacement);\n        return replacement;\n    } \n    else \n    {\n        return expr;\n    }\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) \n    {\n        String str = expr.getString();\n        String replacement = encode(str);\n        Node newExpr = t.createString(replacement);\n        t.replaceChild(parent, expr, newExpr);\n        return newExpr;\n    } \n    else \n    {\n        return expr;\n    }\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) \n    {\n        String str = expr.getString();\n        String encoded = encode(str);\n        Node replacement = t.getNodeFactory().newStringLiteral(encoded);\n        parent.replaceChild(expr, replacement);\n        return replacement;\n    } \n    else \n    {\n        return expr;\n    }\n}"
    ],
    [
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}"
    ],
    [
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    Node jsDocNode = node.getFirstChild();\n    if (jsDocNode != null && jsDocNode.isJsDoc()) {\n        Node descNode = jsDocNode.getFirstChild();\n        while (descNode != null) {\n            if (descNode.isTag() && descNode.getString().equals(\"@desc\")) {\n                Node valueNode = descNode.getNext();\n                String desc = extractStringFromStringExprNode(valueNode);\n                if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n                    builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n                    builder.setIsHidden(true);\n                } else {\n                    builder.setDesc(desc);\n                }\n                return true;\n            }\n            descNode = descNode.getNext();\n        }\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    if (node.isJsDoc()) {\n      Node jsDocNode = node.getFirstChild();\n      while (jsDocNode != null) {\n        if (jsDocNode.isTag(\"desc\")) {\n          Node descNode = jsDocNode.getFirstChild();\n          if (descNode != null) {\n            String desc = extractStringFromStringExprNode(descNode);\n            if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n              builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n              builder.setIsHidden(true);\n            } else {\n              builder.setDesc(desc);\n            }\n            return true;\n          }\n        }\n        jsDocNode = jsDocNode.getNext();\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    Node childNode = node.getFirstChild();\n    while (childNode != null) {\n      if (childNode.isString()) {\n        String jsDoc = childNode.getString();\n        if (jsDoc.startsWith(JSDOC_DESC_PREFIX)) {\n          builder.setDesc(jsDoc.substring(JSDOC_DESC_PREFIX.length()).trim());\n          return true;\n        }\n      }\n      childNode = childNode.getNext();\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    if (node.isJsDoc()) {\n      Node commentNode = node.getFirstChild();\n      while (commentNode != null) {\n        if (commentNode.isTag()) {\n          Node tagNameNode = commentNode.getFirstChild();\n          String tagName = tagNameNode.getString();\n          if (tagName.equals(\"desc\")) {\n            Node valueNode = tagNameNode.getNext();\n            String desc = extractStringFromStringExprNode(valueNode);\n            if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n              builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n              builder.setIsHidden(true);\n            } else {\n              builder.setDesc(desc);\n            }\n            return true;\n          }\n        }\n        commentNode = commentNode.getNext();\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    Node child = node.getFirstChild();\n    while (child != null) {\n        if (child.isString()) {\n            String value = child.getString();\n            if (value.startsWith(\"@desc\")) {\n                String desc = value.substring(\"@desc\".length()).trim();\n                if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n                    builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n                    builder.setIsHidden(true);\n                } else {\n                    builder.setDesc(desc);\n                }\n                return true;\n            }\n        }\n        child = child.getNext();\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    if (node.isJsDoc()) {\n      JsDoc jsDoc = (JsDoc) node;\n      for (JsDocTag tag : jsDoc.getTags()) {\n        if (tag.getName().equals(\"desc\")) {\n          String desc = tag.getValue();\n          if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n            builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n            builder.setIsHidden(true);\n          } else {\n            builder.setDesc(desc);\n          }\n          return true;\n        }\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    Node jsDocNode = node.getFirstChild();\n    if (jsDocNode != null && jsDocNode.isJsDoc()) {\n      Node descNode = jsDocNode.getFirstChild();\n      while (descNode != null) {\n        if (descNode.isTag() && descNode.getString().equals(\"@desc\")) {\n          Node valueNode = descNode.getNext();\n          if (valueNode != null && valueNode.isStringExpr()) {\n            String desc = extractStringFromStringExprNode(valueNode);\n            if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n              builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n              builder.setIsHidden(true);\n            } else {\n              builder.setDesc(desc);\n            }\n            return true;\n          }\n        }\n        descNode = descNode.getNext();\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    Node child = node.getFirstChild();\n    while (child != null) {\n        if (child.isJsDoc()) {\n            String tagName = child.getString();\n            if (tagName.equals(\"desc\")) {\n                Node valueNode = child.getNext();\n                String desc = extractStringFromStringExprNode(valueNode);\n                if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n                    builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n                    builder.setIsHidden(true);\n                } else {\n                    builder.setDesc(desc);\n                }\n                return true;\n            }\n        }\n        child = child.getNext();\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    Node docNode = node.getFirstChild();\n    if (docNode != null && docNode.isJsDoc()) {\n      String desc = JsDocParser.getDescription(docNode);\n      if (desc != null) {\n        if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n          builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n          builder.setIsHidden(true);\n        } else {\n          builder.setDesc(desc);\n        }\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    if (node.isJsDoc()) {\n      Node jsDocNode = node.getFirstChild();\n      while (jsDocNode != null) {\n        Node tagNameNode = jsDocNode.getFirstChild();\n        if (tagNameNode != null && tagNameNode.isName() &&\n            tagNameNode.getString().equals(\"desc\")) {\n          Node descNode = tagNameNode.getNext();\n          if (descNode != null && descNode.isString()) {\n            String desc = descNode.getString();\n            if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n              builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n              builder.setIsHidden(true);\n            } else {\n              builder.setDesc(desc);\n            }\n            return true;\n          }\n        }\n        jsDocNode = jsDocNode.getNext();\n      }\n    }\n    return false;\n  }"
    ],
    [
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int changes = 0;\n    for (int i = 0; i < points.size(); i++) {\n        T point = (T) points.toArray()[i];\n        int oldAssignment = assignments[i];\n        double bestDistance = Double.POSITIVE_INFINITY;\n        int bestCluster = 0;\n        for (int j = 0; j < clusters.size(); j++) {\n            double distance = clusters.get(j).getCenter().distance(point);\n            if (distance < bestDistance) {\n                bestDistance = distance;\n                bestCluster = j;\n            }\n        }\n        if (oldAssignment != bestCluster) {\n            assignments[i] = bestCluster;\n            clusters.get(oldAssignment).removePoint(point);\n            clusters.get(bestCluster).addPoint(point);\n            changes++;\n        }\n    }\n    return changes;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int changes = 0;\n        for (int i = 0; i < points.size(); i++) {\n            T point = (T) points.toArray()[i];\n            double bestDistance = Double.POSITIVE_INFINITY;\n            int bestCluster = 0;\n            for (int j = 0; j < clusters.size(); j++) {\n                double distance = clusters.get(j).getCenter().distance(point);\n                if (distance < bestDistance) {\n                    bestDistance = distance;\n                    bestCluster = j;\n                }\n            }\n            if (assignments[i] != bestCluster) {\n                changes++;\n                assignments[i] = bestCluster;\n            }\n        }\n        return changes;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int changes = 0;\n        for (int i = 0; i < points.size(); i++) {\n            T point = (T) points.toArray()[i];\n            double bestDistance = Double.POSITIVE_INFINITY;\n            int bestCluster = 0;\n            for (int j = 0; j < clusters.size(); j++) {\n                double distance = clusters.get(j).getCenter().distance(point);\n                if (distance < bestDistance) {\n                    bestDistance = distance;\n                    bestCluster = j;\n                }\n            }\n            if (assignments[i] != bestCluster) {\n                changes++;\n                assignments[i] = bestCluster;\n            }\n        }\n        return changes;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int changes = 0;\n        for (int i = 0; i < points.size(); i++) {\n            T point = (T) points.toArray()[i];\n            double bestDistance = Double.POSITIVE_INFINITY;\n            int bestCluster = 0;\n            for (int j = 0; j < clusters.size(); j++) {\n                double distance = clusters.get(j).getCenter().distance(point);\n                if (distance < bestDistance) {\n                    bestDistance = distance;\n                    bestCluster = j;\n                }\n            }\n            if (assignments[i] != bestCluster) {\n                changes++;\n                assignments[i] = bestCluster;\n            }\n        }\n        return changes;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int changes = 0;\n    int index = 0;\n    for (T point : points) {\n        int oldAssignment = assignments[index];\n        double bestDistance = Double.POSITIVE_INFINITY;\n        int bestCluster = 0;\n        for (int i = 0; i < clusters.size(); i++) {\n            double distance = clusters.get(i).getCenter().distance(point);\n            if (distance < bestDistance) {\n                bestDistance = distance;\n                bestCluster = i;\n            }\n        }\n        if (oldAssignment != bestCluster) {\n            changes++;\n        }\n        assignments[index] = bestCluster;\n        clusters.get(bestCluster).addPoint(point);\n        index++;\n    }\n    return changes;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int changes = 0;\n        for (int i = 0; i < points.size(); i++) {\n            T point = (T) points.toArray()[i];\n            int oldAssignment = assignments[i];\n            double bestDistance = Double.POSITIVE_INFINITY;\n            int bestCluster = 0;\n            for (int j = 0; j < clusters.size(); j++) {\n                double distance = clusters.get(j).getCenter().distance(point);\n                if (distance < bestDistance) {\n                    bestDistance = distance;\n                    bestCluster = j;\n                }\n            }\n            if (oldAssignment != bestCluster) {\n                changes++;\n                assignments[i] = bestCluster;\n                clusters.get(bestCluster).addPoint(point);\n            }\n        }\n        return changes;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int changes = 0;\n    for (int i = 0; i < points.size(); i++) {\n        int oldCluster = assignments[i];\n        double bestDistance = Double.POSITIVE_INFINITY;\n        int bestCluster = -1;\n        for (int j = 0; j < clusters.size(); j++) {\n            double distance = clusters.get(j).getCenter().distance(points.iterator().next());\n            if (distance < bestDistance) {\n                bestDistance = distance;\n                bestCluster = j;\n            }\n        }\n        if (oldCluster != bestCluster) {\n            changes++;\n        }\n        assignments[i] = bestCluster;\n    }\n    return changes;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int changes = 0;\n    for (int i = 0; i < points.size(); i++) {\n        final T point = (T) points.toArray()[i];\n        int oldCluster = assignments[i];\n        double bestDistance = Double.POSITIVE_INFINITY;\n        int bestCluster = 0;\n        for (int j = 0; j < clusters.size(); j++) {\n            final double distance = clusters.get(j).getCenter().distance(point);\n            if (distance < bestDistance) {\n                bestDistance = distance;\n                bestCluster = j;\n            }\n        }\n        if (oldCluster != bestCluster) {\n            changes++;\n        }\n        assignments[i] = bestCluster;\n        clusters.get(bestCluster).addPoint(point);\n    }\n    return changes;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int changes = 0;\n    int oldAssignment;\n    for (int i = 0; i < points.size(); i++) {\n        T point = (T) points.toArray()[i];\n        double bestDistance = Double.POSITIVE_INFINITY;\n        int bestCluster = 0;\n        for (int j = 0; j < clusters.size(); j++) {\n            double distance = clusters.get(j).getCenter().distance(point);\n            if (distance < bestDistance) {\n                bestDistance = distance;\n                bestCluster = j;\n            }\n        }\n        oldAssignment = assignments[i];\n        if (oldAssignment != bestCluster) {\n            changes++;\n        }\n        assignments[i] = bestCluster;\n        clusters.get(bestCluster).addPoint(point);\n    }\n    return changes;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int changes = 0;\n    int oldAssignment;\n    for (int i = 0; i < points.size(); i++) {\n        double bestDistance = Double.POSITIVE_INFINITY;\n        int bestCluster = 0;\n        for (int j = 0; j < clusters.size(); j++) {\n            double distance = clusters.get(j).getCenter().distance(points.iterator().next());\n            if (distance < bestDistance) {\n                bestDistance = distance;\n                bestCluster = j;\n            }\n        }\n        oldAssignment = assignments[i];\n        if (oldAssignment != bestCluster) {\n            assignments[i] = bestCluster;\n            clusters.get(bestCluster).addPoint(points.iterator().next());\n            changes++;\n        }\n    }\n    return changes;\n}"
    ],
    [
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.ARRAY_LENGTH, xArray.length, yArray.length);\n    }\n\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA);\n    }\n\n    double sumX = 0.0;\n    double sumY = 0.0;\n    double sumXX = 0.0;\n    double sumYY = 0.0;\n    double sumXY = 0.0;\n\n    for (int i = 0; i < xArray.length; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXX += xArray[i] * xArray[i];\n        sumYY += yArray[i] * yArray[i];\n        sumXY += xArray[i] * yArray[i];\n    }\n\n    double delta = xArray.length;\n\n    if (biasCorrected) {\n        delta--;\n    }\n\n    double cov = (delta * sumXY - sumX * sumY) / delta;\n\n    return cov;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.ARRAY_LENGTH, xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA);\n    }\n\n    double sumX = 0.0;\n    double sumY = 0.0;\n    double sumXX = 0.0;\n    double sumYY = 0.0;\n    double sumXY = 0.0;\n\n    for (int i = 0; i < xArray.length; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXX += xArray[i] * xArray[i];\n        sumYY += yArray[i] * yArray[i];\n        sumXY += xArray[i] * yArray[i];\n    }\n\n    double cov = sumXY / xArray.length - sumX * sumY / (xArray.length * xArray.length);\n\n    if (biasCorrected) {\n        cov = cov * (xArray.length - 1) / (xArray.length - 2);\n    }\n\n    return cov;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.ARRAY_LENGTHS_MUST_MATCH,\n                xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA, 2, xArray.length);\n    }\n\n    double sumX = 0;\n    double sumY = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n    }\n\n    double meanX = sumX / xArray.length;\n    double meanY = sumY / yArray.length;\n\n    double covariance = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        covariance += (xArray[i] - meanX) * (yArray[i] - meanY);\n    }\n\n    if (biasCorrected) {\n        covariance /= (xArray.length - 1);\n    } else {\n        covariance /= xArray.length;\n    }\n\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.ARRAY_LENGTHS_MUST_MATCH,\n                xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA, 2, xArray.length);\n    }\n\n    double sumX = 0.0;\n    double sumY = 0.0;\n    double sumXX = 0.0;\n    double sumYY = 0.0;\n    double sumXY = 0.0;\n\n    for (int i = 0; i < xArray.length; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXX += xArray[i] * xArray[i];\n        sumYY += yArray[i] * yArray[i];\n        sumXY += xArray[i] * yArray[i];\n    }\n\n    double n = xArray.length;\n    double denominator = n * (n - 1);\n\n    if (biasCorrected) {\n        denominator = n - 1;\n    }\n\n    return (n * sumXY - sumX * sumY) / denominator;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.ARRAY_LENGTH, xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA, 2, xArray.length);\n    }\n\n    double sumX = 0.0;\n    double sumY = 0.0;\n    double sumXY = 0.0;\n    double sumX2 = 0.0;\n    double sumY2 = 0.0;\n\n    for (int i = 0; i < xArray.length; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXY += xArray[i] * yArray[i];\n        sumX2 += xArray[i] * xArray[i];\n        sumY2 += yArray[i] * yArray[i];\n    }\n\n    double n = xArray.length;\n    double denominator = n * (n - 1);\n\n    if (biasCorrected) {\n        denominator = n * (n - 1);\n    } else {\n        denominator = n;\n    }\n\n    double cov = (n * sumXY - sumX * sumY) / denominator;\n\n    return cov;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.ARRAY_LENGTHS_MUST_MATCH,\n                xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA, 2, xArray.length);\n    }\n\n    double sumX = 0.0;\n    double sumY = 0.0;\n    for (int i = 0; i < xArray.length; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n    }\n\n    double meanX = sumX / xArray.length;\n    double meanY = sumY / yArray.length;\n\n    double covariance = 0.0;\n    for (int i = 0; i < xArray.length; i++) {\n        covariance += (xArray[i] - meanX) * (yArray[i] - meanY);\n    }\n\n    int n = xArray.length;\n    if (biasCorrected) {\n        n--;\n    }\n\n    return covariance / n;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.ARRAY_LENGTHS_MUST_MATCH,\n                xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA, 2, xArray.length);\n    }\n\n    double sumX = 0;\n    double sumY = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n    }\n\n    double meanX = sumX / xArray.length;\n    double meanY = sumY / yArray.length;\n\n    double covariance = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        covariance += (xArray[i] - meanX) * (yArray[i] - meanY);\n    }\n\n    if (biasCorrected) {\n        covariance /= (xArray.length - 1);\n    } else {\n        covariance /= xArray.length;\n    }\n\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.ARRAY_LENGTHS_MUST_MATCH,\n                xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA, 2, xArray.length);\n    }\n\n    double sumX = 0.0;\n    double sumY = 0.0;\n    for (int i = 0; i < xArray.length; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n    }\n\n    double meanX = sumX / xArray.length;\n    double meanY = sumY / yArray.length;\n\n    double covariance = 0.0;\n    for (int i = 0; i < xArray.length; i++) {\n        covariance += (xArray[i] - meanX) * (yArray[i] - meanY);\n    }\n\n    int n = xArray.length;\n    if (biasCorrected) {\n        n--;\n    }\n\n    return covariance / n;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.ARRAY_LENGTHS_MUST_MATCH,\n                xArray.length, yArray.length);\n    }\n\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA, 2);\n    }\n\n    double sumX = 0.0;\n    double sumY = 0.0;\n    double sumXX = 0.0;\n    double sumYY = 0.0;\n    double sumXY = 0.0;\n\n    for (int i = 0; i < xArray.length; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXX += xArray[i] * xArray[i];\n        sumYY += yArray[i] * yArray[i];\n        sumXY += xArray[i] * yArray[i];\n    }\n\n    double n = xArray.length;\n    double denominator = n * (n - 1);\n\n    if (biasCorrected) {\n        denominator = n - 1;\n    }\n\n    return ((n * sumXY) - (sumX * sumY)) / denominator;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.ARRAY_LENGTHS_MUST_MATCH,\n                xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA, 2, xArray.length);\n    }\n\n    double sumX = 0.0;\n    double sumY = 0.0;\n    for (int i = 0; i < xArray.length; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n    }\n\n    double meanX = sumX / xArray.length;\n    double meanY = sumY / yArray.length;\n\n    double covariance = 0.0;\n    for (int i = 0; i < xArray.length; i++) {\n        covariance += (xArray[i] - meanX) * (yArray[i] - meanY);\n    }\n\n    int n = xArray.length;\n    if (biasCorrected) {\n        n--;\n    }\n\n    return covariance / n;\n}"
    ],
    [
      "private void realSkip(final long value) throws IOException  {\n        long remaining = value;\n        while (remaining > 0) {\n            int read = in.read(buf.array(), 0, (int) Math.min(remaining, buf.size()));\n            if (read < 0) {\n                break;\n            }\n            remaining -= read;\n        }\n        if (remaining > 0) {\n            throw new EOFException(\"Unexpected end of ZipInputStream\");\n        }\n    }",
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    while (remaining > 0) {\n        final long count = in.skip(remaining);\n        if (count > 0) {\n            remaining -= count;\n            bytesRead += count;\n        } else {\n            final int b = readOneByte();\n            if (b == -1) {\n                break;\n            } else {\n                remaining--;\n                bytesRead++;\n            }\n        }\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    while (remaining > 0) {\n        final int bytesToRead = (int) Math.min(remaining, Integer.MAX_VALUE);\n        final int bytesRead = in.read(buf.array(), 0, bytesToRead);\n        if (bytesRead == -1) {\n            throw new EOFException(\"Unexpected end of Zip file\");\n        }\n        remaining -= bytesRead;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    while (remaining > 0) {\n        int bytesToRead = (int) Math.min(remaining, Integer.MAX_VALUE);\n        int bytesRead = in.read(buf.array(), 0, bytesToRead);\n        if (bytesRead == -1) {\n            throw new EOFException(\"Unexpected EOF\");\n        }\n        remaining -= bytesRead;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    while (remaining > 0) {\n        int read = in.read(buf.array(), 0, (int) Math.min(remaining, buf.size()));\n        if (read < 0) {\n            break;\n        }\n        remaining -= read;\n    }\n    if (remaining > 0) {\n        throw new EOFException(\"EOF reached while skipping \" + remaining + \" bytes\");\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    while (remaining > 0) {\n        final int bytesToRead = (int) Math.min(remaining, Integer.MAX_VALUE);\n        final int bytesRead = in.read(new byte[bytesToRead]);\n        if (bytesRead == -1) {\n            throw new EOFException(\"Unexpected EOF\");\n        }\n        remaining -= bytesRead;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    while (remaining > 0) {\n        final long read = in.skip(remaining);\n        if (read <= 0) {\n            throw new EOFException(\"Reached end of stream\");\n        }\n        remaining -= read;\n    }\n    // update bytes read\n    bytesRead += value;\n}",
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    while (remaining > 0) {\n        final long count = in.skip(remaining);\n        if (count > 0) {\n            remaining -= count;\n            bytesRead += count;\n        } else {\n            final int b = readOneByte();\n            if (b == -1) {\n                break;\n            } else {\n                remaining--;\n                bytesRead++;\n            }\n        }\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    while (remaining > 0) {\n        final long skipped = in.skip(remaining);\n        if (skipped <= 0) {\n            throw new EOFException(\"Unexpected end of ZIP file\");\n        }\n        remaining -= skipped;\n        bytesRead += skipped;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    while (remaining > 0) {\n        final long read = in.skip(remaining);\n        if (read <= 0) {\n            throw new EOFException(\"Unexpected end of Zip file\");\n        }\n        remaining -= read;\n        bytesRead += read;\n    }\n}"
    ],
    [
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    if (fieldName == null) \n    {\n        throw new IllegalArgumentException(\"fieldName must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    if (fieldName == null) {\n        throw new IllegalArgumentException(\"fieldName must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    if (fieldName == null) {\n        throw new IllegalArgumentException(\"fieldName must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n        if (target == null) {\n            throw new IllegalArgumentException(\"target object must not be null\");\n        }\n        if (fieldName == null) {\n            throw new IllegalArgumentException(\"fieldName must not be null\");\n        }\n        final Class<?> cls = target.getClass();\n        final Field field = getDeclaredField(cls, fieldName, forceAccess);\n        if (field == null) {\n            throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n        }\n        // already forced access above, don't repeat it here:\n        return readField(field, target);\n    }",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    if (fieldName == null) {\n        throw new IllegalArgumentException(\"fieldName must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    if (fieldName == null) {\n        throw new IllegalArgumentException(\"fieldName must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    if (fieldName == null) {\n        throw new IllegalArgumentException(\"fieldName must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n        if (target == null) {\n            throw new IllegalArgumentException(\"target object must not be null\");\n        }\n        if (fieldName == null) {\n            throw new IllegalArgumentException(\"fieldName must not be null\");\n        }\n        final Class<?> cls = target.getClass();\n        final Field field = getDeclaredField(cls, fieldName, forceAccess);\n        if (field == null) {\n            throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n        }\n        // already forced access above, don't repeat it here:\n        return readField(field, target);\n    }",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    if (fieldName == null) \n    {\n        throw new IllegalArgumentException(\"fieldName must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    if (fieldName == null) {\n        throw new IllegalArgumentException(\"fieldName must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}"
    ],
    [
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    try \n    {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n        StringBuilder sb = new StringBuilder();\n        for (CharSequence part : messageParts) \n        {\n            md.update(part.toString().getBytes(StandardCharsets.UTF_8));\n        }\n        byte[] digest = md.digest();\n        for (byte b : digest) \n        {\n            sb.append(String.format(\"%02x\", b & 0xff));\n        }\n        return sb.toString().toUpperCase();\n    } \n    catch (NoSuchAlgorithmException e) \n    {\n        throw new RuntimeException(e);\n    }\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    MessageDigest digest;\n    try {\n        digest = MessageDigest.getInstance(\"SHA-1\");\n    } catch (NoSuchAlgorithmException e) {\n        throw new RuntimeException(\"SHA-1 algorithm not available\");\n    }\n\n    for (CharSequence part : messageParts) {\n        byte[] bytes = part.toString().getBytes(StandardCharsets.UTF_8);\n        digest.update(bytes, 0, bytes.length);\n    }\n\n    byte[] hash = digest.digest();\n    StringBuilder fingerprint = new StringBuilder(63);\n\n    for (int i = 0; i < hash.length; i++) {\n        int value = hash[i] & 0xFF;\n        if (value < 16) {\n            fingerprint.append('0');\n        }\n        fingerprint.append(Integer.toHexString(value));\n    }\n\n    return fingerprint.toString().toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    int hash = 0;\n    for (CharSequence part : messageParts) {\n        hash = part.hashCode() * 31 + hash;\n    }\n    return Integer.toHexString(hash).toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    try {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n        StringBuilder fingerprint = new StringBuilder();\n\n        for (CharSequence part : messageParts) {\n            md.update(part.toString().getBytes(StandardCharsets.UTF_8));\n        }\n\n        byte[] digest = md.digest();\n\n        for (byte b : digest) {\n            fingerprint.append(String.format(\"%02x\", b & 0xff));\n        }\n\n        return fingerprint.toString().toUpperCase();\n    } catch (NoSuchAlgorithmException e) {\n        throw new RuntimeException(\"SHA-1 algorithm not available\", e);\n    }\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder fingerprint = new StringBuilder();\n    int hashCode = 0;\n\n    for (CharSequence part : messageParts) {\n        hashCode += part.hashCode();\n    }\n\n    while (hashCode != 0) {\n        int remainder = hashCode % 64;\n        hashCode = hashCode / 64;\n        fingerprint.append((char) ('A' + remainder));\n    }\n\n    return fingerprint.toString();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder fingerprint = new StringBuilder();\n    int hashCode = 0;\n\n    for (CharSequence part : messageParts) \n    {\n        hashCode ^= part.hashCode();\n    }\n\n    while (hashCode != 0) \n    {\n        int remainder = hashCode % 64;\n        hashCode = hashCode / 64;\n        fingerprint.append((char) ('A' + remainder));\n    }\n\n    return fingerprint.toString();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // Initialize a hash function\n    MurmurHash3.Hash128 hash128 = new MurmurHash3.Hash128();\n\n    // Convert each part to bytes and update the hash\n    for (CharSequence part : messageParts) \n    {\n        hash128.update(part.toString().getBytes(StandardCharsets.UTF_8));\n    }\n\n    // Generate the 128-bit hash\n    byte[] hashBytes = hash128.digest();\n\n    // Convert the hash to a hexadecimal string\n    StringBuilder hashHex = new StringBuilder(32);\n    for (byte b : hashBytes) \n    {\n        hashHex.append(String.format(\"%02x\", b & 0xff));\n    }\n\n    // Return the first 16 characters of the hexadecimal string (63 bits)\n    return hashHex.toString().substring(0, 16);\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // Your code goes here\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // Implement the logic here\n    StringBuilder fingerprint = new StringBuilder();\n    int hash = 0;\n    for (CharSequence part : messageParts) {\n        hash += part.hashCode();\n    }\n    while (hash != 0) {\n        int rem = hash % 64;\n        hash = hash / 64;\n        fingerprint.append((char) ('A' + rem));\n    }\n    return fingerprint.toString();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder fingerprint = new StringBuilder();\n    int hash = 0;\n    for (CharSequence part : messageParts) \n    {\n        hash += part.hashCode();\n    }\n    while (hash != 0) \n    {\n        int remainder = hash % 64;\n        hash /= 64;\n        fingerprint.append((char) ('A' + remainder));\n    }\n    return fingerprint.toString();\n}"
    ],
    [
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long pos = archive.length();\n    byte[] buffer = new byte[sig.length];\n    for (long i = 0; i < maxDistanceFromEnd; i++) {\n        archive.seek(pos - i);\n        archive.readFully(buffer);\n        if (Arrays.equals(sig, buffer)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long length = archive.length();\n    final long minDistance = minDistanceFromEnd;\n    final long maxDistance = maxDistanceFromEnd;\n    final long searchStart = length - minDistance;\n    final long searchEnd = length - maxDistance;\n    final int sigLength = sig.length;\n    final byte[] buffer = new byte[sigLength];\n    for (long pos = searchStart; pos >= searchEnd; pos--) {\n        archive.seek(pos);\n        IOUtils.readFully(archive, buffer, 0, sigLength);\n        if (Arrays.equals(sig, buffer)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        final long endOfArchive = archive.length();\n        final long minDistance = minDistanceFromEnd + sig.length;\n        final long maxDistance = Math.max(minDistance,\n                                          Math.min(maxDistanceFromEnd,\n                                                   endOfArchive - sig.length));\n        for (long pos = endOfArchive - minDistance;\n             pos >= endOfArchive - maxDistance;\n             pos--) {\n            archive.seek(pos);\n            byte[] buffer = new byte[sig.length];\n            IOUtils.readFully(archive, buffer);\n            if (Arrays.equals(sig, buffer)) {\n                return true;\n            }\n        }\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        long position = archive.length();\n        byte[] buffer = new byte[sig.length];\n        for (long i = 0; i < maxDistanceFromEnd; i++) {\n            position--;\n            if (position < minDistanceFromEnd) {\n                return false;\n            }\n            archive.seek(position);\n            archive.readFully(buffer);\n            if (Arrays.equals(sig, buffer)) {\n                return true;\n            }\n        }\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long end = archive.length();\n    final long minDistance = minDistanceFromEnd;\n    final long maxDistance = maxDistanceFromEnd;\n    final byte[] buffer = new byte[sig.length];\n    final int bufferSize = buffer.length;\n    final long maxSearch = end - minDistance;\n    long position = end - maxDistance;\n    while (position >= maxSearch) {\n        archive.seek(position);\n        archive.readFully(buffer, 0, bufferSize);\n        if (Arrays.equals(sig, buffer)) {\n            return true;\n        }\n        position--;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        long position = archive.length() - minDistanceFromEnd;\n        byte[] buffer = new byte[(int) maxDistanceFromEnd];\n        while (position >= minDistanceFromEnd) {\n            archive.seek(position);\n            archive.readFully(buffer, 0, (int) maxDistanceFromEnd);\n            if (Arrays.equals(sig, buffer, 0, sig.length)) {\n                archive.seek(position);\n                return true;\n            }\n            position--;\n        }\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long length = archive.length();\n    final long maxSearch = length - maxDistanceFromEnd;\n    final long minSearch = length - minDistanceFromEnd;\n    for (long pos = length; pos > minSearch; pos--) {\n        archive.seek(pos);\n        if (archive.read() == sig[0]) {\n            final byte[] buffer = new byte[sig.length];\n            archive.readFully(buffer, 0, sig.length);\n            if (Arrays.equals(sig, buffer)) {\n                return true;\n            }\n        }\n    }\n    for (long pos = minSearch; pos >= minDistanceFromEnd; pos--) {\n        archive.seek(pos);\n        if (archive.read() == sig[0]) {\n            final byte[] buffer = new byte[sig.length];\n            archive.readFully(buffer, 0, sig.length);\n            if (Arrays.equals(sig, buffer)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        long pos = archive.length();\n        byte[] buffer = new byte[sig.length];\n        for (long i = minDistanceFromEnd; i <= maxDistanceFromEnd; i++) {\n            archive.seek(pos - i);\n            archive.readFully(buffer);\n            if (Arrays.equals(sig, buffer)) {\n                return true;\n            }\n        }\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long pos = archive.length();\n    final byte[] buffer = new byte[sig.length];\n    while (pos >= minDistanceFromEnd) {\n        archive.seek(pos);\n        archive.readFully(buffer);\n        if (Arrays.equals(sig, buffer)) {\n            return true;\n        }\n        pos--;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long end = archive.length();\n    final long start = end - maxDistanceFromEnd;\n    final long endOfSearch = end - minDistanceFromEnd;\n    byte[] buffer = new byte[(int)maxDistanceFromEnd];\n    archive.seek(start);\n    archive.read(buffer);\n    for (long i = start; i >= endOfSearch; i--) {\n        if (Arrays.equals(sig, Arrays.copyOfRange(buffer, (int)(i - start), (int)(i - start + sig.length)))) {\n            archive.seek(i);\n            return true;\n        }\n    }\n    return false;\n}"
    ],
    [
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge edge = null;\n\n    if (location == AxisLocation.TOP_OR_LEFT)\n    {\n        edge = RectangleEdge.TOP_OR_LEFT;\n    }\n    else if (location == AxisLocation.BOTTOM_OR_RIGHT)\n    {\n        edge = RectangleEdge.BOTTOM_OR_RIGHT;\n    }\n    else if (location == AxisLocation.LEFT_OR_BOTTOM)\n    {\n        edge = RectangleEdge.LEFT_OR_BOTTOM;\n    }\n    else if (location == AxisLocation.RIGHT_OR_TOP)\n    {\n        edge = RectangleEdge.RIGHT_OR_TOP;\n    }\n\n    return edge;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = null;\n    if (location == AxisLocation.TOP_OR_LEFT) {\n        result = RectangleEdge.TOP_OR_LEFT;\n    } else if (location == AxisLocation.BOTTOM_OR_RIGHT) {\n        result = RectangleEdge.BOTTOM_OR_RIGHT;\n    } else if (location == AxisLocation.LEFT_OR_BOTTOM) {\n        result = RectangleEdge.LEFT_OR_BOTTOM;\n    } else if (location == AxisLocation.RIGHT_OR_TOP) {\n        result = RectangleEdge.RIGHT_OR_TOP;\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge edge = null;\n\n    if (location == AxisLocation.TOP_OR_LEFT) \n    {\n        edge = RectangleEdge.TOP_OR_LEFT;\n    } \n    else if (location == AxisLocation.BOTTOM_OR_RIGHT) \n    {\n        edge = RectangleEdge.BOTTOM_OR_RIGHT;\n    } \n    else if (location == AxisLocation.LEFT_OR_BOTTOM) \n    {\n        edge = RectangleEdge.LEFT_OR_BOTTOM;\n    } \n    else if (location == AxisLocation.RIGHT_OR_TOP) \n    {\n        edge = RectangleEdge.RIGHT_OR_TOP;\n    }\n\n    return edge;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge edge = null;\n\n    switch (location) \n    {\n        case TOP:\n        case BOTTOM:\n            edge = RectangleEdge.BOTTOM;\n            break;\n        case LEFT:\n        case RIGHT:\n            edge = RectangleEdge.LEFT;\n            break;\n    }\n\n    return edge;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge edge = null;\n    if (location == AxisLocation.TOP_OR_LEFT) {\n        edge = RectangleEdge.TOP_OR_LEFT;\n    } else if (location == AxisLocation.BOTTOM_OR_RIGHT) {\n        edge = RectangleEdge.BOTTOM_OR_RIGHT;\n    }\n    return edge;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge edge;\n    switch (location) {\n        case TOP:\n        case BOTTOM:\n            edge = RectangleEdge.BOTTOM;\n            break;\n        case LEFT:\n        case RIGHT:\n            edge = RectangleEdge.LEFT;\n            break;\n        default:\n            throw new IllegalStateException(\"Unknown axis location: \" + location);\n    }\n    return edge;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge edge;\n    switch (location) {\n        case TOP:\n        case BOTTOM:\n            edge = RectangleEdge.BOTTOM;\n            break;\n        case LEFT:\n        case RIGHT:\n            edge = RectangleEdge.LEFT;\n            break;\n        default:\n            throw new IllegalStateException(\"Unknown location: \" + location);\n    }\n    return edge;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge edge;\n    switch (location) \n    {\n        case TOP:\n        case BOTTOM:\n            edge = RectangleEdge.BOTTOM;\n            break;\n        case LEFT:\n        case RIGHT:\n            edge = RectangleEdge.LEFT;\n            break;\n        default:\n            throw new IllegalStateException(\"Unknown location: \" + location);\n    }\n    return edge;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    if (location == AxisLocation.TOP || location == AxisLocation.BOTTOM) \n    {\n        return RectangleEdge.BOTTOM;\n    } \n    else \n    {\n        return RectangleEdge.LEFT;\n    }\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = null;\n    if (location == AxisLocation.TOP_OR_LEFT) \n    {\n        result = RectangleEdge.TOP_OR_LEFT;\n    } \n    else if (location == AxisLocation.BOTTOM_OR_RIGHT) \n    {\n        result = RectangleEdge.BOTTOM_OR_RIGHT;\n    } \n    else if (location == AxisLocation.LEFT_OR_BOTTOM) \n    {\n        result = RectangleEdge.LEFT_OR_BOTTOM;\n    } \n    else if (location == AxisLocation.RIGHT_OR_TOP) \n    {\n        result = RectangleEdge.RIGHT_OR_TOP;\n    }\n    return result;\n}"
    ],
    [
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    return new InputStream() \n}",
      "public InputStream getDataStream()  {\n    // TODO: Complete the function with correct and functional code\n    return new InputStream() \n    {\n        int pos = _bufferedStart;\n        int count = 0;\n\n}\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    return new InputStream() \n}",
      "public InputStream getDataStream()  {\n    // Create a new input stream that reads from the buffered data and the original stream\n    return new ByteArrayInputStream(Arrays.copyOfRange(_bufferedData, _bufferedStart, _bufferedLength), _originalStream);\n}"
    ],
    [
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = this.dataset.getKey(section);\n    if (key == null) \n    {\n        key = new Integer(section);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = this.dataModel.getKey(section);\n    if (key == null) \n    {\n        key = new Integer(section);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = this.dataset.getKey(section);\n    if (key == null) \n    {\n        key = new Integer(section);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = this.dataset.getKey(section);\n    if (key == null) \n    {\n        key = new Integer(section);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    if (section < 0 || section >= getSectionCount()) \n    {\n        throw new IllegalArgumentException(\"section index out of range\");\n    }\n    return getSectionModel().getKey(section);\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = this.dataModel.getRowKey(section);\n    if (key == null) \n    {\n        key = new Integer(section);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = this.dataset.getKey(section);\n    if (key == null) \n    {\n        key = new Integer(section);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n        Comparable key = this.dataset.getKey(section);\n        if (key == null) {\n            key = new Integer(section);\n        }\n        return key;\n    }",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = this.dataset.getKey(section);\n    if (key == null) \n    {\n        key = new Integer(section);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n        Comparable key = this.dataset.getKey(section);\n        if (key == null) {\n            key = new Integer(section);\n        }\n        return key;\n    }"
    ],
    [
      "@Override\n        public boolean isNaN()  {\n            if (_currToken != JsonToken.VALUE_NUMBER_FLOAT) {\n                return false;\n            }\n            Object ob = _currentObject();\n            if (ob instanceof Float) {\n                return Float.isNaN((Float) ob);\n            }\n            if (ob instanceof Double) {\n                return Double.isNaN((Double) ob);\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken != JsonToken.VALUE_NUMBER_FLOAT) {\n                return false;\n            }\n            Object ob = _currentObject();\n            if (ob instanceof Float) {\n                return Float.isNaN((Float) ob);\n            }\n            if (ob instanceof Double) {\n                return Double.isNaN((Double) ob);\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken != JsonToken.VALUE_NUMBER_FLOAT) {\n                return false;\n            }\n            Object ob = _currentObject();\n            if (ob instanceof BigDecimal) {\n                return ((BigDecimal) ob).isNaN();\n            }\n            if (ob instanceof BigInteger) {\n                return ((BigInteger) ob).signum() <= 0;\n            }\n            if (ob instanceof Double) {\n                return Double.isNaN((Double) ob);\n            }\n            if (ob instanceof Float) {\n                return Float.isNaN((Float) ob);\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken != JsonToken.VALUE_NUMBER_FLOAT) {\n                return false;\n            }\n            Object ob = _currentObject();\n            if (ob instanceof Float) {\n                return Float.isNaN((Float) ob);\n            }\n            if (ob instanceof Double) {\n                return Double.isNaN((Double) ob);\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken != JsonToken.VALUE_NUMBER_FLOAT) {\n                return false;\n            }\n            Object ob = _currentObject();\n            if (ob instanceof BigDecimal) {\n                return ((BigDecimal) ob).isNaN();\n            }\n            if (ob instanceof BigInteger) {\n                return ((BigInteger) ob).signum() == 0;\n            }\n            if (ob instanceof Double) {\n                return Double.isNaN((Double) ob);\n            }\n            if (ob instanceof Float) {\n                return Float.isNaN((Float) ob);\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken != JsonToken.VALUE_NUMBER_FLOAT) {\n                return false;\n            }\n            Object ob = _currentObject();\n            if (ob instanceof BigDecimal) {\n                return ((BigDecimal) ob).isNaN();\n            }\n            if (ob instanceof BigInteger) {\n                return ((BigInteger) ob).signum() <= 0;\n            }\n            if (ob instanceof Double) {\n                return Double.isNaN((Double) ob);\n            }\n            if (ob instanceof Float) {\n                return Float.isNaN((Float) ob);\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken != JsonToken.VALUE_NUMBER_FLOAT) {\n                return false;\n            }\n            Object ob = _currentObject();\n            if (ob instanceof Float) {\n                return Float.isNaN((Float) ob);\n            }\n            if (ob instanceof Double) {\n                return Double.isNaN((Double) ob);\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken != JsonToken.VALUE_NUMBER_FLOAT) {\n                return false;\n            }\n            Object ob = _currentObject();\n            if (ob instanceof BigDecimal) {\n                return ((BigDecimal) ob).isNaN();\n            }\n            if (ob instanceof BigInteger) {\n                return false;\n            }\n            if (ob instanceof Double) {\n                return Double.isNaN((Double) ob);\n            }\n            if (ob instanceof Float) {\n                return Float.isNaN((Float) ob);\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken != JsonToken.VALUE_NUMBER_FLOAT) {\n                return false;\n            }\n            Object ob = _currentObject();\n            if (ob instanceof Float) {\n                return Float.isNaN((Float) ob);\n            }\n            if (ob instanceof Double) {\n                return Double.isNaN((Double) ob);\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken != JsonToken.VALUE_NUMBER_FLOAT) {\n                return false;\n            }\n            Object ob = _currentObject();\n            if (ob instanceof Float) {\n                return Float.isNaN((Float) ob);\n            }\n            if (ob instanceof Double) {\n                return Double.isNaN((Double) ob);\n            }\n            return false;\n        }"
    ],
    [
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if(str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if(prefix.length() > str.length()) \n    {\n        return false;\n    }\n    for(int i = 0; i < prefix.length(); i++) \n    {\n        char strChar = str.charAt(i);\n        char prefixChar = prefix.charAt(i);\n        if(ignoreCase) \n        {\n            if(Character.toUpperCase(strChar) != Character.toUpperCase(prefixChar)) \n            {\n                return false;\n            }\n        } \n        else \n        {\n            if(strChar != prefixChar) \n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if(str == null || prefix == null)\n    {\n        return str == null && prefix == null;\n    }\n\n    if(prefix.length() > str.length())\n    {\n        return false;\n    }\n\n    for(int i = 0; i < prefix.length(); i++)\n    {\n        char strChar = str.charAt(i);\n        char prefixChar = prefix.charAt(i);\n\n        if(ignoreCase)\n        {\n            if(Character.toUpperCase(strChar) != Character.toUpperCase(prefixChar))\n            {\n                return false;\n            }\n        }\n        else\n        {\n            if(strChar != prefixChar)\n            {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if(str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if(prefix.length() > str.length()) \n    {\n        return false;\n    }\n    for(int i = 0; i < prefix.length(); i++) \n    {\n        char strChar = str.charAt(i);\n        char prefixChar = prefix.charAt(i);\n        if(ignoreCase) \n        {\n            if(Character.toUpperCase(strChar) != Character.toUpperCase(prefixChar)) \n            {\n                return false;\n            }\n        } \n        else \n        {\n            if(strChar != prefixChar) \n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if(str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if(prefix.length() > str.length()) \n    {\n        return false;\n    }\n    for(int i = 0; i < prefix.length(); i++) \n    {\n        char strChar = str.charAt(i);\n        char prefixChar = prefix.charAt(i);\n        if(ignoreCase) \n        {\n            if(Character.toUpperCase(strChar) != Character.toUpperCase(prefixChar)) \n            {\n                return false;\n            }\n        } \n        else \n        {\n            if(strChar != prefixChar) \n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if(str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if(prefix.length() > str.length()) \n    {\n        return false;\n    }\n    for(int i = 0; i < prefix.length(); i++) \n    {\n        char strChar = str.charAt(i);\n        char prefixChar = prefix.charAt(i);\n        if(ignoreCase) \n        {\n            if(Character.toUpperCase(strChar) != Character.toUpperCase(prefixChar)) \n            {\n                return false;\n            }\n        } \n        else \n        {\n            if(strChar != prefixChar) \n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if(str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if(prefix.length() > str.length()) \n    {\n        return false;\n    }\n    for(int i = 0; i < prefix.length(); i++) \n    {\n        char strChar = str.charAt(i);\n        char prefixChar = prefix.charAt(i);\n        if(ignoreCase) \n        {\n            if(Character.toUpperCase(strChar) != Character.toUpperCase(prefixChar)) \n            {\n                return false;\n            }\n        } \n        else \n        {\n            if(strChar != prefixChar) \n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if(str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if(prefix.length() > str.length()) \n    {\n        return false;\n    }\n    for(int i = 0; i < prefix.length(); i++) \n    {\n        char strChar = str.charAt(i);\n        char prefixChar = prefix.charAt(i);\n        if(ignoreCase) \n        {\n            if(Character.toUpperCase(strChar) != Character.toUpperCase(prefixChar)) \n            {\n                return false;\n            }\n        } \n        else \n        {\n            if(strChar != prefixChar) \n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if(str == null || prefix == null)\n    {\n        return str == null && prefix == null;\n    }\n    if(prefix.length() > str.length())\n    {\n        return false;\n    }\n    for(int i = 0; i < prefix.length(); i++)\n    {\n        char strChar = str.charAt(i);\n        char prefixChar = prefix.charAt(i);\n        if(ignoreCase)\n        {\n            if(Character.toUpperCase(strChar) != Character.toUpperCase(prefixChar))\n            {\n                return false;\n            }\n        }\n        else\n        {\n            if(strChar != prefixChar)\n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if(str == null || prefix == null)\n    {\n        return str == null && prefix == null;\n    }\n\n    if(prefix.length() > str.length())\n    {\n        return false;\n    }\n\n    for(int i = 0; i < prefix.length(); i++)\n    {\n        char strChar = str.charAt(i);\n        char prefixChar = prefix.charAt(i);\n\n        if(ignoreCase)\n        {\n            if(Character.toUpperCase(strChar) != Character.toUpperCase(prefixChar))\n            {\n                return false;\n            }\n        }\n        else\n        {\n            if(strChar != prefixChar)\n            {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if(str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if(prefix.length() > str.length()) \n    {\n        return false;\n    }\n    for(int i = 0; i < prefix.length(); i++) \n    {\n        char c1 = str.charAt(i);\n        char c2 = prefix.charAt(i);\n        if(ignoreCase) \n        {\n            c1 = Character.toUpperCase(c1);\n            c2 = Character.toUpperCase(c2);\n        }\n        if(c1 != c2) \n        {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_STRING) \n    {\n        result = nextUnquotedValue();\n    } \n    else if (p == PEEKED_SINGLE_QUOTED_STRING) \n    {\n        result = nextQuotedValue('\\'');\n    } \n    else if (p == PEEKED_DOUBLE_QUOTED_STRING) \n    {\n        result = nextQuotedValue('\"');\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_STRING) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_STRING) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_STRING) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    return result;\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_STRING) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_STRING) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_STRING) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    return result;\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_STRING) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_STRING) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_STRING) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    return result;\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_STRING) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_STRING) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_STRING) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    return result;\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_STRING) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_STRING) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_STRING) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    return result;\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_STRING) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_STRING) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_STRING) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_STRING) \n    {\n        result = nextUnquotedValue();\n    } \n    else if (p == PEEKED_SINGLE_QUOTED_STRING) \n    {\n        result = nextQuotedValue('\\'');\n    } \n    else if (p == PEEKED_DOUBLE_QUOTED_STRING) \n    {\n        result = nextQuotedValue('\"');\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_STRING) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_STRING) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_STRING) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    return result;\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_STRING) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_STRING) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_STRING) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    return result;\n}"
    ],
    [
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (offset + maxWidth > str.length()) {\n        maxWidth = str.length() - offset;\n    }\n    String leftStr = str.substring(0, offset);\n    String rightStr = str.substring(offset + maxWidth);\n    return leftStr + \"...\" + rightStr;\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    // check for invalid maxWidth\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    // check for null input\n    if (str == null) {\n        return null;\n    }\n    // check for empty string\n    if (str.length() == 0) {\n        return \"\";\n    }\n    // check for invalid offset\n    if (offset < 0) {\n        offset = 0;\n    } else if (offset > str.length()) {\n        offset = str.length();\n    }\n    // check for too long string\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    // check for maxWidth smaller than offset + 3\n    if (maxWidth < offset + 3) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is offset + 3\");\n    }\n    // abbreviate\n    return new StringBuilder(maxWidth)\n        .append(str, 0, offset)\n        .append(\"...\")\n        .append(str.substring(str.length() - (maxWidth - offset - 3)))\n        .toString();\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (offset + maxWidth > str.length()) {\n        maxWidth = str.length() - offset;\n    }\n    String leftStr = str.substring(0, offset);\n    String rightStr = str.substring(offset + maxWidth);\n    return leftStr + \"...\" + rightStr;\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (offset + maxWidth >= str.length()) {\n        return str;\n    }\n    String leftStr = str.substring(0, offset);\n    String rightStr = str.substring(offset + maxWidth - 3);\n    String middleStr = str.substring(offset, offset + maxWidth - 3);\n    return leftStr + \"...\" + middleStr + \"...\" + rightStr;\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    // Validate parameters\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n\n    // Return the original string if it's shorter than the maximum width\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n\n    // If the offset is less than 3, just use an ellipsis and the first 2 characters\n    if (offset < 3) {\n        return \"...\" + str.substring(2);\n    }\n\n    // If the offset is greater than the string length minus the maximum width plus 3,\n    // just use an ellipsis and the last 2 characters\n    if (offset > str.length() - maxWidth + 3) {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n\n    // Otherwise, abbreviate in the middle of the string\n    return str.substring(0, offset) + \"...\" + str.substring(offset + maxWidth - 3);\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    // TODO: Implement the function\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (offset + maxWidth >= str.length()) {\n        return str;\n    }\n    String leftStr = str.substring(0, offset);\n    String rightStr = str.substring(offset + maxWidth - 3);\n    return leftStr + \"...\" + rightStr;\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (offset + maxWidth >= str.length()) {\n        return str;\n    }\n    String leftStr = str.substring(0, offset);\n    String rightStr = str.substring(offset + maxWidth - 3);\n    String middleStr = str.substring(offset, offset + maxWidth - 3);\n    return leftStr + \"...\" + middleStr + \"...\" + rightStr;\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    // Validate parameters\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n\n    // Abbreviate\n    if (str.length() <= maxWidth) {\n        return str;\n    } else if (offset <= maxWidth - 3) {\n        return str.substring(0, offset) + \"...\" + str.substring(str.length() - (maxWidth - offset - 3));\n    } else {\n        return \"...\" + str.substring(str.length() - (maxWidth - 3));\n    }\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (offset + maxWidth > str.length()) {\n        maxWidth = str.length() - offset;\n    }\n    String leftStr = str.substring(0, offset);\n    String rightStr = str.substring(offset + maxWidth);\n    String middleStr = str.substring(offset, offset + maxWidth);\n    return leftStr + \"...\" + middleStr + \"...\" + rightStr;\n}"
    ],
    [
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == s2) \n    {\n        return true;\n    }\n    if (s1 == null || s2 == null) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!s1[i].equals(s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == s2) \n    {\n        return true;\n    }\n\n    if (s1 == null || s2 == null) \n    {\n        return false;\n    }\n\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!s1[i].equals(s2[i])) \n        {\n            return false;\n        }\n    }\n\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == s2) \n    {\n        return true;\n    }\n\n    if (s1 == null || s2 == null) \n    {\n        return false;\n    }\n\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!s1[i].equals(s2[i])) \n        {\n            return false;\n        }\n    }\n\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == s2) \n    {\n        return true;\n    }\n\n    if (s1 == null || s2 == null) \n    {\n        return false;\n    }\n\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!s1[i].equals(s2[i])) \n        {\n            return false;\n        }\n    }\n\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == s2) \n    {\n        return true;\n    }\n    if (s1 == null || s2 == null) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!s1[i].equals(s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == s2) \n    {\n        return true;\n    }\n\n    if (s1 == null || s2 == null) \n    {\n        return false;\n    }\n\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!s1[i].equals(s2[i])) \n        {\n            return false;\n        }\n    }\n\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == s2) \n    {\n        return true;\n    }\n    if (s1 == null || s2 == null) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!s1[i].equals(s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == s2) \n    {\n        return true;\n    }\n    if (s1 == null || s2 == null) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!s1[i].equals(s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == s2) \n    {\n        return true;\n    }\n\n    if (s1 == null || s2 == null) \n    {\n        return false;\n    }\n\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!s1[i].equals(s2[i])) \n        {\n            return false;\n        }\n    }\n\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == s2) \n    {\n        return true;\n    }\n\n    if (s1 == null || s2 == null) \n    {\n        return false;\n    }\n\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!s1[i].equals(s2[i])) \n        {\n            return false;\n        }\n    }\n\n    return true;\n}"
    ],
    [
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) \n    {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) \n        {\n            lastSymbolNameIndex = index;\n        } \n        else \n        {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) {\n      lastSymbolName = symbolName;\n      Integer index = symbolNameMap.get(symbolName);\n      if (index != null) {\n        lastSymbolNameIndex = index;\n      } else {\n        lastSymbolNameIndex = symbolNameMap.size();\n        symbolNameMap.put(symbolName, lastSymbolNameIndex);\n      }\n    }\n    return lastSymbolNameIndex;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) {\n      lastSymbolName = symbolName;\n      Integer index = symbolNameMap.get(symbolName);\n      if (index != null) {\n        lastSymbolNameIndex = index;\n      } else {\n        lastSymbolNameIndex = symbolNameMap.size();\n        symbolNameMap.put(symbolName, lastSymbolNameIndex);\n      }\n    }\n    return lastSymbolNameIndex;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) \n    {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) \n        {\n            lastSymbolNameIndex = index;\n        } \n        else \n        {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) {\n      lastSymbolName = symbolName;\n      Integer index = symbolNameMap.get(symbolName);\n      if (index != null) {\n        lastSymbolNameIndex = index;\n      } else {\n        lastSymbolNameIndex = symbolNameMap.size();\n        symbolNameMap.put(symbolName, lastSymbolNameIndex);\n      }\n    }\n    return lastSymbolNameIndex;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) {\n      lastSymbolName = symbolName;\n      Integer index = symbolNameMap.get(symbolName);\n      if (index != null) {\n        lastSymbolNameIndex = index;\n      } else {\n        lastSymbolNameIndex = symbolNameMap.size();\n        symbolNameMap.put(symbolName, lastSymbolNameIndex);\n      }\n    }\n    return lastSymbolNameIndex;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) \n    {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) \n        {\n            lastSymbolNameIndex = index;\n        } \n        else \n        {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) {\n      lastSymbolName = symbolName;\n      Integer index = symbolNameMap.get(symbolName);\n      if (index != null) {\n        lastSymbolNameIndex = index;\n      } else {\n        lastSymbolNameIndex = symbolNameMap.size();\n        symbolNameMap.put(symbolName, lastSymbolNameIndex);\n      }\n    }\n    return lastSymbolNameIndex;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) {\n      lastSymbolName = symbolName;\n      Integer index = symbolNameMap.get(symbolName);\n      if (index != null) {\n        lastSymbolNameIndex = index;\n      } else {\n        lastSymbolNameIndex = symbolNameMap.size();\n        symbolNameMap.put(symbolName, lastSymbolNameIndex);\n      }\n    }\n    return lastSymbolNameIndex;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) \n    {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) \n        {\n            lastSymbolNameIndex = index;\n        } \n        else \n        {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}"
    ],
    [
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_UNQUOTED) {\n      result = Double.parseDouble(nextUnquotedValue());\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = Double.parseDouble(nextQuotedValue('\\''));\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = Double.parseDouble(nextQuotedValue('\"'));\n    } else if (p == PEEKED_BUFFERED) {\n      result = Double.parseDouble(peekedString);\n      peekedString = null;\n    } else if (p == PEEKED_LONG) {\n      result = peekedLong;\n    } else if (p == PEEKED_NUMBER) {\n      result = parseDouble(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_UNQUOTED) {\n      result = Double.parseDouble(nextUnquotedValue());\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = Double.parseDouble(nextQuotedValue('\\''));\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = Double.parseDouble(nextQuotedValue('\"'));\n    } else if (p == PEEKED_BUFFERED) {\n      result = Double.parseDouble(peekedString);\n      peekedString = null;\n    } else if (p == PEEKED_LONG) {\n      result = peekedLong;\n    } else if (p == PEEKED_NUMBER) {\n      result = Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED) {\n      try {\n        String result = nextUnquotedValue();\n        return Double.parseDouble(result);\n      } catch (NumberFormatException e) {\n        throw new NumberFormatException(\"Expected a number but was \" + peek() + locationString());\n      }\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      try {\n        String result = nextQuotedValue('\\'');\n        return Double.parseDouble(result);\n      } catch (NumberFormatException e) {\n        throw new NumberFormatException(\"Expected a number but was \" + peek() + locationString());\n      }\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      try {\n        String result = nextQuotedValue('\"');\n        return Double.parseDouble(result);\n      } catch (NumberFormatException e) {\n        throw new NumberFormatException(\"Expected a number but was \" + peek() + locationString());\n      }\n    } else if (p == PEEKED_BUFFERED) {\n      try {\n        String result = peekedString;\n        peekedString = null;\n        return Double.parseDouble(result);\n      } catch (NumberFormatException e) {\n        throw new NumberFormatException(\"Expected a number but was \" + peek() + locationString());\n      }\n    } else if (p == PEEKED_LONG) {\n      double result = peekedLong;\n      peekedLong = 0;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else if (p == PEEKED_NUMBER) {\n      try {\n        String result = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n        peekedNumberLength = 0;\n        return Double.parseDouble(result);\n      } catch (NumberFormatException e) {\n}\n}\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED) {\n      String result = nextUnquotedValue();\n      try {\n        return Double.parseDouble(result);\n      } catch (NumberFormatException e) {\n        throw new NumberFormatException(\"Expected a number but was \" + result + locationString());\n      }\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      String result = nextQuotedValue('\\'');\n      try {\n        return Double.parseDouble(result);\n      } catch (NumberFormatException e) {\n        throw new NumberFormatException(\"Expected a number but was \" + result + locationString());\n      }\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      String result = nextQuotedValue('\"');\n      try {\n        return Double.parseDouble(result);\n      } catch (NumberFormatException e) {\n        throw new NumberFormatException(\"Expected a number but was \" + result + locationString());\n      }\n    } else if (p == PEEKED_BUFFERED) {\n      try {\n        return Double.parseDouble(peekedString);\n      } catch (NumberFormatException e) {\n        throw new NumberFormatException(\"Expected a number but was \" + peekedString + locationString());\n      } finally {\n        peekedString = null;\n      }\n    } else if (p == PEEKED_LONG) {\n      double result = peekedLong;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else if (p == PEEKED_NUMBER) {\n      try {\n        double result = Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n        pos += peekedNumberLength;\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      }\n}\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_UNQUOTED) {\n      result = Double.parseDouble(nextUnquotedValue());\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = Double.parseDouble(nextQuotedValue('\\''));\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = Double.parseDouble(nextQuotedValue('\"'));\n    } else if (p == PEEKED_BUFFERED) {\n      result = Double.parseDouble(peekedString);\n      peekedString = null;\n    } else if (p == PEEKED_LONG) {\n      result = peekedLong;\n    } else if (p == PEEKED_NUMBER) {\n      result = Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_UNQUOTED) {\n      result = Double.parseDouble(nextUnquotedValue());\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = Double.parseDouble(nextQuotedValue('\\''));\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = Double.parseDouble(nextQuotedValue('\"'));\n    } else if (p == PEEKED_BUFFERED) {\n      result = Double.parseDouble(peekedString);\n      peekedString = null;\n    } else if (p == PEEKED_LONG) {\n      result = peekedLong;\n    } else if (p == PEEKED_NUMBER) {\n      result = Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NUMBER) {\n      String numberString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      try {\n        return Double.parseDouble(numberString);\n      } catch (NumberFormatException e) {\n        throw new NumberFormatException(\"Failed to parse number: \" + numberString + locationString());\n      }\n    } else if (p == PEEKED_LONG) {\n      double result = peekedLong;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else if (p == PEEKED_UNQUOTED) {\n      try {\n        return Double.parseDouble(nextUnquotedValue());\n      } catch (NumberFormatException e) {\n        throw new NumberFormatException(\"Failed to parse number: \" + peek() + locationString());\n      }\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      try {\n        return Double.parseDouble(nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"'));\n      } catch (NumberFormatException e) {\n        throw new NumberFormatException(\"Failed to parse number: \" + peek() + locationString());\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n    }\n  }",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_UNQUOTED) {\n      result = Double.parseDouble(nextUnquotedValue());\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = Double.parseDouble(nextQuotedValue('\\''));\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = Double.parseDouble(nextQuotedValue('\"'));\n    } else if (p == PEEKED_BUFFERED) {\n      result = Double.parseDouble(peekedString);\n      peekedString = null;\n    } else if (p == PEEKED_LONG) {\n      result = peekedLong;\n    } else if (p == PEEKED_NUMBER) {\n      result = parseDouble(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_UNQUOTED) {\n      result = Double.parseDouble(nextUnquotedValue());\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = Double.parseDouble(nextQuotedValue('\\''));\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = Double.parseDouble(nextQuotedValue('\"'));\n    } else if (p == PEEKED_BUFFERED) {\n      result = Double.parseDouble(peekedString);\n      peekedString = null;\n    } else if (p == PEEKED_LONG) {\n      result = peekedLong;\n    } else if (p == PEEKED_NUMBER) {\n      result = Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_UNQUOTED) {\n      result = Double.parseDouble(nextUnquotedValue());\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = Double.parseDouble(nextQuotedValue('\\''));\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = Double.parseDouble(nextQuotedValue('\"'));\n    } else if (p == PEEKED_BUFFERED) {\n      result = Double.parseDouble(peekedString);\n      peekedString = null;\n    } else if (p == PEEKED_LONG) {\n      result = peekedLong;\n    } else if (p == PEEKED_NUMBER) {\n      result = parseDouble(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }"
    ],
    [
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int inputLength = str.length();\n    final StringBuilder builder = new StringBuilder(inputLength * repeat);\n    for (int i = 0; i < repeat; i++) {\n        builder.append(str);\n    }\n    return builder.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int inputLength = str.length();\n    final StringBuilder builder = new StringBuilder(inputLength * repeat);\n    for (int i = 0; i < repeat; i++) {\n        builder.append(str);\n    }\n    return builder.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) {\n        return str;\n    }\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1 :\n            return repeat(str.charAt(0), repeat);\n        case 2 :\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            switch (repeat) {\n                case 2 :\n                    return new String(new char[] {ch0, ch0, ch1, ch1});\n                case 3 :\n                    return new String(new char[] {ch0, ch0, ch0, ch1, ch1, ch1});\n                default :\n                    final char[] output2 = new char[outputLength];\n                    for (int i = 0; i < repeat; i++) {\n                        output2[i * 2] = ch0;\n                        output2[i * 2 + 1] = ch1;\n                    }\n                    return new String(output2);\n            }\n        default :\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int inputLength = str.length();\n    final StringBuilder builder = new StringBuilder(inputLength * repeat);\n    for (int i = 0; i < repeat; i++) {\n        builder.append(str);\n    }\n    return builder.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int inputLength = str.length();\n    if (inputLength == 0 || repeat == 1) {\n        return str;\n    }\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1 :\n            return repeat(str.charAt(0), repeat);\n        case 2 :\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default :\n            StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int inputLength = str.length();\n    final StringBuilder builder = new StringBuilder(inputLength * repeat);\n    for (int i = 0; i < repeat; i++) {\n        builder.append(str);\n    }\n    return builder.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                return repeat(str.charAt(0), repeat);\n            case 2 :\n                final char ch0 = str.charAt(0);\n                final char ch1 = str.charAt(1);\n                final char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                final StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }",
      "public static String repeat(final String str, final int repeat)  {\n        // write your code here\n        if(str == null)\n            return null;\n        if(repeat <= 0)\n            return \"\";\n        StringBuilder sb = new StringBuilder(str.length() * repeat);\n        for(int i = 0; i < repeat; i++)\n            sb.append(str);\n        return sb.toString();\n    }",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) {\n        return str;\n    }\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1 :\n            return repeat(str.charAt(0), repeat);\n        case 2 :\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default :\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int inputLength = str.length();\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 0:\n            return EMPTY;\n        case 1:\n            return repeat(str.charAt(0), repeat);\n        default:\n            final StringBuilder builder = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                builder.append(str);\n            }\n            return builder.toString();\n    }\n}"
    ],
    [
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        return new UnrecognizedExtraField(headerId);\n    }\n    return (ZipExtraField) clazz.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        return new UnrecognizedExtraField(headerId);\n    }\n    return (ZipExtraField) clazz.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        return new UnrecognizedExtraField(headerId);\n    }\n    return (ZipExtraField) clazz.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> c = implementations.get(headerId);\n    if (c == null) {\n        return new UnrecognizedExtraField(headerId);\n    }\n    return (ZipExtraField) c.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        return new UnrecognizedExtraField(headerId);\n    }\n    return (ZipExtraField) clazz.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        return new UnrecognizedExtraField(headerId);\n    }\n    return (ZipExtraField) clazz.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> c = implementations.get(headerId);\n    if (c == null) {\n        return new UnrecognizedExtraField(headerId);\n    }\n    return (ZipExtraField) c.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        return new UnrecognizedExtraField(headerId);\n    }\n    return (ZipExtraField) clazz.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        return new UnrecognizedExtraField(headerId);\n    }\n    return (ZipExtraField) clazz.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        return new UnrecognizedExtraField(headerId);\n    }\n    return (ZipExtraField) clazz.newInstance();\n}"
    ],
    [
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}"
    ],
    [
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new TreeMap();\n    Iterator iter = map.entrySet().iterator();\n    while (iter.hasNext()) {\n        Map.Entry entry = (Map.Entry) iter.next();\n        clone.put(entry.getKey(), entry.getValue().clone());\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new TreeMap();\n    Iterator iter = map.entrySet().iterator();\n    while (iter.hasNext()) {\n        Map.Entry entry = (Map.Entry) iter.next();\n        Object key = entry.getKey();\n        Object value = entry.getValue();\n        if (value instanceof Cloneable) {\n            value = ((Cloneable) value).clone();\n        }\n        clone.put(key, value);\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new TreeMap();\n    Iterator iterator = map.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Object key = entry.getKey();\n        Object value = entry.getValue();\n        if (value instanceof Cloneable) {\n            clone.put(key, ((Cloneable) value).clone());\n        } else {\n            clone.put(key, value);\n        }\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new TreeMap();\n    Iterator iter = map.entrySet().iterator();\n    while (iter.hasNext()) {\n        Map.Entry entry = (Map.Entry) iter.next();\n        Object key = entry.getKey();\n        Object value = entry.getValue();\n        if (value instanceof Cloneable) {\n            clone.put(key, ((Cloneable) value).clone());\n        } else {\n            clone.put(key, value);\n        }\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new TreeMap();\n    Iterator iter = map.entrySet().iterator();\n    while (iter.hasNext()) {\n        Map.Entry entry = (Map.Entry) iter.next();\n        clone.put(entry.getKey(), ObjectUtilities.clone(entry.getValue()));\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new TreeMap();\n    Iterator iter = map.entrySet().iterator();\n    while (iter.hasNext()) {\n        Map.Entry entry = (Map.Entry) iter.next();\n        Object key = entry.getKey();\n        Object value = entry.getValue();\n        if (value instanceof Cloneable) {\n            value = ((Cloneable) value).clone();\n        }\n        clone.put(key, value);\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new TreeMap();\n    Iterator iterator = map.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        clone.put(entry.getKey(), entry.getValue().clone());\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new TreeMap();\n    Iterator iterator = map.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Object key = entry.getKey();\n        Object value = entry.getValue();\n        if (value instanceof Cloneable) {\n            value = ((Cloneable) value).clone();\n        }\n        clone.put(key, value);\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new TreeMap();\n    Iterator iter = map.entrySet().iterator();\n    while (iter.hasNext()) {\n        Map.Entry entry = (Map.Entry) iter.next();\n        Object key = entry.getKey();\n        Object value = entry.getValue();\n        if (value instanceof Cloneable) {\n            value = ((Cloneable) value).clone();\n        }\n        clone.put(key, value);\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new TreeMap();\n    Iterator iterator = map.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        clone.put(entry.getKey(), entry.getValue().clone());\n    }\n    return clone;\n}"
    ],
    [
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) \n    {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) \n    {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) \n        {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) \n    {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) \n        {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) \n    {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) \n    {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) \n        {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) \n    {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) \n        {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) \n    {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) \n    {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) \n        {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) \n    {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) \n        {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}"
    ],
    [
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (E object : coll) \n        {\n            if (set.contains(object) == false) \n            {\n                super.add(index, object);\n                set.add(object);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (E object : coll) {\n            if (set.contains(object) == false) {\n                super.add(index, object);\n                set.add(object);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean result = false;\n        for (E element : coll) \n        {\n            if (set.contains(element) == false) \n            {\n                super.add(index, element);\n                set.add(element);\n                result = true;\n            }\n        }\n        return result;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean result = false;\n        for (E element : coll) {\n            if (set.contains(element) == false) {\n                super.add(index, element);\n                set.add(element);\n                result = true;\n            }\n        }\n        return result;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (E element : coll) {\n            if (set.contains(element) == false) {\n                super.add(index, element);\n                set.add(element);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean result = false;\n        for (E element : coll) \n        {\n            if (set.contains(element) == false) \n            {\n                super.add(index, element);\n                set.add(element);\n                result = true;\n            }\n        }\n        return result;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean result = false;\n        for (E element : coll) \n        {\n            if (set.contains(element) == false) \n            {\n                super.add(index, element);\n                set.add(element);\n                result = true;\n            }\n        }\n        return result;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (E element : coll) \n        {\n            if (set.contains(element) == false) \n            {\n                super.add(index, element);\n                set.add(element);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (E object : coll) {\n            if (set.contains(object) == false) {\n                super.add(index, object);\n                set.add(object);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean result = false;\n        for (E element : coll) \n        {\n            if (set.contains(element) == false) \n            {\n                super.add(index, element);\n                set.add(element);\n                result = true;\n            }\n        }\n        return result;\n    }"
    ],
    [
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    evaluations.increment();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n        evaluations.increment();\n        return f.value(x);\n    }",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n        evaluations.increment();\n        return f.value(x);\n    }",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n        evaluations.increment();\n        return f.value(x);\n    }",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    evaluations.increment();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n        evaluations.increment();\n        return f.value(x);\n    }",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n        evaluations.increment();\n        return f.value(x);\n    }",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n        evaluations.increment();\n        return f.value(x);\n    }",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n        evaluations.increment();\n        return f.value(x);\n    }",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    evaluations.increment();\n    return f.value(x);\n}"
    ],
    [
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        if (constraint.getRelationship() == Relationship.LEQ) \n        {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(), constraint.getValue()));\n        } \n        else if (constraint.getRelationship() == Relationship.GEQ) \n        {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -constraint.getValue()));\n        } \n        else if (constraint.getRelationship() == Relationship.EQ) \n        {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(), constraint.getValue()));\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -constraint.getValue()));\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n        List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n        for (LinearConstraint constraint : originalConstraints) \n        {\n            if (constraint.getRelationship() == Relationship.LEQ) \n            {\n                normalizedConstraints.add(constraint);\n            } \n            else if (constraint.getRelationship() == Relationship.GEQ) \n            {\n                normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -1 * constraint.getValue()));\n            } \n            else if (constraint.getRelationship() == Relationship.EQ) \n            {\n                LinearConstraint newConstraint = new LinearConstraint(constraint.getCoefficients(), constraint.getValue());\n                newConstraint.setRelationship(Relationship.LEQ);\n                normalizedConstraints.add(newConstraint);\n\n                newConstraint = new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -1 * constraint.getValue());\n                newConstraint.setRelationship(Relationship.GEQ);\n                normalizedConstraints.add(newConstraint);\n            }\n        }\n        return normalizedConstraints;\n    }",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n        List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n        for (LinearConstraint constraint : originalConstraints) \n        {\n            if (constraint.getRelationship() == Relationship.LEQ) \n            {\n                normalizedConstraints.add(constraint);\n            } \n            else if (constraint.getRelationship() == Relationship.GEQ) \n            {\n                normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -1 * constraint.getValue()));\n            } \n            else if (constraint.getRelationship() == Relationship.EQ) \n            {\n                LinearConstraint newConstraint = new LinearConstraint(constraint.getCoefficients(), constraint.getValue());\n                newConstraint.setRelationship(Relationship.LEQ);\n                normalizedConstraints.add(newConstraint);\n\n                newConstraint = new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -1 * constraint.getValue());\n                newConstraint.setRelationship(Relationship.GEQ);\n                normalizedConstraints.add(newConstraint);\n            }\n        }\n        return normalizedConstraints;\n    }",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        if (constraint.getRelationship() == Relationship.LEQ) \n        {\n            normalizedConstraints.add(constraint);\n        } \n        else if (constraint.getRelationship() == Relationship.GEQ) \n        {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -constraint.getValue()));\n        } \n        else if (constraint.getRelationship() == Relationship.EQ) \n        {\n            LinearConstraint newConstraint = new LinearConstraint(constraint.getCoefficients(), constraint.getValue());\n            newConstraint.setRelationship(Relationship.LEQ);\n            normalizedConstraints.add(newConstraint);\n            newConstraint = new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -constraint.getValue());\n            newConstraint.setRelationship(Relationship.LEQ);\n            normalizedConstraints.add(newConstraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n        List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n        for (LinearConstraint constraint : originalConstraints) \n        {\n            if (constraint.getRelationship() == Relationship.LEQ) \n            {\n                normalizedConstraints.add(constraint);\n            } \n            else if (constraint.getRelationship() == Relationship.GEQ) \n            {\n                normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -constraint.getValue()));\n            } \n            else if (constraint.getRelationship() == Relationship.EQ) \n            {\n                normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(), constraint.getValue()));\n                normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -constraint.getValue()));\n            }\n        }\n        return normalizedConstraints;\n    }",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        if (constraint.getRelationship() == Relationship.LEQ) \n        {\n            normalizedConstraints.add(constraint);\n        } \n        else if (constraint.getRelationship() == Relationship.GEQ) \n        {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -1 * constraint.getValue()));\n        } \n        else if (constraint.getRelationship() == Relationship.EQ) \n        {\n            LinearConstraint newConstraint = new LinearConstraint(constraint.getCoefficients(), constraint.getValue());\n            newConstraint.setRelationship(Relationship.LEQ);\n            normalizedConstraints.add(newConstraint);\n            newConstraint = new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -1 * constraint.getValue());\n            newConstraint.setRelationship(Relationship.LEQ);\n            normalizedConstraints.add(newConstraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n        List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n        for (LinearConstraint constraint : originalConstraints) \n        {\n            if (constraint.getRelationship() == Relationship.LEQ) \n            {\n                normalizedConstraints.add(constraint);\n            } \n            else if (constraint.getRelationship() == Relationship.GEQ) \n            {\n                normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -1 * constraint.getValue()));\n            } \n            else if (constraint.getRelationship() == Relationship.EQ) \n            {\n                LinearConstraint newConstraint = new LinearConstraint(constraint.getCoefficients(), constraint.getValue());\n                newConstraint.setRelationship(Relationship.LEQ);\n                normalizedConstraints.add(newConstraint);\n                newConstraint = new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -1 * constraint.getValue());\n                newConstraint.setRelationship(Relationship.LEQ);\n                normalizedConstraints.add(newConstraint);\n            }\n        }\n        return normalizedConstraints;\n    }",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        if (constraint.getRelationship() == Relationship.LEQ) \n        {\n            normalizedConstraints.add(constraint);\n        } \n        else if (constraint.getRelationship() == Relationship.GEQ) \n        {\n            RealVector coefficients = constraint.getCoefficients().mapMultiply(-1);\n            double constantTerm = -1 * constraint.getConstantTerm();\n            normalizedConstraints.add(new LinearConstraint(coefficients, constantTerm, Relationship.LEQ));\n        } \n        else if (constraint.getRelationship() == Relationship.EQ) \n        {\n            normalizedConstraints.add(constraint);\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -1 * constraint.getConstantTerm(), Relationship.LEQ));\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n        List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n        for (LinearConstraint constraint : originalConstraints) \n        {\n            if (constraint.getRelationship() == Relationship.LEQ) \n            {\n                normalizedConstraints.add(constraint);\n            } \n            else if (constraint.getRelationship() == Relationship.GEQ) \n            {\n                normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -1 * constraint.getValue()));\n            } \n            else if (constraint.getRelationship() == Relationship.EQ) \n            {\n                normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -1 * constraint.getValue()));\n                normalizedConstraints.add(constraint);\n            }\n        }\n        return normalizedConstraints;\n    }",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        if (constraint.getRelationship() == Relationship.LEQ) \n        {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(), constraint.getValue()));\n        } \n        else if (constraint.getRelationship() == Relationship.GEQ) \n        {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -constraint.getValue()));\n        } \n        else if (constraint.getRelationship() == Relationship.EQ) \n        {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(), constraint.getValue()));\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -constraint.getValue()));\n        }\n    }\n    return normalizedConstraints;\n}"
    ],
    [
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"bin cannot be null\");\n    }\n    if (this.getUpperBound() <= bin.getLowerBound()) {\n        return false;\n    }\n    if (this.getLowerBound() >= bin.getUpperBound()) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Bin cannot be null\");\n    }\n    if (bin == this) {\n        return false;\n    }\n    if (bin.getUpperBound() < this.getLowerBound()) {\n        return false;\n    }\n    if (this.getUpperBound() < bin.getLowerBound()) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"bin cannot be null\");\n    }\n    if (this.getUpperBound() <= bin.getLowerBound()) {\n        return false;\n    }\n    if (bin.getUpperBound() <= this.getLowerBound()) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Bin cannot be null\");\n    }\n\n    if (this.upperBound <= bin.getLowerBound()) \n    {\n        return false;\n    }\n    if (this.lowerBound >= bin.getUpperBound()) \n    {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"bin cannot be null\");\n    }\n    if (this.upperBound <= bin.getLowerBound()) {\n        return false;\n    }\n    if (bin.getUpperBound() <= this.lowerBound) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Bin cannot be null\");\n    }\n    if (this.upperBound <= bin.getLowerBound()) {\n        return false;\n    }\n    if (this.lowerBound >= bin.getUpperBound()) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Bin cannot be null\");\n    }\n\n    if (this.upperBound <= bin.getLowerBound()) {\n        return false;\n    }\n    if (this.lowerBound >= bin.getUpperBound()) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Bin cannot be null\");\n    }\n\n    if (this.upperBound <= bin.getLowerBound()) {\n        return false;\n    }\n    if (bin.getUpperBound() <= this.lowerBound) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Bin cannot be null\");\n    }\n    if (bin.getUpperBound() < this.getLowerBound()) {\n        return false;\n    }\n    if (bin.getLowerBound() > this.getUpperBound()) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Bin cannot be null\");\n    }\n    if (this.upperBound <= bin.getLowerBound()) \n    {\n        return false;\n    }\n    if (this.lowerBound >= bin.getUpperBound()) \n    {\n        return false;\n    }\n    return true;\n}"
    ],
    [
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if(str == null)\n    {\n        return null;\n    }\n    List<String> list = new ArrayList<String>();\n    int len = str.length();\n    int sizePlus1 = 1;\n    boolean match = false;\n    boolean lastMatch = false;\n    boolean preserveAllTokens = camelCase;\n    int start = 0;\n    int i = 0;\n    int type = Character.getType(str.charAt(0));\n    while (i < len) \n    {\n        int nextType = Character.getType(str.charAt(i));\n        if (type == nextType) \n        {\n            match = true;\n            i++;\n        } \n        else \n        {\n            if (match || preserveAllTokens) \n            {\n                list.add(str.substring(start, i));\n                match = false;\n            }\n            start = ++i;\n            type = nextType;\n        }\n    }\n    if (match || preserveAllTokens) \n    {\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return new String[0];\n    }\n    final List<String> list = new ArrayList<>();\n    final StringBuilder token = new StringBuilder();\n    char prevCharType = 0;\n    for (int i = 0; i < len; i++) {\n        final char chr = str.charAt(i);\n        final char charType = Character.getType(chr);\n        if (charType == prevCharType) {\n            token.append(chr);\n        } else {\n            list.add(token.toString());\n            token.setLength(0);\n            token.append(chr);\n            prevCharType = charType;\n        }\n    }\n    list.add(token.toString());\n    if (camelCase) {\n        for (int i = 1; i < list.size(); i += 2) {\n            final String upper = list.get(i - 1);\n            final String lower = list.get(i);\n            if (upper.length() == 1 && Character.isUpperCase(upper.charAt(0)) && lower.length() > 1 && Character.isLowerCase(lower.charAt(0))) {\n                list.set(i - 1, upper + lower.charAt(0));\n                list.set(i, lower.substring(1));\n            }\n        }\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return new String[0];\n    }\n\n    final List<String> list = new ArrayList<>();\n    final StringBuilder token = new StringBuilder();\n    char ch = str.charAt(0);\n    int type = Character.getType(ch);\n    token.append(ch);\n    for (int i = 1; i < len; i++) {\n        ch = str.charAt(i);\n        int newType = Character.getType(ch);\n        if (camelCase && type == Character.UPPERCASE_LETTER && newType == Character.LOWERCASE_LETTER) {\n            list.add(token.toString());\n            token.setLength(0);\n        }\n        token.append(ch);\n        type = newType;\n    }\n    list.add(token.toString());\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n\n    List<String> list = new ArrayList<>();\n    int len = str.length();\n    boolean match = false;\n    boolean lastMatch = false;\n    boolean preserveAllTokens = camelCase;\n    int sizePlus1 = 1;\n    int max = Integer.MAX_VALUE;\n    int i = 0;\n    int start = 0;\n    StringBuilder token = new StringBuilder();\n    StringBuilder delimiter = new StringBuilder();\n    while (i < len) {\n        char c = str.charAt(i);\n        String type = Character.getType(c) + \"\";\n        if (match || preserveAllTokens) {\n            if (Character.isLetter(c) && lastMatch) {\n                if (camelCase && Character.isUpperCase(c) && token.length() > 0) {\n                    list.add(token.toString());\n                    token.setLength(0);\n                }\n                token.append(c);\n            } else {\n                list.add(token.toString());\n                token.setLength(0);\n                delimiter.append(c);\n            }\n            lastMatch = true;\n            match = false;\n        } else {\n            delimiter.append(c);\n            lastMatch = false;\n        }\n        i++;\n    }\n    if (match || preserveAllTokens && lastMatch) {\n        list.add(token.toString());\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if(str == null) \n    {\n        return null;\n    }\n\n    int len = str.length();\n    if (len == 0) \n    {\n        return new String[0];\n    }\n\n    List<String> list = new ArrayList<>();\n    int sizePlus1 = 1;\n    int lastMatch = -1;\n    boolean match = false;\n    boolean preserveAllTokens = false;\n    boolean lastIsLower = false;\n    boolean lastIsUpper = false;\n    boolean lastIsTitle = false;\n    boolean lastIsDigit = false;\n    boolean lastIsSpace = false;\n    boolean lastIsOther = false;\n    boolean lastIsSurrogate = false;\n    boolean lastIsHighSurrogate = false;\n    boolean lastIsLowSurrogate = false;\n\n    for (int i = 0; i < len; i++) \n    {\n        char ch = str.charAt(i);\n        boolean isLower = Character.isLowerCase(ch);\n        boolean isUpper = Character.isUpperCase(ch);\n        boolean isTitle = Character.isTitleCase(ch);\n        boolean isDigit = Character.isDigit(ch);\n        boolean isSpace = Character.isSpaceChar(ch);\n        boolean isOther = !isLower && !isUpper && !isTitle && !isDigit && !isSpace;\n        boolean isSurrogate = Character.isSurrogate(ch);\n        boolean isHighSurrogate = Character.isHighSurrogate(ch);\n        boolean isLowSurrogate = Character.isLowSurrogate(ch);\n\n        if (camelCase) \n        {\n            if (lastIsUpper && isLower) \n            {\n                preserveAllTokens = true;\n            }\n        }\n\n}\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n\n    List<String> list = new ArrayList<String>();\n    int len = str.length();\n    boolean match = false;\n    boolean lastMatch = false;\n    boolean preserveAllTokens = false;\n    int sizePlus1 = 1;\n    int max = Integer.MAX_VALUE;\n    int i = 0;\n    int start = 0;\n\n    while (i < len) {\n        char ch = str.charAt(i);\n        boolean isLetter = Character.isLetter(ch);\n        boolean isUpperCase = Character.isUpperCase(ch);\n        if (camelCase && lastMatch && isLetter && isUpperCase) {\n            // preserve the case of the last match and the current one\n            list.add(str.substring(start, i));\n            start = i;\n            lastMatch = false;\n        } else if (match || preserveAllTokens) {\n            lastMatch = true;\n            if (sizePlus1++ == max) {\n                i = len;\n                lastMatch = false;\n            }\n            list.add(str.substring(start, i));\n            match = false;\n        }\n        if (isLetter) {\n            match = true;\n        } else {\n            match = false;\n        }\n        i++;\n    }\n    if (match || preserveAllTokens && lastMatch) {\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return new String[0];\n    }\n    final List<String> list = new ArrayList<String>();\n    int sizePlus1 = 1;\n    final boolean preserveAllTokens = camelCase;\n    final StringBuilder token = new StringBuilder();\n    char ch = 0;\n    for (int i = 0; i < len; i++) {\n        ch = str.charAt(i);\n        final int type = Character.getType(ch);\n        if (type == Character.UPPERCASE_LETTER && i > 0 && Character.getType(str.charAt(i - 1)) == Character.LOWERCASE_LETTER) {\n            token.append(ch);\n        } else {\n            if (token.length() > 0) {\n                list.add(token.toString());\n                token.setLength(0);\n                sizePlus1++;\n            }\n            list.add(String.valueOf(ch));\n        }\n    }\n    if (token.length() > 0) {\n        list.add(token.toString());\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if(str == null)\n    {\n        return null;\n    }\n\n    List<String> list = new ArrayList<>();\n    int len = str.length();\n    int i = 0;\n    int start = 0;\n    boolean match = false;\n    boolean lastMatch = false;\n    while (i < len)\n    {\n        char ch = str.charAt(i);\n        int type = Character.getType(ch);\n        if (camelCase && i > 0 && Character.isUpperCase(ch) && Character.getType(str.charAt(i - 1)) == Character.LOWERCASE_LETTER)\n        {\n            list.add(str.substring(start, i));\n            start = i;\n        }\n        else if (type != Character.CONTROL && type != Character.FORMAT && type != Character.SURROGATE && type != Character.UNASSIGNED && type != Character.DASH_PATTERN && type != Character.LOWERCASE_LETTER && type != Character.UPPERCASE_LETTER && type != Character.OTHER_LETTER && type != Character.TITLECASE_LETTER && type != Character.MODIFIER_LETTER && type != Character.LETTER_NUMBER && type != Character.OTHER_NUMBER)\n        {\n            if (match || lastMatch)\n            {\n                list.add(str.substring(start, i));\n                start = i;\n            }\n            else\n            {\n                start = ++i;\n            }\n            match = false;\n            lastMatch = false;\n        }\n        else\n        {\n            match = true;\n            lastMatch = true;\n            i++;\n        }\n    }\n    if (match || lastMatch)\n    {\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    List<String> list = new ArrayList<>();\n    int len = str.length();\n    boolean match = false;\n    boolean lastMatch = false;\n    int sizePlus1 = 1;\n    int start = 0;\n    int i = 0;\n    int type = Character.getType(str.charAt(0));\n    while (i < len) {\n        int newType = Character.getType(str.charAt(i));\n        if (newType == type) {\n            i++;\n            continue;\n        }\n        if (camelCase && newType == Character.UPPERCASE_LETTER && type == Character.LOWERCASE_LETTER) {\n            if (match) {\n                list.add(str.substring(start, i - 1));\n                start = i - 1;\n            }\n        } else {\n            if (match) {\n                list.add(str.substring(start, i));\n                start = i;\n            }\n        }\n        match = !match;\n        type = newType;\n        i++;\n    }\n    if (match) {\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    List<String> list = new ArrayList<String>();\n    int len = str.length();\n    boolean match = false;\n    boolean lastMatch = false;\n    int sizePlus1 = 1;\n    int start = 0;\n    int i = 0;\n    while (i < len) {\n        char ch = str.charAt(i);\n        boolean isSeparator = Character.isWhitespace(ch) || Character.getType(ch) == Character.CONTROL;\n        if (camelCase) {\n            if (i > 0) {\n                char prevCh = str.charAt(i - 1);\n                boolean isPrevSeparator = Character.isWhitespace(prevCh) || Character.getType(prevCh) == Character.CONTROL;\n                if (!isPrevSeparator && Character.getType(ch) == Character.UPPERCASE_LETTER && lastMatch) {\n                    list.add(str.substring(start, i - 1));\n                    start = i - 1;\n                }\n            }\n        }\n        if (isSeparator) {\n            if (match || lastMatch) {\n                list.add(str.substring(start, i));\n                start = i;\n                lastMatch = false;\n            }\n        } else {\n            lastMatch = true;\n        }\n        match = isSeparator;\n        i++;\n    }\n    if (start < len) {\n        list.add(str.substring(start, len));\n    }\n    return list.toArray(new String[list.size()]);\n}"
    ],
    [
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, DateTimeChronology.ISO, iLocale, iPivotYear, 0);\n    parser.parseInto(bucket, text, 0);\n    return bucket.computeMillis(false, text);\n}",
      "public long parseMillis(String text)  {\n        DateTimeParser parser = requireParser();\n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            DateTimeZone.UTC.getOffset(System.currentTimeMillis()),\n            DateTimeChronology.getInstance(DateTimeZone.UTC), iLocale, iPivotYear, 0);\n        parser.parseInto(bucket, text, 0);\n        return bucket.computeMillis(true, text);\n    }",
      "public long parseMillis(String text)  {\n        DateTimeParser parser = requireParser();\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, DateTimeChronology.ISO, iLocale, iPivotYear, 0);\n        int pos = parser.parseInto(bucket, text, 0);\n        if (pos < 0) {\n            throw new IllegalArgumentException(\"Invalid datetime: \" + text);\n        }\n        return bucket.computeMillis(false, text);\n    }",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        DateTimeZone.UTC.getOffset(System.currentTimeMillis()), \n        DateTimeChronology.getInstance(DateTimeZone.UTC), \n        iLocale, \n        iPivotYear, \n        DateTimeUtils.getChronology(DateTimeZone.UTC).year().get(System.currentTimeMillis()));\n    parser.parseInto(bucket, text, 0);\n    return bucket.computeMillis(false, text);\n}",
      "public long parseMillis(String text)  {\n        DateTimeParser parser = requireParser();\n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            DateTimeZone.UTC.getOffset(0), ISOChronology.getInstanceUTC(), iLocale, iPivotYear, 0);\n        parser.parseInto(bucket, text, 0);\n        return bucket.computeMillis(false, text);\n    }",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        DateTimeZone.UTC.getOffset(System.currentTimeMillis()), \n        DateTimeChronology.ISO, \n        Locale.getDefault(), \n        DateTimeFieldType.year().getDefaultValue(), \n        DateTimeFieldType.year().getDefaultValue());\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos < 0) \n    {\n        throw new IllegalArgumentException(\"Invalid datetime: \" + text);\n    }\n    return bucket.computeMillis(false, text);\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        DateTimeZone.UTC.getOffset(0), ISOChronology.getInstanceUTC(), iLocale, iPivotYear, 0);\n    parser.parseInto(bucket, text, 0);\n    return bucket.computeMillis(true, text);\n}",
      "public long parseMillis(String text)  {\n        DateTimeParser parser = requireParser();\n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            DateTimeZone.UTC.getOffset(0), ISOChronology.getInstanceUTC(), iLocale, iPivotYear, 0);\n        parser.parseInto(bucket, text, 0);\n        return bucket.computeMillis(true, text);\n    }",
      "public long parseMillis(String text)  {\n        DateTimeParser parser = requireParser();\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, DateTimeChronology.ISO, iLocale, iPivotYear, 0);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos < 0) {\n            throw new IllegalArgumentException(\"Invalid date: \" + text);\n        }\n        return bucket.computeMillis(false, text);\n    }",
      "public long parseMillis(String text)  {\n        DateTimeParser parser = requireParser();\n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            DateTimeZone.UTC.getOffset(System.currentTimeMillis()), \n            ISOChronology.getInstance(), \n            Locale.getDefault(), \n            DateTimeConstants.get(DateTimeConstants.PIVOT_YEAR), \n            DateTimeConstants.get(DateTimeConstants.DEFAULT_YEAR));\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos < 0) {\n            throw new IllegalArgumentException(\"Invalid datetime: \" + text);\n        }\n        return bucket.computeMillis(true, text);\n    }"
    ],
    [
      "static MinimizedCondition unoptimized(Node n)  {\n    MeasuredNode p = MeasuredNode.fromNode(n);\n    MeasuredNode np = MeasuredNode.fromNode(new ScriptNode(Token.SCRIPT, \"\"));\n    np.length = Integer.MAX_VALUE;\n    return new MinimizedCondition(p, np);\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    MeasuredNode positive = MeasuredNode.fromNode(n);\n    MeasuredNode negative = MeasuredNode.fromNode(new ScriptNode(ScriptNode.Type.SCRIPT, \"\"));\n    negative.length = Integer.MAX_VALUE;\n    return new MinimizedCondition(positive, negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    MeasuredNode p = MeasuredNode.fromNode(n);\n    MeasuredNode np = MeasuredNode.fromNode(new Node(Token.SCRIPT, \"\"));\n    np.length = Integer.MAX_VALUE;\n    return new MinimizedCondition(p, np);\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    MeasuredNode positive = MeasuredNode.fromNode(n);\n    MeasuredNode negative = MeasuredNode.fromNode(new ScriptNode(ScriptType.UNSAFE, \n    new Token[0])).setLength(Integer.MAX_VALUE);\n    MinimizedCondition result = new MinimizedCondition(positive, negative);\n    return result;\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    MeasuredNode p = MeasuredNode.fromNode(n);\n    MeasuredNode m = MeasuredNode.fromNode(new ScriptNode(ScriptType.UNREASONABLY_LARGE_SCRIPT));\n    return new MinimizedCondition(p, m);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    MeasuredNode positive = MeasuredNode.fromNode(n);\n    MeasuredNode negative = MeasuredNode.fromNode(new ScriptNode(Token.SCRIPT, \"unoptimized\"));\n    negative.length = Integer.MAX_VALUE;\n    return new MinimizedCondition(positive, negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    MeasuredNode positive = MeasuredNode.fromNode(n);\n    MeasuredNode negative = MeasuredNode.fromNode(new ScriptNode(Token.SCRIPT, \"\"));\n    negative.length = Integer.MAX_VALUE;\n    return new MinimizedCondition(positive, negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    MeasuredNode positive = MeasuredNode.fromNode(n);\n    MeasuredNode negative = MeasuredNode.fromNode(new ScriptNode(Token.SCRIPT, \"\"));\n    negative.length = Integer.MAX_VALUE;\n    return new MinimizedCondition(positive, negative);\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    MeasuredNode p = MeasuredNode.fromNode(n);\n    MeasuredNode np = MeasuredNode.fromNode(n.deepCopy().change());\n    np.node.setType(Token.NOT);\n    np.length = Integer.MAX_VALUE;\n    return new MinimizedCondition(p, np);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    MeasuredNode positive = MeasuredNode.fromNode(n);\n    MeasuredNode negative = MeasuredNode.fromNode(new ScriptNode(Token.SCRIPT, \"\"));\n    negative.length = Integer.MAX_VALUE;\n    return new MinimizedCondition(positive, negative);\n  }"
    ],
    [
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n\n    long[] total = new long[(int) Math.ceil(enumClass.getEnumConstants().length / 64.0)];\n    int index = 0;\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        total[index] |= 1 << constant.ordinal();\n        if (constant.ordinal() % 64 == 63) \n        {\n            index++;\n        }\n    }\n    return total;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n\n    int size = enumClass.getEnumConstants().length;\n    int longsNeeded = (size + 63) / 64;\n    long[] bitVectors = new long[longsNeeded];\n\n    for (E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        bitVectors[constant.ordinal() / 64] |= 1L << (constant.ordinal() & 63);\n    }\n\n    return bitVectors;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n\n    int maxOrdinal = 0;\n    for (final E constant : enumClass.getEnumConstants()) {\n        if (constant.ordinal() > maxOrdinal) {\n            maxOrdinal = constant.ordinal();\n        }\n    }\n\n    int longsNeeded = (maxOrdinal + 63) / 64;\n    long[] bitVectors = new long[longsNeeded];\n\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        bitVectors[constant.ordinal() / 64] |= 1L << (constant.ordinal() & 63);\n    }\n\n    return bitVectors;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    long[] total = new long[EnumUtils.getEnumList(enumClass).size() / Long.SIZE];\n    int index = 0;\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        total[index / Long.SIZE] |= 1 << (index % Long.SIZE);\n        index++;\n    }\n    return total;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n\n    int maxOrdinal = 0;\n    for (final E constant : enumClass.getEnumConstants()) {\n        if (constant.ordinal() > maxOrdinal) {\n            maxOrdinal = constant.ordinal();\n        }\n    }\n\n    int longsNeeded = (maxOrdinal + 63) / 64;\n    long[] bitVectors = new long[longsNeeded];\n\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        bitVectors[constant.ordinal() / 64] |= 1L << (constant.ordinal() & 63);\n    }\n\n    return bitVectors;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    int size = enumClass.getEnumConstants().length;\n    int longsNeeded = (size + 63) / 64;\n    long[] total = new long[longsNeeded];\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        total[constant.ordinal() / 64] |= 1L << (constant.ordinal() % 64);\n    }\n    return total;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    int maxOrdinal = enumClass.getEnumConstants().length;\n    int longSize = Long.SIZE;\n    int longCount = (maxOrdinal + longSize - 1) / longSize;\n    long[] total = new long[longCount];\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        int ordinal = constant.ordinal();\n        int longIndex = ordinal / longSize;\n        int bitIndex = ordinal % longSize;\n        total[longIndex] |= 1L << bitIndex;\n    }\n    return total;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n\n    List<E> list = new ArrayList<>();\n    for (E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        list.add(constant);\n    }\n\n    int size = list.size();\n    int longsNeeded = (size + 63) / 64;\n    long[] result = new long[longsNeeded];\n\n    for (int i = 0; i < size; i++) \n    {\n        result[i / 64] |= 1L << (i % 64);\n    }\n\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    long[] total = new long[((enumClass.getEnumConstants().length + 63) / 64)];\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        total[constant.ordinal() / 64] |= 1 << (constant.ordinal() % 64);\n    }\n    return total;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n\n    int maxOrdinal = 0;\n    for (final E constant : enumClass.getEnumConstants()) {\n        if (constant.ordinal() > maxOrdinal) {\n            maxOrdinal = constant.ordinal();\n        }\n    }\n\n    int longsNeeded = maxOrdinal / Long.SIZE + 1;\n    long[] bitVectors = new long[longsNeeded];\n\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        bitVectors[constant.ordinal() / Long.SIZE] |= 1L << (constant.ordinal() % Long.SIZE);\n    }\n\n    return bitVectors;\n}"
    ],
    [
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) \n    {\n        return scope.getDepth();\n    } \n    else \n    {\n        int depth = 0;\n        while (scope != null) \n        {\n            scope = scope.getParent();\n            depth++;\n        }\n        return depth;\n    }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    int depth = 0;\n    while (scope != null) \n    {\n        if (scope.isLexicalScope()) \n        {\n            return depth;\n        } \n        else \n        {\n            scope = scope.getParent();\n            depth++;\n        }\n    }\n    return depth;\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    int depth = 0;\n    while (scope != null) \n    {\n        if (scope.isLexicalScope()) \n        {\n            return depth;\n        } \n        else \n        {\n            scope = scope.getParent();\n            depth++;\n        }\n    }\n    return depth;\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (!scope.isLexicalScope()) \n    {\n        return 0;\n    }\n\n    int depth = 0;\n    while (scope != null) \n    {\n        if (scope.isLexicalScope()) \n        {\n            return depth;\n        }\n\n        depth++;\n        scope = scope.getParent();\n    }\n\n    return depth;\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    int depth = 0;\n    while (scope != null) \n    {\n        if (scope.isLexicalScope()) \n        {\n            return depth;\n        } \n        else \n        {\n            scope = scope.getParent();\n            depth++;\n        }\n    }\n    return depth;\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (!scope.isLexicalScope()) \n    {\n        SymbolScope parent = scope.getParent();\n        if (parent == null) \n        {\n            return 0;\n        }\n        return 1 + getLexicalScopeDepth(parent);\n    }\n    return scope.getDepth();\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    int depth = 0;\n    while (scope != null) \n    {\n        if (scope.isLexicalScope()) \n        {\n            return depth;\n        } \n        else \n        {\n            scope = scope.getParent();\n            depth++;\n        }\n    }\n    return depth;\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) \n    {\n        return scope.getDepth();\n    } \n    else \n    {\n        int depth = 0;\n        while (scope != null) \n        {\n            if (scope.isLexicalScope()) \n            {\n                depth += scope.getDepth();\n                break;\n            }\n            depth++;\n            scope = scope.getParent();\n        }\n        return depth;\n    }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    int depth = 0;\n    while (scope != null) \n    {\n        if (scope.isLexicalScope()) \n        {\n            return depth;\n        } \n        else \n        {\n            scope = scope.getParent();\n            depth++;\n        }\n    }\n    return depth;\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isDocInfoScope()) \n    {\n        return 0;\n    } \n    else if (scope.isPropertyScope()) \n    {\n        int depth = 0;\n        SymbolScope currentScope = scope;\n        while (currentScope != null) \n        {\n            if (currentScope.isLexicalScope()) \n            {\n                break;\n            }\n            currentScope = currentScope.getParent();\n            depth++;\n        }\n        return depth + getLexicalScopeDepth(currentScope);\n    } \n    else \n    {\n        return scope.getDepth();\n    }\n}"
    ],
    [
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    int rows = rawData.length;\n    int columns = rawData[0].length;\n\n    // number of blocks\n    int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blockData = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            int jWidth = blockWidth(jBlock);\n            blockData[index] = new double[iHeight * jWidth];\n            for (int i = 0; i < iHeight; ++i) {\n                for (int j = 0; j < jWidth; ++j) {\n                    blockData[index][i * jWidth + j] = rawData[iBlock * BLOCK_SIZE + i][jBlock * BLOCK_SIZE + j];\n                }\n            }\n        }\n    }\n\n    return blockData;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    int rows = rawData.length;\n    int columns = rawData[0].length;\n\n    // number of blocks\n    int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocks = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            int jWidth = blockWidth(jBlock);\n            blocks[index] = new double[iHeight * jWidth];\n            for (int i = 0; i < iHeight; ++i) {\n                for (int j = 0; j < jWidth; ++j) {\n                    blocks[index][i * jWidth + j] = rawData[iBlock * BLOCK_SIZE + i][jBlock * BLOCK_SIZE + j];\n                }\n            }\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    int rows = rawData.length;\n    int columns = rawData[0].length;\n\n    int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blockData = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            int jWidth = blockWidth(jBlock);\n            blockData[index] = new double[iHeight * jWidth];\n            for (int i = 0; i < iHeight; ++i) {\n                for (int j = 0; j < jWidth; ++j) {\n                    blockData[index][i * jWidth + j] = rawData[iBlock * BLOCK_SIZE + i][jBlock * BLOCK_SIZE + j];\n                }\n            }\n        }\n    }\n\n    return blockData;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    int rows = rawData.length;\n    int columns = rawData[0].length;\n\n    // number of blocks\n    int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocks = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            int jWidth = blockWidth(jBlock);\n            blocks[index] = new double[iHeight * jWidth];\n            for (int i = 0; i < iHeight; ++i) {\n                for (int j = 0; j < jWidth; ++j) {\n                    blocks[index][i * jWidth + j] = rawData[iBlock * BLOCK_SIZE + i][jBlock * BLOCK_SIZE + j];\n                }\n            }\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    int rows = rawData.length;\n    int columns = rawData[0].length;\n\n    // number of blocks\n    int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blockData = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            final int jWidth = blockWidth(jBlock);\n            blockData[index] = new double[iHeight * jWidth];\n            for (int i = 0; i < iHeight; ++i) {\n                for (int j = 0; j < jWidth; ++j) {\n                    blockData[index][i * jWidth + j] = rawData[iBlock * BLOCK_SIZE + i][jBlock * BLOCK_SIZE + j];\n                }\n            }\n        }\n    }\n\n    return blockData;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    int rows = rawData.length;\n    int columns = rawData[0].length;\n\n    int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocks = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            int jWidth = blockWidth(jBlock);\n            blocks[index] = new double[iHeight * jWidth];\n            for (int i = 0; i < iHeight; ++i) {\n                for (int j = 0; j < jWidth; ++j) {\n                    blocks[index][i * jWidth + j] = rawData[iBlock * BLOCK_SIZE + i][jBlock * BLOCK_SIZE + j];\n                }\n            }\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    int rows = rawData.length;\n    int columns = rawData[0].length;\n\n    // number of blocks\n    int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocks = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            int jWidth = blockWidth(jBlock);\n            blocks[index] = new double[iHeight * jWidth];\n            for (int i = 0; i < iHeight; ++i) {\n                for (int j = 0; j < jWidth; ++j) {\n                    blocks[index][i * jWidth + j] = rawData[iBlock * BLOCK_SIZE + i][jBlock * BLOCK_SIZE + j];\n                }\n            }\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    int rows = rawData.length;\n    int columns = rawData[0].length;\n\n    // number of blocks\n    int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocks = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            int jWidth = blockWidth(jBlock);\n            blocks[index] = new double[iHeight * jWidth];\n            for (int i = 0; i < iHeight; ++i) {\n                for (int j = 0; j < jWidth; ++j) {\n                    blocks[index][i * jWidth + j] = rawData[iBlock * BLOCK_SIZE + i][jBlock * BLOCK_SIZE + j];\n                }\n            }\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    int rows = rawData.length;\n    int columns = rawData[0].length;\n\n    // number of blocks\n    int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blockData = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            int jWidth = blockWidth(jBlock);\n            blockData[index] = new double[iHeight * jWidth];\n            for (int i = 0; i < iHeight; ++i) {\n                for (int j = 0; j < jWidth; ++j) {\n                    blockData[index][i * jWidth + j] = rawData[iBlock * BLOCK_SIZE + i][jBlock * BLOCK_SIZE + j];\n                }\n            }\n        }\n    }\n\n    return blockData;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    int rows = rawData.length;\n    int columns = rawData[0].length;\n\n    // number of blocks\n    int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocks = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            int jWidth = blockWidth(jBlock);\n            blocks[index] = new double[iHeight * jWidth];\n            for (int i = 0; i < iHeight; ++i) {\n                for (int j = 0; j < jWidth; ++j) {\n                    blocks[index][i * jWidth + j] = rawData[iBlock * BLOCK_SIZE + i][jBlock * BLOCK_SIZE + j];\n                }\n            }\n        }\n    }\n\n    return blocks;\n}"
    ],
    [
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  throws NullPointerException, IllegalArgumentException {\n        if (enumClass == null || values == null) {\n            throw new NullPointerException(\"Enum class and values cannot be null\");\n        }\n        if (!enumClass.isEnum()) {\n            throw new IllegalArgumentException(\"Provided class is not an enum class\");\n        }\n        if (enumClass.getEnumConstants().length > 64) {\n            throw new IllegalArgumentException(\"Enum class has more than 64 values\");\n        }\n        long bitVector = 0;\n        for (E value : values) {\n            if (value == null) {\n                throw new IllegalArgumentException(\"Value cannot be null\");\n            }\n            int ordinal = value.ordinal();\n            if (ordinal >= 64) {\n                throw new IllegalArgumentException(\"Value has an ordinal greater than 63\");\n            }\n            bitVector |= (1L << ordinal);\n        }\n        return bitVector;\n    }",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  throws NullPointerException, IllegalArgumentException {\n    if (enumClass == null || values == null) {\n        throw new NullPointerException(\"Enum class and values must not be null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"Class \" + enumClass.getName() + \" is not an enum\");\n    }\n    long bitVector = 0;\n    final int enumCount = enumClass.getEnumConstants().length;\n    if (enumCount > 64) {\n        throw new IllegalArgumentException(\"Enum \" + enumClass.getName() + \" has more than 64 values\");\n    }\n    for (E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"Value must not be null\");\n        }\n        int enumValue = value.ordinal();\n        if (enumValue < 0 || enumValue >= enumCount) {\n            throw new IllegalArgumentException(\"Value \" + value + \" is not valid for enum \" + enumClass.getName());\n        }\n        bitVector |= (1L << enumValue);\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  throws NullPointerException, IllegalArgumentException {\n    if (enumClass == null || values == null) {\n        throw new NullPointerException(\"Enum class and values cannot be null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"Provided class is not an enum class\");\n    }\n    long bitVector = 0;\n    final List<E> enumList = getEnumList(enumClass);\n    if (enumList.size() > 64) {\n        throw new IllegalArgumentException(\"Enum class has more than 64 values\");\n    }\n    for (E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"Value cannot be null\");\n        }\n        int index = enumList.indexOf(value);\n        if (index == -1) {\n            throw new IllegalArgumentException(\"Value is not part of the enum class\");\n        }\n        bitVector |= (1L << index);\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  throws NullPointerException, IllegalArgumentException {\n    if (enumClass == null || values == null) {\n        throw new NullPointerException(\"Class and values cannot be null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"Class \" + enumClass.getName() + \" is not an enum\");\n    }\n    long bitVector = 0;\n    for (E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"Value cannot be null\");\n        }\n        int ordinal = value.ordinal();\n        if (ordinal >= 64) {\n            throw new IllegalArgumentException(\"Enum \" + enumClass.getName() + \" has more than 64 values\");\n        }\n        bitVector |= (1L << ordinal);\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  throws NullPointerException, IllegalArgumentException {\n    // Check if the class is an enum\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"Class \" + enumClass.getName() + \" is not an enum\");\n    }\n\n    // Check if the enum has more than 64 values\n    if (enumClass.getEnumConstants().length > 64) {\n        throw new IllegalArgumentException(\"Enum \" + enumClass.getName() + \" has more than 64 values\");\n    }\n\n    // Initialize the bit vector\n    long bitVector = 0;\n\n    // Iterate over the values\n    for (E value : values) {\n        // Check if the value is null\n        if (value == null) {\n            throw new IllegalArgumentException(\"Value is null\");\n        }\n\n        // Add the value to the bit vector\n        bitVector |= (1L << value.ordinal());\n    }\n\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  throws NullPointerException, IllegalArgumentException {\n    // Check for null values\n    if (enumClass == null || values == null) {\n        throw new NullPointerException(\"Input values cannot be null\");\n    }\n\n    // Check if enumClass is an enum\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"Provided class is not an enum\");\n    }\n\n    // Check if enumClass has more than 64 values\n    if (enumClass.getEnumConstants().length > 64) {\n        throw new IllegalArgumentException(\"Provided enum has more than 64 values\");\n    }\n\n    long bitVector = 0;\n    for (E value : values) {\n        // Check for null values in values\n        if (value == null) {\n            throw new IllegalArgumentException(\"Provided values cannot contain null\");\n        }\n\n        // Check if value is valid for enumClass\n        if (!isValidEnum(enumClass, value.name())) {\n            throw new IllegalArgumentException(\"Provided value is not valid for the provided enum\");\n        }\n\n        // Set the corresponding bit in the bitVector\n        bitVector |= (1L << enumClass.getEnumConstants().length - Enum.valueOf(enumClass, value.name()).ordinal() - 1);\n    }\n\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  throws NullPointerException, IllegalArgumentException {\n    if (enumClass == null || values == null) {\n        throw new NullPointerException(\"Enum class and values cannot be null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"Provided class is not an enum class\");\n    }\n    if (enumClass.getEnumConstants().length > 64) {\n        throw new IllegalArgumentException(\"Enum class cannot have more than 64 values\");\n    }\n\n    long bitVector = 0;\n    for (E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"Value cannot be null\");\n        }\n        int index = value.ordinal();\n        bitVector |= (1L << index);\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  throws NullPointerException, IllegalArgumentException {\n    if (enumClass == null || values == null) {\n        throw new NullPointerException(\"Class and values cannot be null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"Class must be an enum class\");\n    }\n    long bitVector = 0;\n    for (E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"Values cannot be null\");\n        }\n        int ordinal = value.ordinal();\n        if (ordinal >= 64) {\n            throw new IllegalArgumentException(\"Enum has more than 64 values\");\n        }\n        bitVector |= (1L << ordinal);\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  throws NullPointerException, IllegalArgumentException {\n        // Your code goes here\n    }",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  throws NullPointerException, IllegalArgumentException {\n    if (enumClass == null || values == null) {\n        throw new NullPointerException(\"Enum class and values must not be null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"Provided class is not an enum class\");\n    }\n    long bitVector = 0;\n    final Map<String, E> enumMap = getEnumMap(enumClass);\n    for (E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"Enum value must not be null\");\n        }\n        bitVector |= (1L << enumMap.get(value.name()));\n    }\n    return bitVector;\n}"
    ],
    [
      "protected static Dfp expInternal(final Dfp a)  {\n        final Dfp result = a.getField().getOne();\n        final Dfp term = a;\n        Dfp factorial = a.getField().getOne();\n        Dfp x = a;\n        int i = 2;\n\n        while (true) \n        {\n            Dfp partial = x.divide(factorial);\n            result = result.add(partial);\n            if (partial.getLow().compareTo(Dfp.MIN_NORMAL) <= 0) \n            {\n                break;\n            }\n            x = x.multiply(a);\n            factorial = factorial.multiply(new Dfp(i++));\n        }\n        return result;\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = a.getField().getE();\n    Dfp term = a;\n    Dfp factorial = a.getOne();\n    int i = 2;\n\n    while (true) {\n        Dfp oldResult = result;\n        result = result.add(term);\n        if (result.equals(oldResult)) {\n            break;\n        }\n        term = term.multiply(a);\n        factorial = factorial.multiply(new Dfp(i));\n        term = term.divide(factorial);\n        i++;\n    }\n\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp x = a.multiply(Dfp.LOG2E);\n    final Dfp x2 = x.multiply(x);\n\n    final Dfp[] series = new Dfp[11];\n    series[0] = Dfp.ONE;\n    series[1] = x;\n    series[2] = x2.divide(Dfp.TWO);\n    series[3] = x2.multiply(x).divide(Dfp.SIX);\n    series[4] = x2.multiply(x2).divide(Dfp.TWENTY_FOUR);\n    series[5] = x2.multiply(x2).multiply(x).divide(Dfp.FOUR_HUNDRED_AND_EIGHTY);\n    series[6] = x2.multiply(x2).multiply(x2).divide(Dfp.ONE_MILLION_AND_SEVEN_HUNDRED_AND_TWENTY);\n    series[7] = x2.multiply(x2).multiply(x2).multiply(x).divide(Dfp.THREE_MILLION_AND_SIX_HUNDRED_AND_FORTY_EIGHT);\n    series[8] = x2.multiply(x2).multiply(x2).multiply(x2).divide(Dfp.SEVEN_MILLION_AND_FIVE_HUNDRED_AND_FOUR_HUNDRED);\n    series[9] = x2.multiply(x2).multiply(x2).multiply(x2).multiply(x).divide(Dfp.THIRTY_MILLION_AND_NINE_HUNDRED_AND_SIXTY_HUNDRED_AND_EIGHTY);\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n        final Dfp result;\n        final Dfp term;\n        final Dfp x = a.multiply(a);\n\n        result = Dfp.ONE;\n        term = Dfp.ONE;\n\n        for (int i = 2; i <= Dfp.EXP_TERMS; i++) \n        {\n            term = term.multiply(x).divide(Dfp.valueOf(i));\n            result = result.add(term);\n        }\n\n        return result;\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp result = a.getField().getOne();\n    final Dfp term = a;\n    Dfp factorial = result;\n    Dfp xpower = term;\n\n    for (int i = 2; i <= 20; i++) \n    {\n        factorial = factorial.multiply(new Dfp(i));\n        xpower = xpower.multiply(term);\n        result = result.add(xpower.divide(factorial));\n    }\n\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp ea = a.getField().getE();\n    final Dfp ea2 = ea.multiply(a);\n    final Dfp ea3 = ea2.multiply(a);\n    final Dfp ea4 = ea3.multiply(a);\n    final Dfp ea5 = ea4.multiply(a);\n    final Dfp ea6 = ea5.multiply(a);\n    final Dfp ea7 = ea6.multiply(a);\n    final Dfp ea8 = ea7.multiply(a);\n    final Dfp ea9 = ea8.multiply(a);\n    final Dfp ea10 = ea9.multiply(a);\n\n    final Dfp one = a.getField().getOne();\n    final Dfp two = one.add(one);\n    final Dfp six = two.add(two).add(two);\n    final Dfp twenty = six.add(six).add(six).add(six).add(six);\n    final Dfp fifty = twenty.multiply(twenty);\n    final Dfp oneHundred = fifty.multiply(twenty);\n    final Dfp fiveHundred = oneHundred.multiply(fifty);\n    final Dfp oneThousand = fiveHundred.multiply(two);\n\n    final Dfp ea_val = one.add(ea2.divide(two)).add(ea3.divide(six)).add(ea4.divide(twenty)).add(ea5.divide(fiveHundred)).add(ea6.divide(oneThousand));\n\n    return ea.multiply(ea_val);\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp result;\n    final Dfp term;\n    final Dfp powa = a.getField().getESplit();\n    final Dfp fact = new Dfp(1);\n\n    result = new Dfp(1);\n    term = a;\n\n    for (int i = 2; i <= Dfp.TERMS; i++) \n    {\n        fact = fact.multiply(new Dfp(i));\n        term = term.multiply(a);\n        result = result.add(term.divide(fact));\n    }\n\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp e = a.getField().getE();\n    final Dfp ea = pow(e, a.intValue());\n\n    Dfp result = ea.getField().getOne();\n    Dfp term = ea;\n    int n = 1;\n\n    while (true) {\n        result = result.add(term);\n        term = term.multiply(a).divide(new Dfp(n+1));\n        if (term.getMagnitude() < Dfp.EPSILON) {\n            break;\n        }\n        n++;\n    }\n\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = a.getField().getOne();\n    Dfp term = a;\n    int i = 2;\n\n    while (true) {\n        Dfp temp = term.divide(a.getField().getFactorial(i));\n        result = result.add(temp);\n        if (temp.getMagnitude() < Dfp.EPSILON) {\n            break;\n        }\n        term = term.multiply(a);\n        i++;\n    }\n\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp result;\n    final Dfp term;\n    final Dfp powa;\n    final Dfp fact;\n    final Dfp x = a.getField().getESplit();\n\n    // Compute e^a using a Taylor series\n    result = Dfp.ONE;\n    term = Dfp.ONE;\n    powa = Dfp.ONE;\n    fact = Dfp.ONE;\n\n    for (int i = 1; i <= Dfp.EXP_TERMS; i++) {\n        powa = powa.multiply(x);\n        fact = fact.multiply(Dfp.valueOf(i));\n        term = term.multiply(powa).divide(fact);\n        result = result.add(term);\n    }\n\n    return result;\n}"
    ],
    [
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    if (getNorm().getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n    }\n    FieldVector3D<T> orthogonalVector;\n    if (Math.abs(getX().getReal()) >= Math.abs(getY().getReal()) && Math.abs(getX().getReal()) >= Math.abs(getZ().getReal())) {\n        orthogonalVector = new FieldVector3D<T>(getY(), -getX(), getZ());\n    } else if (Math.abs(getY().getReal()) >= Math.abs(getZ().getReal())) {\n        orthogonalVector = new FieldVector3D<T>(-getX(), getY(), getZ());\n    } else {\n        orthogonalVector = new FieldVector3D<T>(-getX(), -getY(), getZ());\n    }\n    return orthogonalVector.normalize();\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    if (Math.abs(x.getReal()) > Math.abs(y.getReal())) {\n        return new FieldVector3D<T>(T.getField().getZero(), z, y, x.negate());\n    } else {\n        return new FieldVector3D<T>(T.getField().getZero(), y, z, x.negate());\n    }\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    if (x.getReal() == 0 && y.getReal() == 0) {\n        return new FieldVector3D<T>(z.negate(), Field.getInstance(T.class));\n    }\n    if (y.getReal() == 0 && z.getReal() == 0) {\n        return new FieldVector3D<T>(x.negate(), Field.getInstance(T.class));\n    }\n    if (z.getReal() == 0 && x.getReal() == 0) {\n        return new FieldVector3D<T>(y.negate(), Field.getInstance(T.class));\n    }\n    throw new MathArithmeticException(\"Cannot find an orthogonal vector to a zero vector.\");\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    if (Math.abs(getX().getReal()) > Math.abs(getY().getReal()) && Math.abs(getX().getReal()) > Math.abs(getZ().getReal())) {\n        return new FieldVector3D<T>(getY(), -getX(), getZ());\n    } else if (Math.abs(getY().getReal()) > Math.abs(getZ().getReal())) {\n        return new FieldVector3D<T>(getX(), getY(), -getZ());\n    } else {\n        return new FieldVector3D<T>(-getX(), getY(), getZ());\n    }\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    if (Math.abs(getX().getReal()) > Math.abs(getY().getReal()) && Math.abs(getX().getReal()) > Math.abs(getZ().getReal())) {\n        return new FieldVector3D<T>(getY(), -getX(), getZ());\n    } else if (Math.abs(getY().getReal()) > Math.abs(getZ().getReal())) {\n        return new FieldVector3D<T>(getX(), getY(), -getZ());\n    } else {\n        return new FieldVector3D<T>(-getX(), getY(), getZ());\n    }\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    if (Math.abs(x.getReal()) > Math.abs(y.getReal())) {\n        return new FieldVector3D<T>(T.getField().getZero(), z, y, x.negate());\n    } else {\n        return new FieldVector3D<T>(T.getField().getZero(), y, z, x.negate());\n    }\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    if (x.getReal() == 0 && y.getReal() == 0) {\n        return new FieldVector3D<T>(Field.getDefault(), 0, 1, 0);\n    }\n    return new FieldVector3D<T>(Field.getDefault(), -y.getReal(), x.getReal(), 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    if (Math.abs(x.getReal()) > Math.abs(y.getReal()) && Math.abs(x.getReal()) > Math.abs(z.getReal())) {\n        return new FieldVector3D<T>(y.subtract(z.multiply(y).divide(x)), x, y.divide(x), z.divide(x));\n    } else if (Math.abs(y.getReal()) > Math.abs(z.getReal())) {\n        return new FieldVector3D<T>(x.subtract(z.multiply(x).divide(y)), x.divide(y), y, z.divide(y));\n    } else {\n        return new FieldVector3D<T>(x.subtract(y.multiply(x).divide(z)), x.divide(z), y.divide(z), z);\n    }\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    if (Math.abs(getX().getReal()) > Math.abs(getY().getReal()) && Math.abs(getX().getReal()) > Math.abs(getZ().getReal())) {\n        return new FieldVector3D<T>(getY(), -getX(), getZ());\n    } else if (Math.abs(getY().getReal()) > Math.abs(getZ().getReal())) {\n        return new FieldVector3D<T>(getX(), getY(), -getZ());\n    } else {\n        return new FieldVector3D<T>(-getX(), getY(), getZ());\n    }\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    if (getNorm().getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n    }\n    FieldVector3D<T> orthogonalVector;\n    if (Math.abs(getX().getReal()) > Math.abs(getY().getReal()) && Math.abs(getX().getReal()) > Math.abs(getZ().getReal())) {\n        orthogonalVector = new FieldVector3D<T>(getY(), -getX(), getZ());\n    } else if (Math.abs(getY().getReal()) > Math.abs(getZ().getReal())) {\n        orthogonalVector = new FieldVector3D<T>(-getX(), getY(), getZ());\n    } else {\n        orthogonalVector = new FieldVector3D<T>(-getX(), -getY(), getZ());\n    }\n    return orthogonalVector.normalize();\n}"
    ],
    [
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) \n    {\n        throw new NullPointerException(\"Other range is null\");\n    }\n\n    if (!isOverlappedBy(other)) \n    {\n        throw new IllegalArgumentException(\"Other range does not overlap this range\");\n    }\n\n    T intersectionMinimum = maximum.compareTo(other.minimum) < 0 ? other.minimum : maximum;\n    T intersectionMaximum = other.maximum.compareTo(minimum) > 0 ? minimum : other.maximum;\n\n    return new Range<T>(intersectionMinimum, intersectionMaximum);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) \n    {\n        throw new NullPointerException(\"Other range is null\");\n    }\n    if (!isOverlappedBy(other)) \n    {\n        throw new IllegalArgumentException(\"Other range does not overlap this range\");\n    }\n    return new Range<T>(Math.max(minimum.compareTo(other.minimum), 0), Math.min(maximum.compareTo(other.maximum), 0));\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new NullPointerException(\"Other range is null\");\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Other range does not overlap this range\");\n    }\n    return new Range<T>(maximum.compareTo(other.maximum) <= 0 ? maximum : other.maximum, \n                        minimum.compareTo(other.minimum) >= 0 ? minimum : other.minimum);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) \n    {\n        throw new NullPointerException(\"Other range is null\");\n    }\n    if (!isOverlappedBy(other)) \n    {\n        throw new IllegalArgumentException(\"Other range does not overlap this range\");\n    }\n    return new Range<T>(Math.max(minimum.compareTo(other.minimum) < 0 ? minimum : other.minimum, maximum.compareTo(other.maximum) > 0 ? maximum : other.maximum);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) \n    {\n        throw new NullPointerException(\"Other range is null\");\n    }\n    if (!isOverlappedBy(other)) \n    {\n        throw new IllegalArgumentException(\"Other range does not overlap this range\");\n    }\n    return new Range<T>(max(minimum, other.minimum), min(maximum, other.maximum));\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) \n    {\n        throw new NullPointerException(\"Other range is null\");\n    }\n\n    if (!isOverlappedBy(other)) \n    {\n        throw new IllegalArgumentException(\"Other range does not overlap this range\");\n    }\n\n    T newMinimum = maximum(other.minimum);\n    T newMaximum = minimum(other.maximum);\n\n    return new Range<T>(newMinimum, newMaximum);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) \n    {\n        throw new NullPointerException(\"Other range is null\");\n    }\n    if (!isOverlappedBy(other)) \n    {\n        throw new IllegalArgumentException(\"Other range does not overlap this range\");\n    }\n    return new Range<T>(max(minimum, other.minimum), min(maximum, other.maximum));\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) \n    {\n        throw new NullPointerException(\"Range is null\");\n    }\n    if (!isOverlappedBy(other)) \n    {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    return new Range<T>(maximum.compareTo(other.maximum) < 0 ? maximum : other.maximum, \n                        minimum.compareTo(other.minimum) > 0 ? minimum : other.minimum);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new NullPointerException(\"Other range is null\");\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Other range does not overlap this range\");\n    }\n    T min = maximum.compareTo(other.minimum) < 0 ? other.minimum : maximum;\n    T max = minimum.compareTo(other.maximum) > 0 ? other.maximum : minimum;\n    return new Range<T>(min, max);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) \n    {\n        throw new NullPointerException(\"Other range is null\");\n    }\n    if (!isOverlappedBy(other)) \n    {\n        throw new IllegalArgumentException(\"Other range does not overlap this range\");\n    }\n    return new Range<T>(max(minimum, other.minimum), min(maximum, other.maximum));\n}"
    ],
    [
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    OutputStreamWriter writer = new OutputStreamWriter(out, StandardCharsets.UTF_8);\n    return _createGenerator(writer, ctxt);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    OutputStreamWriter writer = new OutputStreamWriter(out, StandardCharsets.UTF_8);\n    return _createGenerator(writer, ctxt);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    WriterBasedJsonGenerator gen = new WriterBasedJsonGenerator(ctxt,\n            _generatorFeatures, _objectCodec, new OutputStreamWriter(out, StandardCharsets.UTF_8));\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    OutputStreamWriter writer = new OutputStreamWriter(out, StandardCharsets.UTF_8);\n    return _createGenerator(writer, ctxt);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    OutputStreamWriter writer = new OutputStreamWriter(out, StandardCharsets.UTF_8);\n    return _createGenerator(writer, ctxt);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    OutputStreamWriter writer = new OutputStreamWriter(out, StandardCharsets.UTF_8);\n    return _createGenerator(writer, ctxt);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    WriterBasedJsonGenerator gen = new WriterBasedJsonGenerator(ctxt,\n            _generatorFeatures, _objectCodec, new OutputStreamWriter(out, \"UTF-8\"));\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    OutputStreamWriter writer = new OutputStreamWriter(out, StandardCharsets.UTF_8);\n    return _createGenerator(writer, ctxt);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    OutputStreamWriter writer = new OutputStreamWriter(out, StandardCharsets.UTF_8);\n    return _createGenerator(writer, ctxt);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    OutputStreamWriter writer = new OutputStreamWriter(out, StandardCharsets.UTF_8);\n    return _createGenerator(writer, ctxt);\n}"
    ],
    [
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) \n    {\n        return Arrays.equals(type.getComponentType(), (Object[]) o1, (Object[]) o2);\n    }\n    if (type.isEnum()) \n    {\n        return type.cast(o1) == type.cast(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) \n    {\n        return Arrays.equals(type.getComponentType(), (Object[]) o1, (Object[]) o2);\n    }\n    if (type.isEnum()) \n    {\n        return type.cast(o1) == type.cast(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) \n    {\n        return Arrays.equals(type.getComponentType(), (Object[]) o1, (Object[]) o2);\n    }\n    if (type.isEnum()) \n    {\n        return type.cast(o1) == type.cast(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) \n    {\n        return Arrays.equals(o1, o2);\n    }\n    if (type.isEnum()) \n    {\n        return type.cast(o1) == type.cast(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) \n    {\n        return Arrays.equals(type.getComponentType(), (Object[]) o1, (Object[]) o2);\n    }\n    if (type.isEnum()) \n    {\n        return type.cast(o1) == type.cast(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) \n    {\n        return Arrays.equals(o1, o2);\n    }\n    if (type.isEnum()) \n    {\n        return type.cast(o1) == type.cast(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) \n    {\n        return Arrays.equals(type.getComponentType(), (Object[]) o1, (Object[]) o2);\n    }\n    if (type.isEnum()) \n    {\n        return type.cast(o1) == type.cast(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) \n    {\n        return Arrays.equals(type.getComponentType(), (Object[]) o1, (Object[]) o2);\n    }\n    if (type.isEnum()) \n    {\n        return type.cast(o1) == type.cast(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) \n    {\n        return Arrays.equals(type.getComponentType(), (Object[]) o1, (Object[]) o2);\n    }\n    if (type.isEnum()) \n    {\n        return type.cast(o1) == type.cast(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) \n    {\n        return Arrays.equals(o1, o2);\n    }\n    if (type.isEnum()) \n    {\n        return type.cast(o1) == type.cast(o2);\n    }\n    return o1.equals(o2);\n}"
    ],
    [
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isUnresolvedType()) {\n      return type.getNativeType(JSTypeNative.NO_TYPE);\n    }\n    return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isUnresolvedType()) {\n      return type.getNativeType(JSTypeNative.NO_TYPE);\n    }\n    return type;\n  }",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isUnresolvedType()) {\n      return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n    }\n    return type;\n  }",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isUnresolvedType()) {\n      return type.getNativeType(JSTypeNative.NO_TYPE);\n    }\n    return type;\n  }",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isUnresolvedType()) \n    {\n        return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n    }\n    return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isUnresolvedType()) {\n      return type.getNativeType(JSTypeNative.NO_TYPE);\n    }\n    return type;\n  }",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isUnresolvedType()) {\n      return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n    }\n    return type;\n  }",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isUnresolvedType()) {\n      return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n    }\n    return type;\n  }",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isUnresolvedType()) {\n      return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n    }\n    return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isUnresolvedType()) {\n      return type.getNativeType(JSTypeNative.NO_TYPE);\n    }\n    return type;\n}"
    ],
    [
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    // If the restrictedType differs from the originalType, then we should\n    // branch the current flow scope and create a new flow scope with the name\n    // declared with the new type.\n    if (restrictedType != null && !restrictedType.equals(originalType)) \n    {\n        // We try not to create spurious child flow scopes as this makes type\n        // inference slower.\n        //\n        // We also do not want spurious slots around in type inference, because\n        // we use these as a signal for \"checked unknown\" types. A \"checked unknown\"\n        // type is a symbol that the programmer has already checked and verified that\n        // it's defined, even if we don't know what it is.\n        //\n        // It is OK to pass non-name nodes into this method, as long as you pass\n        // in {@code null} for a restricted type.\n        if (node instanceof Name) \n        {\n            // Branch the current flow scope and create a new flow scope with the name\n            // declared with the new type.\n            FlowScope newScope = blindScope.createChildFlowScope();\n            newScope.inferSlotType(((Name) node).getSlot(), restrictedType);\n            return newScope;\n        }\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (originalType == null || restrictedType == null) {\n        return blindScope;\n    }\n\n    if (originalType.equals(restrictedType)) {\n        return blindScope;\n    }\n\n    // Check if the restricted type is a subtype of the original type\n    if (!originalType.isSubtypeOf(restrictedType)) {\n        return blindScope;\n    }\n\n    // Create a new scope with the restricted type\n    FlowScope newScope = blindScope.createChildFlowScope();\n    newScope.inferSlotType(node.getName(), restrictedType);\n    return newScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (originalType == null) {\n        return blindScope;\n    }\n\n    if (restrictedType == null || originalType.equals(restrictedType)) {\n        return blindScope;\n    }\n\n    if (blindScope.findSlot(node.getName()) != null) {\n        return blindScope;\n    }\n\n    FlowScope newScope = blindScope.createChildFlowScope();\n    newScope.inferSlotType(node.getName(), restrictedType);\n    return newScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (originalType == null || restrictedType == null) {\n        return blindScope;\n    }\n\n    if (originalType.equals(restrictedType)) {\n        return blindScope;\n    }\n\n    // create new scope\n    FlowScope newScope = blindScope.createChildFlowScope();\n    newScope.inferSlotType(node.getName(), restrictedType);\n\n    return newScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null || restrictedType.equals(originalType)) {\n      return blindScope;\n    }\n\n    FlowScope newScope = blindScope.createChildFlowScope();\n    newScope.inferSlotType(node.getName(), restrictedType);\n    return newScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (originalType == null) {\n      return blindScope;\n    }\n\n    if (restrictedType == null) {\n      return blindScope;\n    }\n\n    if (originalType.equals(restrictedType)) {\n      return blindScope;\n    }\n\n    // Check if the restricted type is a subtype of the original type\n    if (!originalType.isSubtypeOf(restrictedType)) {\n      return blindScope;\n    }\n\n    // Create a new scope with the restricted type\n    FlowScope newScope = blindScope.createChildFlowScope();\n    newScope.inferSlotType(node.getName(), restrictedType);\n    return newScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (originalType == null || restrictedType == null) {\n        return blindScope;\n    }\n\n    if (originalType.equals(restrictedType)) {\n        return blindScope;\n    }\n\n    String name = node.getName();\n    if (name == null) {\n        return blindScope;\n    }\n\n    StaticSlot<JSType> slot = blindScope.findSlot(name);\n    if (slot == null) {\n        return blindScope;\n    }\n\n    if (!slot.getType().equals(originalType)) {\n        return blindScope;\n    }\n\n    FlowScope newScope = blindScope.createChildFlowScope();\n    newScope.inferSlotType(name, restrictedType);\n    return newScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    // If the restrictedType is the same as the originalType, then there's no\n    // need to restrict the type, so we can just return the blindScope.\n    if (restrictedType == null || restrictedType.equals(originalType)) {\n      return blindScope;\n    }\n\n    // If the restrictedType differs from the originalType, then we should\n    // branch the current flow scope and create a new flow scope with the name\n    // declared with the new type.\n    FlowScope newScope = blindScope.createChildFlowScope();\n    newScope.inferSlotType(node.getName(), restrictedType);\n    return newScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null) {\n        return blindScope;\n    }\n\n    if (originalType == null) {\n        originalType = node.getJSType();\n    }\n\n    if (originalType.equals(restrictedType)) {\n        return blindScope;\n    }\n\n    FlowScope newScope = blindScope.createChildFlowScope();\n    newScope.inferSlotType(node.getName(), restrictedType);\n\n    return newScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    // If the restrictedType is the same as the originalType, then there's\n    // no need to restrict the type.\n    if (restrictedType == null || restrictedType.equals(originalType)) {\n        return blindScope;\n    }\n\n    // If the restrictedType differs from the originalType, then we should\n    // branch the current flow scope and create a new flow scope with the name\n    // declared with the new type.\n    FlowScope newScope = blindScope.createChildFlowScope();\n    newScope.inferSlotType(node.getName(), restrictedType);\n    return newScope;\n}"
    ],
    [
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token != JsDocToken.STRING || !\"function\".equals(stream.getString())) {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    Node functionTypeNode = newNode(Token.FUNCTION_TYPE);\n    functionTypeNode.addChildToFront(newStringNode(\"function\"));\n\n    if (match(JsDocToken.LT)) {\n      next();\n      skipEOLs();\n      Node typeParameters = parseTypeParameters(next());\n      if (typeParameters != null) {\n        functionTypeNode.addChildToFront(typeParameters);\n      }\n\n      skipEOLs();\n      if (!match(JsDocToken.GT)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n      }\n\n      next();\n    }\n\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    next();\n    skipEOLs();\n\n    Node thisType = parseTypeName(next());\n    if (thisType == null || !\"this\".equals(thisType.getString())) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n\n    next();\n    skipEOLs();\n\n    Node typeName = parseTypeName(next());\n    if (typeName == null) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.typename\");\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.COMMA)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.comma\");\n    }\n\n    next();\n    skipEOLs();\n\n    Node parametersType = parseParametersType(next());\n    if (parametersType == null) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.parameters\");\n    }\n\n    skipEOLs();\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionTypeNode = newNode(Token.FUNCTION_TYPE);\n    if (!match(JsDocToken.STRING, \"function\")) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.function\");\n    }\n    next();\n\n    if (match(JsDocToken.LT)) {\n      Node typeParameters = parseTypeParameters(next());\n      if (typeParameters != null) {\n        functionTypeNode.addChildToFront(typeParameters);\n      }\n    }\n\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lparen\");\n    }\n    next();\n\n    if (!match(JsDocToken.STRING, \"this\")) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n    }\n    next();\n\n    if (!match(JsDocToken.COLON)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n\n    Node thisType = parseTypeName(next());\n    if (thisType == null) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.invalid.thisType\");\n    }\n    functionTypeNode.addChildToFront(thisType);\n\n    Node parametersType = parseParametersType(next());\n    if (parametersType == null) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.invalid.parametersType\");\n    }\n    functionTypeNode.addChildToFront(parametersType);\n\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rparen\");\n    }\n    next();\n\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.invalid.resultType\");\n    }\n    functionTypeNode.addChildToFront(resultType);\n\n    return functionTypeNode;\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionTypeNode = newNode(Token.FUNCTION_TYPE);\n    if (!match(JsDocToken.STRING, \"function\")) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.function\");\n    }\n    next();\n\n    Node typeParametersNode = parseTypeParameters(next());\n    if (typeParametersNode != null) {\n      functionTypeNode.addChild(typeParametersNode);\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n\n    if (!match(JsDocToken.STRING, \"this\")) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n    }\n    next();\n\n    if (!match(JsDocToken.COLON)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n\n    Node typeNameNode = parseTypeName(next());\n    if (typeNameNode == null) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.invalid.typename\");\n    }\n    functionTypeNode.addChild(typeNameNode);\n\n    Node parametersTypeNode = parseParametersType(next());\n    if (parametersTypeNode != null) {\n      functionTypeNode.addChild(parametersTypeNode);\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n\n    Node resultTypeNode = parseResultType(next());\n    if (resultTypeNode != null) {\n      functionTypeNode.addChild(resultTypeNode);\n    }\n\n    return functionTypeNode;\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token != JsDocToken.STRING || !\"function\".equals(stream.getString())) {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    Node functionTypeNode = newNode(Token.FUNCTION_TYPE);\n\n    if (match(JsDocToken.LT)) {\n      next();\n      Node typeParameters = parseTypeParameters(next());\n      if (typeParameters != null) {\n        functionTypeNode.addChildToFront(typeParameters);\n      }\n\n      skipEOLs();\n      if (!match(JsDocToken.GT)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n      }\n\n      next();\n    }\n\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    next();\n    skipEOLs();\n\n    if (!match(JsDocToken.STRING) || !\"this\".equals(stream.getString())) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.invalid.this\");\n    }\n\n    next();\n    skipEOLs();\n\n    if (!match(JsDocToken.COLON)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n\n    next();\n    skipEOLs();\n\n    Node thisType = parseTypeName(next());\n    if (thisType == null) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.invalid.this.type\");\n    }\n\n    functionTypeNode.addChildToFront(thisType);\n\n    Node parametersType = parseParametersType(next());\n    if (parametersType != null) {\n      functionTypeNode.addChildToFront(parametersType);\n    }\n\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    next();\n    skipEOLs();\n\n    Node resultType = parseResultType(next());\n    if (resultType != null) {\n}\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token != JsDocToken.STRING || !\"function\".equals(stream.getString())) {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    Node functionTypeNode = newNode(Token.FUNCTION_TYPE);\n\n    skipEOLs();\n    if (match(JsDocToken.LT)) {\n      Node typeParameters = parseTypeParameters(next());\n      functionTypeNode.addChildToFront(typeParameters);\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.STRING) || !\"this\".equals(stream.getString())) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.invalid.this\");\n    }\n\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n\n    next();\n    Node thisType = parseTypeName(next());\n    functionTypeNode.addChildToFront(thisType);\n\n    skipEOLs();\n    Node parametersType = parseParametersType(next());\n    functionTypeNode.addChildToFront(parametersType);\n\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    next();\n    Node resultType = parseResultType(next());\n    functionTypeNode.addChildToFront(resultType);\n\n    return functionTypeNode;\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token != JsDocToken.STRING || !\"function\".equals(stream.getString())) \n    {\n        return reportGenericTypeSyntaxWarning();\n    }\n\n    Node functionTypeNode = newNode(Token.FUNCTION_TYPE);\n    next();\n    skipEOLs();\n\n    if (match(JsDocToken.LT)) \n    {\n        next();\n        Node typeParameters = parseTypeParameters(next());\n        if (typeParameters != null) \n        {\n            functionTypeNode.addChildToFront(typeParameters);\n        }\n\n        skipEOLs();\n        if (!match(JsDocToken.GT)) \n        {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n        }\n\n        next();\n    }\n\n    if (!match(JsDocToken.LP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    next();\n    skipEOLs();\n\n    if (!match(JsDocToken.STRING) || !\"this\".equals(stream.getString())) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n    }\n\n    next();\n    skipEOLs();\n\n    if (!match(JsDocToken.COLON)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n\n    next();\n    skipEOLs();\n\n    Node thisType = parseTypeName(next());\n    if (thisType == null) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.invalid.thisType\");\n    }\n\n    functionTypeNode.addChildToFront(thisType);\n\n    if (!match(JsDocToken.COMMA)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.comma\");\n    }\n\n    next();\n    skipEOLs();\n\n    Node parametersType = parseParametersType(next());\n    if (parametersType == null) \n    {\n}\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionTypeNode = newNode(Token.FUNCTION);\n    if (!match(JsDocToken.STRING, \"function\")) \n    {\n        return reportGenericTypeSyntaxWarning();\n    }\n    next();\n    skipEOLs();\n\n    // Parse TypeParameters\n    if (match(JsDocToken.LT)) \n    {\n        next();\n        Node typeParametersNode = parseTypeParameters();\n        if (typeParametersNode != null) \n        {\n            functionTypeNode.addChildToFront(typeParametersNode);\n        }\n        else \n        {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.typeparameters\");\n        }\n    }\n\n    // Parse '('\n    if (!match(JsDocToken.LP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n    skipEOLs();\n\n    // Parse 'this'\n    if (!match(JsDocToken.STRING, \"this\")) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n    }\n    next();\n\n    // Parse ':'\n    if (!match(JsDocToken.COLON)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n    skipEOLs();\n\n    // Parse TypeName\n    Node typeNameNode = parseTypeName(next());\n    if (typeNameNode == null) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.typename\");\n    }\n    functionTypeNode.addChildToFront(typeNameNode);\n\n    // Parse ParametersType\n    Node parametersTypeNode = parseParametersType();\n    if (parametersTypeNode != null) \n    {\n        functionTypeNode.addChildToFront(parametersTypeNode);\n    }\n    else \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.parameters\");\n    }\n\n    // Parse ')'\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionTypeNode = newNode(Token.FUNCTION_TYPE);\n    if (!match(JsDocToken.STRING, \"function\")) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.function\");\n    }\n    next();\n    skipEOLs();\n    Node typeParameters = parseTypeParameters(next());\n    if (typeParameters != null) {\n      functionTypeNode.addChildToFront(typeParameters);\n    }\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.STRING, \"this\")) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n    }\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n    skipEOLs();\n    Node typeName = parseTypeName(next());\n    if (typeName != null) {\n      functionTypeNode.addChildToFront(typeName);\n    }\n    Node parametersType = parseParametersType(next());\n    if (parametersType != null) {\n      functionTypeNode.addChildToFront(parametersType);\n    }\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType != null) {\n      functionTypeNode.addChildToFront(resultType);\n    }\n    return functionTypeNode;\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionTypeNode = newNode(Token.FUNCTION_TYPE);\n\n    if (token != JsDocToken.STRING || !\"function\".equals(stream.getString())) {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    next();\n    skipEOLs();\n\n    // Parse TypeParameters\n    if (match(JsDocToken.LT)) {\n      Node typeParametersNode = parseTypeParameters(next());\n      if (typeParametersNode != null) {\n        functionTypeNode.addChildToFront(typeParametersNode);\n      }\n    }\n\n    // Parse '('\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n\n    // Parse 'this'\n    if (!match(JsDocToken.STRING) || !\"this\".equals(stream.getString())) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n    }\n    next();\n\n    // Parse ':'\n    if (!match(JsDocToken.COLON)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n\n    // Parse TypeName\n    Node typeNameNode = parseTypeName(next());\n    if (typeNameNode == null) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.invalid.typename\");\n    }\n    functionTypeNode.addChildToFront(typeNameNode);\n\n    // Parse ParametersType\n    Node parametersTypeNode = parseParametersType(next());\n    if (parametersTypeNode == null) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.invalid.parameters\");\n    }\n    functionTypeNode.addChildToFront(parametersTypeNode);\n\n    // Parse ')'\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n\n    // Parse ResultType\n    Node resultTypeNode = parseResultType(next());\n    if (resultTypeNode == null) {\n}\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionTypeNode = newNode(Token.FUNCTION_TYPE);\n    if (token == JsDocToken.STRING && \"function\".equals(stream.getString())) {\n      functionTypeNode.addChildToFront(newStringNode(\"function\"));\n      next();\n      skipEOLs();\n      if (match(JsDocToken.LT)) {\n        next();\n        Node typeParams = parseTypeParameters(next());\n        if (typeParams != null) {\n          functionTypeNode.addChildToFront(typeParams);\n        }\n        skipEOLs();\n        if (!match(JsDocToken.GT)) {\n          return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n        }\n        next();\n        skipEOLs();\n        if (!match(JsDocToken.LP)) {\n          return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n        }\n        next();\n        skipEOLs();\n        if (!match(JsDocToken.STRING)) {\n          return reportTypeSyntaxWarning(\"msg.jsdoc.missing.string\");\n        }\n        if (!\"this\".equals(stream.getString())) {\n          return reportTypeSyntaxWarning(\"msg.jsdoc.invalid.this\");\n        }\n        functionTypeNode.addChildToFront(newStringNode(\"this\"));\n        next();\n        skipEOLs();\n        if (!match(JsDocToken.COLON)) {\n          return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n        }\n        next();\n        skipEOLs();\n        Node typeName = parseTypeName(next());\n        if (typeName != null) {\n          functionTypeNode.addChildToFront(typeName);\n        }\n        skipEOLs();\n        if (!match(JsDocToken.COMMA)) {\n          return reportTypeSyntaxWarning(\"msg.jsdoc.missing.comma\");\n        }\n        next();\n        skipEOLs();\n        Node parametersType = parseParametersType(next());\n        if (parametersType != null) {\n          functionTypeNode.addChildToFront(parametersType);\n        }\n}\n}\n}"
    ],
    [
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int size = str.length();\n    final StringBuilder out = new StringBuilder(size);\n    for (int i = 0; i < size; i++) {\n        final char c = str.charAt(i);\n        if (!Character.isWhitespace(c)) {\n            out.append(c);\n        }\n    }\n    return out.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int size = str.length();\n    final StringBuilder out = new StringBuilder(size);\n    for (int i = 0; i < size; i++) {\n        final char c = str.charAt(i);\n        if (!Character.isWhitespace(c)) {\n            out.append(c);\n        }\n    }\n    return out.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int size = str.length();\n    final StringBuilder out = new StringBuilder(size);\n    for (int i = 0; i < size; i++) {\n        final char c = str.charAt(i);\n        if (!Character.isWhitespace(c)) {\n            out.append(c);\n        }\n    }\n    return out.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    final StringBuilder out = new StringBuilder(len);\n    for (int i = 0; i < len; i++) {\n        final char c = str.charAt(i);\n        if (!Character.isWhitespace(c)) {\n            out.append(c);\n        }\n    }\n    return out.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    final StringBuilder out = new StringBuilder(len);\n    for (int i = 0; i < len; i++) {\n        final char c = str.charAt(i);\n        if (!Character.isWhitespace(c)) {\n            out.append(c);\n        }\n    }\n    return out.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    final StringBuilder out = new StringBuilder(len);\n    for (int i = 0; i < len; i++) {\n        final char c = str.charAt(i);\n        if (!Character.isWhitespace(c)) {\n            out.append(c);\n        }\n    }\n    return out.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int size = str.length();\n    final StringBuilder out = new StringBuilder(size);\n    for (int i = 0; i < size; i++) {\n        final char c = str.charAt(i);\n        if (!Character.isWhitespace(c)) {\n            out.append(c);\n        }\n    }\n    return out.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int size = str.length();\n    final StringBuilder out = new StringBuilder(size);\n    for (int i = 0; i < size; i++) {\n        final char c = str.charAt(i);\n        if (!Character.isWhitespace(c)) {\n            out.append(c);\n        }\n    }\n    return out.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int size = str.length();\n    final StringBuilder out = new StringBuilder(size);\n    for (int i = 0; i < size; i++) {\n        final char c = str.charAt(i);\n        if (!Character.isWhitespace(c)) {\n            out.append(c);\n        }\n    }\n    return out.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    final StringBuilder out = new StringBuilder(len);\n    for (int i = 0; i < len; i++) {\n        final char c = str.charAt(i);\n        if (!Character.isWhitespace(c)) {\n            out.append(c);\n        }\n    }\n    return out.toString();\n}"
    ],
    [
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    double sum = 0.0;\n    double sumsq = 0.0;\n    double max = Double.NEGATIVE_INFINITY;\n    double min = Double.POSITIVE_INFINITY;\n    int n = 0;\n\n    for (SummaryStatistics stat : statistics) {\n        sum += stat.getSum();\n        sumsq += stat.getSumsq();\n        max = Math.max(max, stat.getMax());\n        min = Math.min(min, stat.getMin());\n        n += stat.getN();\n    }\n\n    double mean = sum / n;\n    double variance = (sumsq - n * mean * mean) / (n - 1);\n\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) \n    {\n        return null;\n    }\n\n    double sum = 0;\n    double sumsq = 0;\n    double max = Double.NEGATIVE_INFINITY;\n    double min = Double.POSITIVE_INFINITY;\n    long n = 0;\n\n    for (SummaryStatistics stat : statistics) \n    {\n        sum += stat.getSum();\n        sumsq += stat.getSumsq();\n        max = Math.max(max, stat.getMax());\n        min = Math.min(min, stat.getMin());\n        n += stat.getN();\n    }\n\n    double mean = sum / n;\n    double variance = (sumsq - n * mean * mean) / (n - 1);\n\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    double sum = 0;\n    double sumOfSquares = 0;\n    double max = Double.NEGATIVE_INFINITY;\n    double min = Double.POSITIVE_INFINITY;\n    long n = 0;\n\n    for (SummaryStatistics stat : statistics) {\n        sum += stat.getSum();\n        sumOfSquares += stat.getSumsq();\n        max = Math.max(max, stat.getMax());\n        min = Math.min(min, stat.getMin());\n        n += stat.getN();\n    }\n\n    double mean = sum / n;\n    double variance = (sumOfSquares / n) - (mean * mean);\n\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    double sum = 0;\n    double sumsq = 0;\n    double max = Double.NEGATIVE_INFINITY;\n    double min = Double.POSITIVE_INFINITY;\n    long n = 0;\n\n    for (SummaryStatistics stat : statistics) {\n        sum += stat.getSum();\n        sumsq += stat.getSumsq();\n        max = Math.max(max, stat.getMax());\n        min = Math.min(min, stat.getMin());\n        n += stat.getN();\n    }\n\n    double mean = sum / n;\n    double variance = (sumsq - n * mean * mean) / (n - 1);\n\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    double sum = 0;\n    double sumOfSquares = 0;\n    double max = Double.NEGATIVE_INFINITY;\n    double min = Double.POSITIVE_INFINITY;\n    long n = 0;\n\n    for (SummaryStatistics stat : statistics) {\n        sum += stat.getSum();\n        sumOfSquares += stat.getSumsq();\n        max = Math.max(max, stat.getMax());\n        min = Math.min(min, stat.getMin());\n        n += stat.getN();\n    }\n\n    double mean = sum / n;\n    double variance = (sumOfSquares / n) - (mean * mean);\n\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) \n    {\n        return null;\n    }\n\n    double sum = 0;\n    double sumOfSquares = 0;\n    double max = Double.NEGATIVE_INFINITY;\n    double min = Double.POSITIVE_INFINITY;\n    int n = 0;\n\n    for (SummaryStatistics stat : statistics) \n    {\n        sum += stat.getSum();\n        sumOfSquares += stat.getSumsq();\n        max = Math.max(max, stat.getMax());\n        min = Math.min(min, stat.getMin());\n        n += stat.getN();\n    }\n\n    double mean = sum / n;\n    double variance = (sumOfSquares / n) - (mean * mean);\n\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) \n    {\n        return null;\n    }\n\n    double sum = 0;\n    double sumsq = 0;\n    double max = Double.NEGATIVE_INFINITY;\n    double min = Double.POSITIVE_INFINITY;\n    long n = 0;\n\n    for (SummaryStatistics stat : statistics) \n    {\n        sum += stat.getSum();\n        sumsq += stat.getSumsq();\n        max = Math.max(max, stat.getMax());\n        min = Math.min(min, stat.getMin());\n        n += stat.getN();\n    }\n\n    double mean = sum / n;\n    double variance = (sumsq / n) - (mean * mean);\n\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) \n    {\n        return null;\n    }\n\n    double sum = 0;\n    double sumsq = 0;\n    double max = Double.NEGATIVE_INFINITY;\n    double min = Double.POSITIVE_INFINITY;\n    long n = 0;\n\n    for (SummaryStatistics stat : statistics) \n    {\n        sum += stat.getSum();\n        sumsq += stat.getSumsq();\n        max = Math.max(max, stat.getMax());\n        min = Math.min(min, stat.getMin());\n        n += stat.getN();\n    }\n\n    double mean = sum / n;\n    double variance = (sumsq - n * mean * mean) / (n - 1);\n\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) \n    {\n        return null;\n    }\n\n    double sum = 0;\n    double sumOfSquares = 0;\n    double max = Double.NEGATIVE_INFINITY;\n    double min = Double.POSITIVE_INFINITY;\n    long count = 0;\n\n    for (SummaryStatistics stat : statistics) \n    {\n        sum += stat.getSum();\n        sumOfSquares += stat.getSumsq();\n        max = Math.max(max, stat.getMax());\n        min = Math.min(min, stat.getMin());\n        count += stat.getN();\n    }\n\n    double mean = sum / count;\n    double variance = (sumOfSquares / count) - (mean * mean);\n\n    return new StatisticalSummaryValues(mean, variance, count, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    double sum = 0.0;\n    double sumOfSquares = 0.0;\n    double max = Double.NEGATIVE_INFINITY;\n    double min = Double.POSITIVE_INFINITY;\n    int n = 0;\n\n    for (SummaryStatistics stat : statistics) {\n        sum += stat.getSum();\n        sumOfSquares += stat.getSumsq();\n        max = Math.max(max, stat.getMax());\n        min = Math.min(min, stat.getMin());\n        n += stat.getN();\n    }\n\n    double mean = sum / n;\n    double variance = (sumOfSquares / n) - (mean * mean);\n\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}"
    ],
    [
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += Math.pow(sample1[i] - sample2[i] - meanDifference, 2);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += Math.pow(sample1[i] - sample2[i] - meanDifference, 2);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += Math.pow((sample1[i] - sample2[i]) - meanDifference, 2);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += Math.pow(sample1[i] - sample2[i] - meanDifference, 2);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += Math.pow((sample1[i] - sample2[i]) - meanDifference, 2);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += Math.pow((sample1[i] - sample2[i]) - meanDifference, 2);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += Math.pow((sample1[i] - sample2[i]) - meanDifference, 2);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += Math.pow(sample1[i] - sample2[i] - meanDifference, 2);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += Math.pow((sample1[i] - sample2[i]) - meanDifference, 2);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += Math.pow((sample1[i] - sample2[i]) - meanDifference, 2);\n        }\n        return result / (n - 1);\n    }"
    ],
    [
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    Iterator iterator = dataset.getKeys().iterator();\n    while (iterator.hasNext()) \n    {\n        Comparable key = (Comparable) iterator.next();\n        Number value = dataset.getValue(key);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    Iterator iterator = dataset.getKeys().iterator();\n    while (iterator.hasNext()) \n    {\n        Comparable key = (Comparable) iterator.next();\n        Number value = dataset.getValue(key);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    Iterator iterator = dataset.getKeys().iterator();\n    while (iterator.hasNext()) \n    {\n        Comparable key = (Comparable) iterator.next();\n        Number value = dataset.getValue(key);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    Iterator iterator = dataset.getKeys().iterator();\n    while (iterator.hasNext()) \n    {\n        Comparable key = (Comparable) iterator.next();\n        Number value = dataset.getValue(key);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    Iterator iterator = dataset.getKeys().iterator();\n    while (iterator.hasNext()) \n    {\n        Comparable key = (Comparable) iterator.next();\n        Number value = dataset.getValue(key);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    Iterator<Comparable> keys = dataset.getKeys().iterator();\n    while (keys.hasNext()) \n    {\n        Comparable key = keys.next();\n        Number value = dataset.getValue(key);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    Iterator iterator = dataset.getKeys().iterator();\n    while (iterator.hasNext()) \n    {\n        Comparable key = (Comparable) iterator.next();\n        Number value = dataset.getValue(key);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    Iterator iterator = dataset.getKeys().iterator();\n    while (iterator.hasNext()) \n    {\n        Comparable key = (Comparable) iterator.next();\n        Number value = dataset.getValue(key);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    Iterator iterator = dataset.getKeys().iterator();\n    while (iterator.hasNext()) \n    {\n        Comparable key = (Comparable) iterator.next();\n        Number value = dataset.getValue(key);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    Iterator iterator = dataset.getKeys().iterator();\n    while (iterator.hasNext()) \n    {\n        Comparable key = (Comparable) iterator.next();\n        Number value = dataset.getValue(key);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}"
    ],
    [
      "public String nextName() throws IOException  {\n  if (peeked == PEEKED_NAME) {\n    String result = peekedName;\n    peekedName = null;\n    return result;\n  }\n  if (peeked == PEEKED_NONE) {\n    checkToken();\n  }\n  if (peeked != PEEKED_NAME) {\n    throw new JsonSyntaxException.\n      fromJsonToken(peeked);\n  }\n  String result = peekedName;\n  peekedName = null;\n  return result;\n}",
      "public String nextName() throws IOException  {\n  if (peeked == PEEKED_NAME) \n  {\n    peeked = PEEKED_NONE;\n    return peekedName;\n  }\n\n  if (peeked == PEEKED_STRING) \n  {\n    throw new JsonSyntaxException(\"Strings cannot be converted to names\");\n  }\n\n  if (peeked == PEEKED_NUMBER) \n  {\n    throw new JsonSyntaxException(\"Numbers cannot be converted to names\");\n  }\n\n  if (peeked == PEEKED_LONG) \n  {\n    throw new JsonSyntaxException(\"Longs cannot be converted to names\");\n  }\n\n  if (peeked == PEEKED_BOOLEAN) \n  {\n    throw new JsonSyntaxException(\"Booleans cannot be converted to names\");\n  }\n\n  if (peeked == PEEKED_NULL) \n  {\n    throw new JsonSyntaxException(\"Nulls cannot be converted to names\");\n  }\n\n  if (peeked == PEEKED_EOF) \n  {\n    throw new JsonIOException(\"EOF\");\n  }\n\n  // Consume whitespace\n  while (true) \n  {\n    int c = read();\n    if (c == -1) \n    {\n      throw new JsonIOException(\"EOF\");\n    }\n    if (!isNameChar(c)) \n    {\n      unread(c);\n      break;\n    }\n  }\n\n  // Read the name\n  StringBuilder name = new StringBuilder();\n  while (true) \n  {\n    int c = read();\n    if (c == -1) \n    {\n      break;\n    }\n    if (!isNameChar(c)) \n    {\n      unread(c);\n      break;\n    }\n    name.append((char) c);\n  }\n\n  peeked = PEEKED_NAME;\n  peekedName = name.toString();\n  return peekedName;\n}",
      "public String nextName() throws IOException  {\n    StringBuilder name = new StringBuilder();\n    int ch;\n    while ((ch = next()) != -1) \n    {\n        if (ch == ' ' || ch == '\\t' || ch == '\\n' || ch == '\\r' || ch == '\\f' || ch == '/' || ch == '\\\\' || ch == '#' || ch == '=' || ch == '{' || ch == '}' || ch == '[' || ch == ']' || ch == ':' || ch == ',' || ch == ';') \n        {\n            if (name.length() == 0) \n            {\n                throw new JsonSyntaxException(\"Property name must not be empty\");\n            }\n            unread();\n            return name.toString();\n        }\n        name.append((char) ch);\n    }\n    throw new JsonSyntaxException(\"Property name must not be empty\");\n}",
      "public String nextName() throws IOException  {\n  if (peeked == PEEKED_NONE) \n  {\n    throw new JsonSyntaxException(\"Peeked none, expected a property name.\");\n  } \n  else if (peeked != PEEKED_NAME) \n  {\n    throw new JsonSyntaxException(\"Expected a property name, found: \" + peeked);\n  }\n\n  String name = stringBuffer.substring(pos, pos + peekedNameLength);\n  pos += peekedNameLength;\n  peeked = PEEKED_NONE;\n  return name;\n}",
      "public String nextName() throws IOException  {\n  if (nextToken() != NAME) \n  {\n    throw new JsonSyntaxException(\n        \"Expected a name but was \" + peek().toString());\n  }\n  return stringValue;\n}",
      "public String nextName() throws IOException  {\n  StringBuilder stringBuilder = new StringBuilder();\n  boolean isQuoted = false;\n  for (;;) {\n    int c = read();\n    switch (c) {\n      case -1:\n        throw new IOException(\"End of stream\");\n      case '\\\"':\n        isQuoted = !isQuoted;\n        continue;\n      case '\\\\':\n        if (!isQuoted) {\n          throw new IOException(\"Invalid character '\\\\'\");\n        }\n        c = read();\n        if (c == -1) {\n          throw new IOException(\"End of stream\");\n        }\n        switch (c) {\n          case '\\\"':\n          case '\\\\':\n          case '/':\n            stringBuilder.append((char) c);\n            continue;\n          case 'b':\n            stringBuilder.append('\\b');\n            continue;\n          case 'f':\n            stringBuilder.append('\\f');\n            continue;\n          case 'n':\n            stringBuilder.append('\\n');\n            continue;\n          case 'r':\n            stringBuilder.append('\\r');\n            continue;\n          case 't':\n            stringBuilder.append('\\t');\n            continue;\n          case 'u':\n            int u = 0;\n            for (int i = 0; i < 4; i++) {\n              c = read();\n              if (c == -1) {\n                throw new IOException(\"End of stream\");\n              }\n              u <<= 4;\n              if (c >= '0' && c <= '9') {\n                u |= c - '0';\n              } else if (c >= 'a' && c <= 'f') {\n                u |= c - 'a' + 10;\n              } else if (c >= 'A' && c <= 'F') {\n                u |= c - 'A' + 10;\n              } else {\n                throw new IOException(\"Invalid character '\\\\u'\");\n              }\n            }\n            stringBuilder.append((char) u);\n            continue;\n          default:\n            throw new IOException(\"Invalid character '\\\\'\");\n        }\n      case '\\r':\n      case '\\n':\n      case '\\t':\n}\n}\n}",
      "public String nextName() throws IOException  {\n  if (peeked == PEEKED_NAME) {\n    String name = peekedName;\n    peekedName = null;\n    pos += peekedNameLength;\n    return name;\n  }\n\n  int start = pos;\n  int c;\n  while ((c = read()) != -1) {\n    if (c <= ' ') {\n      if (c == ' ' || c == '\\t' || c == '\\n' || c == '\\r' || c == '\\f') {\n        if (start == pos) {\n          // Consume whitespace\n          continue;\n        }\n        break;\n      }\n      if (c == '\\u0000') {\n        throw new JsonSyntaxException(\"Unexpected character 0x00 at position \" + pos);\n      }\n      if (c < ' ') {\n        throw new JsonSyntaxException(\"Unexpected control character at position \" + pos + \": \" + (char) c);\n      }\n    } else if (c == '\\\\') {\n      if (lenient) {\n        // This is a lenient case.\n        // We'll just skip the escape sequence and let the name parser handle it.\n        c = read();\n        if (c == 'u') {\n          // Skip unicode escape sequence\n          for (int i = 0; i < 4; i++) {\n            c = read();\n            if (!isHexDigit(c)) {\n              throw new JsonSyntaxException(\"Expected hex digit at position \" + pos);\n            }\n          }\n        } else if (c == 'U') {\n          // Skip unicode escape sequence\n          for (int i = 0; i < 8; i++) {\n            c = read();\n            if (!isHexDigit(c)) {\n              throw new JsonSyntaxException(\"Expected hex digit at position \" + pos);\n            }\n          }\n        } else {\n          // Backslash is not followed by 'u' or 'U', so it's not a unicode escape.\n          // Let the name parser handle it.\n          break;\n        }\n      } else {\n}\n}\n}\n}",
      "public String nextName() throws IOException  {\n    if (nextToken() != NAME) \n    {\n        throw new JsonSyntaxException(peekedToken);\n    }\n    return stringValue;\n}",
      "public String nextName() throws IOException  {\n  StringBuilder name = new StringBuilder();\n  int c;\n  while ((c = read()) != -1) \n  {\n    if (c == '\\\"') \n    {\n      return name.toString();\n    } \n    else if (c == '\\\\') \n    {\n      c = read();\n      if (c == '\\\"' || c == '\\\\' || c == '/' || c == 'b' || c == 'f' || c == 'n' || c == 'r' || c == 't') \n      {\n        name.append((char) c);\n      } \n      else if (c == 'u') \n      {\n        int u = 0;\n        for (int i = 0; i < 4; i++) \n        {\n          c = read();\n          u <<= 4;\n          if (c >= '0' && c <= '9') \n          {\n            u += c - '0';\n          } \n          else if (c >= 'a' && c <= 'f') \n          {\n            u += c - 'a' + 10;\n          } \n          else if (c >= 'A' && c <= 'F') \n          {\n            u += c - 'A' + 10;\n          } \n          else \n          {\n            throw new JsonSyntaxException(\"Unable to parse unicode escape character: \" + c);\n          }\n        }\n        name.append((char) u);\n      } \n      else \n      {\n        throw new JsonSyntaxException(\"Unable to parse escape character: \" + c);\n      }\n    } \n    else if (c <= ' ') \n    {\n      throw new JsonSyntaxException(\"Names must not contain control characters\");\n    } \n    else \n    {\n      name.append((char) c);\n    }\n  }\n  throw new JsonSyntaxException(\"EOF while reading name\");\n}",
      "public String nextName() throws IOException  {\n  if (nextToken() != NAME) \n  {\n    throw new JsonSyntaxException(String.format(\"Expected a name, but got %s\", peek()));\n  }\n  String name = stringBuilder.substring(stringValueStart, stringValueEnd);\n  nextToken(); // Consume the name.\n  return name;\n}"
    ],
    [
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}"
    ],
    [
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        int toRead = Math.min(uncompressedBytesRemaining, len);\n        int read = in.read(b, off, toRead);\n        if (read != -1) {\n            uncompressedBytesRemaining -= read;\n        }\n        return read;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        int read = in.read(b, off, Math.min(len, uncompressedBytesRemaining));\n        if (read != -1) {\n            uncompressedBytesRemaining -= read;\n        }\n        if (uncompressedBytesRemaining == 0) {\n            inUncompressedChunk = false;\n        }\n        return read;\n    } else if (currentCompressedChunk != null) {\n        int read = currentCompressedChunk.read(b, off, len);\n        if (read == -1) {\n            currentCompressedChunk.close();\n            currentCompressedChunk = null;\n        }\n        return read;\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        int toRead = Math.min(uncompressedBytesRemaining, len);\n        int read = in.read(b, off, toRead);\n        if (read != -1) {\n            uncompressedBytesRemaining -= read;\n        }\n        return read;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        int read = in.read(b, off, Math.min(len, uncompressedBytesRemaining));\n        if (read != -1) {\n            uncompressedBytesRemaining -= read;\n        }\n        return read;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        int read = in.read(b, off, Math.min(len, uncompressedBytesRemaining));\n        if (read != -1) {\n            uncompressedBytesRemaining -= read;\n        }\n        if (uncompressedBytesRemaining == 0) {\n            inUncompressedChunk = false;\n        }\n        return read;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        int read = in.read(b, off, Math.min(len, uncompressedBytesRemaining));\n        if (read > 0) {\n            uncompressedBytesRemaining -= read;\n        }\n        if (uncompressedBytesRemaining == 0) {\n            inUncompressedChunk = false;\n        }\n        return read;\n    } else if (currentCompressedChunk != null) {\n        int read = currentCompressedChunk.read(b, off, len);\n        if (read == -1) {\n            currentCompressedChunk = null;\n        }\n        return read;\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        int read = in.read(b, off, Math.min(len, uncompressedBytesRemaining));\n        if (read != -1) {\n            uncompressedBytesRemaining -= read;\n        }\n        return read;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        int read = in.read(b, off, Math.min(len, uncompressedBytesRemaining));\n        if (read != -1) {\n            uncompressedBytesRemaining -= read;\n        }\n        if (uncompressedBytesRemaining == 0) {\n            inUncompressedChunk = false;\n        }\n        return read;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        int read = in.read(b, off, Math.min(len, uncompressedBytesRemaining));\n        if (read > 0) {\n            uncompressedBytesRemaining -= read;\n        }\n        if (uncompressedBytesRemaining == 0) {\n            inUncompressedChunk = false;\n        }\n        return read;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        int toRead = Math.min(uncompressedBytesRemaining, len);\n        int read = in.read(b, off, toRead);\n        if (read != -1) {\n            uncompressedBytesRemaining -= read;\n        }\n        return read;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}"
    ],
    [
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n        Node arg = null;\n        if (site.getNode().getKind() == Node.Kind.CALL) {\n            arg = site.getNode().getArgument(argIndex);\n        } else if (site.getNode().getKind() == Node.Kind.DOT) {\n            Node call = site.getNode().getParent();\n            if (call.getKind() == Node.Kind.CALL\n                    && call.getArgumentCount() > argIndex) {\n                arg = call.getArgument(argIndex);\n            }\n        }\n        return arg;\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node arg = site.getNode();\n    int i = 0;\n    while (arg != null && i < argIndex) {\n        arg = arg.getNext();\n        i++;\n    }\n    return arg;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node node = site.getNode();\n    if (node instanceof FuncCall) {\n        FuncCall funcCall = (FuncCall) node;\n        if (funcCall.getArgs() != null) {\n            Node arg = funcCall.getArgs();\n            for (int i = 0; i < argIndex && arg != null; i++) {\n                arg = arg.getNext();\n            }\n            return arg;\n        }\n    } else if (node instanceof NewExpr) {\n        NewExpr newExpr = (NewExpr) node;\n        if (newExpr.getArgs() != null) {\n            Node arg = newExpr.getArgs();\n            for (int i = 0; i < argIndex && arg != null; i++) {\n                arg = arg.getNext();\n            }\n            return arg;\n        }\n    } else if (node instanceof DotExpr) {\n        DotExpr dotExpr = (DotExpr) node;\n        if (dotExpr.getArgs() != null) {\n            Node arg = dotExpr.getArgs();\n            for (int i = 0; i < argIndex && arg != null; i++) {\n                arg = arg.getNext();\n            }\n            return arg;\n        }\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node node = site.getNode();\n      if (node instanceof NewExpr) {\n        NewExpr newExpr = (NewExpr) node;\n        if (newExpr.getArgsSize() > argIndex) {\n          return newExpr.getArg(argIndex);\n        }\n      } else if (node instanceof CallExpr) {\n        CallExpr callExpr = (CallExpr) node;\n        if (callExpr.getArgsSize() > argIndex) {\n          return callExpr.getArg(argIndex);\n        }\n      } else if (node instanceof DotExpr) {\n        DotExpr dotExpr = (DotExpr) node;\n        if (dotExpr.getArgsSize() > argIndex) {\n          return dotExpr.getArg(argIndex);\n        }\n      }\n      return null;\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node node = site.getNode();\n    if (node instanceof FuncCall) {\n        FuncCall call = (FuncCall) node;\n        return call.getArg(argIndex);\n    } else if (node instanceof DotCall) {\n        DotCall call = (DotCall) node;\n        return call.getArg(argIndex);\n    } else {\n        throw new IllegalArgumentException(\n                \"Unsupported node type for function call: \" + node.getClass());\n    }\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node node = site.getNode();\n    if (node instanceof NewExpr) {\n        NewExpr newExpr = (NewExpr) node;\n        return newExpr.getArgs().get(argIndex);\n    } else if (node instanceof CallExpr) {\n        CallExpr callExpr = (CallExpr) node;\n        return callExpr.getArgs().get(argIndex);\n    } else if (node instanceof DotExpr) {\n        DotExpr dotExpr = (DotExpr) node;\n        return dotExpr.getArgs().get(argIndex);\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node arg = null;\n    Node call = site.getNode();\n    if (call instanceof FuncCall) {\n      arg = ((FuncCall) call).getArg(argIndex);\n    } else if (call instanceof NewExpr) {\n      arg = ((NewExpr) call).getArg(argIndex);\n    } else if (call instanceof DotExpr) {\n      arg = ((DotExpr) call).getArg(argIndex);\n    }\n    return arg;\n  }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node arg = null;\n    if (site.getUser() instanceof FuncCall) {\n      FuncCall call = (FuncCall) site.getUser();\n      arg = call.getArg(argIndex);\n    } else if (site.getUser() instanceof NewExpr) {\n      NewExpr newExpr = (NewExpr) site.getUser();\n      arg = newExpr.getArg(argIndex);\n    } else if (site.getUser() instanceof DotExpr) {\n      DotExpr dotExpr = (DotExpr) site.getUser();\n      arg = dotExpr.getArg(argIndex);\n    }\n    return arg;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n        Node node = site.getNode();\n        if (node instanceof FuncCall) {\n            FuncCall call = (FuncCall) node;\n            if (call.getArgs().size() > argIndex) {\n                return call.getArgs().get(argIndex);\n            }\n        } else if (node instanceof DotCall) {\n            DotCall call = (DotCall) node;\n            if (call.getArgs().size() > argIndex) {\n                return call.getArgs().get(argIndex);\n            }\n        }\n        return null;\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node node = site.getNode();\n      if (node instanceof NewExpr) {\n        NewExpr newExpr = (NewExpr) node;\n        return newExpr.getArgs().get(argIndex);\n      } else if (node instanceof DotExpr) {\n        DotExpr dotExpr = (DotExpr) node;\n        return dotExpr.getArgs().get(argIndex);\n      } else if (node instanceof CallExpr) {\n        CallExpr callExpr = (CallExpr) node;\n        return callExpr.getArgs().get(argIndex);\n      } else {\n        return null;\n      }\n    }"
    ],
    [
      "private static String getTypeDeprecationInfo(JSType type)  {\n    DeprecationInfo deprecationInfo = type.getDeprecationInfo();\n    if (deprecationInfo == null) \n    {\n        return null;\n    }\n    else if (deprecationInfo.getReason() == null) \n    {\n        return \"\";\n    }\n    else \n    {\n        return deprecationInfo.getReason();\n    }\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type.hasAnnotation(\"deprecated\")) \n    {\n        return type.getAnnotation(\"deprecated\").getLiteralValue();\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type.hasAnnotation(\"deprecated\")) \n    {\n        return type.getAnnotation(\"deprecated\").getLiteralStringValue();\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    DeprecationInfo deprecationInfo = type.getDeprecationInfo();\n    if (deprecationInfo != null) \n    {\n        return deprecationInfo.getReason();\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type.hasAnnotation(\"deprecated\")) {\n      return type.getAnnotation(\"deprecated\").getValue();\n    }\n    return null;\n  }",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    return type.getDeprecationReason();\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    DeprecationInfo deprecationInfo = type.getDeprecationInfo();\n    if (deprecationInfo != null) {\n      return deprecationInfo.getReason();\n    }\n    return null;\n  }",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type.hasAnnotation(\"deprecated\")) \n    {\n        return type.getAnnotation(\"deprecated\").getDetail();\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    DeprecationInfo info = type.getDeprecationInfo();\n    if (info != null) {\n        return info.getReason();\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type.isDeprecated()) {\n      return type.getDeprecationReason();\n    }\n    return null;\n  }"
    ],
    [
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String displayName = cTimeZoneDisplayCache.get(key);\n    if (displayName == null) \n    {\n        displayName = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, displayName);\n    }\n    return displayName;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    // Create the key for the cache\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n\n    // Try to get the value from the cache\n    String cachedValue = cTimeZoneDisplayCache.get(key);\n\n    // If the value is not in the cache, compute it and put it in the cache\n    if (cachedValue == null) \n    {\n        // Create the time zone display\n        TimeZoneDisplay tzd = new TimeZoneDisplay(tz, daylight, style, locale);\n\n        // Get the value from the time zone display\n        cachedValue = tzd.getText();\n\n        // Put the value in the cache\n        cTimeZoneDisplayCache.put(key, cachedValue);\n    }\n\n    // Return the value\n    return cachedValue;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    // Create the key\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n\n    // Try to get the value from the cache\n    String cachedValue = cTimeZoneDisplayCache.get(key);\n    if (cachedValue != null) \n    {\n        return cachedValue;\n    }\n\n    // If not in cache, create it\n    String newValue;\n    if (daylight) \n    {\n        newValue = tz.getDisplayName(daylight, style, locale);\n    } \n    else \n    {\n        newValue = tz.getDisplayName(style, locale);\n    }\n\n    // Add the new value to the cache and return it\n    cTimeZoneDisplayCache.put(key, newValue);\n    return newValue;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String result = cTimeZoneDisplayCache.get(key);\n    if (result == null) \n    {\n        result = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.putIfAbsent(key, result);\n    }\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String displayName = cTimeZoneDisplayCache.get(key);\n    if (displayName == null) \n    {\n        displayName = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, displayName);\n    }\n    return displayName;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String displayName = cTimeZoneDisplayCache.get(key);\n    if (displayName == null) \n    {\n        displayName = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, displayName);\n    }\n    return displayName;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String result = cTimeZoneDisplayCache.get(key);\n    if (result == null) \n    {\n        result = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, result);\n    }\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String displayName = cTimeZoneDisplayCache.get(key);\n    if (displayName == null) \n    {\n        displayName = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, displayName);\n    }\n    return displayName;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String displayName = cTimeZoneDisplayCache.get(key);\n    if (displayName == null) \n    {\n        displayName = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, displayName);\n    }\n    return displayName;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String displayName = cTimeZoneDisplayCache.get(key);\n    if (displayName == null) \n    {\n        displayName = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, displayName);\n    }\n    return displayName;\n}"
    ],
    [
      "public int getColumnIndex(Comparable key)  {\n    int columnCount = underlying.getColumnCount();\n    for (int i = 0; i < columnCount; i++) \n    {\n        if (underlying.getColumnKey(i).equals(key))\n        {\n            return i;\n        }\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int colCount = underlying.getColumnCount();\n    for (int i = 0; i < colCount; i++) \n    {\n        if (underlying.getColumnKey(i).equals(key)) \n        {\n            return i;\n        }\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int colCount = underlying.getColumnCount();\n    for (int i = 0; i < colCount; i++) \n    {\n        if (underlying.getColumnKey(i).equals(key)) \n        {\n            return i;\n        }\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int colCount = underlying.getColumnCount();\n    for (int i = 0; i < colCount; i++) \n    {\n        if (underlying.getColumnKey(i).equals(key)) \n        {\n            return i;\n        }\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int columnCount = underlying.getColumnCount();\n    for (int i = 0; i < columnCount; i++) \n    {\n        if (underlying.getColumnKey(i).equals(key)) \n        {\n            return i;\n        }\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int colCount = underlying.getColumnCount();\n    for (int i = 0; i < colCount; i++) \n    {\n        if (underlying.getColumnKey(i).equals(key)) \n        {\n            return i;\n        }\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int columnCount = underlying.getColumnCount();\n    for (int i = 0; i < columnCount; i++) \n    {\n        if (underlying.getColumnKey(i).equals(key))\n        {\n            return i;\n        }\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int colCount = underlying.getColumnCount();\n    for (int i = 0; i < colCount; i++) \n    {\n        if (underlying.getColumnKey(i).equals(key)) \n        {\n            return i;\n        }\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int colCount = underlying.getColumnCount();\n    for (int i = 0; i < colCount; i++) \n    {\n        if (underlying.getColumnKey(i).equals(key)) \n        {\n            return i;\n        }\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int colCount = underlying.getColumnCount();\n    for (int i = 0; i < colCount; i++) \n    {\n        if (underlying.getColumnKey(i).equals(key)) \n        {\n            return i;\n        }\n    }\n    return -1;\n}"
    ],
    [
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < (lower - tolerance)) \n    {\n        return Location.OUTSIDE;\n    } \n    else if (point > (upper + tolerance)) \n    {\n        return Location.OUTSIDE;\n    } \n    else if (point > (lower - tolerance) && point < (upper + tolerance)) \n    {\n        return Location.INSIDE;\n    } \n    else \n    {\n        return Location.BOUNDARY;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < (lower - tolerance)) {\n        return Location.OUTSIDE;\n    } else if (point > (upper + tolerance)) {\n        return Location.OUTSIDE;\n    } else if (point > (lower - tolerance) && point < (upper + tolerance)) {\n        return Location.INSIDE;\n    } else {\n        return Location.BOUNDARY;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < (lower - tolerance)) \n    {\n        return Location.OUTSIDE;\n    } \n    else if (point > (upper + tolerance)) \n    {\n        return Location.OUTSIDE;\n    } \n    else if ((point >= (lower - tolerance)) && (point <= (lower + tolerance))) \n    {\n        return Location.BOUNDARY;\n    } \n    else if ((point >= (upper - tolerance)) && (point <= (upper + tolerance))) \n    {\n        return Location.BOUNDARY;\n    } \n    else \n    {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > lower - tolerance && point < upper + tolerance) {\n        return Location.INSIDE;\n    } else {\n        return Location.BOUNDARY;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > lower - tolerance && point < upper + tolerance) {\n        return Location.INSIDE;\n    } else {\n        return Location.BOUNDARY;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > lower - tolerance && point < upper + tolerance) {\n        return Location.INSIDE;\n    } else {\n        return Location.BOUNDARY;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < (lower - tolerance)) \n    {\n        return Location.OUTSIDE;\n    } \n    else if (point > (upper + tolerance)) \n    {\n        return Location.OUTSIDE;\n    } \n    else if (point > (lower - tolerance) && point < (upper + tolerance)) \n    {\n        return Location.INSIDE;\n    } \n    else \n    {\n        return Location.BOUNDARY;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < (lower - tolerance)) {\n        return Location.OUTSIDE;\n    } else if (point > (upper + tolerance)) {\n        return Location.OUTSIDE;\n    } else if (point > (lower - tolerance) && point < (upper + tolerance)) {\n        return Location.INSIDE;\n    } else {\n        return Location.BOUNDARY;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < (lower - tolerance)) {\n        return Location.OUTSIDE;\n    } else if (point > (upper + tolerance)) {\n        return Location.OUTSIDE;\n    } else if (point > (lower - tolerance) && point < (upper + tolerance)) {\n        return Location.INSIDE;\n    } else {\n        return Location.BOUNDARY;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < (lower - tolerance)) \n    {\n        return Location.OUTSIDE;\n    } \n    else if (point > (upper + tolerance)) \n    {\n        return Location.OUTSIDE;\n    } \n    else if ((point >= (lower - tolerance)) && (point <= (lower + tolerance))) \n    {\n        return Location.BOUNDARY;\n    } \n    else if ((point >= (upper - tolerance)) && (point <= (upper + tolerance))) \n    {\n        return Location.BOUNDARY;\n    } \n    else \n    {\n        return Location.INSIDE;\n    }\n}"
    ],
    [
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new TickUnitSource() \n    {\n}\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new TickUnitSource() {\n}\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new TickUnitSource() {\n}\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new TickUnitSource() {\n}\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new TickUnitSource() {\n}\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new TickUnitSource() {\n}\n}"
    ],
    [
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double min = Double.POSITIVE_INFINITY;\n    Integer pivotColumn = null;\n    for (int j = 0; j < tableau.getNumColumns() - 1; j++) \n    {\n        if (tableau.getRatioTestCoefficient(0, j) < min) \n        {\n            min = tableau.getRatioTestCoefficient(0, j);\n            pivotColumn = j;\n        }\n    }\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double min = Double.POSITIVE_INFINITY;\n    Integer column = null;\n    for (int i = 0; i < tableau.getNumColumns() - 1; i++) {\n        if (tableau.getObjectiveCoefficient(i) < 0 && tableau.getObjectiveCoefficient(i) < min) {\n            min = tableau.getObjectiveCoefficient(i);\n            column = i;\n        }\n    }\n    return column;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double min = Double.POSITIVE_INFINITY;\n    Integer pivotColumn = null;\n    for (int j = 0; j < tableau[0].length; j++) {\n        if (tableau[0][j] < min) {\n            min = tableau[0][j];\n            pivotColumn = j;\n        }\n    }\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double min = Double.POSITIVE_INFINITY;\n    Integer minCol = null;\n    for (int i = 0; i < tableau.getNumColumns() - 1; i++) {\n        if (tableau.getCoefficient(0, i) < 0 && tableau.getCoefficient(0, i) < min) {\n            min = tableau.getCoefficient(0, i);\n            minCol = i;\n        }\n    }\n    return minCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double min = Double.POSITIVE_INFINITY;\n    Integer pivotColumn = null;\n    for (int j = 0; j < tableau[0].length; j++) \n    {\n        if (tableau[0][j] < min && tableau[0][j] < 0) \n        {\n            min = tableau[0][j];\n            pivotColumn = j;\n        }\n    }\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double min = Double.POSITIVE_INFINITY;\n    Integer pivotColumn = null;\n    for (int i = 0; i < tableau[0].length; i++) {\n        if (tableau[0][i] < min) {\n            min = tableau[0][i];\n            pivotColumn = i;\n        }\n    }\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double min = Double.POSITIVE_INFINITY;\n    Integer column = null;\n    for (int i = 0; i < tableau.getNumColumns(); i++) {\n        if (tableau.getObjectiveCoefficient(i) < 0 && tableau.getObjectiveCoefficient(i) < min) {\n            min = tableau.getObjectiveCoefficient(i);\n            column = i;\n        }\n    }\n    return column;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double min = Double.POSITIVE_INFINITY;\n    Integer pivotColumn = null;\n    for (int i = 0; i < tableau.getNumColumns() - 1; i++) {\n        if (tableau.getB()[i] < 0 && tableau.getB()[i] < min) {\n            min = tableau.getB()[i];\n            pivotColumn = i;\n        }\n    }\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double min = Double.POSITIVE_INFINITY;\n    Integer pivotColumn = null;\n    for (int i = 0; i < tableau.getNumColumns() - 1; i++) {\n        if (tableau.getCoefficient(0, i) < 0 && tableau.getCoefficient(0, i) < min) {\n            min = tableau.getCoefficient(0, i);\n            pivotColumn = i;\n        }\n    }\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double min = Double.POSITIVE_INFINITY;\n    Integer minCol = null;\n    for (int i = 0; i < tableau.getNumCols(); i++) {\n        if (tableau.getB()[i] < 0 && tableau.getB()[i] < min) {\n            min = tableau.getB()[i];\n            minCol = i;\n        }\n    }\n    return minCol;\n}"
    ]
  ]
}