{
  "benchmark": "javaeval_if",
  "lastest_eval": {
    "compile@1": 0.42361809045226134,
    "pass@1": 0.18844221105527642,
    "compile@3": 0.5202261306532662,
    "pass@3": 0.23567839195979903,
    "compile@5": 0.5538007497806493,
    "pass@5": 0.25342984765095317
  },
  "n": 10,
  "k": [
    1,
    3,
    5
  ],
  "fn_codes": [
    [
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }"
    ],
    [
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            result = new Double(((double) duration.getCompleted()) / duration.getTotal() * 100);\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            result = new Double(duration.getProgress());\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            result = new Double(duration.getPercentComplete());\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            result = new Double(task.getProgress() * 100);\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            long start = duration.getStart().getTime();\n            long end = duration.getEnd().getTime();\n            long now = System.currentTimeMillis();\n            if (now >= start && now <= end) {\n                result = new Double((now - start) * 100.0 / (end - start));\n            }\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            result = new Double(task.getProgress() * 100);\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            long start = duration.getStart().getTime();\n            long end = duration.getEnd().getTime();\n            long now = System.currentTimeMillis();\n            if (now >= start && now <= end) {\n                result = new Double(((now - start) * 100.0) / (end - start));\n            }\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            long start = duration.getStart().getTime();\n            long end = duration.getEnd().getTime();\n            long now = System.currentTimeMillis();\n            if (now >= start && now <= end) {\n                result = new Double(((now - start) * 100.0) / (end - start));\n            }\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            result = new Double(((double) duration.getCompleted().getTime() - duration.getStart().getTime()) / (duration.getEnd().getTime() - duration.getStart().getTime()));\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            long start = duration.getStart().getTime();\n            long end = duration.getEnd().getTime();\n            long now = System.currentTimeMillis();\n            if (now >= start && now <= end) {\n                double progress = (now - start) * 1.0 / (end - start);\n                result = new Double(progress * 100);\n            }\n        }\n    }\n    return result;\n}"
    ],
    [
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int index = indexOf(str, 0);\n    if (index >= 0) {\n        deleteImpl(index, index + str.length(), str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}"
    ],
    [
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new Iterable<E>() {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new Iterable<E>() {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new IterableIterator<E>(iterator);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new Iterable<E>() {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new IterableIterator<E>(iterator);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new IterableIterator<E>(iterator);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new Iterable<E>() {\n}\n}"
    ],
    [
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        final double[][] d = new double[m.getRowDimension()][1];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            d[r][0] = m.getEntry(r, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else if (m.getRowDimension() == m.getColumnDimension()) {\n        final double[][] d = new double[m.getRowDimension()][1];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            d[r][0] = m.getEntry(r, r);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        throw new MatrixException(\"Input matrix is not a column or square matrix\");\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        final double[][] d = new double[m.getRowDimension()][1];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            d[r][0] = m.getEntry(r, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else if (m.getRowDimension() == m.getColumnDimension()) {\n        final double[][] d = new double[m.getRowDimension()][1];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            d[r][0] = m.getEntry(r, r);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        throw new MatrixException(\"Input matrix must be a column matrix or a square matrix.\");\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int rows = m.getRowDimension();\n    final int cols = m.getColumnDimension();\n    if(rows == 1) {\n        final double[][] d = new double[cols][1];\n        for(int c = 0; c < cols; c++) {\n            d[c][0] = m.getEntry(0, c);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else if(rows == cols) {\n        final double[][] d = new double[rows][1];\n        for(int r = 0; r < rows; r++) {\n            d[r][0] = m.getEntry(r, r);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        throw new MatrixException(\"Input matrix is not a column or square matrix\");\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        final double[][] d = new double[m.getRowDimension()][1];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            d[r][0] = m.getEntry(r, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                if (r == c) {\n                    d[r][c] = m.getEntry(r, c);\n                } else {\n                    d[r][c] = 0;\n                }\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int n = m.getColumnDimension();\n    final double[][] d = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        d[i][i] = m.getEntry(0, i);\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        final double[][] d = new double[m.getRowDimension()][1];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            d[r][0] = m.getEntry(r, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else if (m.getRowDimension() == m.getColumnDimension()) {\n        final double[][] d = new double[m.getRowDimension()][1];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            d[r][0] = m.getEntry(r, r);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        throw new MatrixRuntimeException(\"Input matrix is neither a column matrix nor a square matrix\");\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        final double[][] d = new double[m.getRowDimension()][1];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            d[r][0] = m.getEntry(r, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                if (r == c) {\n                    d[r][c] = m.getEntry(r, c);\n                } else {\n                    d[r][c] = 0;\n                }\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int n = m.getColumnDimension();\n    final double[][] d = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        d[i][i] = m.getEntry(0, i);\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int n = m.getColumnDimension();\n    final double[][] d = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        d[i][i] = m.getEntry(0, i);\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        final double[][] d = new double[m.getRowDimension()][1];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            d[r][0] = m.getEntry(r, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else if (m.getRowDimension() == m.getColumnDimension()) {\n        final double[][] d = new double[m.getRowDimension()][1];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            d[r][0] = m.getEntry(r, r);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        throw new MatrixNotSquareException(\"Matrix is not square\");\n    }\n}"
    ],
    [
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    double[][] blocks = new double[blockRows * blockColumns][];\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            if (copyArray) {\n                blocks[index] = new double[iHeight * blockWidth(jBlock)];\n            }\n        }\n    }\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocks = new double[blockRows * blockColumns][];\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            final int jWidth = blockWidth(jBlock);\n            blocks[index] = new double[iHeight * jWidth];\n        }\n    }\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < blockRows; ++i) {\n        final int iHeight = blockHeight(i);\n        for (int j = 0; j < blockColumns; ++j) {\n            final int jWidth = blockWidth(j);\n            if (iHeight * jWidth != 0) {\n                throw new DimensionMismatchException(iHeight * jWidth, 0);\n            }\n        }\n    }\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    double[][] blocks = new double[blockRows * blockColumns][];\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            blocks[index] = new double[iHeight * blockWidth(jBlock)];\n        }\n    }\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocks = new double[blockRows * blockColumns][];\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            final int jWidth = blockWidth(jBlock);\n            blocks[index] = new double[iHeight * jWidth];\n        }\n    }\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocks = new double[blockRows * blockColumns][];\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            final int jWidth = blockWidth(jBlock);\n            blocks[index] = new double[iHeight * jWidth];\n        }\n    }\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocks = new double[blockRows * blockColumns][];\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            final int jWidth = blockWidth(jBlock);\n            blocks[index] = new double[iHeight * jWidth];\n        }\n    }\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    if (rows < 0 || columns < 0) {\n        throw new MatrixException(\"Number of rows and columns must be non-negative.\");\n    }\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    double[][] blocks = new double[blockRows * blockColumns][];\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            final int jWidth = blockWidth(jBlock);\n            blocks[index] = new double[iHeight * jWidth];\n        }\n    }\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocks = new double[blockRows * blockColumns][];\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            final int jWidth = blockWidth(jBlock);\n            blocks[index] = new double[iHeight * jWidth];\n        }\n    }\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    double[][] blocks = new double[blockRows * blockColumns][];\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            if (copyArray) {\n                blocks[index] = new double[iHeight * blockWidth(jBlock)];\n            }\n        }\n    }\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    if (rows < 0 || columns < 0) {\n        throw new MatrixException(\"Number of rows and columns must be non-negative.\");\n    }\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    double[][] blocks = new double[blockRows * blockColumns][];\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            final int jWidth = blockWidth(jBlock);\n            if (jWidth * iHeight != 0) {\n                blocks[index] = new double[iHeight * jWidth];\n            }\n        }\n    }\n    return blocks;\n}"
    ],
    [
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field must be static\");\n    }\n    if (!field.isAccessible()) {\n        if (forceAccess) {\n            field.setAccessible(true);\n        } else {\n            throw new IllegalAccessException(\"The field is not accessible\");\n        }\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!field.isStatic()) {\n        throw new IllegalArgumentException(\"The field must be static\");\n    }\n    if (!MemberUtils.isAccessible(field)) {\n        if (forceAccess) {\n            field.setAccessible(true);\n        } else {\n            throw new IllegalAccessException(\"The field is not accessible\");\n        }\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!field.isStatic()) {\n        throw new IllegalArgumentException(\"The field must be static\");\n    }\n    if (!field.isAccessible()) {\n        if (forceAccess) {\n            field.setAccessible(true);\n        } else {\n            throw new IllegalAccessException(\"The field is not accessible\");\n        }\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null || !Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field must not be null and must be static\");\n    }\n    if (!field.isAccessible()) {\n        if (forceAccess) {\n            field.setAccessible(true);\n        } else {\n            throw new IllegalAccessException(\"The field is not accessible\");\n        }\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!field.isStatic()) {\n        throw new IllegalArgumentException(\"The field must be static\");\n    }\n    if (!MemberUtils.isAccessible(field)) {\n        if (forceAccess) {\n            field.setAccessible(true);\n        } else {\n            throw new IllegalAccessException(\"The field is not accessible\");\n        }\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field must be static\");\n    }\n    if (!field.isAccessible()) {\n        if (forceAccess) {\n            field.setAccessible(true);\n        } else {\n            throw new IllegalAccessException(\"The field is not accessible\");\n        }\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field must be static\");\n    }\n    if (!field.isAccessible()) {\n        if (forceAccess) {\n            field.setAccessible(true);\n        } else {\n            throw new IllegalAccessException(\"The field is not accessible\");\n        }\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field must be static\");\n    }\n    if (!field.isAccessible()) {\n        if (forceAccess) {\n            field.setAccessible(true);\n        } else {\n            throw new IllegalAccessException(\"The field is not accessible\");\n        }\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!field.isStatic()) {\n        throw new IllegalArgumentException(\"The field must be static\");\n    }\n    if (!MemberUtils.isAccessible(field)) {\n        if (forceAccess) {\n            field.setAccessible(true);\n        } else {\n            throw new IllegalAccessException(\"The field is not accessible\");\n        }\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!field.isStatic()) {\n        throw new IllegalArgumentException(\"The field must be static\");\n    }\n    if (!MemberUtils.isAccessible(field)) {\n        if (forceAccess) {\n            field.setAccessible(true);\n        } else {\n            throw new IllegalAccessException(\"The field is not accessible\");\n        }\n    }\n    return field.get(null);\n}"
    ],
    [
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return cDefault;\n        }\n        if (id.equalsIgnoreCase(\"UTC\")) {\n            return UTC;\n        }\n        if (iFixedOffsetCache.containsKey(id)) {\n            return iFixedOffsetCache.get(id).get();\n        }\n        for (String fixedOffsetId : cAvailableIDs) {\n            if (fixedOffsetId.equals(id)) {\n                return forFixedOffset(fixedOffsetId);\n            }\n        }\n        if (cZoneIdConversion.containsKey(id)) {\n            return forID(cZoneIdConversion.get(id));\n        }\n        throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return cDefault;\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        if (id.length() == 5 && id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int offset = Integer.parseInt(id.substring(1, 3)) * 60 + Integer.parseInt(id.substring(3, 5));\n            return FixedOffsetDateTimeZone.forUTCOffset(offset);\n        }\n        if (cZoneIdConversion.containsKey(id)) {\n            id = cZoneIdConversion.get(id);\n        }\n        DateTimeZone zone = iFixedOffsetCache.get(id);\n        if (zone == null) {\n            zone = DateTimeZoneFactory.createZone(id);\n            iFixedOffsetCache.put(id, new SoftReference<>(zone));\n        }\n        return zone;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return cDefault;\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        if (id.length() == 5 && id.startsWith(\"+\") && id.endsWith(\"00\")) {\n            int offset = Integer.parseInt(id.substring(1, 3));\n            return new FixedOffsetDateTimeZone(offset);\n        }\n        if (iFixedOffsetCache.containsKey(id)) {\n            return iFixedOffsetCache.get(id).get();\n        }\n        if (cZoneIdConversion.containsKey(id)) {\n            return forID(cZoneIdConversion.get(id));\n        }\n        throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return cDefault;\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        if (id.length() == 6 && id.charAt(0) == '+' || id.charAt(0) == '-') {\n            return forFixedOffset(id);\n        }\n        if (iFixedOffsetCache.containsKey(id)) {\n            return iFixedOffsetCache.get(id).get();\n        }\n        if (cZoneIdConversion.containsKey(id)) {\n            return forID(cZoneIdConversion.get(id));\n        }\n        if (cAvailableIDs.contains(id)) {\n            return new DateTimeZone(id);\n        }\n        throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return cDefault;\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        if (iFixedOffsetCache.containsKey(id)) {\n            return iFixedOffsetCache.get(id).get();\n        }\n        if (cZoneIdConversion.containsKey(id)) {\n            String newId = cZoneIdConversion.get(id);\n            return forID(newId);\n        }\n        for (String availableId : cAvailableIDs) {\n            if (availableId.equals(id)) {\n                return DateTimeZone.forID(availableId);\n            }\n        }\n        throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return cDefault;\n        }\n        if (id.equalsIgnoreCase(\"UTC\")) {\n            return UTC;\n        }\n        if (iFixedOffsetCache.containsKey(id)) {\n            return iFixedOffsetCache.get(id).get();\n        }\n        if (cZoneIdConversion.containsKey(id)) {\n            String newId = cZoneIdConversion.get(id);\n            return forID(newId);\n        }\n        DateTimeZone zone = DateTimeZoneFactory.createZone(id);\n        if (zone != null) {\n            iFixedOffsetCache.put(id, new SoftReference<>(zone));\n        }\n        return zone;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return cDefault;\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        if (iFixedOffsetCache.containsKey(id)) {\n            return iFixedOffsetCache.get(id).get();\n        }\n        if (cZoneIdConversion.containsKey(id)) {\n            String newId = cZoneIdConversion.get(id);\n            return forID(newId);\n        }\n        // Check for fixed offset strings\n        if (id.matches(\"[-+][01]\\\\d\\\\d:\\\\d\\\\d\")) {\n            int offset = Integer.parseInt(id.substring(1, 3)) * 60 + Integer.parseInt(id.substring(4, 6));\n            return new FixedOffsetDateTimeZone(offset);\n        }\n        // Check for zone IDs\n        for (String availableID : cAvailableIDs) {\n            if (id.equals(availableID)) {\n                return new DateTimeZone(availableID);\n            }\n        }\n        throw new IllegalArgumentException(\"Unrecognised time zone ID: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return cDefault;\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        if (iFixedOffsetCache.containsKey(id)) {\n            return iFixedOffsetCache.get(id).get();\n        }\n        if (cZoneIdConversion.containsKey(id)) {\n            String newId = cZoneIdConversion.get(id);\n            return forID(newId);\n        }\n        for (String availableID : cAvailableIDs) {\n            if (availableID.equals(id)) {\n                return DateTimeZoneFactory.createZone(availableID);\n            }\n        }\n        throw new IllegalArgumentException(\"Unrecognised ID: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return cDefault;\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        if (iFixedOffsetCache.containsKey(id)) {\n            return iFixedOffsetCache.get(id).get();\n        }\n        if (cZoneIdConversion.containsKey(id)) {\n            id = cZoneIdConversion.get(id);\n        }\n        DateTimeZone zone = DateTimeZone.forID(id);\n        if (zone == null) {\n            throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n        }\n        return zone;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return cDefault;\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        if (id.length() == 5 && id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            String offset = id.substring(1);\n            int offsetHours = Integer.parseInt(offset.substring(0, 2));\n            int offsetMinutes = Integer.parseInt(offset.substring(2));\n            return FixedOffsetDateTimeZone.forOffsetHoursMinutes(offsetHours, offsetMinutes);\n        }\n        if (cZoneIdConversion.containsKey(id)) {\n            id = cZoneIdConversion.get(id);\n        }\n        if (iFixedOffsetCache.containsKey(id)) {\n            return iFixedOffsetCache.get(id).get();\n        }\n        if (cAvailableIDs.contains(id)) {\n            return DateTimeZoneFactory.createZone(id);\n        }\n        throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n    }"
    ],
    [
      "private Dfp multiplyFast(final int x)  {\n    Dfp result = newInstance(this);\n    result.sign = (byte) (this.sign * x);\n    if (x == 0) {\n        return getZero();\n    }\n\n    int[] product = new int[mant.length];  // Big enough to hold even the largest result\n\n    for (int i = 0; i < mant.length; i++) {\n        int rh = 0;  // acts as a carry\n        int r = mant[i] * x;    // multiply the 2 digits\n        r = r + rh;  // add to the product digit with carry in\n\n        rh = r / RADIX;\n        product[i] = r - rh * RADIX;\n    }\n\n    // Copy the digits into the result\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[mant.length - i - 1] = product[i];\n    }\n\n    // Fixup the exponent.\n    result.exp = exp + 1;\n\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    Dfp result = newInstance(this);\n    result.sign = (byte) (this.sign * x);\n    if (x == 0) {\n        return getZero();\n    }\n    if (this.nans == INFINITE) {\n        result = newInstance(this);\n        result.sign = (byte) (this.sign * x);\n        return result;\n    }\n    if (x == 1) {\n        return this;\n    }\n    if (x == RADIX - 1) {\n        result = newInstance(this);\n        result.sign = (byte) (this.sign * -1);\n        return result;\n    }\n    if (x == RADIX) {\n        return this;\n    }\n    if (x == 2) {\n        result = newInstance(this);\n        result.sign = (byte) (this.sign * 1);\n        return result;\n    }\n    if (x == 3) {\n        result = newInstance(this);\n        result.sign = (byte) (this.sign * -1);\n        return result;\n    }\n    if (x == 4) {\n        result = newInstance(this);\n        result.sign = (byte) (this.sign * 1);\n        return result;\n    }\n    if (x == 5) {\n        result = newInstance(this);\n        result.sign = (byte) (this.sign * -1);\n        return result;\n    }\n    if (x == 6) {\n        result = newInstance(this);\n        result.sign = (byte) (this.sign * 1);\n        return result;\n    }\n    if (x == 7) {\n        result = newInstance(this);\n        result.sign = (byte) (this.sign * -1);\n        return result;\n    }\n    if (x == 8) {\n        result = newInstance(this);\n        result.sign = (byte) (this.sign * 1);\n        return result;\n    }\n    if (x == 9) {\n        result = newInstance(this);\n        result.sign = (byte) (this.sign * -1);\n        return result;\n    }\n    if (x == 10) {\n        return this;\n    }\n    if (x == 11) {\n        result = newInstance(this);\n        result.sign = (byte) (this.sign * -1);\n        return result;\n    }\n    if (x == 12) {\n        result = newInstance(this);\n        result.sign = (byte) (this.sign * 1);\n        return result;\n    }\n}",
      "private Dfp multiplyFast(final int x)  {\n    Dfp result = newInstance(this);\n    int[] mant = result.mant;\n    int exp = result.exp;\n    int sign = result.sign;\n    int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n    for (int i = 0; i < mant.length; i++) {\n        int rh = 0;  // acts as a carry\n        for (int j=0; j<mant.length; j++) {\n            int r = mant[i] * x;    // multiply the 2 digits\n            r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n            rh = r / RADIX;\n            product[i+j] = r - rh * RADIX;\n        }\n        product[i+mant.length] = rh;\n    }\n\n    // Find the most sig digit\n    int md = mant.length * 2 - 1;  // default, in case result is zero\n    for (int i = mant.length * 2 - 1; i >= 0; i--) {\n        if (product[i] != 0) {\n            md = i;\n            break;\n        }\n    }\n\n    // Copy the digits into the result\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[mant.length - i - 1] = product[md - i];\n    }\n\n    // Fixup the exponent.\n    result.exp = exp + 1;\n    result.sign = (byte)((sign == 1)?1:-1);\n\n    if (result.mant[mant.length-1] == 0) {\n        // if result is zero, set exp to zero\n        result.exp = 0;\n    }\n\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    Dfp result = newInstance(this);\n    result.sign = (byte) (this.sign * x);\n    int[] mant = result.mant;\n\n    for (int i = 0; i < mant.length; i++) {\n        mant[i] *= x;\n    }\n\n    int carry = 0;\n    for (int i = mant.length - 1; i >= 0; i--) {\n        int r = mant[i] + carry;\n        mant[i] = r % RADIX;\n        carry = r / RADIX;\n    }\n\n    while (carry > 0) {\n        for (int i = mant.length - 1; i >= 0; i--) {\n            int r = mant[i] + carry;\n            mant[i] = r % RADIX;\n            carry = r / RADIX;\n        }\n    }\n\n    result.exp = this.exp;\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    Dfp result = newInstance(this);\n    result.sign = (byte) (sign * x);\n    if (x == 0) {\n        return getZero();\n    }\n\n    int[] product = new int[mant.length];  // Big enough to hold even the largest result\n\n    for (int i = 0; i < mant.length; i++) {\n        int rh = 0;  // acts as a carry\n        for (int j = 0; j < mant.length; j++) {\n            int r = mant[i] * x;    // multiply the 2 digits\n            r = r + product[i + j] + rh;  // add to the product digit with carry in\n\n            rh = r / RADIX;\n            product[i + j] = r - rh * RADIX;\n        }\n        product[i] = rh;\n    }\n\n    // Find the most sig digit\n    int md = mant.length - 1;  // default, in case result is zero\n    for (int i = mant.length - 1; i >= 0; i--) {\n        if (product[i] != 0) {\n            md = i;\n            break;\n        }\n    }\n\n    // Copy the digits into the result\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[mant.length - i - 1] = product[md - i];\n    }\n\n    // Fixup the exponent.\n    result.exp = exp + 1;\n    result.sign = (byte) (sign * x);\n\n    if (result.mant[mant.length - 1] == 0) {\n        // if result is zero, set exp to zero\n        result.exp = 0;\n    }\n\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    Dfp result = newInstance(this);\n    result.sign = (byte) (sign * x);\n    if (x == 0) {\n        return getZero();\n    }\n    if (nans == INFINITE || x == INFINITE) {\n        return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, this, newInstance(x));\n    }\n    if (nans == QNAN || x == QNAN) {\n        return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, this, newInstance(x));\n    }\n    if (nans == FINITE && x == FINITE) {\n        if (mant[mant.length-1] == 0 && x == 0) {\n            result = getZero();\n        } else {\n            result = newInstance(this);\n            result.sign = (byte) (sign * x);\n        }\n        return result;\n    }\n    if (nans == INFINITE && x == FINITE) {\n        result = newInstance(this);\n        result.sign = (byte) (sign * x);\n        return result;\n    }\n    if (nans == FINITE && x == INFINITE) {\n        result = newInstance(x);\n        result.sign = (byte) (sign * x);\n        return result;\n    }\n    int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n    for (int i = 0; i < mant.length; i++) {\n        int rh = 0;  // acts as a carry\n        for (int j=0; j<mant.length; j++) {\n            int r = mant[i] * x;    // multiply the 2 digits\n            r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n            rh = r / RADIX;\n            product[i+j] = r - rh * RADIX;\n        }\n        product[i+mant.length] = rh;\n    }\n\n    // Find the most sig digit\n    int md = mant.length * 2 - 1;  // default, in case result is zero\n    for (int i = mant.length * 2 - 1; i >= 0; i--) {\n        if (product[i] != 0) {\n            md = i;\n            break;\n        }\n    }\n\n    // Copy the digits into the result\n}",
      "private Dfp multiplyFast(final int x)  {\n    Dfp result = newInstance(this);\n    int[] mant = result.mant;\n    int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n    for (int i = 0; i < mant.length; i++) {\n        int rh = 0;  // acts as a carry\n        for (int j=0; j<mant.length; j++) {\n            int r = mant[i] * x;    // multiply the 2 digits\n            r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n            rh = r / RADIX;\n            product[i+j] = r - rh * RADIX;\n        }\n        product[i+mant.length] = rh;\n    }\n\n    // Find the most sig digit\n    int md = mant.length * 2 - 1;  // default, in case result is zero\n    for (int i = mant.length * 2 - 1; i >= 0; i--) {\n        if (product[i] != 0) {\n            md = i;\n            break;\n        }\n    }\n\n    // Copy the digits into the result\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[mant.length - i - 1] = product[md - i];\n    }\n\n    // Fixup the exponent.\n    result.exp = exp + 1; // since we are multiplying by a single digit\n    result.sign = (byte)((sign == 1)?1:-1);\n\n    if (result.mant[mant.length-1] == 0) {\n        // if result is zero, set exp to zero\n        result.exp = 0;\n    }\n\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    Dfp result = newInstance(this);\n    int[] mant = result.mant;\n    int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n    for (int i = 0; i < mant.length; i++) {\n        int rh = 0;  // acts as a carry\n        for (int j=0; j<mant.length; j++) {\n            int r = mant[i] * x;    // multiply the 2 digits\n            r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n            rh = r / RADIX;\n            product[i+j] = r - rh * RADIX;\n        }\n        product[i+mant.length] = rh;\n    }\n\n    // Find the most sig digit\n    int md = mant.length * 2 - 1;  // default, in case result is zero\n    for (int i = mant.length * 2 - 1; i >= 0; i--) {\n        if (product[i] != 0) {\n            md = i;\n            break;\n        }\n    }\n\n    // Copy the digits into the result\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[mant.length - i - 1] = product[md - i];\n    }\n\n    // Fixup the exponent.\n    result.exp = exp + 1; // add 1 to the exponent\n    result.sign = (byte)(sign * x);\n\n    if (result.mant[mant.length-1] == 0) {\n        // if result is zero, set exp to zero\n        result.exp = 0;\n    }\n\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    Dfp result = newInstance(this);\n    result.sign = (byte) (this.sign * x);\n    if (x == 0) {\n        return getZero();\n    }\n\n    int[] product = new int[mant.length];  // Big enough to hold even the largest result\n\n    for (int i = 0; i < mant.length; i++) {\n        int rh = 0;  // acts as a carry\n        for (int j = 0; j < mant.length; j++) {\n            int r = mant[i] * x;    // multiply the 2 digits\n            r = r + product[i + j] + rh;  // add to the product digit with carry in\n\n            rh = r / RADIX;\n            product[i + j] = r - rh * RADIX;\n        }\n        product[i] = rh;\n    }\n\n    // Find the most sig digit\n    int md = 0;  // default, in case result is zero\n    for (int i = 0; i < mant.length; i++) {\n        if (product[i] != 0) {\n            md = i;\n            break;\n        }\n    }\n\n    // Copy the digits into the result\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[mant.length - i - 1] = product[md - i];\n    }\n\n    // Fixup the exponent.\n    result.exp = this.exp + 1;\n    result.sign = (byte) (this.sign * x);\n\n    if (result.mant[mant.length - 1] == 0) {\n        // if result is zero, set exp to zero\n        result.exp = 0;\n    }\n\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    Dfp result = newInstance(this);\n    result.sign = (byte) (sign * x);\n    if (x == 0) {\n        return getZero();\n    }\n    if (nans == INFINITE) {\n        result = newInstance(this);\n        return result;\n    }\n    if (x == 1) {\n        return this;\n    }\n    if (x == RADIX-1) {\n        result = newInstance(this);\n        result.sign = (byte) (sign * -1);\n        result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, this, result);\n        return result;\n    }\n    if (x == 2) {\n        result = newInstance(this);\n        result.sign = (byte) (sign * -1);\n        result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, this, result);\n        return result;\n    }\n    if (x == 3) {\n        result = newInstance(this);\n        result.sign = (byte) (sign * -1);\n        result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, this, result);\n        return result;\n    }\n    if (x == 4) {\n        result = newInstance(this);\n        result.sign = (byte) (sign * -1);\n        result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, this, result);\n        return result;\n    }\n    if (x == 5) {\n        result = newInstance(this);\n        result.sign = (byte) (sign * -1);\n        result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, this, result);\n        return result;\n    }\n    if (x == 6) {\n        result = newInstance(this);\n        result.sign = (byte) (sign * -1);\n        result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, this, result);\n        return result;\n    }\n    if (x == 7) {\n        result = newInstance(this);\n        result.sign = (byte) (sign * -1);\n        result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, this, result);\n        return result;\n    }\n    if (x == 8) {\n        result = newInstance(this);\n        result.sign = (byte) (sign * -1);\n        result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, this, result);\n        return result;\n    }\n}"
    ],
    [
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> transformedMap = new HashMap<>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            K key = transformKey(entry.getKey());\n            V value = transformValue(entry.getValue());\n            transformedMap.put(key, value);\n        }\n        return transformedMap;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> transformedMap = new HashMap<>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            K key = transformKey(entry.getKey());\n            V value = transformValue(entry.getValue());\n            transformedMap.put(key, value);\n        }\n        return transformedMap;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> transformedMap = new HashMap<>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            K key = transformKey(entry.getKey());\n            V value = transformValue(entry.getValue());\n            transformedMap.put(key, value);\n        }\n        return transformedMap;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> transformedMap = new HashMap<>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            K key = transformKey(entry.getKey());\n            V value = transformValue(entry.getValue());\n            transformedMap.put(key, value);\n        }\n        return transformedMap;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> transformedMap = new HashMap<>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            K key = transformKey(entry.getKey());\n            V value = transformValue(entry.getValue());\n            transformedMap.put(key, value);\n        }\n        return transformedMap;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> transformedMap = new HashMap<>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            K key = transformKey(entry.getKey());\n            V value = transformValue(entry.getValue());\n            transformedMap.put(key, value);\n        }\n        return transformedMap;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> transformedMap = new HashMap<>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            K key = transformKey(entry.getKey());\n            V value = transformValue(entry.getValue());\n            transformedMap.put(key, value);\n        }\n        return transformedMap;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> transformedMap = new HashMap<>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            K key = transformKey(entry.getKey());\n            V value = transformValue(entry.getValue());\n            transformedMap.put(key, value);\n        }\n        return transformedMap;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> transformedMap = new HashMap<>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            K key = transformKey(entry.getKey());\n            V value = transformValue(entry.getValue());\n            transformedMap.put(key, value);\n        }\n        return transformedMap;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> transformedMap = new HashMap<>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            K key = transformKey(entry.getKey());\n            V value = transformValue(entry.getValue());\n            transformedMap.put(key, value);\n        }\n        return transformedMap;\n    }"
    ],
    [
      "private Node createExternFunction(Node exportedFunction)  {\n    // Get the name of the function\n    String functionName = exportedFunction.getName();\n\n    // Get the parameters of the function\n    List<Node> parameters = exportedFunction.getParameters();\n\n    // Get the return type of the function\n    Node returnType = exportedFunction.getReturnType();\n\n    // Create the extern function\n    Node externFunction = IR.newFunction(functionName, parameters, returnType);\n\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = IR.newFunction(exportedFunction.getName(), exportedFunction.getReturnType());\n    for (Node param : exportedFunction.getParameters()) {\n        externFunction.addParameter(param.getType(), param.getName());\n    }\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    // Create the extern function with the same type as the original function\n    Node externFunction = IR.newFunction(exportedFunction.getType(), exportedFunction.getName());\n    \n    // Check if the function to export is missing parameter or return types\n    if (exportedFunction.getReturnType() == null) {\n        System.out.println(\"Warning: The function \" + exportedFunction.getName() + \" is missing return type.\");\n    }\n    if (exportedFunction.getParameters() == null || exportedFunction.getParameters().isEmpty()) {\n        System.out.println(\"Warning: The function \" + exportedFunction.getName() + \" is missing parameters.\");\n    }\n    \n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    // Create a new function node\n    Node externFunction = IR.newFunction(exportedFunction.getType(), exportedFunction.getName());\n    \n    // Get the parameters of the exported function\n    List<Node> exportedFunctionParams = exportedFunction.getParameters();\n    \n    // Create a new list for the extern function's parameters\n    List<Node> externFunctionParams = new ArrayList<>();\n    \n    // Iterate over the exported function's parameters\n    for (Node exportedFunctionParam : exportedFunctionParams) {\n        // Create a new parameter node for the extern function\n        Node externFunctionParam = IR.newParameter(exportedFunctionParam.getType(), exportedFunctionParam.getName());\n        \n        // Add the parameter to the list\n        externFunctionParams.add(externFunctionParam);\n    }\n    \n    // Set the parameters of the extern function\n    externFunction.setParameters(externFunctionParams);\n    \n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = IR.newFunction(exportedFunction.getName(), exportedFunction.getReturnType());\n    for (Node param : exportedFunction.getParameters()) {\n        externFunction.addParameter(param.getType(), param.getName());\n    }\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = IR.newFunction(exportedFunction.getName());\n    List<Node> parameters = new ArrayList<>();\n    for (Node parameter : exportedFunction.getParameters()) {\n        parameters.add(IR.newParameter(parameter.getName()));\n    }\n    externFunction.setParameters(parameters);\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = IR.newFunction(exportedFunction.getName());\n    for (Node param : exportedFunction.getParameters()) {\n        externFunction.addParameter(param.getName(), param.getType());\n    }\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = IR.newFunction(exportedFunction.getName());\n    List<Node> parameters = exportedFunction.getParameters();\n    for (Node parameter : parameters) {\n        externFunction.addParameter(parameter);\n    }\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = IR.newFunction(exportedFunction.getType(), exportedFunction.getName());\n    for (Node param : exportedFunction.getParameters()) {\n        externFunction.addParameter(param);\n    }\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    // Get the function type\n    FunctionType functionType = exportedFunction.getType();\n\n    // Create the extern function\n    Node externFunction = IR.newFunction(functionType.getReturnType(), functionType.getParameterTypes());\n\n    // Set the function name\n    externFunction.setName(exportedFunction.getName());\n\n    // Set the function parameters\n    externFunction.setParameters(functionType.getParameters());\n\n    return externFunction;\n}"
    ],
    [
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[][] covariances = computeCovariances(params, covarianceSingularityThreshold);\n    double[] sigma = new double[covariances.length];\n    for (int i = 0; i < covariances.length; i++) {\n        sigma[i] = Math.sqrt(covariances[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[][] covariances = computeCovariances(params, covarianceSingularityThreshold);\n    double[] sigma = new double[covariances.length];\n    for (int i = 0; i < covariances.length; i++) {\n        sigma[i] = Math.sqrt(covariances[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[][] covariances = computeCovariances(params, covarianceSingularityThreshold);\n    double[] sigma = new double[params.length];\n    for (int i = 0; i < params.length; i++) {\n        sigma[i] = Math.sqrt(covariances[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[][] covariances = computeCovariances(params, covarianceSingularityThreshold);\n    double[] sigma = new double[covariances.length];\n    for (int i = 0; i < covariances.length; i++) {\n        sigma[i] = Math.sqrt(covariances[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[][] covariances = computeCovariances(params, covarianceSingularityThreshold);\n    double[] sigma = new double[covariances.length];\n    for (int i = 0; i < covariances.length; i++) {\n        sigma[i] = Math.sqrt(covariances[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[][] covariances = computeCovariances(params, covarianceSingularityThreshold);\n    double[] sigma = new double[covariances.length];\n    for (int i = 0; i < covariances.length; i++) {\n        sigma[i] = Math.sqrt(covariances[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[][] covariances = computeCovariances(params, covarianceSingularityThreshold);\n    double[] sigma = new double[covariances.length];\n    for (int i = 0; i < covariances.length; i++) {\n        sigma[i] = Math.sqrt(covariances[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[][] covariances = computeCovariances(params, covarianceSingularityThreshold);\n    double[] sigma = new double[covariances.length];\n    for (int i = 0; i < covariances.length; i++) {\n        sigma[i] = Math.sqrt(covariances[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[][] covariances = computeCovariances(params, covarianceSingularityThreshold);\n    double[] sigma = new double[params.length];\n    for (int i = 0; i < params.length; i++) {\n        sigma[i] = Math.sqrt(covariances[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[][] covariances = computeCovariances(params, covarianceSingularityThreshold);\n    double[] sigma = new double[params.length];\n    for (int i = 0; i < params.length; i++) {\n        sigma[i] = Math.sqrt(covariances[i][i]);\n    }\n    return sigma;\n}"
    ],
    [
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new SubstitutionException(\"Cyclic substitution detected for variable '\" + varName + \"'\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    for (int i = 0; i < priorVariables.size(); i++) {\n        if (priorVariables.get(i).equals(varName)) {\n            throw new SubstitutionException(\"Cyclic substitution detected: \" + varName);\n        }\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new SubstitutionException(\"Cyclic substitution detected for variable '\" + varName + \"'\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new SubstitutionException(\"Cyclic substitution detected: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new SubstitutionException(\"Cyclic substitution detected: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new SubstitutionException(\"Cyclic substitution detected: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new SubstitutionException(\"Cyclic substitution detected: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    for (String priorVar : priorVariables) {\n        if (priorVar.equals(varName)) {\n            throw new SubstitutionException(\"Cyclic substitution detected: \" + varName);\n        }\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new SubstitutionException(\"Cyclic substitution detected for variable \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new SubstitutionException(\"Cyclic substitution detected: \" + varName);\n    }\n}"
    ],
    [
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    Multimap<INPUT, INPUT> deps = Multimap.create();\n    for (INPUT root : roots) {\n        for (String symbol : root.getRequires()) {\n            INPUT input = provideMap.get(symbol);\n            deps.putAll(input, root);\n        }\n    }\n    List<INPUT> sortedList = new ArrayList<>();\n    for (INPUT root : roots) {\n        List<INPUT> cycle = findCycle(new ArrayList<INPUT>(), deps);\n        if (cycle != null) {\n            throw new MissingProvideException(cycleToString(cycle));\n        }\n        sortedList.add(root);\n    }\n    if (sorted) {\n        sortedList = getSortedDependencies(sortedList, deps);\n    }\n    return sortedList;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    Set<INPUT> visited = new HashSet<>();\n    List<INPUT> dependencies = new ArrayList<>();\n    for (INPUT root : roots) {\n        getDependenciesOf(root, visited, dependencies, sorted);\n    }\n    return dependencies;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    Multimap<INPUT, INPUT> deps = Multimap.create();\n    for (INPUT root : roots) {\n        for (String symbol : root.getRequires()) {\n            INPUT input = provideMap.get(symbol);\n            deps.put(input, root);\n        }\n    }\n    if (sorted) {\n        List<INPUT> sortedList = new ArrayList<>();\n        Set<INPUT> visited = new HashSet<>();\n        for (INPUT root : roots) {\n            if (!visited.contains(root)) {\n                findDependencies(root, deps, sortedList, visited);\n            }\n        }\n        return sortedList;\n    } else {\n        return new ArrayList<>(roots);\n    }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    if (sorted) {\n        Set<INPUT> visited = new HashSet<>();\n        List<INPUT> sortedList = new ArrayList<>();\n        for (INPUT root : roots) {\n            if (!visited.contains(root)) {\n                getDependenciesOf(root, visited, sortedList);\n            }\n        }\n        return sortedList;\n    } else {\n        return new ArrayList<>(roots);\n    }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    Multimap<INPUT, INPUT> deps = Multimap.create();\n    for (INPUT root : roots) {\n        for (String symbol : root.getRequires()) {\n            INPUT candidate = provideMap.get(symbol);\n            deps.put(candidate, root);\n        }\n    }\n    List<INPUT> result = new ArrayList<>();\n    Set<INPUT> visited = new HashSet<>();\n    for (INPUT root : roots) {\n        if (!visited.contains(root)) {\n            List<INPUT> cycle = findCycle(new ArrayList<INPUT>(), deps);\n            if (cycle != null) {\n                throw new RuntimeException(\"Circular dependency: \" + cycleToString(cycle));\n            }\n            List<INPUT> dependencies = getDependencies(root, deps, visited);\n            if (sorted) {\n                result.addAll(sortedList(dependencies));\n            } else {\n                result.addAll(dependencies);\n            }\n        }\n    }\n    return result;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    if (sorted) {\n        List<INPUT> sortedList = new ArrayList<>();\n        Set<INPUT> visited = new HashSet<>();\n        for (INPUT root : roots) {\n            if (!visited.contains(root)) {\n                getDependenciesOf(root, sortedList, visited);\n            }\n        }\n        return sortedList;\n    } else {\n        return new ArrayList<>(roots);\n    }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    Set<INPUT> visited = new HashSet<>();\n    List<INPUT> dependencies = new ArrayList<>();\n    for (INPUT root : roots) {\n        if (!visited.contains(root)) {\n            dependencies.addAll(getDependencies(root, visited, sorted));\n        }\n    }\n    return dependencies;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    Multimap<INPUT, INPUT> deps = Multimap.create();\n    for (INPUT root : roots) {\n        for (String symbol : root.getRequires()) {\n            INPUT candidate = provideMap.get(symbol);\n            deps.put(candidate, root);\n        }\n    }\n    List<INPUT> sortedList = new ArrayList<>();\n    for (INPUT root : roots) {\n        List<INPUT> cycle = findCycle(new ArrayList<INPUT>(), deps);\n        if (cycle != null) {\n            throw new MissingProvideException(cycleToString(cycle));\n        }\n        sortedList.add(root);\n    }\n    if (sorted) {\n        sortedList = new ArrayList<>(new LinkedHashSet<>(sortedList));\n    }\n    return sortedList;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    Multimap<INPUT, INPUT> deps = Multimap.create();\n    for (INPUT root : roots) {\n        for (String symbol : root.getRequires()) {\n            INPUT input = provideMap.get(symbol);\n            deps.put(input, root);\n        }\n    }\n    List<INPUT> result = new ArrayList<>();\n    for (INPUT root : roots) {\n        result.add(root);\n        List<INPUT> cycle = findCycle(new ArrayList<INPUT>(result), deps);\n        if (cycle != null) {\n            throw new MissingProvideException(cycleToString(cycle));\n        }\n    }\n    if (sorted) {\n        List<INPUT> sortedList = new ArrayList<>();\n        for (INPUT input : getSortedList()) {\n            if (!result.contains(input)) {\n                sortedList.add(input);\n            }\n        }\n        result.addAll(sortedList);\n    }\n    return result;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    Multimap<INPUT, INPUT> deps = Multimap.create();\n    for (INPUT root : roots) {\n        for (String symbol : root.getRequires()) {\n            INPUT candidate = provideMap.get(symbol);\n            if (!candidate.equals(root)) {\n                deps.put(candidate, root);\n            }\n        }\n    }\n    List<INPUT> sortedList = new ArrayList<>();\n    for (INPUT root : roots) {\n        List<INPUT> cycle = findCycle(new ArrayList<INPUT>(), deps);\n        if (cycle != null) {\n            sortedList.add(cycle.get(cycle.size() - 1));\n        }\n    }\n    if (sorted) {\n        List<INPUT> sortedDependencies = new ArrayList<>();\n        for (INPUT input : getSortedList()) {\n            if (!sortedList.contains(input)) {\n                sortedDependencies.add(input);\n            }\n        }\n        sortedDependencies.addAll(sortedList);\n        return sortedDependencies;\n    } else {\n        return sortedList;\n    }\n}"
    ],
    [
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    if (delimiters == null) {\n        delimiters = new char[]{' '};\n    }\n    final int delimLen = delimiters.length;\n    if (delimiters.length == 0) {\n        return str.toLowerCase();\n    }\n    final StringBuilder sb = new StringBuilder();\n    boolean capitalize = true;\n    for (int i = 0; i < str.length(); i++) {\n        char c = str.charAt(i);\n        if (delimiters[0] == c) {\n            capitalize = true;\n        } else if (capitalize) {\n            sb.append(Character.toUpperCase(c));\n            capitalize = false;\n        } else {\n            sb.append(Character.toLowerCase(c));\n        }\n    }\n    return sb.toString();\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return str.toLowerCase();\n    }\n    StringBuilder sb = new StringBuilder();\n    boolean inWord = false;\n    for (char c : str.toCharArray()) {\n        if (delimLen != -1 && Arrays.binarySearch(delimiters, c) >= 0) {\n            inWord = false;\n        } else if (!inWord) {\n            inWord = true;\n            c = Character.toLowerCase(c);\n        }\n        sb.append(c);\n    }\n    return sb.toString();\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return str.toLowerCase();\n    }\n    StringBuilder sb = new StringBuilder();\n    boolean inWord = false;\n    for (char c : str.toCharArray()) {\n        if (delimLen > 0 && Arrays.binarySearch(delimiters, c) >= 0) {\n            inWord = false;\n        } else if (!inWord) {\n            inWord = true;\n            sb.append(Character.toLowerCase(c));\n        } else {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    if (delimiters == null) {\n        delimiters = new char[]{' '};\n    }\n    final int delimLen = delimiters.length;\n    final StringBuilder sb = new StringBuilder();\n    boolean inWord = false;\n    for (int i = 0; i < str.length(); i++) {\n        char c = str.charAt(i);\n        if (inWord) {\n            if (Character.isWhitespace(c) || Arrays.binarySearch(delimiters, c) >= 0) {\n                inWord = false;\n            } else {\n                sb.append(Character.toLowerCase(c));\n            }\n        } else {\n            if (Character.isWhitespace(c) || Arrays.binarySearch(delimiters, c) >= 0) {\n                sb.append(c);\n                inWord = true;\n            } else {\n                sb.append(Character.toLowerCase(c));\n                inWord = true;\n            }\n        }\n    }\n    return sb.toString();\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    if (delimiters == null) {\n        delimiters = new char[]{' '};\n    }\n    final int delimLen = delimiters.length;\n    if (delimiters.length == 0) {\n        return str.toLowerCase();\n    }\n    final StringBuilder sb = new StringBuilder();\n    boolean inWord = false;\n    for (char c : str.toCharArray()) {\n        if (Arrays.binarySearch(delimiters, c) >= 0) {\n            inWord = false;\n        } else if (!inWord) {\n            sb.append(Character.toLowerCase(c));\n            inWord = true;\n        } else {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return str.toLowerCase();\n    }\n    StringBuilder sb = new StringBuilder();\n    boolean inWord = false;\n    for (char c : str.toCharArray()) {\n        if (delimLen != -1 && Arrays.binarySearch(delimiters, c) >= 0) {\n            inWord = false;\n        } else if (!inWord) {\n            inWord = true;\n            sb.append(Character.toLowerCase(c));\n        } else {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return str.toLowerCase();\n    }\n    final StringBuilder sb = new StringBuilder();\n    boolean inWord = false;\n    for (int i = 0; i < str.length(); i++) {\n        char c = str.charAt(i);\n        if (delimLen != -1 && Arrays.binarySearch(delimiters, c) >= 0) {\n            inWord = false;\n        } else if (!inWord) {\n            inWord = true;\n            c = Character.toLowerCase(c);\n        }\n        sb.append(c);\n    }\n    return sb.toString();\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return str.toLowerCase();\n    }\n    StringBuilder sb = new StringBuilder();\n    boolean inWord = false;\n    for (char c : str.toCharArray()) {\n        if (delimLen > 0 && Arrays.binarySearch(delimiters, c) >= 0) {\n            inWord = false;\n        } else {\n            if (!inWord) {\n                sb.append(Character.toLowerCase(c));\n                inWord = true;\n            } else {\n                sb.append(c);\n            }\n        }\n    }\n    return sb.toString();\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return str.toLowerCase();\n    }\n    StringBuilder sb = new StringBuilder();\n    boolean inWord = false;\n    for (char c : str.toCharArray()) {\n        if (delimLen != -1 && Arrays.binarySearch(delimiters, c) >= 0) {\n            inWord = false;\n        } else if (!inWord) {\n            inWord = true;\n            c = Character.toLowerCase(c);\n        }\n        sb.append(c);\n    }\n    return sb.toString();\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return str.toLowerCase();\n    }\n    StringBuilder sb = new StringBuilder();\n    boolean inWord = false;\n    for (char c : str.toCharArray()) {\n        if (delimLen > 0 && Arrays.binarySearch(delimiters, c) >= 0) {\n            inWord = false;\n        } else {\n            if (!inWord) {\n                sb.append(Character.toLowerCase(c));\n                inWord = true;\n            } else {\n                sb.append(c);\n            }\n        }\n    }\n    return sb.toString();\n}"
    ],
    [
      "protected static Dfp[] split(final Dfp a)  {\n    DfpField field = a.getField();\n    Dfp[] result = new Dfp[2];\n    result[0] = field.newDfp(a.toString().substring(0, a.toString().indexOf('.')));\n    result[1] = field.newDfp(a.toString().substring(a.toString().indexOf('.') + 1));\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    DfpField field = a.getField();\n    String str = a.toString();\n    Dfp[] splitDfps = split(field, str);\n    result[0] = field.newDfp(splitDfps[0].toString());\n    result[1] = field.newDfp(splitDfps[1].toString());\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    DfpField field = a.getField();\n    Dfp[] result = new Dfp[2];\n    String str = a.toString();\n    result[0] = field.newDfp(str.substring(0, str.indexOf('.')));\n    result[1] = field.newDfp(str.substring(str.indexOf('.') + 1));\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    DfpField field = a.getField();\n    String str = a.toString();\n    Dfp[] splitResult = split(field, str);\n    result[0] = field.newDfp(splitResult[0].toString());\n    result[1] = field.newDfp(splitResult[1].toString());\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    DfpField field = a.getField();\n    Dfp[] result = new Dfp[2];\n    result[0] = a.setScale(a.getScale() / 2);\n    result[1] = a.setScale(a.getScale() / 2).add(a.setScale(0));\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    DfpField field = a.getField();\n    Dfp[] result = new Dfp[2];\n    String str = a.toString();\n    result[0] = field.newDfp(str.substring(0, str.indexOf('.')));\n    result[1] = field.newDfp(str.substring(str.indexOf('.') + 1));\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    DfpField field = a.getField();\n    Dfp[] result = new Dfp[2];\n    String str = a.toString();\n    result[0] = field.newDfp(str.substring(0, str.indexOf('.')));\n    result[1] = field.newDfp(str.substring(str.indexOf('.') + 1));\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    DfpField field = a.getField();\n    String str = a.toString();\n    result[0] = field.newDfp(str.substring(0, str.indexOf('.')));\n    result[1] = field.newDfp(str.substring(str.indexOf('.') + 1));\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    DfpField field = a.getField();\n    String str = a.toString();\n    Dfp[] splitResult = split(field, str);\n    result[0] = field.newDfp(splitResult[0].toString());\n    result[1] = field.newDfp(splitResult[1].toString());\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    DfpField field = a.getField();\n    Dfp[] result = new Dfp[2];\n    result[0] = field.newDfp(a.toString().substring(0, a.toString().indexOf('.')));\n    result[1] = field.newDfp(a.toString().substring(a.toString().indexOf('.') + 1));\n    return result;\n}"
    ],
    [
      "public String cssSelector()  {\n    String selector = \"\";\n    if (getId() != null) {\n        selector = \"#\" + getId();\n    } else {\n        Node parent = getParent();\n        if (parent != null) {\n            selector = parent.cssSelector() + \" > \";\n        }\n        selector += getTagName();\n        if (!getClassName().isEmpty()) {\n            selector += \".\" + getClassName();\n        }\n        if (getSiblingIndex() > 0) {\n            selector += \":nth-child(\" + getSiblingIndex() + \")\";\n        }\n    }\n    return selector;\n}",
      "public String cssSelector()  {\n    if (getId() != null) {\n        return \"#\" + getId();\n    } else {\n        StringBuilder sb = new StringBuilder();\n        Element parent = getParent();\n        if (parent != null) {\n            sb.append(parent.cssSelector());\n            sb.append(\" > \");\n        }\n        sb.append(getTagName());\n        String className = getClassAttribute();\n        if (className != null && !className.isEmpty()) {\n            sb.append(\".\" + className);\n        }\n        int index = getIndex();\n        if (index >= 0) {\n            sb.append(\":nth-child(\" + (index + 1) + \")\");\n        }\n        return sb.toString();\n    }\n}",
      "public String cssSelector()  {\n    if (getId() != null) {\n        return \"#\" + getId();\n    }\n    StringBuilder sb = new StringBuilder();\n    Element parent = getParent();\n    if (parent != null) {\n        sb.append(parent.cssSelector());\n        sb.append(\" > \");\n    }\n    sb.append(getTagName());\n    String className = getClassAttribute();\n    if (className != null) {\n        sb.append(\".\" + className);\n    }\n    int index = getIndex();\n    if (index != -1) {\n        sb.append(\":nth-child(\" + index + \")\");\n    }\n    return sb.toString();\n}",
      "public String cssSelector()  {\n    String selector = \"\";\n    if (getId() != null) {\n        selector = \"#\" + getId();\n    } else {\n        Element parent = getParentElement();\n        if (parent != null) {\n            selector = parent.cssSelector() + \" > \";\n        }\n        selector += getTag().getName();\n        if (!getClasses().isEmpty()) {\n            selector += \".\" + String.join(\".\", getClasses());\n        }\n        if (getIndex() > 0) {\n            selector += \":nth-child(\" + getIndex() + \")\";\n        }\n    }\n    return selector;\n}",
      "public String cssSelector()  {\n    String id = getId();\n    if (id != null) {\n        return \"#\" + id;\n    }\n    StringBuilder sb = new StringBuilder();\n    Element parent = getParent();\n    if (parent != null) {\n        sb.append(parent.cssSelector());\n        sb.append(\" > \");\n    }\n    sb.append(getTagName());\n    List<String> classes = getClassNames();\n    if (!classes.isEmpty()) {\n        sb.append(\":\");\n        for (String className : classes) {\n            sb.append(\".\" + className);\n        }\n    }\n    int index = getIndex();\n    if (index != -1) {\n        sb.append(\":nth-child(\" + index + \")\");\n    }\n    return sb.toString();\n}",
      "public String cssSelector()  {\n    if (getId() != null) {\n        return \"#\" + getId();\n    }\n    StringBuilder selector = new StringBuilder();\n    Element parent = getParentElement();\n    if (parent != null) {\n        selector.append(parent.cssSelector());\n        selector.append(\" > \");\n    }\n    selector.append(getTagName());\n    List<String> classes = getClassNames();\n    if (!classes.isEmpty()) {\n        selector.append(\":nth-child(\" + classes.size() + \")\");\n        selector.append(\".\");\n        for (String className : classes) {\n            selector.append(className);\n            selector.append(\".\");\n        }\n    }\n    return selector.toString();\n}",
      "public String cssSelector()  {\n    if (getId() != null) {\n        return \"#\" + getId();\n    }\n    StringBuilder selector = new StringBuilder();\n    Element parent = getParentElement();\n    if (parent != null) {\n        selector.append(parent.cssSelector());\n        selector.append(\" > \");\n    }\n    selector.append(getTagName());\n    for (String className : getClassNames()) {\n        selector.append(\".\" + className);\n    }\n    int index = getIndex();\n    if (index != -1) {\n        selector.append(\":nth-child(\" + index + \")\");\n    }\n    return selector.toString();\n}",
      "public String cssSelector()  {\n    String id = getId();\n    if (id != null) {\n        return \"#\" + id;\n    }\n    StringBuilder selector = new StringBuilder();\n    Element parent = getParentElement();\n    if (parent != null) {\n        selector.append(parent.cssSelector());\n        selector.append(\" > \");\n    }\n    selector.append(getTagName());\n    List<String> classNames = getClassNames();\n    if (!classNames.isEmpty()) {\n        selector.append(\":nth-child(\");\n        selector.append(classNames.size());\n        selector.append(\")\");\n    }\n    return selector.toString();\n}",
      "public String cssSelector()  {\n    String id = getId();\n    if (id != null) {\n        return \"#\" + id;\n    }\n    StringBuilder sb = new StringBuilder();\n    Element parent = getParentElement();\n    if (parent != null) {\n        sb.append(parent.cssSelector());\n        sb.append(\" > \");\n    }\n    sb.append(getTagName());\n    List<String> classes = getClassNames();\n    if (!classes.isEmpty()) {\n        sb.append(\":\");\n        sb.append(String.join(\".\", classes));\n    }\n    int index = getIndex();\n    if (index > 0) {\n        sb.append(\":nth-child(\");\n        sb.append(index);\n        sb.append(\")\");\n    }\n    return sb.toString();\n}",
      "public String cssSelector()  {\n    if (getId() != null) {\n        return \"#\" + getId();\n    } else {\n        StringBuilder sb = new StringBuilder();\n        Element parent = getParentElement();\n        if (parent != null) {\n            sb.append(parent.cssSelector());\n            sb.append(\" > \");\n        }\n        sb.append(getTagName());\n        List<String> classNames = getClassNames();\n        if (!classNames.isEmpty()) {\n            sb.append(\":\");\n            sb.append(String.join(\".\", classNames));\n        }\n        int index = getIndexInParent();\n        if (index != -1) {\n            sb.append(\":nth-child(\");\n            sb.append(index + 1);\n            sb.append(\")\");\n        }\n        return sb.toString();\n    }\n}"
    ],
    [
      "private static int estimateCostOneLevel(Node n)  {\n    if (n.getType() == Token.NOT) {\n        return 1;\n    } else if (n.getType() == Token.PAREN_OPEN || n.getType() == Token.PAREN_CLOSE) {\n        return 0;\n    } else {\n        return 0;\n    }\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    if (n.getType() == Token.NOT) {\n        return 2; // for '!' and the negated node\n    } else if (n.getType() == Token.LPAREN || n.getType() == Token.RPAREN) {\n        return 0; // parentheses are counted by the parent node\n    } else {\n        return 0; // other nodes do not affect the cost\n    }\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    if (n.getType() == Token.NOT) {\n        return 2;\n    } else if (n.getType() == Token.LPAREN || n.getType() == Token.RPAREN) {\n        return 1;\n    } else {\n        return 0;\n    }\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    if (n.getType() == Token.NOT) {\n        return 1;\n    }\n    return 0;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    if (n.getType() == Token.NOT) {\n        return 1;\n    } else if (n.getType() == Token.PAREN_OPEN || n.getType() == Token.PAREN_CLOSE) {\n        return 0;\n    } else {\n        return 0;\n    }\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    if (n.getType() == Token.NOT) {\n        return 1;\n    } else if (n.getType() == Token.LPAREN || n.getType() == Token.RPAREN) {\n        return 0;\n    } else {\n        return 0;\n    }\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    if (n.getType() == Token.NOT) {\n        return 2; // for NOT\n    } else if (n.getType() == Token.LPAREN || n.getType() == Token.RPAREN) {\n        return 1; // for parentheses\n    } else {\n        return 0; // for other nodes\n    }\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    if (n.getType() == Token.NOT) {\n        return 1;\n    } else if (n.getType() == Token.LPAREN || n.getType() == Token.RPAREN) {\n        return 0;\n    } else {\n        return 0;\n    }\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    if (n.getType() == Token.NOT) {\n        return 2; // NOT node\n    }\n    return 0;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    if (n.getType() == Token.NOT) {\n        return 2; // for NOT\n    } else if (n.getType() == Token.LPAREN || n.getType() == Token.RPAREN) {\n        return 0; // parentheses are counted by parent\n    } else {\n        return 0; // no negations or parentheses\n    }\n}"
    ],
    [
      "public StrBuilder reverse()  {\n    char[] buffer = this.buffer;\n    int start = 0;\n    int end = size - 1;\n    while (start < end) {\n        char temp = buffer[start];\n        buffer[start] = buffer[end];\n        buffer[end] = temp;\n        start++;\n        end--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int start = 0;\n    int end = size - 1;\n    char[] buffer = this.buffer;\n    while (start < end) {\n        char temp = buffer[start];\n        buffer[start] = buffer[end];\n        buffer[end] = temp;\n        start++;\n        end--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    char[] buffer = this.buffer;\n    int start = 0;\n    int end = buffer.length - 1;\n    while (start < end) {\n        char temp = buffer[start];\n        buffer[start] = buffer[end];\n        buffer[end] = temp;\n        start++;\n        end--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    char[] buffer = this.buffer;\n    int start = 0;\n    int end = size;\n    while (start < end) {\n        char temp = buffer[start];\n        buffer[start] = buffer[end - 1];\n        buffer[end - 1] = temp;\n        start++;\n        end--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int start = 0;\n    int end = size - 1;\n    char[] buffer = this.buffer;\n    while (start < end) {\n        char temp = buffer[start];\n        buffer[start] = buffer[end];\n        buffer[end] = temp;\n        start++;\n        end--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    char[] buffer = this.buffer;\n    int start = 0;\n    int end = size - 1;\n    while (start < end) {\n        char temp = buffer[start];\n        buffer[start] = buffer[end];\n        buffer[end] = temp;\n        start++;\n        end--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int start = 0;\n    int end = size - 1;\n    char[] buffer = this.buffer;\n    while (start < end) {\n        char temp = buffer[start];\n        buffer[start] = buffer[end];\n        buffer[end] = temp;\n        start++;\n        end--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    char[] buffer = this.buffer;\n    int start = 0;\n    int end = buffer.length - 1;\n    while (start < end) {\n        char temp = buffer[start];\n        buffer[start] = buffer[end];\n        buffer[end] = temp;\n        start++;\n        end--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    char[] buffer = this.buffer;\n    int start = 0;\n    int end = size - 1;\n    while (start < end) {\n        char temp = buffer[start];\n        buffer[start] = buffer[end];\n        buffer[end] = temp;\n        start++;\n        end--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    char[] buffer = this.buffer;\n    int start = 0;\n    int end = buffer.length - 1;\n    while (start < end) {\n        char temp = buffer[start];\n        buffer[start] = buffer[end];\n        buffer[end] = temp;\n        start++;\n        end--;\n    }\n    return this;\n}"
    ],
    [
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "public TextNode splitText(int offset)  {\n    String text = getWholeText();\n    String before = text.substring(0, offset);\n    String after = text.substring(offset);\n    TextNode newNode = new TextNode(after);\n    this.text(before);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = getWholeText();\n    String firstPart = text.substring(0, offset);\n    String secondPart = text.substring(offset);\n    TextNode newNode = new TextNode(secondPart);\n    this.text(firstPart);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = getWholeText();\n    String before = text.substring(0, offset);\n    String after = text.substring(offset);\n    TextNode newNode = new TextNode(after);\n    setCoreContent(before);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = getWholeText();\n    String firstPart = text.substring(0, offset);\n    String secondPart = text.substring(offset);\n    TextNode first = new TextNode(firstPart);\n    TextNode second = new TextNode(secondPart);\n    insertBefore(second);\n    return second;\n}",
      "public TextNode splitText(int offset)  {\n    String text = getWholeText();\n    String firstPart = text.substring(0, offset);\n    String secondPart = text.substring(offset);\n    TextNode newNode = new TextNode(secondPart);\n    this.text(firstPart);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = getWholeText();\n    String left = text.substring(0, offset);\n    String right = text.substring(offset);\n    TextNode leftNode = new TextNode(left);\n    TextNode rightNode = new TextNode(right);\n    insertAfter(this, rightNode);\n    return rightNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = getWholeText();\n    String before = text.substring(0, offset);\n    String after = text.substring(offset);\n    TextNode newNode = new TextNode(after);\n    this.text(before);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = getWholeText();\n    String before = text.substring(0, offset);\n    String after = text.substring(offset);\n    TextNode newNode = new TextNode(after);\n    this.text(before);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = getWholeText();\n    String before = text.substring(0, offset);\n    String after = text.substring(offset);\n    TextNode newNode = new TextNode(after);\n    this.value = before;\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = getWholeText();\n    String left = text.substring(0, offset);\n    String right = text.substring(offset);\n    TextNode leftNode = new TextNode(left);\n    TextNode rightNode = new TextNode(right);\n    insertAfter(this, rightNode);\n    return rightNode;\n}"
    ],
    [
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    Set<O> setA = new HashSet<O>();\n    Set<O> setB = new HashSet<O>();\n    for (O obj : a) {\n        setA.add(obj);\n    }\n    for (O obj : b) {\n        setB.add(obj);\n    }\n    setA.removeAll(setB);\n    setB.removeAll(setA);\n    setA.addAll(setB);\n    return new HashSet<O>(setA);\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    Collection<O> union = union(a, b);\n    Collection<O> intersection = intersection(a, b);\n    return subtract(union, intersection);\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    Collection<O> unionCollection = union(a, b);\n    Collection<O> intersectionCollection = intersection(a, b);\n    return subtract(unionCollection, intersectionCollection);\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    Collection<O> unionCollection = union(a, b);\n    Collection<O> intersectionCollection = intersection(a, b);\n    Collection<O> disjunctionCollection = new ArrayList<O>();\n    for (O obj : unionCollection) {\n        if (!intersectionCollection.contains(obj)) {\n            disjunctionCollection.add(obj);\n        }\n    }\n    return disjunctionCollection;\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    Collection<O> unionCollection = union(a, b);\n    Collection<O> intersectionCollection = intersection(a, b);\n    return subtract(unionCollection, intersectionCollection);\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    Collection<O> unionCollection = union(a, b);\n    Collection<O> intersectionCollection = intersection(a, b);\n    return subtract(unionCollection, intersectionCollection);\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    Collection<O> unionSet = union(a, b);\n    Collection<O> intersectionSet = intersection(a, b);\n    return subtract(unionSet, intersectionSet);\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    Collection<O> unionCollection = union(a, b);\n    Collection<O> intersectionCollection = intersection(a, b);\n    return subtract(unionCollection, intersectionCollection);\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    Collection<O> unionCollection = union(a, b);\n    Collection<O> intersectionCollection = intersection(a, b);\n    Collection<O> disjunctionCollection = new ArrayList<O>();\n    for (O obj : unionCollection) {\n        if (!intersectionCollection.contains(obj)) {\n            disjunctionCollection.add(obj);\n        }\n    }\n    return disjunctionCollection;\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    Collection<O> unionCollection = union(a, b);\n    Collection<O> intersectionCollection = intersection(a, b);\n    return subtract(unionCollection, intersectionCollection);\n}"
    ],
    [
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    bytes[0] = (byte) ((value.byteAt(BYTE_7_SHIFT) & BYTE_7_MASK) >> BYTE_7_SHIFT);\n    bytes[1] = (byte) ((value.byteAt(BYTE_6_SHIFT) & BYTE_6_MASK) >> BYTE_6_SHIFT);\n    bytes[2] = (byte) ((value.byteAt(BYTE_5_SHIFT) & BYTE_5_MASK) >> BYTE_5_SHIFT);\n    bytes[3] = (byte) ((value.byteAt(BYTE_4_SHIFT) & BYTE_4_MASK) >> BYTE_4_SHIFT);\n    bytes[4] = (byte) ((value.byteAt(BYTE_3_SHIFT) & BYTE_3_MASK) >> BYTE_3_SHIFT);\n    bytes[5] = (byte) ((value.byteAt(LEFTMOST_BIT_SHIFT) & LEFTMOST_BIT) >> LEFTMOST_BIT_SHIFT);\n    bytes[6] = (byte) (value.byteAt(0) & 0xFF);\n    bytes[7] = (byte) (value.byteAt(0) >> 8);\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    bytes[0] = (byte) ((value.byteAt(BYTE_7_SHIFT / 8) >>> BYTE_7_SHIFT % 8) & 0x7F);\n    bytes[1] = (byte) ((value.byteAt(BYTE_7_SHIFT / 8) & 0x7F) << (7 - BYTE_7_SHIFT % 8));\n    bytes[1] |= (byte) ((value.byteAt(BYTE_6_SHIFT / 8) >>> BYTE_6_SHIFT % 8) & 0x7F);\n    bytes[2] = (byte) ((value.byteAt(BYTE_6_SHIFT / 8) & 0x7F) << (7 - BYTE_6_SHIFT % 8));\n    bytes[2] |= (byte) ((value.byteAt(BYTE_5_SHIFT / 8) >>> BYTE_5_SHIFT % 8) & 0x7F);\n    bytes[3] = (byte) ((value.byteAt(BYTE_5_SHIFT / 8) & 0x7F) << (7 - BYTE_5_SHIFT % 8));\n    bytes[3] |= (byte) ((value.byteAt(BYTE_4_SHIFT / 8) >>> BYTE_4_SHIFT % 8) & 0x7F);\n    bytes[4] = (byte) ((value.byteAt(BYTE_4_SHIFT / 8) & 0x7F) << (7 - BYTE_4_SHIFT % 8));\n    bytes[4] |= (byte) ((value.byteAt(BYTE_3_SHIFT / 8) >>> BYTE_3_SHIFT % 8) & 0x7F);\n    bytes[5] = (byte) ((value.byteAt(BYTE_3_SHIFT / 8) & 0x7F) << (7 - BYTE_3_SHIFT % 8));\n    bytes[5] |= (byte) ((value.byteAt(BYTE_2_SHIFT / 8) >>> BYTE_2_SHIFT % 8) & 0x7F);\n    bytes[6] = (byte) ((value.byteAt(BYTE_2_SHIFT / 8) & 0x7F) << (7 - BYTE_2_SHIFT % 8));\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    bytes[0] = (byte) ((value.byteAt(BYTE_7_SHIFT) >> BYTE_7_SHIFT) & 0x7F);\n    bytes[1] = (byte) ((value.byteAt(BYTE_7_SHIFT) >> (BYTE_7_SHIFT - 7)) & 0x7F);\n    bytes[2] = (byte) ((value.byteAt(BYTE_6_SHIFT) >> BYTE_6_SHIFT) & 0xFF);\n    bytes[3] = (byte) ((value.byteAt(BYTE_6_SHIFT) >> (BYTE_6_SHIFT - 8)) & 0xFF);\n    bytes[4] = (byte) ((value.byteAt(BYTE_5_SHIFT) >> BYTE_5_SHIFT) & 0xFF);\n    bytes[5] = (byte) ((value.byteAt(BYTE_5_SHIFT) >> (BYTE_5_SHIFT - 8)) & 0xFF);\n    bytes[6] = (byte) ((value.byteAt(BYTE_4_SHIFT) >> BYTE_4_SHIFT) & 0xFF);\n    bytes[7] = (byte) ((value.byteAt(BYTE_4_SHIFT) >> (BYTE_4_SHIFT - 8)) & 0xFF);\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    bytes[0] = (byte) ((value.byteAt(BYTE_7_SHIFT / 8) >> (BYTE_7_SHIFT % 8)) & 0x7F);\n    bytes[1] = (byte) ((value.byteAt(BYTE_7_SHIFT / 8) << (7 - (BYTE_7_SHIFT % 8))) | (value.byteAt(BYTE_6_SHIFT / 8) >> (BYTE_6_SHIFT % 8)) & 0x7F);\n    bytes[2] = (byte) ((value.byteAt(BYTE_6_SHIFT / 8) << (7 - (BYTE_6_SHIFT % 8))) | (value.byteAt(BYTE_5_SHIFT / 8) >> (BYTE_5_SHIFT % 8)) & 0x7F);\n    bytes[3] = (byte) ((value.byteAt(BYTE_5_SHIFT / 8) << (7 - (BYTE_5_SHIFT % 8))) | (value.byteAt(BYTE_4_SHIFT / 8) >> (BYTE_4_SHIFT % 8)) & 0x7F);\n    bytes[4] = (byte) ((value.byteAt(BYTE_4_SHIFT / 8) << (7 - (BYTE_4_SHIFT % 8))) | (value.byteAt(BYTE_3_SHIFT / 8) >> (BYTE_3_SHIFT % 8)) & 0x7F);\n    bytes[5] = (byte) ((value.byteAt(BYTE_3_SHIFT / 8) << (7 - (BYTE_3_SHIFT % 8))) | (value.byteAt(BYTE_2_SHIFT / 8) >> (BYTE_2_SHIFT % 8)) & 0x7F);\n    bytes[6] = (byte) ((value.byteAt(BYTE_2_SHIFT / 8) << (7 - (BYTE_2_SHIFT % 8))) | (value.byteAt(0) >> (LEFTMOST_BIT_SHIFT % 8)) & 0x7F);\n    bytes[7] = (byte) ((value.byteAt(0) << (7 - (LEFTMOST_BIT_SHIFT % 8))) & 0x7F);\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    bytes[0] = (byte) ((value.byteAt(BYTE_7_SHIFT / 8) >>> BYTE_7_SHIFT % 8) & 0x7F);\n    bytes[1] = (byte) ((value.byteAt(BYTE_7_SHIFT / 8) << (8 - BYTE_7_SHIFT % 8)) | (value.byteAt(BYTE_6_SHIFT / 8) >>> BYTE_6_SHIFT % 8) & 0x7F);\n    bytes[2] = (byte) ((value.byteAt(BYTE_6_SHIFT / 8) << (8 - BYTE_6_SHIFT % 8)) | (value.byteAt(BYTE_5_SHIFT / 8) >>> BYTE_5_SHIFT % 8) & 0x7F);\n    bytes[3] = (byte) ((value.byteAt(BYTE_5_SHIFT / 8) << (8 - BYTE_5_SHIFT % 8)) | (value.byteAt(BYTE_4_SHIFT / 8) >>> BYTE_4_SHIFT % 8) & 0x7F);\n    bytes[4] = (byte) ((value.byteAt(BYTE_4_SHIFT / 8) << (8 - BYTE_4_SHIFT % 8)) | (value.byteAt(BYTE_3_SHIFT / 8) >>> BYTE_3_SHIFT % 8) & 0x7F);\n    bytes[5] = (byte) ((value.byteAt(BYTE_3_SHIFT / 8) << (8 - BYTE_3_SHIFT % 8)) | (value.byteAt(BYTE_2_SHIFT / 8) >>> BYTE_2_SHIFT % 8) & 0x7F);\n    bytes[6] = (byte) ((value.byteAt(BYTE_2_SHIFT / 8) << (8 - BYTE_2_SHIFT % 8)) | (value.byteAt(0) >>> 0) & 0x7F);\n    bytes[7] = (byte) (value.byteAt(0) << (8 - 0) & 0x7F);\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    bytes[0] = (byte) ((value.byteAt(BYTE_7_SHIFT / 8) >> (BYTE_7_SHIFT % 8)) & 0x7F);\n    bytes[1] = (byte) ((value.byteAt(BYTE_7_SHIFT / 8) << (7 - (BYTE_7_SHIFT % 8))) | (value.byteAt(BYTE_6_SHIFT / 8) >> (BYTE_6_SHIFT % 8)) & 0x7F);\n    bytes[2] = (byte) ((value.byteAt(BYTE_6_SHIFT / 8) << (7 - (BYTE_6_SHIFT % 8))) | (value.byteAt(BYTE_5_SHIFT / 8) >> (BYTE_5_SHIFT % 8)) & 0x7F);\n    bytes[3] = (byte) ((value.byteAt(BYTE_5_SHIFT / 8) << (7 - (BYTE_5_SHIFT % 8))) | (value.byteAt(BYTE_4_SHIFT / 8) >> (BYTE_4_SHIFT % 8)) & 0x7F);\n    bytes[4] = (byte) ((value.byteAt(BYTE_4_SHIFT / 8) << (7 - (BYTE_4_SHIFT % 8))) | (value.byteAt(BYTE_3_SHIFT / 8) >> (BYTE_3_SHIFT % 8)) & 0x7F);\n    bytes[5] = (byte) ((value.byteAt(BYTE_3_SHIFT / 8) << (7 - (BYTE_3_SHIFT % 8))) | (value.byteAt(BYTE_2_SHIFT / 8) >> (BYTE_2_SHIFT % 8)) & 0x7F);\n    bytes[6] = (byte) ((value.byteAt(BYTE_2_SHIFT / 8) << (7 - (BYTE_2_SHIFT % 8))) | (value.byteAt(0) >> (0)) & 0x7F);\n    bytes[7] = (byte) ((value.byteAt(0) << (7 - (0))) | (value.testBit(LEFTMOST_BIT_SHIFT)) ? LEFTMOST_BIT : (byte) 0);\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    bytes[0] = (byte) ((value.testBit(LEFTMOST_BIT_SHIFT) ? 1 : 0) << BYTE_7_SHIFT);\n    bytes[0] = (byte) ((value.testBit(BYTE_7_SHIFT) ? 1 : 0) << BYTE_6_SHIFT);\n    bytes[0] = (byte) ((value.testBit(BYTE_6_SHIFT) ? 1 : 0) << BYTE_5_SHIFT);\n    bytes[0] = (byte) ((value.testBit(BYTE_5_SHIFT) ? 1 : 0) << BYTE_4_SHIFT);\n    bytes[0] = (byte) ((value.testBit(BYTE_4_SHIFT) ? 1 : 0) << BYTE_3_SHIFT);\n    bytes[0] = (byte) ((value.testBit(BYTE_3_SHIFT) ? 1 : 0) << BYTE_2_SHIFT);\n    bytes[0] = (byte) (value.testBit(BYTE_2_SHIFT) ? 1 : 0);\n    bytes[1] = (byte) (value.byteValue());\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    bytes[0] = (byte) ((value.byteAt(BYTE_7_SHIFT) & BYTE_7_MASK) >> BYTE_7_SHIFT);\n    bytes[1] = (byte) ((value.byteAt(BYTE_6_SHIFT) & BYTE_6_MASK) >> BYTE_6_SHIFT);\n    bytes[2] = (byte) ((value.byteAt(BYTE_5_SHIFT) & BYTE_5_MASK) >> BYTE_5_SHIFT);\n    bytes[3] = (byte) ((value.byteAt(BYTE_4_SHIFT) & BYTE_4_MASK) >> BYTE_4_SHIFT);\n    bytes[4] = (byte) ((value.byteAt(BYTE_3_SHIFT) & BYTE_3_MASK) >> BYTE_3_SHIFT);\n    bytes[5] = (byte) ((value.byteAt(LEFTMOST_BIT_SHIFT) & LEFTMOST_BIT) >> LEFTMOST_BIT_SHIFT);\n    bytes[6] = (byte) (value.byteAt(0) & 0xFF);\n    bytes[7] = (byte) (value.byteAt(0) >> 8);\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    bytes[0] = (byte) ((value.byteAt(BYTE_7_SHIFT / 8) >> (BYTE_7_SHIFT % 8)) & 0x7F);\n    bytes[1] = (byte) ((value.byteAt(BYTE_7_SHIFT / 8) << (7 - (BYTE_7_SHIFT % 8))) | (value.byteAt(BYTE_6_SHIFT / 8) >> (BYTE_6_SHIFT % 8)) & 0x7F);\n    bytes[2] = (byte) ((value.byteAt(BYTE_6_SHIFT / 8) << (7 - (BYTE_6_SHIFT % 8))) | (value.byteAt(BYTE_5_SHIFT / 8) >> (BYTE_5_SHIFT % 8)) & 0x7F);\n    bytes[3] = (byte) ((value.byteAt(BYTE_5_SHIFT / 8) << (7 - (BYTE_5_SHIFT % 8))) | (value.byteAt(BYTE_4_SHIFT / 8) >> (BYTE_4_SHIFT % 8)) & 0x7F);\n    bytes[4] = (byte) ((value.byteAt(BYTE_4_SHIFT / 8) << (7 - (BYTE_4_SHIFT % 8))) | (value.byteAt(BYTE_3_SHIFT / 8) >> (BYTE_3_SHIFT % 8)) & 0x7F);\n    bytes[5] = (byte) ((value.byteAt(BYTE_3_SHIFT / 8) << (7 - (BYTE_3_SHIFT % 8))) | (value.byteAt(BYTE_2_SHIFT / 8) >> (BYTE_2_SHIFT % 8)) & 0x7F);\n    bytes[6] = (byte) ((value.byteAt(BYTE_2_SHIFT / 8) << (7 - (BYTE_2_SHIFT % 8))) | (value.byteAt(0) >> (LEFTMOST_BIT_SHIFT % 8)) & 0x7F);\n    bytes[7] = (byte) ((value.byteAt(0) << (7 - (LEFTMOST_BIT_SHIFT % 8))) | (value.testBit(LEFTMOST_BIT_SHIFT))) & 0xFF;\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    bytes[0] = (byte) ((value.byteAt(BYTE_7_SHIFT / 8) >>> BYTE_7_SHIFT % 8) & 0x7F);\n    bytes[1] = (byte) ((value.byteAt(BYTE_7_SHIFT / 8) << (8 - BYTE_7_SHIFT % 8)) | (value.byteAt(BYTE_6_SHIFT / 8) >>> BYTE_6_SHIFT % 8) & 0x7F);\n    bytes[2] = (byte) ((value.byteAt(BYTE_6_SHIFT / 8) << (8 - BYTE_6_SHIFT % 8)) | (value.byteAt(BYTE_5_SHIFT / 8) >>> BYTE_5_SHIFT % 8) & 0x7F);\n    bytes[3] = (byte) ((value.byteAt(BYTE_5_SHIFT / 8) << (8 - BYTE_5_SHIFT % 8)) | (value.byteAt(BYTE_4_SHIFT / 8) >>> BYTE_4_SHIFT % 8) & 0x7F);\n    bytes[4] = (byte) ((value.byteAt(BYTE_4_SHIFT / 8) << (8 - BYTE_4_SHIFT % 8)) | (value.byteAt(BYTE_3_SHIFT / 8) >>> BYTE_3_SHIFT % 8) & 0x7F);\n    bytes[5] = (byte) ((value.byteAt(BYTE_3_SHIFT / 8) << (8 - BYTE_3_SHIFT % 8)) | (value.byteAt(BYTE_2_SHIFT / 8) >>> BYTE_2_SHIFT % 8) & 0x7F);\n    bytes[6] = (byte) ((value.byteAt(BYTE_2_SHIFT / 8) << (8 - BYTE_2_SHIFT % 8)) | (value.byteAt(0) >>> 0) & 0x7F);\n    bytes[7] = (byte) ((value.byteAt(0) << (8 - 0)) & 0x7F);\n    return bytes;\n}"
    ],
    [
      "public static String keep(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return str;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        StringBuilder buffer = new StringBuilder();\n        for (int i = 0; i < str.length(); i++) {\n            char ch = str.charAt(i);\n            if (chars.contains(ch)) {\n                buffer.append(ch);\n            }\n        }\n        return buffer.toString();\n    }",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    StringBuilder buffer = new StringBuilder();\n    for (int i = 0; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        if (chars.contains(ch)) {\n            buffer.append(ch);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    StringBuilder buffer = new StringBuilder();\n    char lastChar = 0;\n    for (int i = 0; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        if (chars.contains(ch) && ch != lastChar) {\n            buffer.append(ch);\n            lastChar = ch;\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    StringBuilder buffer = new StringBuilder();\n    for (int i = 0; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        if (chars.contains(ch)) {\n            buffer.append(ch);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return str;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        StringBuilder buffer = new StringBuilder();\n        for (int i = 0; i < str.length(); i++) {\n            char ch = str.charAt(i);\n            if (chars.contains(ch)) {\n                buffer.append(ch);\n            }\n        }\n        return buffer.toString();\n    }",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    StringBuilder buffer = new StringBuilder();\n    char lastChar = '\\0';\n    for (int i = 0; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        if (chars.contains(ch) && ch != lastChar) {\n            buffer.append(ch);\n            lastChar = ch;\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    StringBuilder buffer = new StringBuilder();\n    char lastChar = 0;\n    for (int i = 0; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        if (chars.contains(ch) && ch != lastChar) {\n            buffer.append(ch);\n            lastChar = ch;\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    StringBuilder buffer = new StringBuilder();\n    for (int i = 0; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        if (chars.contains(ch)) {\n            buffer.append(ch);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    StringBuilder buffer = new StringBuilder();\n    for (int i = 0; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        if (chars.contains(ch)) {\n            buffer.append(ch);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    StringBuilder buffer = new StringBuilder();\n    for (int i = 0; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        if (chars.contains(ch)) {\n            buffer.append(ch);\n        }\n    }\n    return buffer.toString();\n}"
    ],
    [
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(\"Matrix is not symmetric\");\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(\"Matrix is not positive definite\");\n    }\n    RealMatrix sqrtMatrix = new RealMatrix(realEigenvalues.length);\n    for (int i = 0; i < realEigenvalues.length; i++) {\n        sqrtMatrix.setEntry(i, i, Math.sqrt(realEigenvalues[i]));\n    }\n    return sqrtMatrix;\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(\"Matrix is not symmetric\");\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(\"Matrix is not positive definite\");\n    }\n    RealMatrix squareRoot = MatrixUtils.createRealMatrix(realEigenvalues.length);\n    for (int i = 0; i < realEigenvalues.length; i++) {\n        squareRoot.setEntry(i, i, Math.sqrt(realEigenvalues[i]));\n    }\n    return squareRoot;\n}",
      "public RealMatrix getSquareRoot()  {\n    RealMatrix squareRoot = null;\n    for (int i = 0; i < realEigenvalues.length; i++) {\n        double lambda = realEigenvalues[i];\n        if (lambda < 0) {\n            throw new MathUnsupportedOperationException(\"Matrix is not positive definite\");\n        }\n    }\n    for (int i = 0; i < realEigenvalues.length; i++) {\n        double lambda = realEigenvalues[i];\n        double sqrtLambda = Math.sqrt(lambda);\n        if (squareRoot == null) {\n            squareRoot = MatrixUtils.createRealMatrix(new double[][]{{sqrtLambda}});\n        } else {\n            squareRoot = squareRoot.multiply(MatrixUtils.createRealMatrix(new double[][]{{sqrtLambda}}));\n        }\n    }\n    return squareRoot;\n}",
      "public RealMatrix getSquareRoot()  {\n    RealMatrix squareRoot = new Array2DRowRealMatrix(realEigenvalues.length);\n    for (int i = 0; i < realEigenvalues.length; i++) {\n        squareRoot.setEntry(i, i, Math.sqrt(realEigenvalues[i]));\n    }\n    return squareRoot;\n}",
      "public RealMatrix getSquareRoot()  {\n    RealMatrix sqrtMatrix = null;\n    try {\n        sqrtMatrix = EigenDecomposition.getSquareRoot(this);\n    } catch (Exception e) {\n        throw new MathUnsupportedOperationException(\"Matrix is not symmetric or not positive definite\");\n    }\n    return sqrtMatrix;\n}",
      "public RealMatrix getSquareRoot()  {\n    RealMatrix squareRoot = new BlockRealMatrix(realEigenvalues.length);\n    for (int i = 0; i < realEigenvalues.length; i++) {\n        squareRoot.setEntry(i, i, Math.sqrt(realEigenvalues[i]));\n    }\n    return squareRoot;\n}",
      "public RealMatrix getSquareRoot()  {\n    RealMatrix sqrtMatrix = null;\n    for (int i = 0; i < realEigenvalues.length; i++) {\n        double eigenvalue = realEigenvalues[i];\n        if (eigenvalue < 0) {\n            throw new MathUnsupportedOperationException(\"Matrix is not positive definite\");\n        }\n    }\n    sqrtMatrix = new BlockDiagonalMatrix();\n    for (int i = 0; i < realEigenvalues.length; i++) {\n        sqrtMatrix.addBlock(new DiagonalMatrix(new double[][]{{Math.sqrt(realEigenvalues[i])}}));\n    }\n    return sqrtMatrix;\n}",
      "public RealMatrix getSquareRoot()  {\n    RealMatrix sqrtMatrix = null;\n    try {\n        sqrtMatrix = EigenDecomposition.decompose(getD()).getSquareRoot();\n    } catch (MatrixNotPositiveDefiniteException e) {\n        throw new MathUnsupportedOperationException(\"Matrix is not symmetric or not positive definite.\");\n    }\n    return sqrtMatrix;\n}",
      "public RealMatrix getSquareRoot()  {\n    RealMatrix squareRoot = new BlockRealMatrix(realEigenvalues.length);\n    for (int i = 0; i < realEigenvalues.length; i++) {\n        squareRoot.setEntry(i, i, Math.sqrt(realEigenvalues[i]));\n    }\n    return squareRoot;\n}",
      "public RealMatrix getSquareRoot()  {\n    RealMatrix squareRoot = null;\n    for (int i = 0; i < realEigenvalues.length; i++) {\n        double eigenvalue = realEigenvalues[i];\n        if (eigenvalue < 0) {\n            throw new MathUnsupportedOperationException(\"Matrix is not positive definite\");\n        }\n    }\n    squareRoot = new Array2DRowRealMatrix(realEigenvalues);\n    return squareRoot;\n}"
    ],
    [
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t.id()) {\n            case JsonTokenId.ID_NUMBER_INT:\n                return deserializeFromInt(p, ctxt);\n            case JsonTokenId.ID_NUMBER_FLOAT:\n                return deserializeFromDouble(p, ctxt);\n            case JsonTokenId.ID_STRING:\n                return deserializeFromString(p, ctxt);\n            case JsonTokenId.ID_ARRAY_START:\n                return deserializeFromArray(p, ctxt);\n            case JsonTokenId.ID_OBJECT_START:\n                return deserializeFromObject(p, ctxt);\n            case JsonTokenId.ID_TRUE:\n                return deserializeFromBoolean(p, ctxt);\n            case JsonTokenId.ID_FALSE:\n                return deserializeFromBoolean(p, ctxt);\n            case JsonTokenId.ID_NULL:\n                return deserializeFromNull(p, ctxt);\n            default:\n                return ctxt.handleUnexpectedToken(handledType(), p);\n        }\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t.id()) {\n        case JsonTokenId.ID_NUMBER_INT:\n            return deserializeFromInt(p, ctxt);\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            return deserializeFromDouble(p, ctxt);\n        case JsonTokenId.ID_STRING:\n            return deserializeFromString(p, ctxt);\n        case JsonTokenId.ID_ARRAY_START:\n            return deserializeFromArray(p, ctxt);\n        case JsonTokenId.ID_OBJECT_START:\n            return deserializeFromObject(p, ctxt);\n        case JsonTokenId.ID_FIELD_NAME:\n            return deserializeFromField(p, ctxt);\n        case JsonTokenId.ID_END_OBJECT:\n        case JsonTokenId.ID_END_ARRAY:\n            return ctxt.handleUnexpectedToken(handledType(), p);\n        default:\n            throw ctxt.mappingException(\"Unknown token id \" + t.id());\n        }\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t.id()) {\n        case JsonTokenId.ID_NUMBER_INT:\n            return deserializeFromNumber(p, ctxt);\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            return deserializeFromDouble(p, ctxt);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return deserializeFromEmbedded(p, ctxt);\n        case JsonTokenId.ID_TRUE:\n        case JsonTokenId.ID_FALSE:\n            return deserializeFromBoolean(p, ctxt);\n        case JsonTokenId.ID_NULL:\n            return deserializeFromNull(p, ctxt);\n        case JsonTokenId.ID_START_ARRAY:\n            return deserializeFromArray(p, ctxt);\n        case JsonTokenId.ID_FIELD_NAME:\n        case JsonTokenId.ID_END_OBJECT:\n            return deserializeFromObject(p, ctxt);\n        default:\n            return ctxt.handleUnexpectedToken(handledType(), p);\n        }\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t.id()) {\n            case JsonTokenId.ID_NUMBER_INT:\n                return deserializeFromInt(p, ctxt);\n            case JsonTokenId.ID_NUMBER_FLOAT:\n                return deserializeFromDouble(p, ctxt);\n            case JsonTokenId.ID_STRING:\n                return deserializeFromString(p, ctxt);\n            case JsonTokenId.ID_ARRAY_START:\n                return deserializeFromArray(p, ctxt);\n            case JsonTokenId.ID_OBJECT_START:\n                return deserializeFromObject(p, ctxt);\n            case JsonTokenId.ID_FIELD_NAME:\n                return deserializeFromField(p, ctxt);\n            case JsonTokenId.ID_END_OBJECT:\n            case JsonTokenId.ID_END_ARRAY:\n                return deserializeToEnd(p, ctxt);\n            default:\n                return ctxt.handleUnexpectedToken(handledType(), p);\n        }\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t.id()) {\n            case JsonTokenId.ID_NUMBER_INT:\n                return deserializeFromInt(p, ctxt);\n            case JsonTokenId.ID_NUMBER_FLOAT:\n                return deserializeFromDouble(p, ctxt);\n            case JsonTokenId.ID_STRING:\n                return deserializeFromString(p, ctxt);\n            case JsonTokenId.ID_TRUE:\n                return deserializeFromBoolean(p, ctxt, true);\n            case JsonTokenId.ID_FALSE:\n                return deserializeFromBoolean(p, ctxt, false);\n            case JsonTokenId.ID_NULL:\n                return deserializeFromNull(p, ctxt);\n            case JsonTokenId.ID_START_ARRAY:\n                return deserializeFromArray(p, ctxt);\n            case JsonTokenId.ID_START_OBJECT:\n                return deserializeFromObject(p, ctxt);\n            case JsonTokenId.ID_FIELD_NAME:\n            case JsonTokenId.ID_END_OBJECT:\n                return deserializeFromObject(p, ctxt);\n            default:\n                return ctxt.handleUnexpectedToken(handledType(), p);\n        }\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.END_OBJECT) {\n            return ctxt.handleEndOfInputAtEndObject(handledType());\n        }\n        if (t == JsonToken.END_ARRAY) {\n            return ctxt.handleEndOfInputAtEndArray(handledType());\n        }\n        if (t == JsonToken.VALUE_NULL) {\n            return deserializeFromNull(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_TRUE) {\n            return deserializeFromBoolean(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_FALSE) {\n            return deserializeFromBoolean(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return deserializeFromNumber(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return deserializeFromDouble(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            return deserializeFromEmbedded(p, ctxt);\n        }\n        if (t == JsonToken.START_ARRAY) {\n            return deserializeFromArray(p, ctxt);\n        }\n        if (t == JsonToken.FIELD_NAME) {\n            String propName = p.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                try {\n                    prop.deserializeAndSet(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            handleUnknownVanilla(p, ctxt, bean, propName);\n        }\n        return ctxt.handleUnexpectedToken(handledType(), p);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t.id()) {\n        case JsonTokenId.ID_NUMBER_INT:\n            return deserializeFromNumber(p, ctxt);\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            return deserializeFromDouble(p, ctxt);\n        case JsonTokenId.ID_STRING:\n            return deserializeFromString(p, ctxt);\n        case JsonTokenId.ID_ARRAY_START:\n            return deserializeFromArray(p, ctxt);\n        case JsonTokenId.ID_OBJECT_START:\n            return deserializeFromObject(p, ctxt);\n        case JsonTokenId.ID_TRUE:\n            return deserializeFromBoolean(p, ctxt, true);\n        case JsonTokenId.ID_FALSE:\n            return deserializeFromBoolean(p, ctxt, false);\n        case JsonTokenId.ID_NULL:\n            return deserializeFromNull(p, ctxt);\n        default:\n            return ctxt.handleUnexpectedToken(handledType(), p);\n        }\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t.id()) {\n        case JsonTokenId.ID_START_OBJECT:\n            return deserializeFromObject(p, ctxt);\n        case JsonTokenId.ID_ARRAY_START:\n            return deserializeFromArray(p, ctxt);\n        case JsonTokenId.ID_FIELD_NAME:\n            return deserializeFromField(p, ctxt);\n        case JsonTokenId.ID_END_OBJECT:\n            return deserializeToEndObject(p, ctxt);\n        case JsonTokenId.ID_END_ARRAY:\n            return deserializeToEndArray(p, ctxt);\n        case JsonTokenId.ID_VALUE_STRING:\n            return deserializeFromString(p, ctxt);\n        case JsonTokenId.ID_VALUE_NUMBER_INT:\n            return deserializeFromInt(p, ctxt);\n        case JsonTokenId.ID_VALUE_NUMBER_FLOAT:\n            return deserializeFromDouble(p, ctxt);\n        case JsonTokenId.ID_VALUE_TRUE:\n            return deserializeFromBoolean(p, ctxt);\n        case JsonTokenId.ID_VALUE_FALSE:\n            return deserializeFromBoolean(p, ctxt);\n        case JsonTokenId.ID_NULL:\n            return deserializeFromNull(p, ctxt);\n        default:\n            throw ctxt.handleUnexpectedToken(handledType(), p);\n        }\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.END_OBJECT) {\n            return ctxt.handleEndOfInputAtCurrentPos();\n        }\n        if (t == JsonToken.END_ARRAY) {\n            return ctxt.handleEndOfInputAtCurrentPos();\n        }\n        if (t == JsonToken.VALUE_NULL) {\n            return ctxt.handleMissingId();\n        }\n        if (t == JsonToken.VALUE_TRUE) {\n            return Boolean.TRUE;\n        }\n        if (t == JsonToken.VALUE_FALSE) {\n            return Boolean.FALSE;\n        }\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return p.getIntValue();\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return p.getDoubleValue();\n        }\n        if (t == JsonToken.VALUE_STRING) {\n            return p.getText();\n        }\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            return p.getEmbeddedObject();\n        }\n        if (t == JsonToken.START_ARRAY) {\n            return ctxt.constructArrayInstance();\n        }\n        if (t == JsonToken.FIELD_NAME) {\n            return p.getCurrentName();\n        }\n        return ctxt.handleUnexpectedToken(handledType(), p);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t.id()) {\n        case JsonTokenId.ID_NUMBER_INT:\n            return deserializeFromInt(p, ctxt);\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            return deserializeFromDouble(p, ctxt);\n        case JsonTokenId.ID_STRING:\n            return deserializeFromString(p, ctxt);\n        case JsonTokenId.ID_ARRAY_START:\n            return deserializeFromArray(p, ctxt);\n        case JsonTokenId.ID_OBJECT_START:\n            return deserializeFromObject(p, ctxt);\n        case JsonTokenId.ID_FIELD_NAME:\n            return deserializeFromField(p, ctxt);\n        case JsonTokenId.ID_TRUE:\n            return deserializeFromBoolean(p, ctxt, true);\n        case JsonTokenId.ID_FALSE:\n            return deserializeFromBoolean(p, ctxt, false);\n        case JsonTokenId.ID_NULL:\n            return deserializeFromNull(p, ctxt);\n        default:\n            return ctxt.handleUnexpectedToken(handledType(), p);\n        }\n    }"
    ],
    [
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if(sample1.length != sample2.length) {\n        throw new DimensionMismatchException(\"The arrays must have the same length.\");\n    }\n    if(sample1.length == 0) {\n        throw new NoDataException(\"The sample arrays are empty.\");\n    }\n    double sum = 0;\n    for(int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1 == null || sample2 == null) {\n        throw new NoDataException(\"Sample arrays are empty\");\n    }\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(\"Arrays do not have the same length\");\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1 == null || sample2 == null) {\n        throw new NoDataException(\"Sample arrays are empty\");\n    }\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(\"Arrays do not have the same length\");\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if(sample1 == null || sample2 == null || sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException(\"Sample arrays are empty\");\n    }\n    if(sample1.length != sample2.length) {\n        throw new DimensionMismatchException(\"Arrays do not have the same length\");\n    }\n    double sum = 0;\n    for(int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if(sample1 == null || sample2 == null) {\n        throw new NoDataException(\"Sample arrays are empty\");\n    }\n    if(sample1.length != sample2.length) {\n        throw new DimensionMismatchException(\"Arrays do not have the same length\");\n    }\n    double sum = 0;\n    for(int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if(sample1 == null || sample2 == null) {\n        throw new NoDataException(\"Sample arrays are empty\");\n    }\n    if(sample1.length != sample2.length) {\n        throw new DimensionMismatchException(\"Arrays do not have the same length\");\n    }\n    double sum = 0;\n    for(int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if(sample1.length != sample2.length) {\n        throw new DimensionMismatchException(\"Arrays must have the same length\");\n    }\n    if(sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException(\"Arrays must not be empty\");\n    }\n    double sum = 0;\n    for(int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException(\"Sample arrays are empty.\");\n    }\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(\"Arrays do not have the same length.\");\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1 == null || sample2 == null) {\n        throw new NoDataException(\"Sample arrays are empty\");\n    }\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(\"Arrays do not have the same length\");\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if(sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException(\"Sample arrays are empty\");\n    }\n    if(sample1.length != sample2.length) {\n        throw new DimensionMismatchException(\"Arrays do not have the same length\");\n    }\n    double sum = 0;\n    for(int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}"
    ],
    [
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         if (_head == null) {\n             _head = _tail = new LinkedNode<>(fullChunk);\n             _size = fullChunk.length;\n         } else {\n             _tail.setNext(new LinkedNode<>(fullChunk));\n             _tail = _tail.getNext();\n             _size += fullChunk.length;\n         }\n         if (_size > MAX_CHUNK) {\n             _freeBuffer = fullChunk;\n             _head = _tail = null;\n             _size = 0;\n         }\n         return _freeBuffer;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         if (_head == null) {\n             _head = _tail = new LinkedNode<>(fullChunk);\n             _size = fullChunk.length;\n         } else {\n             _tail.next = new LinkedNode<>(fullChunk);\n             _tail = _tail.next;\n             _size += fullChunk.length;\n         }\n         if (_size > MAX_CHUNK) {\n             _freeBuffer = fullChunk;\n             _head = _tail = null;\n             _size = 0;\n         }\n         return _freeBuffer;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         if (_head == null) {\n             _head = _tail = new LinkedNode<>(fullChunk);\n             _size = fullChunk.length;\n         } else {\n             _tail.next = new LinkedNode<>(fullChunk);\n             _tail = _tail.next;\n             _size += fullChunk.length;\n         }\n\n         if (_size > MAX_CHUNK) {\n             Object[] buffer = _freeBuffer;\n             _freeBuffer = null;\n             return buffer;\n         }\n\n         return _freeBuffer;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         if (_freeBuffer == null) {\n             _freeBuffer = fullChunk;\n         } else {\n             Object[] newChunk = new Object[fullChunk.length + _freeBuffer.length];\n             System.arraycopy(_freeBuffer, 0, newChunk, 0, _freeBuffer.length);\n             System.arraycopy(fullChunk, 0, newChunk, _freeBuffer.length, fullChunk.length);\n             _freeBuffer = newChunk;\n         }\n         return _freeBuffer;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         if (_head == null) {\n             _head = new LinkedNode<>(fullChunk);\n             _tail = _head;\n         } else {\n             _tail.next = new LinkedNode<>(fullChunk);\n             _tail = _tail.next;\n         }\n         _size += fullChunk.length;\n         if (_size > MAX_CHUNK) {\n             _freeBuffer = fullChunk;\n             _head = _tail = null;\n             _size = 0;\n         }\n         return _freeBuffer;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         if (_head == null) {\n             _head = new LinkedNode<>();\n             _tail = _head;\n         }\n         _tail.setNext(new LinkedNode<>(fullChunk));\n         _tail = _tail.getNext();\n         _size += fullChunk.length;\n         if (_size > MAX_CHUNK) {\n             _size = 0;\n             _head = _head.getNext();\n             _tail = _head;\n         }\n         if (_freeBuffer == null || _freeBuffer.length < SMALL_CHUNK) {\n             _freeBuffer = new Object[SMALL_CHUNK];\n         }\n         return _freeBuffer;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         if (_head == null) {\n             _head = new LinkedNode<>();\n             _tail = _head;\n             _size = 0;\n         }\n\n         _tail.setNext(new LinkedNode<>(fullChunk));\n         _tail = _tail.getNext();\n         _size += fullChunk.length;\n\n         if (_size > MAX_CHUNK) {\n             _freeBuffer = fullChunk;\n             _head = _head.getNext();\n             _tail = _head;\n             _size = 0;\n         }\n\n         return _freeBuffer;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         if (_freeBuffer == null) {\n             _freeBuffer = fullChunk;\n         } else {\n             Object[] newChunk = new Object[fullChunk.length + _freeBuffer.length];\n             System.arraycopy(_freeBuffer, 0, newChunk, 0, _freeBuffer.length);\n             System.arraycopy(fullChunk, 0, newChunk, _freeBuffer.length, fullChunk.length);\n             _freeBuffer = newChunk;\n         }\n         return _freeBuffer;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         if (_head == null) {\n             _head = new LinkedNode<>();\n             _tail = _head;\n             _size = 0;\n         }\n\n         _tail.setNext(new LinkedNode<>(fullChunk));\n         _tail = _tail.getNext();\n         _size += fullChunk.length;\n\n         if (_size >= MAX_CHUNK) {\n             _reset();\n         }\n\n         return _freeBuffer;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         if (_head == null) {\n             _head = new LinkedNode<>();\n             _tail = _head;\n             _size = 0;\n         }\n\n         if (_size + fullChunk.length > MAX_CHUNK) {\n             // double the size of the buffer\n             Object[] newChunk = new Object[SMALL_CHUNK];\n             _tail._next = new LinkedNode<>(newChunk);\n             _tail = _tail._next;\n             _size = 0;\n         }\n\n         System.arraycopy(fullChunk, 0, _tail._next._array, 0, fullChunk.length);\n         _tail = _tail._next;\n         _size += fullChunk.length;\n\n         return _tail._next._array;\n     }"
    ],
    [
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);\n    return formatter;\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    StringBuilder buf = new StringBuilder();\n    int[] indexRef = new int[1];\n\n    while (pattern.length() > 0) {\n        String token = parseToken(pattern, indexRef);\n        pattern = pattern.substring(indexRef[0]);\n\n        if (isNumericToken(token)) {\n            buf.append('n');\n        } else if (token.equals(\"yyyy\")) {\n            buf.append('y');\n        } else if (token.equals(\"MM\")) {\n            buf.append('M');\n        } else if (token.equals(\"dd\")) {\n            buf.append('d');\n        } else if (token.equals(\"HH\")) {\n            buf.append('H');\n        } else if (token.equals(\"mm\")) {\n            buf.append('m');\n        } else if (token.equals(\"ss\")) {\n            buf.append('s');\n        } else if (token.equals(\"EEEE\")) {\n            buf.append('E');\n        } else if (token.equals(\"EEEEEE\")) {\n            buf.append('e');\n        } else if (token.equals(\"EEEEEEEE\")) {\n            buf.append('c');\n        } else if (token.equals(\"GGGG\")) {\n            buf.append('G');\n        } else if (token.equals(\"GGGGGG\")) {\n            buf.append('g');\n        } else {\n            throw new IllegalArgumentException(\"Invalid pattern: \" + token);\n        }\n    }\n\n    return DateTimeFormatter.ofPattern(buf.toString());\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);\n    return formatter;\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);\n    return formatter;\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    StringBuilder buf = new StringBuilder();\n    int[] indexRef = new int[1];\n    String token = parseToken(pattern, indexRef);\n    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSSXXX\");\n\n    while (indexRef[0] < pattern.length()) {\n        token = parseToken(pattern, indexRef);\n        if (isNumericToken(token)) {\n            buf.append(token);\n            formatter = formatter.withNumberFormat(token);\n        } else {\n            buf.append(token);\n            formatter = formatter.withText(token);\n        }\n    }\n\n    return formatter;\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    StringBuilder sb = new StringBuilder();\n    int[] indexRef = new int[1];\n\n    while (indexRef[0] < pattern.length()) {\n        String token = parseToken(pattern, indexRef);\n        if (isNumericToken(token)) {\n            if (token.equals(\"c\")) {\n                sb.append(\"yyyy\");\n            } else if (token.equals(\"C\")) {\n                sb.append(\"yyyy\");\n            } else if (token.equals(\"x\")) {\n                sb.append(\"xxxx\");\n            } else if (token.equals(\"y\")) {\n                sb.append(\"yyyy\");\n            } else if (token.equals(\"Y\")) {\n                sb.append(\"yyyy\");\n            } else if (token.equals(\"d\")) {\n                sb.append(\"dd\");\n            } else if (token.equals(\"h\")) {\n                sb.append(\"HH\");\n            } else if (token.equals(\"H\")) {\n                sb.append(\"HH\");\n            } else if (token.equals(\"m\")) {\n                sb.append(\"mm\");\n            } else if (token.equals(\"s\")) {\n                sb.append(\"ss\");\n            } else if (token.equals(\"S\")) {\n                sb.append(\"SSS\");\n            } else if (token.equals(\"e\")) {\n                sb.append(\"EE\");\n            } else if (token.equals(\"D\")) {\n                sb.append(\"dd\");\n            } else if (token.equals(\"F\")) {\n                sb.append(\"dd\");\n            } else if (token.equals(\"w\")) {\n                sb.append(\"ww\");\n            } else if (token.equals(\"W\")) {\n                sb.append(\"ww\");\n            } else if (token.equals(\"k\")) {\n                sb.append(\"HH\");\n            } else if (token.equals(\"K\")) {\n                sb.append(\"HH\");\n            } else if (token.equals(\"M\")) {\n                sb.append(\"MM\");\n            }\n        } else {\n            sb.append(token);\n        }\n    }\n\n    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(sb.toString());\n    return formatter;\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    StringBuilder result = new StringBuilder();\n    int[] indexRef = new int[1];\n    indexRef[0] = 0;\n\n    while (indexRef[0] < pattern.length()) {\n        String token = parseToken(pattern, indexRef);\n        if (isNumericToken(token)) {\n            result.append('y'); // year\n        } else {\n            result.append('t'); // text\n        }\n    }\n\n    return DateTimeFormatter.ofPattern(result.toString());\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    StringBuilder buf = new StringBuilder();\n    int[] indexRef = new int[1];\n\n    while (indexRef[0] < pattern.length()) {\n        String token = parseToken(pattern, indexRef);\n        if (isNumericToken(token)) {\n            // numeric token\n            if (token.equals(\"S\")) {\n                buf.append(\"SSSS\");\n            } else if (token.equals(\"s\")) {\n                buf.append(\"SSS\");\n            } else if (token.equals(\"m\")) {\n                buf.append(\"mm\");\n            } else if (token.equals(\"s\")) {\n                buf.append(\"ss\");\n            } else if (token.equals(\"H\")) {\n                buf.append(\"HH\");\n            } else if (token.equals(\"h\")) {\n                buf.append(\"hh\");\n            } else if (token.equals(\"K\")) {\n                buf.append(\"KK\");\n            } else if (token.equals(\"k\")) {\n                buf.append(\"kk\");\n            } else if (token.equals(\"M\")) {\n                buf.append(\"MM\");\n            } else if (token.equals(\"d\")) {\n                buf.append(\"dd\");\n            } else if (token.equals(\"D\")) {\n                buf.append(\"dd\");\n            } else if (token.equals(\"e\")) {\n                buf.append(\"EE\");\n            } else if (token.equals(\"E\")) {\n                buf.append(\"EEE\");\n            } else if (token.equals(\"y\")) {\n                buf.append(\"yyyy\");\n            } else if (token.equals(\"Y\")) {\n                buf.append(\"yyyy\");\n            } else if (token.equals(\"x\")) {\n                buf.append(\"xxxx\");\n            } else if (token.equals(\"w\")) {\n                buf.append(\"ww\");\n            } else if (token.equals(\"W\")) {\n                buf.append(\"ww\");\n            }\n        } else {\n            // text token\n            buf.append(token);\n        }\n    }\n\n    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(buf.toString());\n    return formatter;\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    StringBuilder buf = new StringBuilder();\n    int[] indexRef = new int[1];\n\n    while (indexRef[0] < pattern.length()) {\n        String token = parseToken(pattern, indexRef);\n        if (isNumericToken(token)) {\n            buf.append(token);\n        } else {\n            buf.append(\"'\");\n            buf.append(token);\n            buf.append(\"'\");\n        }\n    }\n\n    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(buf.toString());\n    return formatter;\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    StringBuilder buf = new StringBuilder();\n    int[] indexRef = new int[1];\n\n    while (pattern.length() > 0) {\n        String token = parseToken(pattern, indexRef);\n        pattern = pattern.substring(indexRef[0]);\n\n        if (isNumericToken(token)) {\n            buf.append(\"d\");\n        } else {\n            buf.append(\"text\");\n        }\n    }\n\n    return DateTimeFormatter.ofPattern(buf.toString());\n}"
    ],
    [
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n        return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL || token == JsDocToken.UNDEFINED) {\n        return newNode(token);\n    } else if (token == JsDocToken.TYPE_NAME) {\n        return parseTypeName(token);\n    } else {\n        return parseFunctionType(token);\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n        return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL || token == JsDocToken.UNDEFINED) {\n        return newNode(token);\n    } else if (token == JsDocToken.TYPENAME) {\n        return parseTypeName(token);\n    } else {\n        return parseFunctionType(token);\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL || token == JsDocToken.UNDEFINED) {\n      return newNode(token);\n    } else if (token == JsDocToken.TYPENAME) {\n      return parseTypeName(token);\n    } else {\n      return parseFunctionType(token);\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL || token == JsDocToken.UNDEFINED) {\n      return newNode(token);\n    } else if (token == JsDocToken.TYPE_NAME) {\n      return parseTypeName(token);\n    } else {\n      return parseFunctionType(token);\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL || token == JsDocToken.UNDEFINED) {\n      return newNode(token);\n    } else if (token == JsDocToken.TYPE_NAME) {\n      return parseTypeName(token);\n    } else {\n      return parseFunctionType(token);\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL || token == JsDocToken.UNDEFINED) {\n      return newNode(token);\n    } else if (token == JsDocToken.TYPE_NAME) {\n      return parseTypeName(token);\n    } else {\n      return parseFunctionType(token);\n    }\n  }",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL || token == JsDocToken.UNDEFINED) {\n      return newNode(token);\n    } else if (token == JsDocToken.TYPENAME) {\n      return parseTypeName(token);\n    } else {\n      return parseFunctionType(token);\n    }\n  }",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.NULL || token == JsDocToken.UNDEFINED) {\n    return newNode(token);\n  } else if (token == JsDocToken.TYPE_NAME) {\n    return parseTypeName(token);\n  } else {\n    return parseFunctionType(token);\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n        return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL || token == JsDocToken.UNDEFINED) {\n        return newNode(token);\n    } else if (token == JsDocToken.TYPENAME) {\n        return parseTypeName(token);\n    } else {\n        return parseFunctionType(token);\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.NULL || token == JsDocToken.UNDEFINED) {\n    return newNode(token);\n  } else if (token == JsDocToken.TYPE_NAME) {\n    return parseTypeName(token);\n  } else {\n    return parseFunctionType(token);\n  }\n}"
    ],
    [
      "public JsonWriter name(String name) throws IOException  {\n    writeDeferredName();\n    out.write('\"');\n    for (int i = 0; i < name.length(); i++) {\n        char c = name.charAt(i);\n        if (c <= '\\u001F' || c >= '\\u007F') {\n            out.write(\"\\\\u\");\n            out.write(String.format(\"%04x\", (int) c));\n        } else if (c == '\"') {\n            out.write(\"\\\\\\\"\");\n        } else if (c == '\\\\') {\n            out.write(\"\\\\\\\\\");\n        } else {\n            out.write(c);\n        }\n    }\n    out.write('\"');\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"Name is null\");\n    }\n    writeDeferredName();\n    writeQuote();\n    out.write(name);\n    writeQuote();\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name\");\n    }\n    writeDeferredName();\n    out.write('\"');\n    for (int i = 0; i < name.length(); i++) {\n        char c = name.charAt(i);\n        if (c <= '\\u001F' || c >= '\\u007F') {\n            encodeSurrogate(name, i);\n        } else if (c == '\"') {\n            out.write('\\\\');\n            out.write('\"');\n        } else if (c == '\\\\') {\n            out.write('\\\\');\n            out.write('\\\\');\n        } else {\n            out.write(c);\n        }\n    }\n    out.write('\"');\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (stackSize == 0) {\n        throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    out.write('\"');\n    for (int i = 0; i < name.length(); i++) {\n        char c = name.charAt(i);\n        if (c <= '\\u001F' || c >= '\\u007F') {\n            encodeSurrogate(c);\n        } else if (c == '\"') {\n            out.write('\\\\');\n            out.write('\"');\n        } else if (c == '\\\\') {\n            out.write('\\\\');\n            out.write('\\\\');\n        } else {\n            out.write(c);\n        }\n    }\n    out.write('\"');\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    writeDeferredName();\n    out.write('\"');\n    for (int i = 0; i < name.length(); i++) {\n        char c = name.charAt(i);\n        if (c <= '\\u001F' || c >= '\\u007F') {\n            encodeUtf8Segment(name, i, name.length());\n            break;\n        }\n        if (c == '\"') {\n            out.write('\\\\');\n            out.write('\"');\n        } else if (c == '\\\\') {\n            out.write('\\\\');\n            out.write('\\\\');\n        } else {\n            out.write(c);\n        }\n    }\n    out.write('\"');\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"Name is null\");\n    }\n    writeDeferredName();\n    writeQuote();\n    out.write(name);\n    writeQuote();\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"Name is null\");\n    }\n    writeDeferredName();\n    out.write('\"');\n    for (char c : name.toCharArray()) {\n        if (c == '\"') {\n            out.write('\\\\');\n            out.write('\"');\n        } else if (c == '\\\\') {\n            out.write('\\\\');\n            out.write('\\\\');\n        } else {\n            out.write(c);\n        }\n    }\n    out.write('\"');\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name\");\n    }\n    writeDeferredName();\n    out.write('\"');\n    for (int i = 0; i < name.length(); i++) {\n        char c = name.charAt(i);\n        if (c <= '\\u001F' || c >= '\\u007F') {\n            out.write(\"\\\\u\");\n            out.write(String.format(\"%04x\", (int) c));\n        } else if (c == '\"') {\n            out.write(\"\\\\\\\"\");\n        } else if (c == '\\\\') {\n            out.write(\"\\\\\\\\\");\n        } else {\n            out.write(c);\n        }\n    }\n    out.write('\"');\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (stackSize == 0) {\n        throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    writeDeferredName();\n    out.write('\"');\n    for (int i = 0; i < name.length(); i++) {\n        char c = name.charAt(i);\n        if (c <= '\\u001F' || c >= '\\u007F') {\n            encodeSpecialCharacter(c);\n        } else if (c == '\"') {\n            out.write('\\\\');\n            out.write('\"');\n        } else if (c == '\\\\') {\n            out.write('\\\\');\n            out.write('\\\\');\n        } else {\n            out.write(c);\n        }\n    }\n    out.write('\"');\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    writeDeferredName();\n    out.write('\"');\n    for (int i = 0; i < name.length(); i++) {\n        char c = name.charAt(i);\n        if (c == '\\\\') {\n            out.write('\\\\');\n            out.write('\\\\');\n        } else if (c == '\"') {\n            out.write('\\\\');\n            out.write('\"');\n        } else if (c < ' ') {\n            out.write('\\\\');\n            out.write('u');\n            out.write(Integer.toHexString(c));\n        } else {\n            out.write(c);\n        }\n    }\n    out.write('\"');\n    return this;\n}"
    ],
    [
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.MAX_VALUE;\n    int seriesCount = dataset.getRowCount();\n    for (int series = 0; series < seriesCount; series++) {\n        Number number = dataset.getValue(series, 0);\n        if (number != null) {\n            double value = number.doubleValue();\n            if (value < minimum) {\n                minimum = value;\n            }\n        }\n    }\n    return new Double(minimum);\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.MAX_VALUE;\n    double negative = 0.0;\n    int seriesCount = dataset.getRowCount();\n    for (int series = 0; series < seriesCount; series++) {\n        Number number = dataset.getValue(series, 0);\n        if (number != null) {\n            double value = number.doubleValue();\n            if (value < minimum) {\n                minimum = value;\n            }\n            if (value < 0.0) {\n                negative = negative + value;\n            }\n        }\n    }\n    minimum = Math.min(minimum, negative);\n    return new Double(minimum);\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.MAX_VALUE;\n    double positive = 0.0;\n    double negative = 0.0;\n\n    int seriesCount = dataset.getRowCount();\n    for (int series = 0; series < seriesCount; series++) {\n        Number number = dataset.getValue(series, 0);\n        if (number != null) {\n            double value = number.doubleValue();\n            if (value > 0.0) {\n                positive = positive + value;\n            }\n            if (value < 0.0) {\n                negative = negative + value;\n            }\n        }\n    }\n    minimum = Math.min(minimum, negative);\n    return new Double(minimum);\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.MAX_VALUE;\n    double positive = 0.0;\n    double negative = 0.0;\n    int seriesCount = dataset.getRowCount();\n    for (int series = 0; series < seriesCount; series++) {\n        Number number = dataset.getValue(series, 0);\n        if (number != null) {\n            double value = number.doubleValue();\n            if (value > 0.0) {\n                positive = positive + value;\n            }\n            if (value < 0.0) {\n                negative = negative + value;\n            }\n        }\n    }\n    minimum = Math.min(minimum, negative);\n    return new Double(minimum);\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.MAX_VALUE;\n    int seriesCount = dataset.getRowCount();\n    for (int series = 0; series < seriesCount; series++) {\n        Number number = dataset.getValue(series, 0);\n        if (number != null) {\n            double value = number.doubleValue();\n            if (value < minimum) {\n                minimum = value;\n            }\n        }\n    }\n    return new Double(minimum);\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.MAX_VALUE;\n    double negative = 0.0;\n    int seriesCount = dataset.getRowCount();\n    for (int series = 0; series < seriesCount; series++) {\n        Number number = dataset.getValue(series, 0);\n        if (number != null) {\n            double value = number.doubleValue();\n            if (value < minimum) {\n                minimum = value;\n            }\n            if (value < 0.0) {\n                negative = negative + value;\n            }\n        }\n    }\n    return new Double(minimum);\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.MAX_VALUE;\n    int seriesCount = dataset.getRowCount();\n    for (int series = 0; series < seriesCount; series++) {\n        Number number = dataset.getValue(series, 0);\n        if (number != null) {\n            double value = number.doubleValue();\n            if (value < minimum) {\n                minimum = value;\n            }\n        }\n    }\n    return new Double(minimum);\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.MAX_VALUE;\n    int seriesCount = dataset.getRowCount();\n    for (int series = 0; series < seriesCount; series++) {\n        Number number = dataset.getValue(series, 0);\n        if (number != null) {\n            double value = number.doubleValue();\n            if (value < minimum) {\n                minimum = value;\n            }\n        }\n    }\n    return new Double(minimum);\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.MAX_VALUE;\n    int seriesCount = dataset.getRowCount();\n    for (int series = 0; series < seriesCount; series++) {\n        Number number = dataset.getValue(series, 0);\n        if (number != null) {\n            double value = number.doubleValue();\n            if (value < minimum) {\n                minimum = value;\n            }\n        }\n    }\n    return new Double(minimum);\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.MAX_VALUE;\n    double negative = 0.0;\n    int seriesCount = dataset.getRowCount();\n    for (int series = 0; series < seriesCount; series++) {\n        Number number = dataset.getValue(series, 0);\n        if (number != null) {\n            double value = number.doubleValue();\n            if (value > 0.0) {\n                minimum = Math.min(minimum, value);\n            }\n            if (value < 0.0) {\n                negative = Math.min(negative, value);\n            }\n        }\n    }\n    return negative;\n}"
    ],
    [
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}"
    ],
    [
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    if (delimiters == null) {\n        delimiters = new char[]{' '};\n    }\n    final StringBuilder result = new StringBuilder();\n    boolean word = true;\n    for (int i = 0; i < str.length(); i++) {\n        final char ch = str.charAt(i);\n        if (Arrays.binarySearch(delimiters, ch) >= 0) {\n            word = true;\n        } else if (word) {\n            result.append(Character.toUpperCase(ch));\n            word = false;\n        }\n    }\n    return result.length() > 0 ? result.toString() : \"\";\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    if (delimiters == null) {\n        delimiters = new char[]{' '};\n    }\n    StringBuilder result = new StringBuilder();\n    boolean word = true;\n    for (char ch : str.toCharArray()) {\n        if (Arrays.binarySearch(delimiters, ch) >= 0) {\n            word = true;\n        } else if (word) {\n            result.append(Character.toUpperCase(ch));\n            word = false;\n        }\n    }\n    return result.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    if (delimiters == null) {\n        delimiters = new char[] {' '};\n    }\n    final StringBuilder result = new StringBuilder();\n    boolean word = true;\n\n    for (char ch : str.toCharArray()) {\n        if (Arrays.binarySearch(delimiters, ch) >= 0) {\n            word = true;\n        } else if (word) {\n            result.append(Character.toUpperCase(ch));\n            word = false;\n        } else {\n            result.append(ch);\n        }\n    }\n    return result.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean inWord = false;\n    StringBuilder result = new StringBuilder();\n\n    for (int i = 0; i < buffer.length; i++) {\n        char ch = buffer[i];\n        if (delimiters != null && ArrayUtils.contains(delimiters, ch)) {\n            inWord = false;\n        } else if (!inWord) {\n            inWord = true;\n            result.append(Character.toUpperCase(ch));\n        } else {\n            result.append(ch);\n        }\n    }\n    return result.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    if (delimiters == null) {\n        delimiters = new char[]{' '};\n    }\n    final StringBuilder result = new StringBuilder();\n    boolean word = true;\n    for (int i = 0; i < str.length(); i++) {\n        final char ch = str.charAt(i);\n        if (Arrays.binarySearch(delimiters, ch) >= 0) {\n            word = true;\n        } else if (word) {\n            result.append(Character.toUpperCase(ch));\n            word = false;\n        }\n    }\n    return result.length() > 0 ? result.toString() : \"\";\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    if (delimiters == null) {\n        delimiters = new char[]{' '};\n    }\n    StringBuilder result = new StringBuilder();\n    boolean word = true;\n    for (char ch : str.toCharArray()) {\n        if (Arrays.binarySearch(delimiters, ch) >= 0) {\n            word = true;\n        } else if (word) {\n            result.append(Character.toUpperCase(ch));\n            word = false;\n        }\n    }\n    return result.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean whitespace = true;\n    StringBuilder initials = new StringBuilder();\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (delimiters == null) {\n            whitespace = Character.isWhitespace(ch);\n        } else if (ArrayUtils.contains(delimiters, ch)) {\n            whitespace = true;\n        } else {\n            whitespace = false;\n        }\n        if (whitespace) {\n            if (initials.length() > 0) {\n                initials.append(' ');\n            }\n        } else {\n            if (Character.isUpperCase(ch)) {\n                initials.append(ch);\n            } else {\n                initials.append(Character.toUpperCase(ch));\n            }\n        }\n    }\n    return initials.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    if (delimiters == null) {\n        delimiters = new char[]{' '};\n    }\n    final StringBuilder result = new StringBuilder();\n    boolean inWord = false;\n\n    for (int i = 0; i < str.length(); i++) {\n        final char ch = str.charAt(i);\n        if (Arrays.binarySearch(delimiters, ch) >= 0) {\n            inWord = false;\n        } else if (!inWord) {\n            result.append(Character.toUpperCase(ch));\n            inWord = true;\n        }\n    }\n    return result.length() > 0 ? result.toString() : \"\";\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    if (delimiters == null) {\n        delimiters = new char[]{' '};\n    }\n    final StringBuilder initials = new StringBuilder();\n    boolean inWord = false;\n\n    for (int i = 0; i < str.length(); i++) {\n        final char ch = str.charAt(i);\n        if (Arrays.binarySearch(delimiters, ch) >= 0) {\n            if (inWord) {\n                inWord = false;\n            }\n        } else {\n            if (!inWord) {\n                initials.append(Character.toUpperCase(ch));\n                inWord = true;\n            }\n        }\n    }\n    return initials.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    if (delimiters == null) {\n        delimiters = new char[]{' '};\n    }\n    final StringBuilder initials = new StringBuilder();\n    boolean inWord = false;\n    for (int i = 0; i < str.length(); i++) {\n        final char ch = str.charAt(i);\n        if (Arrays.binarySearch(delimiters, ch) >= 0) {\n            inWord = false;\n        } else if (!inWord) {\n            inWord = true;\n            initials.append(Character.toUpperCase(ch));\n        }\n    }\n    return initials.length() > 0 ? initials.toString() : \"\";\n}"
    ],
    [
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0;\n    if (data != null) {\n        for (int i = 0; i < data.getRowCount(); i++) {\n            total += data.getValue(i, column);\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0;\n    for (int i = 0; i < data.getRowCount(); i++) {\n        total += data.get(i, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0;\n    for (double[] row : data) {\n        total += row[column];\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0;\n    for (double[] row : data) {\n        total += row[column];\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new NullPointerException(\"Null 'data' argument.\");\n    }\n    double total = 0;\n    for (double[] row : data) {\n        total += row[column];\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0;\n    for (int i = 0; i < data.getRowCount(); i++) {\n        total += data.get(i, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0;\n    for (int i = 0; i < data.getRowCount(); i++) {\n        total += data.get(i, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0;\n    for (double[] row : data) {\n        total += row[column];\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0;\n    for (double[] row : data) {\n        total += row[column];\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0;\n    for (int i = 0; i < data.length; i++) {\n        total += data[i][column];\n    }\n    return total;\n}"
    ],
    [
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / this.scaleX;\n    double y = (screenPoint.y - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    int x = screenPoint.x - insets.left;\n    int y = screenPoint.y - insets.top;\n    return new Point2D.Double(x / this.scaleX, y / this.scaleY);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    int x = screenPoint.x - insets.left;\n    int y = screenPoint.y - insets.top;\n    return new Point2D.Double(x / this.scaleX, y / this.scaleY);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    int x = screenPoint.x - insets.left;\n    int y = screenPoint.y - insets.top;\n    return new Point2D.Double(x / this.scaleX, y / this.scaleY);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    int x = screenPoint.x - insets.left;\n    int y = screenPoint.y - insets.top;\n    return new Point2D.Double(x / this.scaleX, y / this.scaleY);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    int x = screenPoint.x - insets.left;\n    int y = screenPoint.y - insets.top;\n    return new Point2D.Double(x / this.scaleX, y / this.scaleY);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    int x = screenPoint.x - insets.left;\n    int y = screenPoint.y - insets.top;\n    return new Point2D.Double(x / this.scaleX, y / this.scaleY);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / this.scaleX;\n    double y = (screenPoint.y - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / this.scaleX;\n    double y = (screenPoint.y - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / this.scaleX;\n    double y = (screenPoint.y - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}"
    ],
    [
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        String[] parts = source.split(\" / \");\n        if(parts.length != 2) {\n            throw new MathParseException(\"Invalid fraction format\");\n        }\n        BigInteger numerator = new BigInteger(parts[0]);\n        BigInteger denominator = new BigInteger(parts[1]);\n        return new BigFraction(numerator, denominator);\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        String[] parts = source.split(\" / \");\n        if (parts.length != 2) {\n            throw new MathParseException(\"Invalid format\");\n        }\n        BigInteger numerator = new BigInteger(parts[0]);\n        BigInteger denominator = new BigInteger(parts[1]);\n        return new BigFraction(numerator, denominator);\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        String[] parts = source.split(\" / \");\n        if (parts.length != 2) {\n            throw new MathParseException(\"Invalid fraction format: \" + source);\n        }\n        BigInteger numerator = new BigInteger(parts[0]);\n        BigInteger denominator = new BigInteger(parts[1]);\n        return new BigFraction(numerator, denominator);\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        String[] parts = source.split(\" / \");\n        if (parts.length != 2) {\n            throw new MathParseException(\"Invalid format: \" + source);\n        }\n        BigInteger numerator = getNumeratorFormat().parse(parts[0]);\n        BigInteger denominator = getDenominatorFormat().parse(parts[1]);\n        return new BigFraction(numerator, denominator);\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        String[] parts = source.split(\" / \");\n        if (parts.length != 2) {\n            throw new MathParseException(\"Invalid fraction format: \" + source);\n        }\n        BigInteger numerator = new BigInteger(parts[0]);\n        BigInteger denominator = new BigInteger(parts[1]);\n        return new BigFraction(numerator, denominator);\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        String[] parts = source.split(\" / \");\n        if (parts.length != 2) {\n            throw new MathParseException(\"Invalid fraction format: \" + source);\n        }\n        BigInteger numerator = getNumeratorFormat().parse(parts[0]);\n        BigInteger denominator = getDenominatorFormat().parse(parts[1]);\n        return new BigFraction(numerator, denominator);\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        String[] parts = source.split(\" / \");\n        if(parts.length != 2) {\n            throw new MathParseException(\"Invalid fraction format\");\n        }\n        BigInteger numerator = new BigInteger(parts[0]);\n        BigInteger denominator = new BigInteger(parts[1]);\n        return new BigFraction(numerator, denominator);\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        String[] parts = source.split(\" / \");\n        if (parts.length != 2) {\n            throw new MathParseException(\"Invalid fraction format\");\n        }\n        BigInteger numerator = new BigInteger(parts[0]);\n        BigInteger denominator = new BigInteger(parts[1]);\n        return new BigFraction(numerator, denominator);\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        String[] parts = source.split(\" / \");\n        if (parts.length != 2) {\n            throw new MathParseException(\"Invalid format: \" + source);\n        }\n        BigInteger numerator = new BigInteger(parts[0]);\n        BigInteger denominator = new BigInteger(parts[1]);\n        return new BigFraction(numerator, denominator);\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        String[] parts = source.split(\" / \");\n        if (parts.length != 2) {\n            throw new MathParseException(\"Invalid format: \" + source);\n        }\n        BigInteger numerator = new BigInteger(parts[0]);\n        BigInteger denominator = new BigInteger(parts[1]);\n        return new BigFraction(numerator, denominator);\n    }"
    ],
    [
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    Set<E> set = new HashSet<>(list);\n    List<E> setOrder = new ArrayList<>(list);\n    return new ListOrderedSet<>(set, setOrder);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<E>(list);\n    List<E> setOrder = new ArrayList<E>(list);\n    return new ListOrderedSet<E>(set, setOrder);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<>(list);\n    List<E> setOrder = new ArrayList<>(list);\n    return new ListOrderedSet<>(set, setOrder);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<E>(list);\n    List<E> setOrder = new ArrayList<E>(list);\n    return new ListOrderedSet<E>(set, setOrder);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    Set<E> set = new HashSet<E>(list);\n    return new ListOrderedSet<E>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<>(list);\n    List<E> setOrder = new ArrayList<>(list);\n    return new ListOrderedSet<>(set, setOrder);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    Set<E> set = new HashSet<E>(list);\n    return new ListOrderedSet<E>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<>(list);\n    return new ListOrderedSet<>(set, new ArrayList<>(list));\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    Set<E> set = new HashSet<E>(list);\n    List<E> setOrder = new ArrayList<E>(list);\n    return new ListOrderedSet<E>(set, setOrder);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<E>(list);\n    return new ListOrderedSet<E>(set, new ArrayList<E>(list));\n}"
    ],
    [
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis == getRangeAxis()) {\n        double min = Double.MAX_VALUE;\n        double max = Double.MIN_VALUE;\n        for (int i = 0; i < this.subplots.size(); i++) {\n            CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n            Range range = plot.getRangeAxis().getDataRange();\n            if (range != null) {\n                if (range.getMin() < min) {\n                    min = range.getMin();\n                }\n                if (range.getMax() > max) {\n                    max = range.getMax();\n                }\n            }\n        }\n        return new Range(min, max);\n    } else {\n        return null;\n    }\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range range = null;\n    for (int i = 0; i < this.subplots.size(); i++) {\n        CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n        Range plotRange = plot.getDataRange(axis);\n        if (range == null) {\n            range = plotRange;\n        } else {\n            range = range.expandToInclude(plotRange);\n        }\n    }\n    return range;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis == getRangeAxis()) {\n        double min = Double.MAX_VALUE;\n        double max = Double.MIN_VALUE;\n        for (int i = 0; i < this.subplots.size(); i++) {\n            CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n            Range range = plot.getRangeAxis().getDataRange();\n            if (range != null) {\n                min = Math.min(min, range.getMinimum());\n                max = Math.max(max, range.getMaximum());\n            }\n        }\n        return new Range(min, max);\n    } else {\n        return null;\n    }\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis instanceof ValueAxis) {\n        ValueAxis valueAxis = (ValueAxis) axis;\n        double min = Double.MAX_VALUE;\n        double max = Double.MIN_VALUE;\n        for (int i = 0; i < this.subplots.size(); i++) {\n            CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n            Range range = plot.getDataRange(valueAxis);\n            if (range != null) {\n                if (range.getLowerBound() < min) {\n                    min = range.getLowerBound();\n                }\n                if (range.getUpperBound() > max) {\n                    max = range.getUpperBound();\n                }\n            }\n        }\n        return new Range(min, max);\n    } else {\n        return null;\n    }\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range range = null;\n    for (int i = 0; i < this.subplots.size(); i++) {\n        CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n        Range subplotRange = plot.getDataRange(axis);\n        if (range == null) {\n            range = subplotRange;\n        } else {\n            range = range.expandToInclude(subplotRange);\n        }\n    }\n    return range;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range range = null;\n    for (int i = 0; i < this.subplots.size(); i++) {\n        CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n        Range plotRange = plot.getDataRange(axis);\n        if (range == null) {\n            range = plotRange;\n        } else {\n            range = Range.combine(range, plotRange);\n        }\n    }\n    return range;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis == getRangeAxis()) {\n        double min = Double.MAX_VALUE;\n        double max = Double.MIN_VALUE;\n        for (int i = 0; i < this.subplots.size(); i++) {\n            CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n            Number[] range = plot.getRange();\n            if (range != null) {\n                for (Number number : range) {\n                    if (number.doubleValue() < min) {\n                        min = number.doubleValue();\n                    }\n                    if (number.doubleValue() > max) {\n                        max = number.doubleValue();\n                    }\n                }\n            }\n        }\n        return new Range(min, max);\n    } else {\n        return null;\n    }\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range range = null;\n    for (int i = 0; i < this.subplots.size(); i++) {\n        CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n        Range subplotRange = plot.getDataRange(axis);\n        if (range == null) {\n            range = subplotRange;\n        } else {\n            range = Range.combine(range, subplotRange);\n        }\n    }\n    return range;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis instanceof CategoryAxis) {\n        return null;\n    } else {\n        Range range = null;\n        for (int i = 0; i < this.subplots.size(); i++) {\n            CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n            range = plot.getDataRange(axis);\n            if (range != null) {\n                return range;\n            }\n        }\n        return range;\n    }\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range range = null;\n    for (int i = 0; i < this.subplots.size(); i++) {\n        CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n        Range plotRange = plot.getDataRange(axis);\n        if (range == null) {\n            range = plotRange;\n        } else {\n            range = Range.combine(range, plotRange);\n        }\n    }\n    return range;\n}"
    ],
    [
      "public double adjustedLog10(double val)  {\n    if (val < 0) {\n        val = -val;\n    }\n    double logVal = Math.log(val) / Math.log(10);\n    if (val < 10) {\n        logVal += (1 - val / 10) * 0.5;\n    }\n    return -logVal;\n}",
      "public double adjustedLog10(double val)  {\n    if (val < 0) {\n        val = -val;\n    }\n    double result = Math.log(val) / Math.log(10);\n    if (val < 10) {\n        result += (1 - val / 10);\n    }\n    return -result;\n}",
      "public double adjustedLog10(double val)  {\n    if (val < 0) {\n        val = -val;\n    }\n    if (val < 10) {\n        val = Math.log(val) / Math.log(10);\n        val += (1 - val) / (val * Math.log(10));\n    } else {\n        val = Math.log10(val);\n    }\n    return -val;\n}",
      "public double adjustedLog10(double val)  {\n    if (val < 0) {\n        val = -val;\n    }\n    double logVal = Math.log(val) / Math.log(10);\n    if (val < 10) {\n        logVal += (1 - val / 10);\n    }\n    return -logVal;\n}",
      "public double adjustedLog10(double val)  {\n    if (val < 0) {\n        val = -val;\n    }\n    double logVal = Math.log(val) / Math.log(10);\n    if (val < 10) {\n        logVal += (1 - val / 10);\n    }\n    return -logVal;\n}",
      "public double adjustedLog10(double val)  {\n    double adjustedVal = Math.abs(val);\n    if (adjustedVal < 10) {\n        adjustedVal = Math.log(adjustedVal) / Math.log(10);\n        adjustedVal += (1 - adjustedVal);\n    } else {\n        adjustedVal = Math.log(adjustedVal) / Math.log(10);\n    }\n    return -adjustedVal;\n}",
      "public double adjustedLog10(double val)  {\n    if (val < 0) {\n        val = -val;\n    }\n    if (val < 10) {\n        return Math.log(val) / Math.log(10) + (1 - val / 10);\n    }\n    return Math.log(val) / Math.log(10);\n}",
      "public double adjustedLog10(double val)  {\n    if (val < 0) {\n        val = -val;\n    }\n    double logVal = Math.log10(val);\n    if (val < 10) {\n        logVal += (1 - val / 10) * LOG10_VALUE;\n    }\n    return -logVal;\n}",
      "public double adjustedLog10(double val)  {\n    if (val < 0) {\n        val = -val;\n    }\n    if (val < 10) {\n        val = Math.log(val) / Math.log(10) + (1 - val / 10);\n    }\n    return -val;\n}",
      "public double adjustedLog10(double val)  {\n    if (val < 0) {\n        val = -val;\n    }\n    if (val < 1) {\n        val = Math.log(val) / Math.log(10.0);\n        val += (1 - val);\n    } else {\n        val = Math.log10(val);\n    }\n    return -val;\n}"
    ],
    [
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    Node entry = cfg.getEntry();\n    Node implicitReturn = cfg.getImplicitReturn();\n    for (Node node : cfg.getNodes()) {\n        if (node == entry) {\n            continue;\n        }\n        if (cfg.getEdge(entry, node) != null) {\n            if (cfg.getEdge(node, implicitReturn) == null) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    Node start = cfg.getEntry();\n    Node end = cfg.getImplicitReturn();\n    for (Node node : cfg.getNodes()) {\n        if (cfg.getEdge(start, node) != null) {\n            if (!cfg.getEdge(start, node).isReturn()) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    Node entry = cfg.getEntry();\n    Node implicitReturn = cfg.getImplicitReturn();\n    if (entry == implicitReturn) {\n        return true;\n    }\n    for (Node node : cfg.getNodes()) {\n        if (node.isReturn()) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    Node start = cfg.getEntry();\n    Node end = cfg.getImplicitReturn();\n    return cfg.shortestPath(start, end).allNodesMatch(IS_RETURN);\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    Node start = cfg.getEntry();\n    Node end = cfg.getImplicitReturn();\n    return cfg.shortestPath(start, end).allNodesMatch(IS_RETURN);\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    Node start = cfg.getEntry();\n    Node end = cfg.getImplicitReturn();\n    for (Node node : cfg.getNodes()) {\n        if (node == start || node == end) {\n            continue;\n        }\n        if (cfg.getEdgesFrom(node).stream()\n                .anyMatch(edge -> edge.getTarget() == end)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    for (ControlFlowGraph.Branch branch : cfg.getEdges()) {\n        if (branch.isConditional()) {\n            Node condition = NodeUtil.getConditionExpression(branch.getSource());\n            if (condition != null) {\n                TernaryValue val = NodeUtil.getImpureBooleanValue(condition);\n                if (val != TernaryValue.UNKNOWN) {\n                    if (val.toBoolean(true)) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    Node start = cfg.getEntry();\n    Node end = cfg.getImplicitReturn();\n    for (Node node : cfg.getNodes()) {\n        if (node == start || node == end) {\n            continue;\n        }\n        if (!cfg.getEdge(start, node).isPresent()) {\n            continue;\n        }\n        if (!cfg.getEdge(node, end).isPresent()) {\n            continue;\n        }\n        return false;\n    }\n    return true;\n  }",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    Node start = cfg.getEntry();\n    Node end = cfg.getImplicitReturn();\n    for (Node node : cfg.getNodes()) {\n        if (node == start || node == end) {\n            continue;\n        }\n        if (!cfg.getEdges().stream()\n                .filter(edge -> edge.getSource().equals(node) && edge.getTarget().equals(end))\n                .findFirst()\n                .isPresent()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    for (ControlFlowGraph.Branch branch : cfg.getEdges()) {\n        if (branch.isConditional()) {\n            Node condition = NodeUtil.getConditionExpression(branch);\n            if (condition != null) {\n                TernaryValue val = NodeUtil.getImpureBooleanValue(condition);\n                if (val != TernaryValue.UNKNOWN) {\n                    if (val.toBoolean(true)) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    return false;\n  }"
    ],
    [
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] spx = split(a[0]);\n    Dfp[] spy = new Dfp[2];\n    spy[0] = pow(a[1], 0);          // use spy[0] temporarily as a divisor\n    spx[0] = spx[0].divide(spy[0]);\n    spx[1] = spx[1].divide(spy[0]);\n\n    spy[0] = a[1].newInstance(\"0.5\");    // Use spy[0] for comparison\n    while (spx[0].add(spx[1]).greaterThan(spy[0])) {\n        spx[0] = spx[0].divide(2);\n        spx[1] = spx[1].divide(2);\n    }\n\n    Dfp[] spz = new Dfp[2];\n    spz[0] = spx[0].add(spx[1]);\n    spz[1] = a[1].getZero();\n\n    return spz;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] spx = split(a[0]);\n    Dfp[] spy = new Dfp[2];\n    spy[0] = pow(a[1], spx[0]);\n    spx[0] = spx[0].divide(spy[0]);\n    spx[1] = spx[1].divide(spy[0]);\n\n    spy[0] = a[1].newInstance(\"1.33333\");\n    while (spx[0].add(spx[1]).greaterThan(spy[0])) {\n        spx[0] = spx[0].divide(2);\n        spx[1] = spx[1].divide(2);\n    }\n\n    Dfp[] spz = logInternal(spx);\n    spx[0] = a[1].newInstance(new StringBuilder().append(spx[0].intValue()).toString());\n    spx[1] = a[1].getZero();\n    spy = splitMult(a[1].getField().getLn2Split(), spx);\n\n    spz[0] = spz[0].add(spy[0]);\n    spz[1] = spz[1].add(spy[1]);\n\n    spx[0] = a[1].newInstance(new StringBuilder().append(4*spx[0].intValue()).toString());\n    spx[1] = a[1].getZero();\n    spy = splitMult(a[1].getField().getLn5Split(), spx);\n\n    spz[0] = spz[0].add(spy[0]);\n    spz[1] = spz[1].add(spy[1]);\n\n    return new Dfp[]{spz[0], spz[1]};\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    int p2 = 0;\n    Dfp x = a[0].add(a[1]);\n    Dfp ix = x.floor().intValue();\n    while (ix > 2) {\n        ix >>= 1;\n        p2++;\n    }\n    Dfp[] spx = split(x);\n    Dfp[] spy = new Dfp[2];\n    spy[0] = pow(a[2], p2);          // use spy[0] temporarily as a divisor\n    spx[0] = spx[0].divide(spy[0]);\n    spx[1] = spx[1].divide(spy[0]);\n\n    spy[0] = a[2].newInstance(\"1.33333\");    // Use spy[0] for comparison\n    while (spx[0].add(spx[1]).greaterThan(spy[0])) {\n        spx[0] = spx[0].divide(2);\n        spx[1] = spx[1].divide(2);\n        p2++;\n    }\n\n    Dfp[] spz = new Dfp[2];\n    spz[0] = spx[0].add(spx[1]);\n    spz[1] = a[2].getZero();\n\n    return spz;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    int ix = a[0].intValue();\n    int p2 = 0;\n    while (ix > 2) {\n        ix >>= 1;\n        p2++;\n    }\n\n    Dfp[] spx = split(a[0]);\n    Dfp[] spy = new Dfp[2];\n    spy[0] = pow(a[1], p2);\n    spx[0] = spx[0].divide(spy[0]);\n    spx[1] = spx[1].divide(spy[0]);\n\n    spy[0] = a[1].newInstance(\"1.33333\");\n    while (spx[0].add(spx[1]).greaterThan(spy[0])) {\n        spx[0] = spx[0].divide(2);\n        spx[1] = spx[1].divide(2);\n        p2++;\n    }\n\n    Dfp[] spz = new Dfp[2];\n    spz[0] = spx[0].add(spx[1]);\n    spz[1] = a[1].getZero();\n\n    return spz;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] spx = split(a[0]);\n    Dfp[] spy = new Dfp[2];\n    spy[0] = pow(a[1], spx[1].intValue());\n    spx[0] = spx[0].divide(spy[0]);\n    spx[1] = spx[1].divide(spy[0]);\n\n    Dfp[] spz = new Dfp[2];\n    while (spx[0].add(spx[1]).greaterThan(spy[0])) {\n        spx[0] = spx[0].divide(2);\n        spx[1] = spx[1].divide(2);\n    }\n\n    Dfp[] spz1 = new Dfp[2];\n    spz1[0] = spx[0].add(spx[1]);\n    spz1[1] = a[1].getZero();\n\n    Dfp[] spz2 = new Dfp[2];\n    spz2[0] = spx[0].add(spx[1]);\n    spz2[1] = a[1].getZero();\n\n    return spz1;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] spx = split(a[0]);\n    Dfp[] spy = new Dfp[2];\n    spy[0] = pow(a[1], spx[1].intValue());\n    spx[0] = spx[0].divide(spy[0]);\n    spx[1] = spx[1].divide(spy[0]);\n\n    Dfp[] spz = new Dfp[2];\n    while (spx[0].add(spx[1]).greaterThan(spy[0])) {\n        spx[0] = spx[0].divide(2);\n        spx[1] = spx[1].divide(2);\n    }\n\n    Dfp[] spz0 = new Dfp[2];\n    spz0[0] = a[0].newInstance(new StringBuilder().append(spx[1].intValue() + 4 * spx[1].getLog10K()).toString());\n    spz0[1] = a[0].getZero();\n    Dfp[] spy0 = splitMult(a[0].getField().getLn2Split(), spz0);\n    spz[0] = spz0[0].add(spy0[0]);\n    spz[1] = spz0[1].add(spy0[1]);\n\n    Dfp[] spz1 = new Dfp[2];\n    spz1[0] = a[0].newInstance(new StringBuilder().append(4 * spx[1].getLog10K()).toString());\n    spz1[1] = a[0].getZero();\n    Dfp[] spy1 = splitMult(a[0].getField().getLn5Split(), spz1);\n    spz[0] = spz[0].add(spy1[0]);\n    spz[1] = spz[1].add(spy1[1]);\n\n    return a[0].newInstance(spz[0].add(spz[1]));\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    int p2 = 0;\n    Dfp x = a[0];\n    Dfp ix = x.floor().intValue();\n    while (ix > 2) {\n        ix >>= 1;\n        p2++;\n    }\n    Dfp[] spx = split(x);\n    Dfp[] spy = new Dfp[2];\n    spy[0] = pow(a[1], p2);\n    spx[0] = spx[0].divide(spy[0]);\n    spx[1] = spx[1].divide(spy[0]);\n    spy[0] = a[1].newInstance(\"1.33333\");\n    while (spx[0].add(spx[1]).greaterThan(spy[0])) {\n        spx[0] = spx[0].divide(2);\n        spx[1] = spx[1].divide(2);\n        p2++;\n    }\n    Dfp[] spz = new Dfp[2];\n    spz[0] = spx[0].add(spx[1]);\n    spz[1] = a[1].getZero();\n    Dfp[] spy1 = splitMult(a[1].getField().getLn2Split(), spx);\n    spz[0] = spz[0].add(spy1[0]);\n    spz[1] = spz[1].add(spy1[1]);\n    Dfp[] spy2 = splitMult(a[1].getField().getLn5Split(), spx);\n    spz[0] = spz[0].add(spy2[0]);\n    spz[1] = spz[1].add(spy2[1]);\n    return new Dfp[]{spz[0], spz[1]};\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp x = a[0].add(a[1]);\n    Dfp lr = x.log10K();\n\n    x = x.divide(pow(a.newInstance(10000), lr));  /* This puts x in the range 0-10000 */\n    int ix = x.floor().intValue();\n\n    while (ix > 2) {\n        ix >>= 1;\n        int p2 = 0;\n    }\n\n    Dfp[] spx = split(x);\n    Dfp[] spy = new Dfp[2];\n    spy[0] = pow(a.getTwo(), p2);          // use spy[0] temporarily as a divisor\n    spx[0] = spx[0].divide(spy[0]);\n    spx[1] = spx[1].divide(spy[0]);\n\n    spy[0] = a.newInstance(\"1.33333\");    // Use spy[0] for comparison\n    while (spx[0].add(spx[1]).greaterThan(spy[0])) {\n        spx[0] = spx[0].divide(2);\n        spx[1] = spx[1].divide(2);\n        p2++;\n    }\n\n    // X is now in the range of 2/3 < x < 4/3\n    Dfp[] spz = logInternal(spx);\n\n    spx[0] = a.newInstance(new StringBuilder().append(p2+4*lr).toString());\n    spx[1] = a.getZero();\n    spy = splitMult(a.getField().getLn2Split(), spx);\n\n    spz[0] = spz[0].add(spy[0]);\n    spz[1] = spz[1].add(spy[1]);\n\n    spx[0] = a.newInstance(new StringBuilder().append(4*lr).toString());\n    spx[1] = a.getZero();\n    spy = splitMult(a.getField().getLn5Split(), spx);\n\n    spz[0] = spz[0].add(spy[0]);\n    spz[1] = spz[1].add(spy[1]);\n\n    return a.newInstance(spz[0].add(spz[1]));\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    int ix = a[0].intValue();\n    int p2 = 0;\n    while (ix > 2) {\n        ix >>= 1;\n        p2++;\n    }\n    Dfp[] spx = split(a[0]);\n    Dfp[] spy = new Dfp[2];\n    spy[0] = pow(a[1], p2);\n    spx[0] = spx[0].divide(spy[0]);\n    spx[1] = spx[1].divide(spy[0]);\n\n    spy[0] = a[1].newInstance(\"1.33333\");\n    while (spx[0].add(spx[1]).greaterThan(spy[0])) {\n        spx[0] = spx[0].divide(2);\n        spx[1] = spx[1].divide(2);\n        p2++;\n    }\n\n    Dfp[] spz = new Dfp[2];\n    spz[0] = spx[0].subtract(spx[1]);\n    spz[1] = spx[1].subtract(spx[0]);\n\n    Dfp[] spx2 = split(a[0]);\n    spx2[0] = spx2[0].add(spx[0]);\n    spx2[1] = spx2[1].add(spx[1]);\n\n    Dfp[] spz2 = new Dfp[2];\n    spz2[0] = spx2[0].subtract(spx2[1]);\n    spz2[1] = spx2[1].subtract(spx2[0]);\n\n    return new Dfp[] {spz2[0], spz2[1]};\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] spx = split(a[0]);\n    Dfp[] spy = new Dfp[2];\n    spy[0] = a[1].newInstance(\"1.33333\");    // Use spy[0] for comparison\n    while (spx[0].add(spx[1]).greaterThan(spy[0])) {\n        spx[0] = spx[0].divide(2);\n        spx[1] = spx[1].divide(2);\n    }\n\n    Dfp[] spz = new Dfp[2];\n    spz[0] = spx[0].add(spx[1]);\n    spz[1] = a[1].newInstance(\"0.0\");\n\n    return spz;\n}"
    ],
    [
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) {\n            return false;\n        }\n        Map<K, ? super Collection<V>> decoratedMap = decorated();\n        if (!decoratedMap.containsKey(key)) {\n            return false;\n        }\n        Collection<V> collection = (Collection<V>) decoratedMap.get(key);\n        if (!collection.remove(value)) {\n            return false;\n        }\n        if (collection.isEmpty()) {\n            decoratedMap.remove(key);\n        }\n        return true;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (map.containsKey(key)) {\n            Collection<V> collection = (Collection<V>) map.get(key);\n            if (collection.remove(value)) {\n                if (collection.isEmpty()) {\n                    map.remove(key);\n                }\n                return true;\n            }\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null) {\n            return false;\n        }\n        Map<K, Collection<V>> decoratedMap = decorated();\n        if (!decoratedMap.containsKey(key)) {\n            return false;\n        }\n        Collection<V> collection = decoratedMap.get(key);\n        if (collection.remove(value)) {\n            if (collection.isEmpty()) {\n                decoratedMap.remove(key);\n            }\n            return true;\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) {\n            return false;\n        }\n        Collection<V> collection = (Collection<V>) map.get(key);\n        if (collection == null) {\n            return false;\n        }\n        collection.remove(value);\n        if (collection.isEmpty()) {\n            map.remove(key);\n        }\n        return true;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) {\n            return false;\n        }\n        Map<K, ? super Collection<V>> decoratedMap = decorated();\n        if (!decoratedMap.containsKey(key)) {\n            return false;\n        }\n        Collection<V> collection = (Collection<V>) decoratedMap.get(key);\n        if (collection.remove(value)) {\n            if (collection.isEmpty()) {\n                decoratedMap.remove(key);\n            }\n            return true;\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (map.containsKey(key)) {\n            Collection<V> coll = (Collection<V>) map.get(key);\n            coll.remove(value);\n            if (coll.isEmpty()) {\n                map.remove(key);\n            }\n            return true;\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null) {\n            throw new NullPointerException(\"Key must not be null\");\n        }\n        if (value == null) {\n            throw new NullPointerException(\"Value must not be null\");\n        }\n        Collection<V> coll = (Collection<V>) map.get(key);\n        if (coll == null) {\n            return false;\n        }\n        if (coll.remove(value)) {\n            if (coll.isEmpty()) {\n                map.remove(key);\n            }\n            return true;\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null) {\n            return false;\n        }\n        Collection<V> coll = (Collection<V>) getMap().get(key);\n        if (coll == null) {\n            return false;\n        }\n        coll.remove(value);\n        if (coll.isEmpty()) {\n            getMap().remove(key);\n        }\n        return true;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) {\n            return false;\n        }\n        Map<K, Collection<V>> decoratedMap = decorated();\n        if (!decoratedMap.containsKey(key)) {\n            return false;\n        }\n        Collection<V> collection = decoratedMap.get(key);\n        if (collection.remove(value)) {\n            if (collection.isEmpty()) {\n                decoratedMap.remove(key);\n            }\n            return true;\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (map.containsKey(key)) {\n            Collection<V> collection = (Collection<V>) map.get(key);\n            if (collection.remove(value)) {\n                if (collection.isEmpty()) {\n                    map.remove(key);\n                }\n                return true;\n            }\n        }\n        return false;\n    }"
    ],
    [
      "private Node transformAsString(AstNode n)  {\n    Node node = newNode(transformTokenType(n.getType()));\n    if (n.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n    } else if (n.getType() == Token.STRING) {\n        node.setChars('\" + n.getChars() + \"\\\"\");\n    }\n    for (AstNode child : n.getChildren()) {\n        node.addChildToBack(transform(child));\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = newNode(transformTokenType(n.getType()));\n    if (n.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n    } else if (n.getType() == Token.STRING) {\n        node.setStringValue(\"\\\"\" + n.getStringValue() + \"\\\"\");\n    }\n    for (AstNode child : n.getChildren()) {\n        node.addChildToBack(transform(child));\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = newNode(transformTokenType(n.getType()));\n    for (AstNode child : n.getChildren()) {\n        node.addChildToBack(transform(child));\n    }\n    if (n.getType() == TokenType.NAME) {\n        node.setType(TokenType.STRING);\n    } else if (n.getType() == TokenType.STRING) {\n        node.setValue(\"\\\"\" + node.getValue() + \"\\\"\");\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = newNode(transformTokenType(n.getType()));\n    if (n.getType() == TokenType.NAME) {\n        node.setType(TokenType.STRING);\n    } else if (n.getType() == TokenType.STRING) {\n        node.addStringQuotes();\n    }\n    for (AstNode child : n.getChildren()) {\n        node.addChildToBack(transform(child));\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = newNode(transformTokenType(n.getType()));\n    if (n.getType() == TokenType.NAME) {\n        node.setType(TokenType.STRING);\n    } else if (n.getType() == TokenType.STRING) {\n        node.addStringQuotes();\n    }\n    for (AstNode child : n.getChildren()) {\n        node.addChildToBack(transform(child));\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = newNode(transformTokenType(n.getType()));\n    if (n.getType() == TokenType.NAME) {\n        node.setType(TokenType.STRING);\n    } else if (n.getType() == TokenType.STRING) {\n        node.setValue(\"\\\"\" + n.getValue() + \"\\\"\");\n    }\n    for (AstNode child : n.getChildren()) {\n        node.addChildToBack(transform(child));\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = newNode(transformTokenType(n.getType()));\n    for (AstNode child : n.getChildren()) {\n        node.addChildToBack(transform(child));\n    }\n    if (n.getType() == TokenType.NAME) {\n        node.setType(TokenType.STRING);\n    } else if (n.getType() == TokenType.STRING) {\n        node.setQuotes(true);\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = newNode(transformTokenType(n.getType()));\n    if (n.getType() == TokenType.NAME) {\n        node.setType(TokenType.STRING);\n    } else if (n.getType() == TokenType.STRING) {\n        node.setValue(node.getValue().replace(\"\\\"\", \"\"));\n    }\n    for (AstNode child : n.getChildren()) {\n        node.addChildToBack(transform(child));\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = newNode(transformTokenType(n.getType()));\n    for (Node child : n) {\n        node.addChildToBack(transform((AstNode) child));\n    }\n    if (n.getType() == TokenType.NAME) {\n        node.setType(TokenType.STRING);\n    } else if (n.getType() == TokenType.STRING) {\n        node.addStringQuote();\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = newNode(transformTokenType(n.getType()));\n    for (AstNode child : n.getChildren()) {\n        node.addChildToBack(transform(child));\n    }\n    if (n.getType() == TokenType.NAME) {\n        node.setType(TokenType.STRING);\n    } else if (n.getType() == TokenType.STRING) {\n        node.addToken(new Token(TokenType.STRING, \"\\\"\" + n.getToken().getValue() + \"\\\"\"));\n    }\n    return node;\n}"
    ],
    [
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List valueList = new ArrayList();\n    int seriesIndex = dataset.getColumnIndex(category);\n    if (seriesIndex == -1) {\n        return valueList;\n    }\n    double total = 0;\n    for (int i : includedRows) {\n        double value = dataset.getValue(seriesIndex, i);\n        if (asPercentages) {\n            total += value;\n        }\n        else {\n            total += value;\n        }\n        valueList.add(value);\n    }\n    if (asPercentages) {\n        for (int i = 0; i < valueList.size(); i++) {\n            valueList.set(i, valueList.get(i) / total * 100);\n        }\n    }\n    valueList.add(base);\n    return valueList;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List valueList = new ArrayList();\n    double total = 0.0;\n    for (int row : includedRows) {\n        double value = dataset.getValue(category, row);\n        if (asPercentages) {\n            total += value;\n        }\n        valueList.add(value);\n    }\n    if (asPercentages) {\n        for (int i = 0; i < valueList.size(); i++) {\n            double value = (double) valueList.get(i);\n            valueList.set(i, value / total * 100);\n        }\n    }\n    valueList.add(base);\n    return valueList;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List values = new ArrayList();\n    values.add(base);\n    for (int i = 0; i < includedRows.length; i++) {\n        int row = includedRows[i];\n        double value = dataset.getValue(category, row);\n        if (asPercentages) {\n            double total = DatasetUtilities.findStackedSum(dataset, category);\n            value = (value / total) * 100;\n        }\n        values.add(value);\n    }\n    return values;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List values = new ArrayList();\n    double total = 0.0;\n    for (int i = 0; i < includedRows.length; i++) {\n        int row = includedRows[i];\n        double value = dataset.getValue(category, row);\n        if (asPercentages) {\n            total += value;\n        }\n        values.add(value);\n    }\n    if (asPercentages) {\n        for (int i = 0; i < values.size(); i++) {\n            values.set(i, values.get(i) / total * 100);\n        }\n    }\n    values.add(base);\n    return values;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List valueList = new ArrayList();\n    int seriesIndex = dataset.indexOf(category);\n    if (seriesIndex != -1) {\n        double total = 0;\n        for (int i = 0; i < includedRows.length; i++) {\n            int row = includedRows[i];\n            double value = dataset.getValue(seriesIndex, row);\n            total += value;\n            if (asPercentages) {\n                value = (value / total) * 100;\n            }\n            valueList.add(value);\n        }\n        if (base > 0) {\n            total += base;\n            if (asPercentages) {\n                total = (total / total) * 100;\n            }\n            valueList.add(total);\n        }\n    }\n    return valueList;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List values = new ArrayList();\n    int seriesIndex = dataset.indexOf(category);\n    if (seriesIndex != -1) {\n        int rowsCount = dataset.getRowCount();\n        for (int i = 0; i < rowsCount; i++) {\n            if (includedRows[i]) {\n                double value = dataset.getValue(seriesIndex, i);\n                if (asPercentages) {\n                    value = (value / DatasetUtilities.findStackedRangeBounds(dataset).getUpperBound()) * 100;\n                }\n                values.add(value);\n            }\n        }\n    }\n    values.add(base);\n    return values;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List values = new ArrayList();\n    int seriesIndex = dataset.getColumnIndex(category);\n    if (seriesIndex != -1) {\n        double total = 0.0;\n        for (int i = 0; i < includedRows.length; i++) {\n            int row = includedRows[i];\n            double value = dataset.getValue(seriesIndex, row);\n            total += value;\n        }\n        for (int i = 0; i < includedRows.length; i++) {\n            int row = includedRows[i];\n            double value = dataset.getValue(seriesIndex, row);\n            if (asPercentages) {\n                value = (value / total) * 100;\n            }\n            values.add(value + base);\n        }\n    }\n    return values;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List values = new ArrayList();\n    double total = 0.0;\n    for (int i = 0; i < includedRows.length; i++) {\n        int row = includedRows[i];\n        double value = dataset.getValue(category, row);\n        if (!this.ignoreZeroValues || value != 0.0) {\n            total += value;\n            values.add(value);\n        }\n    }\n    if (asPercentages) {\n        total = total > 0.0 ? total : 1.0;\n        for (int i = 0; i < values.size(); i++) {\n            values.set(i, values.get(i) / total * 100.0);\n        }\n    }\n    values.add(0, base);\n    return values;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List values = new ArrayList();\n    values.add(base);\n    int seriesIndex = dataset.indexOf(category);\n    if (seriesIndex != -1) {\n        for (int row : includedRows) {\n            double value = dataset.getValue(seriesIndex, row);\n            if (asPercentages) {\n                value = (value / DatasetUtilities.findStackedRangeBounds(dataset).getMaximum()) * 100;\n            }\n            values.add(value);\n        }\n    }\n    return values;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List values = new ArrayList();\n    int seriesIndex = dataset.indexOf(category);\n    if (seriesIndex != -1) {\n        double sum = 0;\n        for (int i = 0; i < includedRows.length; i++) {\n            double value = dataset.getValue(seriesIndex, includedRows[i]);\n            if (asPercentages) {\n                sum += value / DatasetUtilities.findStackedRangeBounds(dataset).getMaximum();\n            } else {\n                sum += value;\n            }\n        }\n        values.add(sum + base);\n    }\n    return values;\n}"
    ],
    [
      "private List<Element> childElementsList()  {\n    if (childElementsList == null) {\n        childElementsList = new ArrayList<>();\n        for (Node node : childNodes()) {\n            if (node instanceof Element) {\n                childElementsList.add((Element) node);\n            }\n        }\n    }\n    return childElementsList;\n}",
      "private List<Element> childElementsList()  {\n    if (childElements == null) {\n        childElements = new Elements();\n        for (Node node : childNodes()) {\n            if (node instanceof Element) {\n                childElements.add((Element) node);\n            }\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    if (childElements == null) {\n        childElements = new ArrayList<>();\n        for (Node node : childNodes()) {\n            if (node instanceof Element) {\n                childElements.add((Element) node);\n            }\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    if (childElements == null) {\n        childElements = new ArrayList<>();\n        for (Node node : childNodes()) {\n            if (node instanceof Element) {\n                childElements.add((Element) node);\n            }\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    List<Element> list = new ArrayList<>();\n    for (Node node : childNodes()) {\n        if (node instanceof Element) {\n            list.add((Element) node);\n        }\n    }\n    return list;\n}",
      "private List<Element> childElementsList()  {\n    if (childElements == null) {\n        childElements = new ArrayList<>();\n        for (Node node : childNodes()) {\n            if (node instanceof Element) {\n                childElements.add((Element) node);\n            }\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    if (childElementsList == null) {\n        childElementsList = new ArrayList<>();\n        for (Node node : childNodes()) {\n            if (node instanceof Element) {\n                childElementsList.add((Element) node);\n            }\n        }\n    }\n    return childElementsList;\n}",
      "private List<Element> childElementsList()  {\n    List<Element> childElements = new ArrayList<>();\n    for (Node node : childNodes()) {\n        if (node instanceof Element) {\n            childElements.add((Element) node);\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    if (childElements == null) {\n        childElements = new ArrayList<>();\n        for (Node node : childNodes()) {\n            if (node instanceof Element) {\n                childElements.add((Element) node);\n            }\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    List<Element> elements = new ArrayList<>();\n    for (Node node : childNodes()) {\n        if (node instanceof Element) {\n            elements.add((Element) node);\n        }\n    }\n    return elements;\n}"
    ],
    [
      "private int getHash(final Object key)  {\n        return Math.abs(key.hashCode()) % buckets.length;\n    }",
      "private int getHash(final Object key)  {\n        return Math.abs(key.hashCode()) % buckets.length;\n    }",
      "private int getHash(final Object key)  {\n        return Math.abs(key.hashCode()) % buckets.length;\n    }",
      "private int getHash(final Object key)  {\n        return Math.abs(key.hashCode()) % buckets.length;\n    }",
      "private int getHash(final Object key)  {\n        return Math.abs(key.hashCode()) % buckets.length;\n    }",
      "private int getHash(final Object key)  {\n        return Math.abs(key.hashCode()) % buckets.length;\n    }",
      "private int getHash(final Object key)  {\n        return Math.abs(key.hashCode()) % buckets.length;\n    }",
      "private int getHash(final Object key)  {\n        return Math.abs(key.hashCode()) % buckets.length;\n    }",
      "private int getHash(final Object key)  {\n        return Math.abs(key.hashCode()) % buckets.length;\n    }",
      "private int getHash(final Object key)  {\n        return Math.abs(key.hashCode()) % buckets.length;\n    }"
    ],
    [
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    int rows = m.getRowDimension();\n    int cols = m.getColumnDimension();\n    double[][] d = new double[rows-k][cols];\n    for (int r = k; r < rows; r++) {\n        for (int c = k; c < cols; c++) {\n            d[r-k][c-k] = m.getEntry(r, c);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    int rows = m.getRowDimension();\n    int cols = m.getColumnDimension();\n    double[][] d = new double[rows - k][cols - k];\n    for (int r = 0; r < rows - k; r++) {\n        for (int c = 0; c < cols - k; c++) {\n            d[r][c] = m.getEntry(r + k, c + k);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    int rows = m.getRowDimension();\n    int cols = m.getColumnDimension();\n    double[][] d = new double[rows - k][cols - k];\n    for (int r = k; r < rows; r++) {\n        for (int c = k; c < cols; c++) {\n            d[r - k][c - k] = m.getEntry(r, c);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    int rows = m.getRowDimension();\n    int cols = m.getColumnDimension();\n    double[][] d = new double[rows-k][cols];\n    for (int r = k; r < rows; r++) {\n        for (int c = k; c < cols; c++) {\n            d[r-k][c-k] = m.getEntry(r, c);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    int rows = m.getRowDimension();\n    int cols = m.getColumnDimension();\n    double[][] d = new double[rows - k][cols - k];\n    for (int r = k; r < rows; r++) {\n        for (int c = Math.max(k, r - k + 1); c < cols; c++) {\n            d[r - k][c - k] = m.getEntry(r, c);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    int rows = m.getRowDimension();\n    int cols = m.getColumnDimension();\n    double[][] d = new double[rows][cols];\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (i >= j - k) {\n                d[i][j] = m.getEntry(i, j);\n            } else {\n                d[i][j] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    int rows = m.getRowDimension();\n    int cols = m.getColumnDimension();\n    double[][] d = new double[rows - k][cols - k];\n    for (int i = 0; i < rows - k; i++) {\n        for (int j = 0; j < cols - k; j++) {\n            d[i][j] = m.getEntry(i + k, j + k);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    int rows = m.getRowDimension();\n    int cols = m.getColumnDimension();\n    double[][] d = new double[rows-k][cols-k];\n    for (int r = k; r < rows; r++) {\n        for (int c = k; c < cols; c++) {\n            d[r-k][c-k] = m.getEntry(r, c);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    int rows = m.getRowDimension();\n    int cols = m.getColumnDimension();\n    double[][] d = new double[rows - k][cols - k];\n    for (int i = 0; i < rows - k; i++) {\n        for (int j = 0; j < cols - k; j++) {\n            d[i][j] = m.getEntry(i + k, j + k);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    int rows = m.getRowDimension();\n    int cols = m.getColumnDimension();\n    double[][] d = new double[rows - k][cols - k];\n    for (int r = 0; r < rows - k; r++) {\n        for (int c = 0; c < cols - k; c++) {\n            d[r][c] = m.getEntry(r + k, c + k);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}"
    ],
    [
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) {\n                rotateCCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } else if (right.skew == Skew.BALANCED) {\n                rotateCCW();\n                skew      = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } else {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return true;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.LEFT_HIGH) {\n                rotateCCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return false;\n            } else if (right.skew == Skew.BALANCED) {\n                skew = Skew.RIGHT_HIGH;\n                return true;\n            } else {\n                final Skew s = right.right.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.LEFT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.RIGHT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return false;\n            }\n        default:\n            skew = Skew.LEFT_HIGH;\n            return true;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) {\n                rotateCCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } else if (right.skew == Skew.BALANCED) {\n                rotateCCW();\n                skew      = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } else {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return true;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.LEFT_HIGH) {\n                rotateCCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } else if (right.skew == Skew.BALANCED) {\n                rotateCCW();\n                skew      = Skew.RIGHT_HIGH;\n                left.skew = Skew.LEFT_HIGH;\n                return false;\n            } else {\n                final Skew s = right.right.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.LEFT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.RIGHT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            if (right.skew == Skew.LEFT_HIGH) {\n                rotateCCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return false;\n            } else if (right.skew == Skew.BALANCED) {\n                rotateCCW();\n                skew      = Skew.RIGHT_HIGH;\n                left.skew = Skew.LEFT_HIGH;\n                return true;\n            } else {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.LEFT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.RIGHT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return false;\n            }\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return true;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) {\n                rotateCCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n            } else if (right.skew == Skew.BALANCED) {\n                rotateCCW();\n                skew      = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n            } else {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n            }\n            return false;\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return true;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.LEFT_HIGH) {\n                rotateCCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return false;\n            } else if (right.skew == Skew.BALANCED) {\n                skew      = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } else {\n                final Skew s = right.right.skew;\n                right.rotateCCW();\n                rotateCCW();\n                switch (s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.LEFT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.RIGHT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return false;\n            }\n        default:\n            skew = Skew.LEFT_HIGH;\n            return true;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.LEFT_HIGH) {\n                rotateCCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return false;\n            } else if (right.skew == Skew.BALANCED) {\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return true;\n            } else {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.LEFT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.RIGHT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return false;\n            }\n        default:\n            skew = Skew.LEFT_HIGH;\n            return true;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.LEFT_HIGH) {\n                rotateCCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return false;\n            } else if (right.skew == Skew.BALANCED) {\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } else {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return false;\n            }\n        default:\n            skew = Skew.LEFT_HIGH;\n            return true;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.LEFT_HIGH) {\n                rotateCCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return false;\n            } else if (right.skew == Skew.BALANCED) {\n                rotateCCW();\n                skew      = Skew.RIGHT_HIGH;\n                left.skew = Skew.LEFT_HIGH;\n                return true;\n            } else {\n                final Skew s = right.right.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.LEFT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.RIGHT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.LEFT_HIGH;\n            return true;\n    }\n}"
    ],
    [
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    double min = Double.MAX_VALUE;\n    int index = -1;\n    for (int i = startIdx; i < matrixT.length; i++) {\n        for (int j = i - 1; j >= 0; j--) {\n            if (FastMath.abs(matrixT[i][j]) < min) {\n                min = FastMath.abs(matrixT[i][j]);\n                index = j;\n            }\n        }\n    }\n    return index;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    double min = Double.MAX_VALUE;\n    int idx = -1;\n    for (int i = startIdx; i < matrixT.length; i++) {\n        for (int j = i - 1; j >= 0; j--) {\n            if (FastMath.abs(matrixT[i][j]) < min) {\n                min = FastMath.abs(matrixT[i][j]);\n                idx = j;\n            }\n        }\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    double threshold = norm * EPSILON;\n    for (int i = startIdx; i < matrixT.length; i++) {\n        for (int j = i - 1; j >= 0; j--) {\n            if (FastMath.abs(matrixT[i][j]) < threshold) {\n                return j;\n            }\n        }\n    }\n    return startIdx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    double min = norm;\n    int minIndex = startIdx;\n\n    for (int i = startIdx; i < matrixT.length; i++) {\n        for (int j = i - 1; j >= 0; j--) {\n            if (FastMath.abs(matrixT[i][j]) < min) {\n                min = FastMath.abs(matrixT[i][j]);\n                minIndex = j;\n            }\n        }\n    }\n    return minIndex;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int il = startIdx;\n    double min = norm;\n    for (int i = startIdx; i < matrixT.length; i++) {\n        if (FastMath.abs(matrixT[i][i - 1]) < min) {\n            min = FastMath.abs(matrixT[i][i - 1]);\n            il = i;\n        }\n    }\n    return il;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    double min = norm;\n    int idx = startIdx;\n    for (int i = startIdx; i < matrixT.length; i++) {\n        for (int j = i - 1; j >= 0; j--) {\n            if (FastMath.abs(matrixT[i][j]) < min) {\n                min = FastMath.abs(matrixT[i][j]);\n                idx = j;\n            }\n        }\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    double threshold = norm * EPSILON;\n    for (int i = startIdx; i < matrixT.length - 1; i++) {\n        if (FastMath.abs(matrixT[i][i + 1]) < threshold) {\n            return i;\n        }\n    }\n    return matrixT.length - 1;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    double min = norm;\n    int index = startIdx;\n\n    for (int i = startIdx; i < matrixT.length; i++) {\n        if (i < matrixT.length - 1 && FastMath.abs(matrixT[i][i + 1]) < min) {\n            min = FastMath.abs(matrixT[i][i + 1]);\n            index = i;\n        }\n    }\n    return index;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    double threshold = norm * EPSILON;\n    for (int i = startIdx; i < matrixT.length; i++) {\n        for (int j = i - 1; j >= 0; j--) {\n            if (FastMath.abs(matrixT[i][j]) <= threshold) {\n                return j;\n            }\n        }\n    }\n    return startIdx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int il = startIdx;\n    double min = norm;\n    for (int i = startIdx; i < matrixT.length; i++) {\n        if (FastMath.abs(matrixT[i][i - 1]) < min) {\n            min = FastMath.abs(matrixT[i][i - 1]);\n            il = i;\n        }\n    }\n    return il;\n}"
    ],
    [
      "public Node getNotSmaller(final T reference)  {\n    Node current = top;\n    Node smallestNotSmaller = null;\n    while (current != null) {\n        if (current.element.compareTo(reference) >= 0) {\n            if (smallestNotSmaller == null) {\n                smallestNotSmaller = current;\n            }\n            current = current.getPrevious();\n        } else {\n            current = current.getNext();\n        }\n    }\n    return smallestNotSmaller;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node current = top;\n    Node smallestNotSmaller = null;\n\n    while (current != null) {\n        if (current.element.compareTo(reference) >= 0) {\n            if (smallestNotSmaller == null || current.element.compareTo(smallestNotSmaller.element) < 0) {\n                smallestNotSmaller = current;\n            }\n        }\n        current = current.getNext();\n    }\n\n    return smallestNotSmaller;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node current = top;\n    Node previous = null;\n    while (current != null) {\n        if (current.element.compareTo(reference) >= 0) {\n            return current;\n        }\n        previous = current;\n        current = current.getNext();\n    }\n    return previous;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node current = top;\n    Node previous = null;\n    while (current != null) {\n        if (current.element.compareTo(reference) >= 0) {\n            return current;\n        }\n        previous = current;\n        current = current.getNext();\n    }\n    return previous;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node current = top;\n    Node previous = null;\n    while (current != null) {\n        if (current.element.compareTo(reference) < 0) {\n            previous = current;\n            current = current.right;\n        } else if (current.element.compareTo(reference) > 0) {\n            return previous == null ? current : previous;\n        } else {\n            return current;\n        }\n    }\n    return previous;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node current = top;\n    Node smallestNotSmaller = null;\n    while (current != null) {\n        if (current.element.compareTo(reference) >= 0) {\n            if (smallestNotSmaller == null) {\n                smallestNotSmaller = current;\n            }\n            current = current.getPrevious();\n        } else {\n            current = current.getNext();\n        }\n    }\n    return smallestNotSmaller;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node current = top;\n    Node previous = null;\n    while (current != null) {\n        if (current.element.compareTo(reference) >= 0) {\n            return current;\n        }\n        previous = current;\n        current = current.getNext();\n    }\n    return previous;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node current = top;\n    Node previous = null;\n    while (current != null) {\n        if (current.element.compareTo(reference) >= 0) {\n            return current;\n        }\n        previous = current;\n        current = current.getNext();\n    }\n    return previous;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node current = top;\n    Node previous = null;\n    while (current != null) {\n        if (current.element.compareTo(reference) >= 0) {\n            return current;\n        }\n        previous = current;\n        current = current.getNext();\n    }\n    return previous;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node current = top;\n    Node smallestNotSmaller = null;\n    while (current != null) {\n        if (current.element.compareTo(reference) >= 0) {\n            if (smallestNotSmaller == null) {\n                smallestNotSmaller = current;\n            }\n            return smallestNotSmaller;\n        }\n        if (current.element.compareTo(reference) < 0) {\n            if (current.right != null) {\n                current = current.right;\n            } else {\n                smallestNotSmaller = current;\n                return smallestNotSmaller;\n            }\n        }\n    }\n    return smallestNotSmaller;\n}"
    ],
    [
      "public StrBuilder deleteAll(final String str)  {\n        if (str == null) {\n            return this;\n        }\n        int start = 0;\n        while (true) {\n            start = bufferIndexOf(start, str);\n            if (start == -1) {\n                break;\n            }\n            final int end = start + str.length();\n            deleteImpl(start, end, end - start);\n            start = end;\n        }\n        return this;\n    }",
      "public StrBuilder deleteAll(final String str)  {\n        if (str == null) {\n            return this;\n        }\n        int start = 0;\n        while (true) {\n            int index = indexOf(str, start);\n            if (index == -1) {\n                break;\n            }\n            deleteImpl(start, start + index + str.length(), index + str.length());\n            start = index + str.length();\n        }\n        return this;\n    }",
      "public StrBuilder deleteAll(final String str)  {\n        if (str == null) {\n            return this;\n        }\n        int index = 0;\n        while ((index = find(str, index)) != -1) {\n            final int start = index;\n            index += str.length();\n            final int len = index - start;\n            deleteImpl(start, index, len);\n            index -= len;\n        }\n        return this;\n    }",
      "public StrBuilder deleteAll(final String str)  {\n        if (str == null) {\n            return this;\n        }\n        int start = 0;\n        while (true) {\n            start = indexOf(str, start);\n            if (start == -1) {\n                break;\n            }\n            final int end = start + str.length();\n            deleteImpl(start, end, str.length());\n            start = end;\n        }\n        return this;\n    }",
      "public StrBuilder deleteAll(final String str)  {\n        if (str == null) {\n            return this;\n        }\n        int index = 0;\n        while ((index = indexOf(str, index)) != -1) {\n            final int start = index;\n            index += str.length();\n            final int len = str.length();\n            deleteImpl(start, index, len);\n        }\n        return this;\n    }",
      "public StrBuilder deleteAll(final String str)  {\n        if (str == null) {\n            return this;\n        }\n        int start = 0;\n        while (true) {\n            start = indexOf(str, start);\n            if (start == -1) {\n                break;\n            }\n            final int end = start + str.length();\n            deleteImpl(start, end, str.length());\n            start = end;\n        }\n        return this;\n    }",
      "public StrBuilder deleteAll(final String str)  {\n        if (str == null) {\n            return this;\n        }\n        int start = 0;\n        while (true) {\n            int index = indexOf(str, start);\n            if (index == -1) {\n                break;\n            }\n            deleteImpl(start, start + index + str.length(), index + str.length());\n            start = index + str.length();\n        }\n        return this;\n    }",
      "public StrBuilder deleteAll(final String str)  {\n        if (str == null) {\n            return this;\n        }\n        int index = 0;\n        while ((index = find(str, index)) != -1) {\n            final int start = index;\n            index += str.length();\n            final int len = index - start;\n            deleteImpl(start, index, len);\n        }\n        return this;\n    }",
      "public StrBuilder deleteAll(final String str)  {\n        if (str == null) {\n            return this;\n        }\n        int start = 0;\n        while (true) {\n            start = indexOf(str, start);\n            if (start == -1) {\n                break;\n            }\n            final int end = start + str.length();\n            deleteImpl(start, end, str.length());\n            start = end;\n        }\n        return this;\n    }",
      "public StrBuilder deleteAll(final String str)  {\n        if (str == null) {\n            return this;\n        }\n        int index = 0;\n        while ((index = indexOf(str, index)) != -1) {\n            final int start = index;\n            index += str.length();\n            final int len = str.length();\n            deleteImpl(start, index, len);\n        }\n        return this;\n    }"
    ],
    [
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    if (node.getType() == com.google.javascript.rhino.head.Token.NAME) {\n        if (node.getParent() instanceof Parameter || node.getParent() instanceof VariableInitializer) {\n            String jsDocType = getJsDocType(node);\n            if (jsDocType != null) {\n                Node irNode = justTransform(node);\n                JSDocInfo jsDocInfo = new JSDocInfo(jsDocType);\n                irNode.setJSDocInfo(jsDocInfo);\n                return irNode;\n            }\n        }\n    }\n    return node;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    if (node.getType() == com.google.javascript.rhino.head.Token.NAME) {\n        if (node.getParent() instanceof Parameter || node.getParent() instanceof VariableDeclaration) {\n            JSDocInfo jsDocInfo = getJsDocInfoFromInlineComment(node);\n            if (jsDocInfo != null) {\n                node = maybeInjectCastNode(node, jsDocInfo, newNode(Token.CAST, node));\n                node.setJSDocInfo(jsDocInfo);\n            }\n        }\n    }\n    return transform(node);\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    if (node.getType() == com.google.javascript.rhino.head.Token.NAME) {\n        JSDocInfo jsDocInfo = getJsDocInfoFromNode(node);\n        if (jsDocInfo != null) {\n            return maybeInjectCastNode(node, jsDocInfo, newNode(Token.CAST, node));\n        }\n    }\n    return transform(node);\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    if (node.getType() == com.google.javascript.rhino.head.Token.NAME) {\n        JSDocInfo jsDocInfo = getJsDocInfoFromNode(node);\n        if (jsDocInfo != null) {\n            Node irNode = justTransform(node);\n            irNode.setJSDocInfo(jsDocInfo);\n            return irNode;\n        }\n    }\n    return transform(node);\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    if (node.getType() == com.google.javascript.rhino.head.Token.NAME) {\n        if (node.getParent() instanceof ParameterList\n            || node.getParent() instanceof VariableInitializer) {\n            JSDocInfo jsDocInfo = getJsDocInfoFromInlineComment(node);\n            if (jsDocInfo != null) {\n                return maybeInjectCastNode(node, jsDocInfo, newNode(Token.NAME, node));\n            }\n        }\n    }\n    return transform(node);\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    if (node.getType() == com.google.javascript.rhino.head.Token.NAME\n        && (node.getParent() instanceof FunctionParameter\n            || node.getParent() instanceof VariableInitializer)) {\n        JSDocInfo jsDocInfo = node.getJSDocInfo();\n        if (jsDocInfo != null && jsDocInfo.hasType()) {\n            return newNode(Token.CAST, transform(node));\n        }\n    }\n    return transform(node);\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  if (node.getType() == com.google.javascript.rhino.head.Token.NAME\n      && (node.getParent() instanceof Parameter || node.getParent() instanceof VariableDeclaration)) {\n    String jsDoc = getJsDoc(node);\n    if (jsDoc != null) {\n      Node irNode = transform(node);\n      if (irNode instanceof Node) {\n        return newNode(Token.TYPE_ANNOTATION, irNode, jsDoc);\n      }\n    }\n  }\n  return transform(node);\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    if (node.getType() == com.google.javascript.rhino.head.Token.NAME\n        && (node.getParent() instanceof ParameterList\n            || node.getParent() instanceof VariableInitializer)) {\n        String jsDocComment = node.getJsDocComment();\n        if (jsDocComment != null) {\n            // Extract the type from the jsdoc comment\n            String type = extractTypeFromJsDocComment(jsDocComment);\n            if (type != null) {\n                // Create a cast node with the extracted type\n                Node irNode = newNode(Token.CAST, node);\n                irNode.setType(type);\n                return irNode;\n            }\n        }\n    }\n    return node;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    if (node.getType() == com.google.javascript.rhino.head.Token.NAME\n        && (node.getParent() instanceof ParameterList\n            || node.getParent() instanceof VariableInitializer)) {\n      JSDocInfo jsDocInfo = node.getJSDocInfo();\n      if (jsDocInfo != null && jsDocInfo.hasType()) {\n        Node irNode = justTransform(node);\n        return newNode(Token.CAST, irNode);\n      }\n    }\n    return justTransform(node);\n  }",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    if (node.getType() == com.google.javascript.rhino.head.Token.NAME) {\n        JSDocInfo jsDocInfo = handleJsDoc(node, null);\n        if (jsDocInfo != null) {\n            if (node.getParent() instanceof Parameter) {\n                // Add a cast node to the parameter\n                node = newNode(Token.CAST, newNode(Token.NAME, jsDocInfo.getType()));\n            } else if (node.getParent() instanceof VariableInitializer) {\n                // Add a cast node to the variable initializer\n                node = newNode(Token.CAST, newNode(Token.NAME, jsDocInfo.getType()));\n            }\n        }\n    }\n    return node;\n}"
    ],
    [
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List cannot be null\");\n    }\n    SetUniqueList<E> setUniqueList = new SetUniqueList<>(list);\n    return setUniqueList;\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List cannot be null\");\n    }\n    SetUniqueList<E> setUniqueList = new SetUniqueList<>(list);\n    return setUniqueList;\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List cannot be null\");\n    }\n    SetUniqueList<E> setUniqueList = new SetUniqueList<>(list);\n    return setUniqueList;\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List cannot be null\");\n    }\n    SetUniqueList<E> setUniqueList = new SetUniqueList<>(list);\n    return setUniqueList;\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List cannot be null\");\n    }\n    SetUniqueList<E> setUniqueList = new SetUniqueList<>(list);\n    return setUniqueList;\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List cannot be null\");\n    }\n    SetUniqueList<E> setUniqueList = new SetUniqueList<>(list);\n    return setUniqueList;\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List cannot be null\");\n    }\n    SetUniqueList<E> setUniqueList = new SetUniqueList<>(list);\n    return setUniqueList;\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    SetUniqueList<E> setUniqueList = new SetUniqueList<>(list);\n    return setUniqueList;\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List cannot be null\");\n    }\n    SetUniqueList<E> setUniqueList = new SetUniqueList<>(list);\n    return setUniqueList;\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List cannot be null\");\n    }\n    SetUniqueList<E> setUniqueList = new SetUniqueList<>(list);\n    return setUniqueList;\n}"
    ],
    [
      "private Node parseArrayType(JsDocToken token)  {\n    if (!match(JsDocToken.LSQUARE)) {\n        return null;\n    }\n    Node arrayType = newNode(Token.ARRAY);\n    if (match(JsDocToken.RSQUARE)) {\n        return arrayType;\n    }\n    if (match(JsDocToken.ELLIPSIS)) {\n        Node ellipsis = newNode(Token.ELLIPSIS);\n        arrayType.addChildToBack(ellipsis);\n        if (match(JsDocToken.RSQUARE)) {\n            return arrayType;\n        }\n    }\n    Node elementType = parseTypeExpression(next());\n    arrayType.addChildToBack(elementType);\n    while (match(JsDocToken.COMMA)) {\n        arrayType.addChildToBack(parseTypeExpression(next()));\n    }\n    if (!match(JsDocToken.RSQUARE)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rsquare\");\n    }\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    if (!match(JsDocToken.LSQUARE)) {\n        return null;\n    }\n\n    Node arrayType = newNode(Token.ARRAY);\n    Node elementTypeList = parseElementTypeList(next());\n\n    if (!match(JsDocToken.RSQUARE)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rsquare\");\n    }\n\n    arrayType.addChildToBack(elementTypeList);\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node array = newNode(Token.LBRACKET);\n  if (!match(JsDocToken.RBRACKET)) {\n    skipEOLs();\n    token = next();\n    if (match(JsDocToken.ELLIPSIS)) {\n      array.addChildToBack(parseTypeExpression(next()));\n    } else {\n      do {\n        array.addChildToBack(parseTypeExpression(token));\n        if (match(JsDocToken.COMMA)) {\n          next();\n        } else {\n          break;\n        }\n      } while (true);\n    }\n    skipEOLs();\n    if (!match(JsDocToken.RBRACKET)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rbracket\");\n    }\n    next();\n  }\n  return array;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    if (!match(JsDocToken.LSQUARE)) {\n        return null;\n    }\n\n    Node arrayType = newNode(Token.ARRAY);\n\n    if (!match(JsDocToken.RSQUARE)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rsquare\");\n    }\n\n    token = next();\n    skipEOLs();\n\n    if (match(JsDocToken.RSQUARE)) {\n        return arrayType;\n    }\n\n    Node elementTypeList = newNode(Token.EMPTY);\n\n    while (true) {\n        if (match(JsDocToken.RSQUARE)) {\n            break;\n        }\n\n        Node elementType = parseTypeExpression(next());\n        if (elementType == null) {\n            return null;\n        }\n\n        elementTypeList.addChildToBack(elementType);\n\n        if (match(JsDocToken.COMMA)) {\n            skipEOLs();\n            token = next();\n        } else if (match(JsDocToken.RSQUARE)) {\n            break;\n        } else if (match(JsDocToken.Ellipsis)) {\n            skipEOLs();\n            token = next();\n            if (!match(JsDocToken.RSQUARE)) {\n                return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rsquare\");\n            }\n            break;\n        } else {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.invalid.arraytype\");\n        }\n    }\n\n    arrayType.addChildToBack(elementTypeList);\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node array = newNode(Token.LBRACKET);\n    if (!match(JsDocToken.RBRACKET)) {\n        token = next();\n        skipEOLs();\n        if (match(JsDocToken.ELLIPSIS)) {\n            array.addChild(parseTypeExpression(next()));\n        } else {\n            do {\n                array.addChild(parseTypeExpression(token));\n                if (match(JsDocToken.COMMA)) {\n                    token = next();\n                    skipEOLs();\n                } else {\n                    break;\n                }\n            } while (true);\n        }\n        skipEOLs();\n        if (!match(JsDocToken.RBRACKET)) {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rbracket\");\n        }\n        next();\n    }\n    return array;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node array = newNode(Token.LBRACKET);\n  if (!match(JsDocToken.RBRACKET)) {\n    if (match(JsDocToken.ELLIPSIS)) {\n      token = next();\n      Node type = parseTypeExpression(next());\n      array.addChildToBack(type);\n    } else {\n      do {\n        array.addChildToBack(parseTypeExpression(next()));\n        if (!match(JsDocToken.COMMA)) {\n          break;\n        }\n      } while (true);\n    }\n  }\n  skipEOLs();\n  if (!match(JsDocToken.RBRACKET)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rbracket\");\n  }\n  next();\n  return array;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node array = newNode(Token.LBRACKET);\n  if (!match(JsDocToken.RBRACKET)) {\n    if (match(JsDocToken.ELLIPSIS)) {\n      token = next();\n      Node type = parseTypeExpression(next());\n      array.addChildToBack(type);\n    } else {\n      do {\n        array.addChildToBack(parseTypeExpression(next()));\n        if (match(JsDocToken.COMMA)) {\n          next();\n        } else {\n          break;\n        }\n      } while (true);\n    }\n  }\n  array.addChildToBack(newNode(Token.RBRACKET));\n  return array;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node array = newNode(Token.LBRACKET);\n    if (match(JsDocToken.RBRACKET)) {\n        return array;\n    }\n\n    if (match(JsDocToken.DOTDOTDOT)) {\n        array.addChildToBack(parseTypeExpression(next()));\n        skipEOLs();\n        if (!match(JsDocToken.RBRACKET)) {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rbracket\");\n        }\n        return array;\n    }\n\n    do {\n        array.addChildToBack(parseTypeExpression(next()));\n        skipEOLs();\n        if (!match(JsDocToken.COMMA)) {\n            break;\n        }\n    } while (true);\n\n    skipEOLs();\n    if (!match(JsDocToken.RBRACKET)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rbracket\");\n    }\n    return array;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    if (!match(JsDocToken.LBRACKET)) {\n        return null;\n    }\n    Node arrayType = newNode(Token.ARRAY);\n    Node elementTypeList = parseElementTypeList(next());\n    if (!match(JsDocToken.RBRACKET)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rbracket\");\n    }\n    arrayType.addChildToBack(elementTypeList);\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node array = newNode(Token.LBRACKET);\n  if (!match(JsDocToken.RBRACKET)) {\n    token = next();\n    skipEOLs();\n    if (match(JsDocToken.ELLIPSIS)) {\n      array.addChildToBack(newNode(Token.ELLIPSIS));\n      token = next();\n      skipEOLs();\n      if (!match(JsDocToken.RBRACKET)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rbracket\");\n      }\n      next();\n    } else {\n      Node elementType = parseTypeExpression(token);\n      if (elementType == null) {\n        return null;\n      }\n      array.addChildToBack(elementType);\n      while (match(JsDocToken.COMMA)) {\n        token = next();\n        skipEOLs();\n        array.addChildToBack(parseTypeExpression(next()));\n      }\n    }\n  }\n  return array;\n}"
    ],
    [
      "public Vector3D getAxis()  {\n    return new Vector3D(2 * (quat[1] * quat[3] - quat[0] * quat[2]), 2 * (quat[0] * quat[1] + quat[2] * quat[3]), quat[0] * quat[0] - quat[1] * quat[1] - quat[2] * quat[2] + quat[3] * quat[3]);\n}",
      "public Vector3D getAxis()  {\n    return new Vector3D(2 * (quat[1] * quat[3] - quat[0] * quat[2]), 2 * (quat[0] * quat[1] + quat[2] * quat[3]), quat[0] * quat[0] - quat[1] * quat[1] - quat[2] * quat[2] + quat[3] * quat[3]);\n}",
      "public Vector3D getAxis()  {\n    return new Vector3D(2 * (quat[1] * quat[3] - quat[0] * quat[2]), 2 * (quat[0] * quat[1] + quat[2] * quat[3]), quat[0] * quat[0] - quat[1] * quat[1] - quat[2] * quat[2] + quat[3] * quat[3]);\n}",
      "public Vector3D getAxis()  {\n    return new Vector3D(2*(quat[1]*quat[3] - quat[0]*quat[2]), 2*(quat[0]*quat[3] + quat[1]*quat[2]), quat[0]*quat[0] - quat[1]*quat[1] - quat[2]*quat[2]);\n}",
      "public Vector3D getAxis()  {\n    return new Vector3D(2 * (quat[1] * quat[3] - quat[0] * quat[2]), 2 * (quat[0] * quat[1] + quat[2] * quat[3]), quat[0] * quat[0] - quat[1] * quat[1] - quat[2] * quat[2] + quat[3] * quat[3]);\n}",
      "public Vector3D getAxis()  {\n    return new Vector3D(q1, q2, q3);\n}",
      "public Vector3D getAxis()  {\n    return new Vector3D(q1, q2, q3);\n}",
      "public Vector3D getAxis()  {\n    return new Vector3D(2*(quat[1]*quat[3] - quat[0]*quat[2]), 2*(quat[0]*quat[3] + quat[1]*quat[2]), quat[0]*quat[0] - quat[1]*quat[1] - quat[2]*quat[2]);\n}",
      "public Vector3D getAxis()  {\n    return new Vector3D(q1, q2, q3);\n}",
      "public Vector3D getAxis()  {\n    return new Vector3D(2 * (quat[1] * quat[3] - quat[0] * quat[2]), 2 * (quat[0] * quat[1] + quat[2] * quat[3]), quat[0] * quat[0] - quat[1] * quat[1] - quat[2] * quat[2] + quat[3] * quat[3]);\n}"
    ],
    [
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (final byte c : bytes) {\n        if (c == ESCAPE_CHAR) {\n            try {\n                final byte[] hex = new byte[2];\n                buffer.write((byte) Character.toLowerCase(Character.forDigit((bytes[buffer.size()] >> 4) & 0xF, RADIX)));\n                buffer.write((byte) Character.toLowerCase(Character.forDigit(bytes[buffer.size()] & 0xF, RADIX)));\n                buffer.write((byte) (bytes[buffer.size()] = bytes[buffer.size() + 2]));\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding\");\n            }\n        } else if (c == '+') {\n            buffer.write(' ');\n        } else {\n            buffer.write(c);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (final byte c : bytes) {\n        if (c == ESCAPE_CHAR) {\n            try {\n                final byte[] hex = new byte[2];\n                buffer.write(hex[0] = (byte) Character.toLowerCase(Character.forDigit((bytes[buffer.size() - 2] >> 4) & 0xF, RADIX)));\n                buffer.write(hex[1] = (byte) Character.toLowerCase(Character.forDigit(bytes[buffer.size() - 1] & 0xF, RADIX)));\n                buffer.write((byte) (Integer.parseInt(new String(hex), RADIX) & 0xFF));\n            } catch (NumberFormatException e) {\n                throw new DecoderException(\"Invalid URL encoding\");\n            }\n        } else if (c == '+') {\n            buffer.write(' ');\n        } else {\n            buffer.write(c);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (final byte c : bytes) {\n        if (c == ESCAPE_CHAR) {\n            final byte[] hex = new byte[2];\n            buffer.write(hex[0] = (byte) (bytes[buffer.size() + 1] & 0x0F));\n            buffer.write(hex[1] = (byte) ((bytes[buffer.size() + 2] & 0x0F) << 4));\n            int b = (hex[0] - '0') * 16 + (hex[1] - '0');\n            if (b < 0) {\n                b = 256 + b;\n            }\n            buffer.write((byte) b);\n        } else if (c == '+') {\n            buffer.write(' ');\n        } else {\n            buffer.write(c);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (final byte c : bytes) {\n        if (c == ESCAPE_CHAR) {\n            final byte[] hex = new byte[2];\n            buffer.write(hex[0] = (byte) (Character.toLowerCase(bytes[buffer.size()]) - 'a' + 10));\n            buffer.write(hex[1] = (byte) (Character.toLowerCase(bytes[buffer.size()]) - 'a' + 10));\n            buffer.write((byte) ((int) hex[0] << 4 | (int) hex[1]));\n        } else if (c == '+') {\n            buffer.write(' ');\n        } else {\n            buffer.write(c);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (final byte c : bytes) {\n        if (c == ESCAPE_CHAR) {\n            try {\n                final byte[] hexBytes = new byte[2];\n                buffer.write(hexBytes[0] = (byte) Character.toLowerCase(Character.forDigit((bytes[buffer.size()] >> 4) & 0xF, RADIX)));\n                buffer.write(hexBytes[1] = (byte) Character.toLowerCase(Character.forDigit(bytes[buffer.size()] & 0xF, RADIX)));\n                buffer.write((byte) ((int) Character.toUpperCase(hexBytes[0]) - 48));\n                buffer.write((byte) ((int) Character.toUpperCase(hexBytes[1]) - 48));\n                buffer.size++;\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding\");\n            }\n        } else {\n            buffer.write(c);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (final byte c : bytes) {\n        if (c == ESCAPE_CHAR) {\n            final byte[] hex = new byte[2];\n            buffer.write(hex[0] = bytes[buffer.size() + 1]);\n            buffer.write(hex[1] = bytes[buffer.size() + 2]);\n            int b = ((Character.digit(hex[0], RADIX) << 4) + Character.digit(hex[1], RADIX));\n            if (b < 0) {\n                b = 256 + b;\n            }\n            buffer.write((byte) b);\n        } else {\n            buffer.write(c);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (final byte c : bytes) {\n        if (c == ESCAPE_CHAR) {\n            final byte[] hex = new byte[2];\n            buffer.write(hex[0] = (byte) (Character.toLowerCase(bytes[buffer.size()]) - 'a' + 10));\n            buffer.write(hex[1] = (byte) (Character.toLowerCase(bytes[buffer.size()]) - 'a' + 10));\n            buffer.write((byte) ((int) (Character.toUpperCase(hex[0]) - 'A' + 10) << 4 | (int) (Character.toUpperCase(hex[1]) - 'A' + 10)));\n        } else if (c == '+') {\n            buffer.write(' ');\n        } else {\n            buffer.write(c);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (final byte c : bytes) {\n        if (c == ESCAPE_CHAR) {\n            final byte[] hexBytes = new byte[2];\n            buffer.write(hexBytes[0] = (byte) Character.toLowerCase(Character.forDigit((bytes[buffer.size() - 2] >> 4) & 0xF, RADIX)));\n            buffer.write(hexBytes[1] = (byte) Character.toLowerCase(Character.forDigit(bytes[buffer.size() - 1] & 0xF, RADIX)));\n            buffer.write((byte) (Character.toUpperCase(hexBytes[0]) - '0'));\n            buffer.write((byte) (Character.toUpperCase(hexBytes[1]) - '0'));\n        } else if (c == '+') {\n            buffer.write(' ');\n        } else {\n            buffer.write(c);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (final byte c : bytes) {\n        if (c == ESCAPE_CHAR) {\n            try {\n                final byte[] hex = new byte[2];\n                buffer.write((byte) Character.toLowerCase(Character.forDigit((bytes[buffer.size()] >> 4) & 0xF, RADIX)));\n                buffer.write((byte) Character.toLowerCase(Character.forDigit(bytes[buffer.size()] & 0xF, RADIX)));\n                buffer.write((byte) Character.toUpperCase(Character.forDigit((bytes[buffer.size() + 1] >> 4) & 0xF, RADIX)));\n                buffer.write((byte) Character.toUpperCase(Character.forDigit(bytes[buffer.size() + 1] & 0xF, RADIX)));\n                buffer.size += 4;\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding\");\n            }\n        } else if (c == '+') {\n            buffer.write(' ');\n        } else {\n            buffer.write(c);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (final byte c : bytes) {\n        if (c == ESCAPE_CHAR) {\n            try {\n                final byte[] hex = new byte[2];\n                buffer.write((byte) Character.toLowerCase(Character.forDigit((bytes[buffer.size()] >> 4) & 0xF, RADIX)));\n                buffer.write((byte) Character.toLowerCase(Character.forDigit(bytes[buffer.size()] & 0xF, RADIX)));\n                buffer.write((byte) (bytes[buffer.size()] = bytes[buffer.size() + 2]));\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding\");\n            }\n        } else {\n            buffer.write(c);\n        }\n    }\n    return buffer.toByteArray();\n}"
    ],
    [
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial is null\");\n    }\n    // implement the logic here\n    // for example, you can check the type of the partial and its fields\n    // and return true if it is contiguous, false otherwise\n    return false;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial is null\");\n    }\n    // Check if the partial is contiguous\n    // For example, LocalDate is contiguous because DayOfMonth has the same range (Month) as the unit of the next field (MonthOfYear), and MonthOfYear has the same range (Year) as the unit of the next field (Year).\n    // Similarly, LocalTime is contiguous, as it consists of MillisOfSecond, SecondOfMinute, MinuteOfHour and HourOfDay (note how the names of each field 'join up').\n    // However, a Year/HourOfDay partial is not contiguous because the range field Day is not equal to the next field Year.\n    // Similarly, a DayOfWeek/DayOfMonth partial is not contiguous because the range Month is not equal to the next field Day.\n    // Here, we can use the getFields() method of the partial to get the fields of the partial, and then check if the range of each field is equal to the next field.\n    // If the range of each field is equal to the next field, then the partial is contiguous.\n    // Otherwise, the partial is not contiguous.\n    // \n    // Here is the code to check if the partial is contiguous:\n    // \n    // int i = 0;\n    // for (int j = 0; j < partial.getFields().length; j++) {\n    //     if (i >= partial.getFields().length - 1) {\n    //         break;\n    //     }\n    //     if (partial.getFields()[j].getMaximumValue() != partial.getFields()[i + 1].getMinimumValue()) {\n    //         return false;\n    //     }\n    //     i++;\n    // }\n    // return true;\n    // \n    // This code checks if the range of each field is equal to the next field.\n    // If the range of each field is equal to the next field, then the partial is contiguous.\n    // Otherwise, the partial is not contiguous.\n    // \n    // Here is the code to check if the partial is contiguous:\n    // \n    // for (int i = 0; i < partial.getFields().length - 1; i++) {\n    //     if (partial.getFields()[i].getMaximumValue() != partial.getFields()[i + 1].getMinimumValue()) {\n    //         return false;\n    //     }\n    // }\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial is null\");\n    }\n    // TO DO\n    // implement the logic to check if the partial is contiguous\n    // You can use the provided context for reference\n    return false; // TO DO\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial is null\");\n    }\n    // TO DO: implement the logic to check if the partial is contiguous\n    // This could involve iterating over the fields of the partial and\n    // checking if the range of each field is equal to the unit of the next field\n    // For example, if the partial is a LocalDate, you could check if the range\n    // of the DayOfMonth field is equal to the unit of the next field, MonthOfYear\n    // If the partial is a LocalTime, you could check if the range of the MillisOfSecond\n    // field is equal to the unit of the next field, SecondOfMinute\n    // If the partial is not contiguous, return false\n    // Otherwise, return true\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial is null\");\n    }\n    // Your code here\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial is null\");\n    }\n    // implement the logic here\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial is null\");\n    }\n    // Check if the partial is contiguous\n    // This is a placeholder for the actual implementation\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial is null\");\n    }\n    // TO DO: implement the logic here\n    return false;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial is null\");\n    }\n    // TO DO: implement the logic to check if the partial is contiguous\n    return false;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial is null\");\n    }\n    // Check if the partial is contiguous\n    // This is a placeholder and should be replaced with the actual implementation\n    return true;\n}"
    ],
    [
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    Collection<O> result = helper.list();\n    for (O obj : a) {\n        helper.setCardinality(obj, countOccurrences(a, obj));\n    }\n    for (O obj : b) {\n        helper.setCardinality(obj, countOccurrences(b, obj));\n    }\n    return result;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    Collection<O> result = helper.list();\n    return result;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    Collection<O> result = helper.list();\n    return result;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    Collection<O> result = helper.list();\n    for (O obj : a) {\n        helper.setCardinality(obj, count(a, obj));\n    }\n    for (O obj : b) {\n        helper.setCardinality(obj, count(b, obj));\n    }\n    return result;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    Collection<O> result = helper.list();\n    return result;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    Collection<O> result = helper.list();\n    for (O obj : a) {\n        helper.setCardinality(obj, count(a, obj));\n    }\n    for (O obj : b) {\n        helper.setCardinality(obj, count(b, obj));\n    }\n    return result;\n}"
    ],
    [
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    Node param = params.getFirstChild();\n    while (param != null) {\n}\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    Node param = params.getFirstChild();\n    while (param != null) {\n      result.add(IR.string(param.getFirstChild().getLiteral()));\n      param = param.getNext();\n    }\n    return result;\n  }",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    Node param = params.getFirstChild();\n    while (param != null) {\n        result.add(IR.string(param.getFirstChild().getLiteral().getValue()));\n        param = param.getNext();\n    }\n    return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    Node param = params.getFirstChild();\n    while (param != null) {\n}\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    Node param = params.getFirstChild();\n    while (param != null) {\n}\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    Node param = params.getFirstChild();\n    while (param != null) {\n}\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    Node param = params.getFirstChild();\n    while (param != null) {\n}\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    Node param = params.getFirstChild();\n    while (param != null) {\n        result.add(IR.string(param.getFirstChild().getLiteral()));\n        param = param.getNext();\n    }\n    return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    Node param = params.getFirstChild();\n    while (param != null) {\n      result.add(IR.string(param.getFirstChild().getLiteral()));\n      param = param.getNext();\n    }\n    return result;\n  }",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    Node param = params.getFirstChild();\n    while (param != null) {\n      result.add(IR.string(param.getFirstChild().getLiteral()));\n      param = param.getNext();\n    }\n    return result;\n  }"
    ],
    [
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            append(str.substring(strLen - width));\n        } else {\n            append(str);\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                append(padChar);\n            }\n        }\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen > width) {\n            str = str.substring(0, width);\n        }\n        final int padLen = width - strLen;\n        if (padLen > 0) {\n            for (int i = 0; i < padLen; i++) {\n                buffer[size++] = padChar;\n            }\n        }\n        str.getChars(0, strLen, buffer, size);\n        size += strLen;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            append(str.substring(strLen - width));\n        } else {\n            append(str);\n            for (int i = 0; i < width - strLen; i++) {\n                append(padChar);\n            }\n        }\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen > width) {\n            str = str.substring(0, width);\n        }\n        final int padLen = width - strLen;\n        if (padLen > 0) {\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n        }\n        str.getChars(0, strLen, buffer, size);\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            getChars(size, size + width - strLen, buffer, size);\n            size += width;\n        } else {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n            size += width;\n        }\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen > width) {\n            str = str.substring(0, width);\n        }\n        final int padLen = width - strLen;\n        if (padLen > 0) {\n            for (int i = 0; i < padLen; i++) {\n                buffer[size++] = padChar;\n            }\n        }\n        str.getChars(0, strLen, buffer, size);\n        size += strLen;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen > width) {\n            str = str.substring(0, width);\n        }\n        final int padLen = width - strLen;\n        if (padLen > 0) {\n            for (int i = 0; i < padLen; i++) {\n                buffer[size++] = padChar;\n            }\n        }\n        str.getChars(0, strLen, buffer, size);\n        size += strLen;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen > width) {\n            str = str.substring(0, width);\n        }\n        final int padLen = width - strLen;\n        if (padLen > 0) {\n            for (int i = 0; i < padLen; i++) {\n                buffer[size++] = padChar;\n            }\n        }\n        str.getChars(0, strLen, buffer, size);\n        size += strLen;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            getChars(0, strLen - width, buffer, size);\n            size += width;\n        } else {\n            final int padLen = width - strLen;\n            getChars(0, strLen, buffer, size);\n            size += strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            size += padLen;\n        }\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen > width) {\n            str = str.substring(0, width);\n        }\n        final int padLen = width - strLen;\n        if (padLen > 0) {\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n        }\n        str.getChars(0, strLen, buffer, size);\n        size += width;\n    }\n    return this;\n}"
    ],
    [
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    StringBuilder sb = new StringBuilder();\n    boolean capitalizeNext = true;\n    for (char ch : str.toCharArray()) {\n        if (isDelimiter(ch, delimiters)) {\n            sb.append(ch);\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            sb.append(Character.toTitleCase(ch));\n            capitalizeNext = false;\n        } else {\n            sb.append(Character.toLowerCase(ch));\n        }\n    }\n    return sb.toString();\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    String result = str;\n    if (delimiters != null) {\n        result = result.replaceAll(\"[\" + String.valueOf(delimiters) + \"]\", \" $0\");\n    }\n    result = result.trim().replaceAll(\" +\", \" \");\n    String[] words = result.split(\" \");\n    for (int i = 0; i < words.length; i++) {\n        words[i] = words[i].substring(0, 1).toUpperCase() + words[i].substring(1).toLowerCase();\n    }\n    return String.join(\" \", words);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    String result = str;\n    if (delimiters != null) {\n        result = result.replaceAll(\"([^\\\"])\" + Pattern.quote(String.valueOf(delimiters)), \"$1 \");\n    }\n    result = capitalize(result);\n    return result.trim();\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    String result = str;\n    if (delimiters != null) {\n        result = result.replaceAll(\"([^\" + new String(delimiters) + \"])\", \" $1\");\n    }\n    result = result.trim().replaceAll(\" +\", \" \");\n    String[] words = result.split(\"\\\\s+\");\n    for (int i = 0; i < words.length; i++) {\n        words[i] = words[i].substring(0, 1).toUpperCase() + words[i].substring(1).toLowerCase();\n    }\n    return String.join(\" \", words);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    String[] words = str.split((delimiters == null ? \"\\\\s+\" : new String(delimiters)));\n    StringBuilder sb = new StringBuilder();\n    for (String word : words) {\n        sb.append(Character.toTitleCase(word.charAt(0)));\n        sb.append(word.substring(1).toLowerCase());\n        if (sb.length() > 0) {\n            sb.append((delimiters == null ? \" \" : new String(delimiters)));\n        }\n    }\n    return sb.toString();\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    StringBuilder result = new StringBuilder();\n    boolean capitalizeNext = true;\n    for (char ch : str.toCharArray()) {\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            result.append(Character.toTitleCase(ch));\n            capitalizeNext = false;\n        } else {\n            result.append(Character.toLowerCase(ch));\n        }\n    }\n    return result.toString();\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    StringBuilder sb = new StringBuilder();\n    boolean capitalizeNext = true;\n    for (char ch : str.toCharArray()) {\n        if (isDelimiter(ch, delimiters)) {\n            sb.append(ch);\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            sb.append(Character.toTitleCase(ch));\n            capitalizeNext = false;\n        } else {\n            sb.append(Character.toLowerCase(ch));\n        }\n    }\n    return sb.toString();\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    StringBuilder result = new StringBuilder();\n    boolean capitalizeNext = true;\n    for (char ch : str.toCharArray()) {\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            result.append(Character.toTitleCase(ch));\n            capitalizeNext = false;\n        } else {\n            result.append(Character.toLowerCase(ch));\n        }\n    }\n    return result.toString();\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    StringBuilder buffer = new StringBuilder();\n    boolean capitalizeNext = true;\n    for (char ch : str.toCharArray()) {\n        if (isDelimiter(ch, delimiters)) {\n            buffer.append(capitalizeNext ? Character.toTitleCase(ch) : ch);\n            capitalizeNext = true;\n        } else {\n            buffer.append(capitalizeNext ? Character.toLowerCase(ch) : ch);\n            capitalizeNext = false;\n        }\n    }\n    return buffer.toString();\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    StringBuilder buffer = new StringBuilder();\n    boolean capitalizeNext = true;\n    for (char ch : str.toCharArray()) {\n        if (isDelimiter(ch, delimiters)) {\n            buffer.append(capitalizeNext ? Character.toTitleCase(ch) : Character.toLowerCase(ch));\n            capitalizeNext = true;\n        } else {\n            buffer.append(capitalizeNext ? Character.toTitleCase(ch) : Character.toLowerCase(ch));\n            capitalizeNext = false;\n        }\n    }\n    return buffer.toString();\n}"
    ],
    [
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    String[] parts = id.split(\"/\");\n    if (parts.length < 2) {\n        return null;\n    }\n    String providerId = parts[0];\n    String zoneId = parts[1];\n    NameProvider provider = getNameProvider();\n    if (provider == null) {\n        return null;\n    }\n    String newId = provider.getName(zoneId);\n    if (newId == null) {\n        return null;\n    }\n    return providerId + \"/\" + newId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n\n    if (id.length() == 4) {\n        return id;\n    }\n\n    try {\n        String[] parts = id.split(\"/\");\n        if (parts.length == 2) {\n            String zoneId = parts[0];\n            String offsetId = parts[1];\n            String newId = getZoneId(zoneId) + \"/\" + offsetId;\n            return newId;\n        }\n    } catch (Exception ex) {\n        // ignored\n    }\n\n    return null;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n\n    if (id.length() == 4) {\n        return id;\n    }\n\n    try {\n        NameProvider provider = getNameProvider();\n        if (provider != null) {\n            return provider.getName(id);\n        }\n    } catch (Exception ex) {\n        // ignored\n    }\n\n    return null;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n\n    if (id.length() == 3) {\n        return id;\n    }\n\n    if (id.length() == 5) {\n        return id.substring(0, 3) + id.substring(4);\n    }\n\n    return null;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n\n    if (id.length() == 3) {\n        return id;\n    }\n\n    if (id.length() == 5) {\n        return id.substring(0, 3) + \"-\" + id.substring(3);\n    }\n\n    if (id.length() == 6) {\n        return id.substring(0, 4) + \"-\" + id.substring(4);\n    }\n\n    return null;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n\n    NameProvider provider = getNameProvider();\n    if (provider == null) {\n        provider = getDefaultNameProvider();\n    }\n\n    if (provider != null) {\n        try {\n            return provider.getName(id);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return null;\n        }\n    }\n\n    return null;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    if (id.length() == 3) {\n        return id;\n    }\n    try {\n        String provider = getNameProvider().getName(id);\n        if (provider != null) {\n            return provider;\n        }\n    } catch (Exception ex) {\n        // ignored\n    }\n    return null;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n\n    String[] ids = new String[] {\"Europe/London\", \"Europe/Paris\", \"Europe/Berlin\", \"America/New_York\", \"Asia/Tokyo\"};\n    for (String oldId : ids) {\n        if (oldId.equals(id)) {\n            return \"Europe/London\"; // return the new id\n        }\n    }\n    return null;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    if (id.startsWith(\"GMT\")) {\n        id = id.substring(3);\n    }\n    if (id.length() == 3) {\n        return id;\n    }\n    if (id.length() == 4) {\n        return id.substring(0, 3) + \":\" + id.substring(3);\n    }\n    if (id.length() == 5) {\n        return id.substring(0, 3) + \":\" + id.substring(3, 4) + \":\" + id.substring(4);\n    }\n    return null;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    String provider = getNameProvider();\n    if (provider == null) {\n        return id;\n    }\n    try {\n        return provider.getZoneId(id);\n    } catch (Exception ex) {\n        return id;\n    }\n}"
    ],
    [
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    RealMatrix jacobian = jF.value(params);\n    RealMatrix weightMatrixSqrtInverse = weightMatrixSqrt.inverse();\n    return jacobian.multiply(weightMatrixSqrtInverse);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    RealMatrix jacobian = jF.value(params);\n    RealMatrix weightMatrix = weightMatrixSqrt.transpose().multiply(weightMatrixSqrt);\n    return weightMatrix.multiply(jacobian);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    jF = new MultivariateDifferentiableVectorFunction() {\n}\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    jF = new MultivariateDifferentiableVectorFunction() {\n}\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    jF = new MultivariateDifferentiableVectorFunction() {\n}\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    jF = new MultivariateDifferentiableVectorFunction() {\n}\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    RealMatrix jacobian = jF.valueAndDerivative(params);\n    RealMatrix weightMatrixSqrtInv = weightMatrixSqrt.inverse();\n    return weightMatrixSqrtInv.multiply(jacobian);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    jF = new MultivariateDifferentiableVectorFunction() {\n}\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    jF = new MultivariateDifferentiableVectorFunction() {\n}\n}"
    ],
    [
      "private int least()  {\n    start();\n    int leastIndex = -1;\n    E leastVal = null;\n    for (int i = 0; i < iterators.size(); i++) {\n        if (set(i)) {\n            if (leastVal == null || comparator.compare(leastVal, values.get(i)) > 0) {\n                leastIndex = i;\n                leastVal = values.get(i);\n            }\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    start();\n    int leastIndex = -1;\n    for (int i = 0; i < iterators.size(); i++) {\n        if (set(i)) {\n            if (leastIndex == -1 || iterators.get(i).compare(values.get(i), values.get(leastIndex)) < 0) {\n                leastIndex = i;\n            }\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    start();\n    int leastIndex = -1;\n    E leastValue = null;\n    for (int i = 0; i < iterators.size(); i++) {\n        if (set(i)) {\n            if (leastValue == null || comparator.compare(values.get(i), leastValue) < 0) {\n                leastIndex = i;\n                leastValue = values.get(i);\n            }\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    start();\n    int leastIndex = -1;\n    E leastValue = null;\n    for (int i = 0; i < iterators.size(); i++) {\n        if (set(i)) {\n            if (leastValue == null || comparator.compare(values.get(i), leastValue) < 0) {\n                leastIndex = i;\n                leastValue = values.get(i);\n            }\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    start();\n    int leastIndex = -1;\n    E leastVal = null;\n    for (int i = 0; i < iterators.size(); i++) {\n        if (set(i)) {\n            if (leastIndex == -1 || comparator.compare(values.get(i), leastVal) < 0) {\n                leastIndex = i;\n                leastVal = values.get(i);\n            }\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    start();\n    int leastIndex = -1;\n    E leastValue = null;\n    for (int i = 0; i < iterators.size(); i++) {\n        if (set(i)) {\n            if (leastValue == null || comparator.compare(values.get(i), leastValue) < 0) {\n                leastIndex = i;\n                leastValue = values.get(i);\n            }\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    start();\n    int leastIndex = -1;\n    for (int i = 0; i < iterators.size(); i++) {\n        if (set(i)) {\n            if (leastIndex == -1 || valueSet.get(i)) {\n                leastIndex = i;\n            }\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    start();\n    int leastIndex = -1;\n    E leastValue = null;\n    for (int i = 0; i < iterators.size(); i++) {\n        if (set(i)) {\n            if (leastValue == null || comparator.compare(values.get(i), leastValue) < 0) {\n                leastIndex = i;\n                leastValue = values.get(i);\n            }\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    start();\n    int leastIndex = -1;\n    E leastVal = null;\n    for (int i = 0; i < iterators.size(); i++) {\n        if (set(i)) {\n            if (leastVal == null || comparator.compare(leastVal, values.get(i)) > 0) {\n                leastVal = values.get(i);\n                leastIndex = i;\n            }\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    start();\n    int leastIndex = -1;\n    E leastValue = null;\n    for (int i = 0; i < iterators.size(); i++) {\n        if (set(i)) {\n            if (leastValue == null || comparator.compare(leastValue, values.get(i)) > 0) {\n                leastIndex = i;\n                leastValue = values.get(i);\n            }\n        }\n    }\n    return leastIndex;\n}"
    ],
    [
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    if (step.getAxis() == Compiler.AXIS_CHILD) {\n        return parentPointer.getChild(step.getName());\n    } else if (step.getAxis() == Compiler.AXIS_SELF) {\n        return parentPointer;\n    } else if (step.getAxis() == Compiler.AXIS_PARENT) {\n        return parentPointer.getParent();\n    } else {\n        throw new RuntimeException(\"Unsupported axis: \" + step.getAxis());\n    }\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    String stepName = step.getName();\n    if (stepName.equals(\"child\")) {\n        return parentPointer.getChild(stepName);\n    } else if (stepName.equals(\"descendant\")) {\n        return parentPointer.getDescendant(stepName);\n    } else {\n        return null;\n    }\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    String stepName = step.getName();\n    if (stepName.equals(\"children\")) {\n        return parentPointer.getChildren();\n    } else if (stepName.equals(\"attributes\")) {\n        return parentPointer.getAttributes();\n    } else {\n        return parentPointer.getProperty(stepName);\n    }\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    if (step.getAxis() == Compiler.AXIS_SELF) {\n        return parentPointer;\n    }\n    return parentPointer.createChildPointer(step.getLocalName());\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    if (step.getAxis() == Compiler.AXIS_CHILD) {\n        return parentPointer.getChild(step.getName());\n    } else if (step.getAxis() == Compiler.AXIS_SELF) {\n        return parentPointer;\n    } else if (step.getAxis() == Compiler.AXIS_PARENT) {\n        return parentPointer.getParent();\n    } else {\n        throw new RuntimeException(\"Invalid axis: \" + step.getAxis());\n    }\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    return new NodePointer(parentPointer, step.getAxis(), step.getName());\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    if (step.getAxis() == Compiler.AXIS_CHILD) {\n        return parentPointer.getChild(step.getName());\n    } else if (step.getAxis() == Compiler.AXIS_SELF) {\n        return parentPointer;\n    } else if (step.getAxis() == Compiler.AXIS_PARENT) {\n        return parentPointer.getParent();\n    } else {\n        throw new UnsupportedOperationException(\"Unsupported axis: \" + step.getAxis());\n    }\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    if (step.getAxis() == Compiler.AXIS_SELF) {\n        return parentPointer;\n    }\n    return new NodePointer(parentPointer, step);\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    return new NodePointer(parentPointer, step.getAxis(), step.getName());\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    if (step.getAxis() == Compiler.AXIS_CHILD) {\n        return parentPointer.getChild(step.getName());\n    } else if (step.getAxis() == Compiler.AXIS_SELF) {\n        return parentPointer;\n    } else if (step.getAxis() == Compiler.AXIS_PARENT) {\n        return parentPointer.getParent();\n    } else {\n        throw new RuntimeException(\"Invalid axis: \" + step.getAxis());\n    }\n}"
    ],
    [
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        return Double.NEGATIVE_INFINITY;\n    } else if (getTree(false).getCut().getHyperplane().isWhole()) {\n        return Double.NEGITIVE_INFINITY;\n    } else {\n        return ((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation().getX();\n    }\n}",
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        return Double.NEGATIVE_INFINITY;\n    } else {\n        return ((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation().getCoordinate();\n    }\n}",
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        return Double.NEGATIVE_INFINITY;\n    } else if (getTree(false).getCut().getHyperplane().isWholeHyperplane()) {\n        return Double.NEGITIVE_INFINITY;\n    } else {\n        return ((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation().getX();\n    }\n}",
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    return ((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation().getCoordinate();\n}",
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        return Double.NEGATIVE_INFINITY;\n    } else if (getTree(false).getCut().getHyperplane().getNormal().isNegative()) {\n        return ((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation().getCoordinate();\n    } else {\n        return Double.POSITIVE_INFINITY;\n    }\n}",
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    return ((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation().getX();\n}",
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    return ((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation().getX();\n}",
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        return Double.NEGATIVE_INFINITY;\n    } else {\n        return ((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation().getCoordinate();\n    }\n}",
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        return Double.NEGATIVE_INFINITY;\n    } else {\n        return ((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation().getX();\n    }\n}",
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    return ((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation().getCoordinate();\n}"
    ],
    [
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    Strategy strategy = null;\n    ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    if(cache.containsKey(definingCalendar.getLocale())) {\n        strategy = cache.get(definingCalendar.getLocale());\n    } else {\n        strategy = new TextStrategy(field, definingCalendar);\n        cache.put(definingCalendar.getLocale(), strategy);\n    }\n    return strategy;\n}\n\nvoid setCalendar(final FastDateParser parser, final Calendar cal, final String value) {\n    String[] parts = value.split(\"\\\\|\");\n    for (String part : parts) {\n        Strategy strategy = parser.getStrategy(part);\n        if (strategy.addRegex(parser, new StringBuilder())) {\n            cal.set(strategy.getField(), Integer.parseInt(part));\n        }\n    }\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    Strategy strategy = getCache(field).get(definingCalendar.getLocale());\n    if(strategy == null) {\n        strategy = new TextStrategy(field, definingCalendar);\n        getCache(field).put(definingCalendar.getLocale(), strategy);\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    Strategy strategy = getCache(field).get(definingCalendar.getLocale());\n    if(strategy==null) {\n        strategy = new TextStrategy(field, definingCalendar);\n        getCache(field).put(definingCalendar.getLocale(), strategy);\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    Strategy strategy = getCache(field).get(definingCalendar.getLocale());\n    if (strategy == null) {\n        strategy = new TextStrategy(field, definingCalendar);\n        getCache(field).put(definingCalendar.getLocale(), strategy);\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    Strategy strategy = null;\n    switch(field) {\n        case Calendar.DAY_OF_WEEK:\n            strategy = new DayOfWeekStrategy(definingCalendar);\n            break;\n        case Calendar.ERA:\n            strategy = new EraStrategy(definingCalendar);\n            break;\n        case Calendar.AM_PM:\n            strategy = new AmPmStrategy(definingCalendar);\n            break;\n        case Calendar.ZONE_OFFSET:\n            strategy = new ZoneOffsetStrategy(definingCalendar);\n            break;\n        default:\n            throw new UnsupportedOperationException(\"Unsupported field: \" + field);\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    Strategy strategy = getCache(field).get(definingCalendar.getLocale());\n    if (strategy == null) {\n        strategy = new TextStrategy(field, definingCalendar);\n        getCache(field).put(definingCalendar.getLocale(), strategy);\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar);\n}"
    ],
    [
      "private boolean setNextObject()  {\n        while (iterator.hasNext()) {\n            E obj = iterator.next();\n            if (predicate.test(obj)) {\n                nextObject = obj;\n                nextObjectSet = true;\n                return true;\n            }\n        }\n        return false;\n    }",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        E obj = iterator.next();\n        if (predicate.test(obj)) {\n            nextObject = obj;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    if (!iterator.hasNext()) {\n        return false;\n    }\n    nextObject = iterator.next();\n    if (!predicate.test(nextObject)) {\n        return setNextObject();\n    }\n    nextObjectSet = true;\n    return true;\n}",
      "private boolean setNextObject()  {\n    if (iterator.hasNext()) {\n        nextObject = iterator.next();\n        if (predicate.test(nextObject)) {\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        E obj = iterator.next();\n        if (predicate.test(obj)) {\n            nextObject = obj;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n        if (!iterator.hasNext()) {\n            return false;\n        }\n        nextObject = iterator.next();\n        if (!predicate.test(nextObject)) {\n            return setNextObject();\n        }\n        nextObjectSet = true;\n        return true;\n    }",
      "private boolean setNextObject()  {\n        while (iterator.hasNext()) {\n            E obj = iterator.next();\n            if (predicate.test(obj)) {\n                nextObject = obj;\n                nextObjectSet = true;\n                return true;\n            }\n        }\n        return false;\n    }",
      "private boolean setNextObject()  {\n    if (iterator.hasNext()) {\n        nextObject = iterator.next();\n        if (predicate.test(nextObject)) {\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        E obj = iterator.next();\n        if (predicate.test(obj)) {\n            nextObject = obj;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n        if (!iterator.hasNext()) {\n            return false;\n        }\n        nextObject = iterator.next();\n        if (!predicate.test(nextObject)) {\n            return setNextObject();\n        }\n        nextObjectSet = true;\n        return true;\n    }"
    ],
    [
      "private double[] repair(final double[] x)  {\n            double[] lB = CMAESOptimizer.this.getLowerBound();\n            double[] uB = CMAESOptimizer.this.getUpperBound();\n            double[] repaired = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                if (x[i] < lB[i]) {\n                    repaired[i] = lB[i];\n                } else if (x[i] > uB[i]) {\n                    repaired[i] = uB[i];\n                } else {\n                    repaired[i] = x[i];\n                }\n            }\n            return repaired;\n        }",
      "private double[] repair(final double[] x)  {\n            double[] lB = CMAESOptimizer.this.getLowerBound();\n            double[] uB = CMAESOptimizer.this.getUpperBound();\n            double[] repaired = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                if (x[i] < lB[i]) {\n                    repaired[i] = lB[i];\n                } else if (x[i] > uB[i]) {\n                    repaired[i] = uB[i];\n                } else {\n                    repaired[i] = x[i];\n                }\n            }\n            return repaired;\n        }",
      "private double[] repair(final double[] x)  {\n            final double[] lB = CMAESOptimizer.this.getLowerBound();\n            final double[] uB = CMAESOptimizer.this.getUpperBound();\n            double[] repaired = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                if (x[i] < lB[i]) {\n                    repaired[i] = lB[i];\n                } else if (x[i] > uB[i]) {\n                    repaired[i] = uB[i];\n                } else {\n                    repaired[i] = x[i];\n                }\n            }\n            return repaired;\n        }",
      "private double[] repair(final double[] x)  {\n            double[] lB = CMAESOptimizer.this.getLowerBound();\n            double[] uB = CMAESOptimizer.this.getUpperBound();\n            double[] repaired = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                if (x[i] < lB[i]) {\n                    repaired[i] = lB[i];\n                } else if (x[i] > uB[i]) {\n                    repaired[i] = uB[i];\n                } else {\n                    repaired[i] = x[i];\n                }\n            }\n            return repaired;\n        }",
      "private double[] repair(final double[] x)  {\n            final double[] lB = CMAESOptimizer.this.getLowerBound();\n            final double[] uB = CMAESOptimizer.this.getUpperBound();\n            double[] repaired = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                if (x[i] < lB[i]) {\n                    repaired[i] = lB[i];\n                } else if (x[i] > uB[i]) {\n                    repaired[i] = uB[i];\n                } else {\n                    repaired[i] = x[i];\n                }\n            }\n            return repaired;\n        }",
      "private double[] repair(final double[] x)  {\n            final double[] lB = CMAESOptimizer.this.getLowerBound();\n            final double[] uB = CMAESOptimizer.this.getUpperBound();\n            double[] repaired = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                if (x[i] < lB[i]) {\n                    repaired[i] = lB[i];\n                } else if (x[i] > uB[i]) {\n                    repaired[i] = uB[i];\n                } else {\n                    repaired[i] = x[i];\n                }\n            }\n            return repaired;\n        }",
      "private double[] repair(final double[] x)  {\n            final double[] lB = CMAESOptimizer.this.getLowerBound();\n            final double[] uB = CMAESOptimizer.this.getUpperBound();\n            double[] repaired = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                if (x[i] < lB[i]) {\n                    repaired[i] = lB[i];\n                } else if (x[i] > uB[i]) {\n                    repaired[i] = uB[i];\n                } else {\n                    repaired[i] = x[i];\n                }\n            }\n            return repaired;\n        }",
      "private double[] repair(final double[] x)  {\n            double[] lB = CMAESOptimizer.this.getLowerBound();\n            double[] uB = CMAESOptimizer.this.getUpperBound();\n            double[] repaired = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                if (x[i] < lB[i]) {\n                    repaired[i] = lB[i];\n                } else if (x[i] > uB[i]) {\n                    repaired[i] = uB[i];\n                } else {\n                    repaired[i] = x[i];\n                }\n            }\n            return repaired;\n        }",
      "private double[] repair(final double[] x)  {\n            double[] repaired = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                if (x[i] < CMAESOptimizer.this.getLowerBound()[i]) {\n                    repaired[i] = CMAESOptimizer.this.getLowerBound()[i];\n                } else if (x[i] > CMAESOptimizer.this.getUpperBound()[i]) {\n                    repaired[i] = CMAESOptimizer.this.getUpperBound()[i];\n                } else {\n                    repaired[i] = x[i];\n                }\n            }\n            return repaired;\n        }",
      "private double[] repair(final double[] x)  {\n            final double[] lB = CMAESOptimizer.this.getLowerBound();\n            final double[] uB = CMAESOptimizer.this.getUpperBound();\n            double[] repaired = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                if (x[i] < lB[i]) {\n                    repaired[i] = lB[i];\n                } else if (x[i] > uB[i]) {\n                    repaired[i] = uB[i];\n                } else {\n                    repaired[i] = x[i];\n                }\n            }\n            return repaired;\n        }"
    ],
    [
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final int n = matrix.getRowDimension();\n    final double[] realEigenvalues = new double[n];\n    final double[][] z = new double[n][n];\n    double maxAbsoluteValue = 0.0;\n    for (int i = 0; i < n; i++) {\n        realEigenvalues[i] = matrix.getEntry(i, i);\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            z[i][j] = matrix.getEntry(i, j);\n        }\n    }\n    int m = n;\n    int j = 0;\n    while (m > j) {\n        double q = realEigenvalues[m - 1] - realEigenvalues[j];\n        double t = q;\n        double e = 0.0;\n        double s = 1.0;\n        double c = 1.0;\n        int i;\n        for (i = m - 1; i >= j; i--) {\n            double p = s * e;\n            double h = c * e;\n            if (FastMath.abs(p) >= FastMath.abs(q)) {\n                c = q / p;\n                t = FastMath.sqrt(c * c + 1.0);\n                e[i + 1] = p * t;\n                s = 1.0 / t;\n                c = c * s;\n            } else {\n                s = p / q;\n                t = FastMath.sqrt(s * s + 1.0);\n                e[i + 1] = q * t;\n                c = 1.0 / t;\n                s = s * c;\n            }\n            if (e[i + 1] == 0.0) {\n                realEigenvalues[i + 1] -= s;\n                e[m] = 0.0;\n                break;\n            }\n            q = realEigenvalues[i + 1] - s;\n            t = (realEigenvalues[i] - q) * s + 2.0 * c * h;\n            s = s * t;\n            realEigenvalues[i + 1] = q + s;\n            q = c * t - h;\n            for (int ia = 0; ia < n; ia++) {\n                p = z[ia][i + 1];\n}\n}\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    int n = matrix.getRowDimension();\n    double[][] z = new double[n][n];\n    double[] realEigenvalues = new double[n];\n    double[] e = new double[n];\n    double maxAbsoluteValue = 0.0;\n    ArrayRealVector[] eigenvectors = new ArrayRealVector[n];\n    double[] tmp = new double[n];\n\n    // Initialize z and e\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            z[i][j] = matrix.getEntry(i, j);\n        }\n        e[i] = matrix.getEntry(i, i);\n    }\n\n    // Calculate the Schur decomposition\n    int m = n;\n    while (m > 0) {\n        int j = 0;\n        double t = 0.0;\n        for (int k = 0; k < m; k++) {\n            if (e[k] > t) {\n                t = e[k];\n                j = k;\n            }\n        }\n        double q = realEigenvalues[m] - realEigenvalues[j] + e[j] / (q + t);\n        double u = 0.0;\n        double s = 1.0;\n        double c = 1.0;\n        int i;\n        for (i = m - 1; i >= j; i--) {\n            double p = s * e[i];\n            double h = c * e[i];\n            if (FastMath.abs(p) >= FastMath.abs(q)) {\n                c = q / p;\n                t = FastMath.sqrt(c * c + 1.0);\n                e[i + 1] = p * t;\n                s = 1.0 / t;\n                c = c * s;\n            } else {\n                s = p / q;\n                t = FastMath.sqrt(s * s + 1.0);\n                e[i + 1] = q * t;\n                c = 1.0 / t;\n                s = s * c;\n            }\n            if (e[i + 1] == 0.0) {\n                realEigenvalues[i + 1] -= u;\n                e[m] = 0.0;\n                break;\n            }\n            q = realEigenvalues[i + 1] - u;\n}\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    int n = matrix.getRowDimension();\n    double[][] realEigenvalues = new double[n];\n    double[][] e = new double[n];\n    double[][] z = new double[n][n];\n    double maxAbsoluteValue = 0.0;\n    for (int i = 0; i < n; i++) {\n        realEigenvalues[i] = matrix.getEntry(i, i);\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            z[i][j] = matrix.getEntry(i, j);\n        }\n    }\n    int m = n - 1;\n    while (m > 0) {\n        int j = 0;\n        double q = realEigenvalues[m] - realEigenvalues[j] + e[j] / (q + e[m]);\n        double u = 0.0;\n        double s = 1.0;\n        double c = 1.0;\n        int i;\n        for (i = m - 1; i >= j; i--) {\n            double p = s * e[i];\n            double h = c * e[i];\n            if (FastMath.abs(p) >= FastMath.abs(q)) {\n                c = q / p;\n                double t = FastMath.sqrt(c * c + 1.0);\n                e[i + 1] = p * t;\n                s = 1.0 / t;\n                c = c * s;\n            } else {\n                s = p / q;\n                double t = FastMath.sqrt(s * s + 1.0);\n                e[i + 1] = q * t;\n                c = 1.0 / t;\n                s = s * c;\n            }\n            if (e[i + 1] == 0.0) {\n                realEigenvalues[i + 1] -= u;\n                e[m] = 0.0;\n                break;\n            }\n            q = realEigenvalues[i + 1] - u;\n            double t = (realEigenvalues[i] - q) * s + 2.0 * c * h;\n            u = s * t;\n            realEigenvalues[i + 1] = q + u;\n            q = c * t - h;\n            for (int ia = 0; ia < n; ia++) {\n}\n}\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    int n = matrix.getRowDimension();\n    double[][] z = new double[n][n];\n    double[] realEigenvalues = new double[n];\n    double[] e = new double[n];\n    double maxAbsoluteValue = 0.0;\n    SchurTransformer schurTransformer = new SchurTransformer();\n\n    // Initialize the matrix z and the array e\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            z[i][j] = matrix.getEntry(i, j);\n        }\n        e[i] = 0.0;\n    }\n\n    int m = 0;\n    while (m < n) {\n        // Find the submatrix that is not diagonal\n        int j = m;\n        while (j < n && e[j] == 0.0) {\n            j++;\n        }\n        if (j == n) {\n            break;\n        }\n\n        // Find the real eigenvalue of the submatrix\n        double q = z[m][m] - z[j][j];\n        double t = e[j] / (q + e[j]);\n        realEigenvalues[m] = z[m][m] + t * (z[m][j] - z[j][m]);\n        realEigenvalues[j] = z[j][j] + t * (z[j][m] - z[m][j]);\n\n        // Perform the QR algorithm\n        double u = 0.0;\n        double s = 1.0;\n        double c = 1.0;\n        int i;\n        for (i = m - 1; i >= j; i--) {\n            double p = s * e[i];\n            double h = c * e[i];\n            if (FastMath.abs(p) >= FastMath.abs(q)) {\n                c = q / p;\n                t = FastMath.sqrt(c * c + 1.0);\n                e[i + 1] = p * t;\n                s = 1.0 / t;\n                c = c * s;\n            } else {\n                s = p / q;\n                t = FastMath.sqrt(s * s + 1.0);\n                e[i + 1] = q * t;\n                c = 1.0 / t;\n                s = s * c;\n            }\n            if (e[i + 1] == 0.0) {\n}\n}\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    int n = matrix.getRowDimension();\n    double[][] z = new double[n][n];\n    double[] realEigenvalues = new double[n];\n    double[] e = new double[n];\n    double maxAbsoluteValue = 0.0;\n\n    for (int i = 0; i < n; i++) {\n        z[i][i] = 1.0;\n        e[i] = matrix.getEntry(i, i);\n    }\n\n    int m = n;\n    while (m > 0) {\n        int j = 0;\n        double q = 0.0;\n        for (int k = 0; k < m; k++) {\n            if (e[k] > q) {\n                q = e[k];\n                j = k;\n            }\n        }\n        double t = q;\n        for (int k = 0; k < m; k++) {\n            e[k] = e[k] - t;\n        }\n        for (int k = 0; k < n; k++) {\n            z[k][j] = z[k][j] / t;\n        }\n        double realEigenvalues[m] = realEigenvalues[j];\n        for (int k = 0; k < m; k++) {\n            q = 0.0;\n            for (int l = 0; l < m; l++) {\n                q += z[j][l] * z[j][l];\n            }\n            q = FastMath.sqrt(q);\n            for (int l = 0; l < m; l++) {\n                z[j][l] = z[j][l] / q;\n            }\n            for (int l = 0; l < m; l++) {\n                e[l] = e[l] - z[j][l] * z[j][l];\n            }\n            for (int l = 0; l < m; l++) {\n                q = 0.0;\n                for (int i = 0; i < m; i++) {\n                    q += z[j][i] * z[j][i];\n                }\n                q = FastMath.sqrt(q);\n                for (int i = 0; i < m; i++) {\n                    z[j][i] = z[j][i] / q;\n                }\n                for (int i = 0; i < m; i++) {\n}\n}\n}\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    int n = matrix.getRowDimension();\n    double[][] realEigenvalues = new double[n];\n    double[][] e = new double[n];\n    double[][] z = new double[n][n];\n    double maxAbsoluteValue = 0;\n    for (int i = 0; i < n; i++) {\n        e[i] = new double[n];\n        for (int j = 0; j < n; j++) {\n            e[i][j] = matrix.getEntry(i, j);\n        }\n    }\n    int m = n;\n    int j = 0;\n    while (m > j) {\n        double q = 0.0;\n        for (int i = j; i < n; i++) {\n            q += e[j][i] * e[j][i];\n        }\n        q = FastMath.sqrt(q);\n        for (int i = j; i < n; i++) {\n            e[i][j] /= q;\n        }\n        for (int k = j + 1; k < n; k++) {\n            double p = 0.0;\n            for (int i = j; i < n; i++) {\n                p += e[i][j] * e[i][k];\n            }\n            for (int i = j; i < n; i++) {\n                e[i][k] -= p * e[i][j];\n            }\n        }\n        for (int i = j; i < n; i++) {\n            realEigenvalues[i] = e[i][i];\n        }\n        for (int i = j + 1; i < n; i++) {\n            e[i][j] = 0.0;\n        }\n        for (int i = j; i < n; i++) {\n            e[i][i] = realEigenvalues[i];\n        }\n        double t = 0.0;\n        for (int i = j; i < n; i++) {\n            t += e[i][i] * e[i][i];\n        }\n        t = FastMath.sqrt(t);\n        for (int i = j; i < n; i++) {\n            e[i][i] /= t;\n        }\n        for (int i = j + 1; i < n; i++) {\n            e[i][j] = 0.0;\n        }\n        for (int i = j; i < n; i++) {\n}\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    int n = matrix.getRowDimension();\n    double[][] realEigenvalues = new double[n];\n    double[][] e = new double[n];\n    double[][] z = new double[n][n];\n    double maxAbsoluteValue = 0.0;\n    for (int i = 0; i < n; i++) {\n        realEigenvalues[i] = matrix.getEntry(i, i);\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i != j) {\n                e[i] += matrix.getEntry(i, j) * matrix.getEntry(j, i);\n                z[i][j] = matrix.getEntry(i, j);\n            }\n        }\n    }\n    int m = n - 1;\n    while (m >= 0) {\n        int j = m;\n        double q = realEigenvalues[m] - realEigenvalues[j] + e[j] / (q + e[m]);\n        double u = 0.0;\n        double s = 1.0;\n        double c = 1.0;\n        int i;\n        for (i = m - 1; i >= j; i--) {\n            double p = s * e[i];\n            double h = c * e[i];\n            if (FastMath.abs(p) >= FastMath.abs(q)) {\n                c = q / p;\n                double t = FastMath.sqrt(c * c + 1.0);\n                e[i + 1] = p * t;\n                s = 1.0 / t;\n                c = c * s;\n            } else {\n                s = p / q;\n                t = FastMath.sqrt(s * s + 1.0);\n                e[i + 1] = q * t;\n                c = 1.0 / t;\n                s = s * c;\n            }\n            if (e[i + 1] == 0.0) {\n                realEigenvalues[i + 1] -= u;\n                e[m] = 0.0;\n                break;\n            }\n            q = realEigenvalues[i + 1] - u;\n            double t = (realEigenvalues[i] - q) * s + 2.0 * c * h;\n            u = s * t;\n            realEigenvalues[i + 1] = q + u;\n}\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    int n = matrix.getRowDimension();\n    double[][] z = new double[n][n];\n    double[] realEigenvalues = new double[n];\n    double[] e = new double[n];\n    double maxAbsoluteValue = 0.0;\n    ArrayRealVector[] eigenvectors = new ArrayRealVector[n];\n    double[][] Q = matrix.getData();\n\n    for (int i = 0; i < n; i++) {\n        realEigenvalues[i] = Q[i][i];\n        for (int j = 0; j < n; j++) {\n            z[i][j] = Q[i][j];\n        }\n    }\n\n    int m = n;\n    while (m > 0) {\n        int j = 0;\n        for (int k = 0; k < m; k++) {\n            if (FastMath.abs(realEigenvalues[k]) > FastMath.abs(realEigenvalues[j])) {\n                j = k;\n            }\n        }\n        double q = realEigenvalues[m - 1] - realEigenvalues[j] + e[m - 1] / (q + e[m - 1]);\n        double u = 0.0;\n        double s = 1.0;\n        double c = 1.0;\n        int i;\n        for (i = m - 1; i >= j; i--) {\n            double p = s * e[i];\n            double h = c * e[i];\n            if (FastMath.abs(p) >= FastMath.abs(q)) {\n                c = q / p;\n                double t = FastMath.sqrt(c * c + 1.0);\n                e[i + 1] = p * t;\n                s = 1.0 / t;\n                c = c * s;\n            } else {\n                s = p / q;\n                t = FastMath.sqrt(s * s + 1.0);\n                e[i + 1] = q * t;\n                c = 1.0 / t;\n                s = s * c;\n            }\n            if (e[i + 1] == 0.0) {\n                realEigenvalues[i + 1] -= u;\n                e[m] = 0.0;\n                break;\n            }\n            q = realEigenvalues[i + 1] - u;\n            double t = (realEigenvalues[i] - q) * s + 2.0 * c * h;\n}\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    int n = matrix.getRowDimension();\n    double[][] z = new double[n][n];\n    double[] realEigenvalues = new double[n];\n    double[] e = new double[n];\n    double maxAbsoluteValue = 0.0;\n    ArrayRealVector[] eigenvectors = new ArrayRealVector[n];\n    double[][] work = new double[n][n];\n\n    for (int i = 0; i < n; i++) {\n        z[i][i] = 1.0;\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            double q = matrix.getEntry(i, j);\n            double r = matrix.getEntry(j, j);\n            if (i == j) {\n                realEigenvalues[i] = r;\n            } else {\n                realEigenvalues[i] = realEigenvalues[j] - q / (r - realEigenvalues[j]);\n            }\n            e[j] = q;\n        }\n    }\n\n    int m = n - 1;\n    while (m > 0) {\n        int j = m;\n        double t = 0.0;\n        double s = 1.0;\n        double c = 1.0;\n        int i;\n        for (i = m - 1; i >= 0; i--) {\n            double p = s * e[i];\n            double h = c * e[i];\n            if (FastMath.abs(p) >= FastMath.abs(q)) {\n                c = q / p;\n                t = FastMath.sqrt(c * c + 1.0);\n                e[i + 1] = p * t;\n                s = 1.0 / t;\n                c = c * s;\n            } else {\n                s = p / q;\n                t = FastMath.sqrt(s * s + 1.0);\n                e[i + 1] = q * t;\n                c = 1.0 / t;\n                s = s * c;\n            }\n            if (e[i + 1] == 0.0) {\n                realEigenvalues[i + 1] -= t;\n                e[m] = 0.0;\n                break;\n            }\n            q = realEigenvalues[i + 1] - t;\n            t = (realEigenvalues[i] - q) * s + 2.0 * c * h;\n}\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    int n = matrix.getRowDimension();\n    double[][] realEigenvalues = new double[n];\n    double[][] e = new double[n];\n    double[][] z = new double[n][n];\n    double maxAbsoluteValue = 0;\n    ArrayRealVector[] eigenvectors = null;\n\n    // Calculate the Schur decomposition\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            if (i == j) {\n                realEigenvalues[i] = matrix.getEntry(i, i);\n            } else {\n                realEigenvalues[i] = matrix.getEntry(i, j);\n                realEigenvalues[j] = matrix.getEntry(j, i);\n            }\n            e[i] = 0;\n            z[i][j] = matrix.getEntry(i, j);\n            z[j][i] = matrix.getEntry(j, i);\n        }\n    }\n\n    int m = n;\n    while (m > 0) {\n        int j = 0;\n        for (int k = 0; k < m; k++) {\n            if (FastMath.abs(realEigenvalues[k]) > FastMath.abs(realEigenvalues[j])) {\n                j = k;\n            }\n        }\n        double q = realEigenvalues[m] - realEigenvalues[j] + e[j] / (q + e[m]);\n        double u = 0;\n        double s = 1;\n        double c = 1;\n        int i;\n        for (i = m - 1; i >= j; i--) {\n            double p = s * e[i];\n            double h = c * e[i];\n            if (FastMath.abs(p) >= FastMath.abs(q)) {\n                c = q / p;\n                double t = FastMath.sqrt(c * c + 1);\n                e[i + 1] = p * t;\n                s = 1 / t;\n                c = c * s;\n            } else {\n                s = p / q;\n                t = FastMath.sqrt(s * s + 1);\n                e[i + 1] = q * t;\n                c = 1 / t;\n                s = s * c;\n            }\n            if (e[i + 1] == 0) {\n                realEigenvalues[i + 1] -= u;\n                e[m] = 0;\n                break;\n            }\n}\n}\n}"
    ],
    [
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        for (int j = Long.SIZE - 1; j >= 0; j--) {\n            if (((values[i] >> j) & 1) == 1) {\n                result.add(Enum.valueOf(enumClass, i * Long.SIZE + j));\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    Validate.notNull(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (long value : values) {\n        for (int i = Long.SIZE - 1; i >= 0; i--) {\n            if (((value >> i) & 1) == 1) {\n                result.add(Enum.valueOf(enumClass, result.size()));\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    Validate.notNull(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (long value : values) {\n        for (int i = Long.SIZE - 1; i >= 0; i--) {\n            if (((value >> i) & 1) == 1) {\n                result.add(enumClass.getEnumConstants()[(int) (value & ((1L << i) - 1))]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    Validate.notNull(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        for (int j = 0; j < Long.SIZE; j++) {\n            if (((values[i] >> j) & 1) == 1) {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        for (int j = 0; j < Long.SIZE; j++) {\n            if (((values[i] >> j) & 1) == 1) {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        long value = values[i];\n        for (int j = Long.SIZE - 1; j >= 0; j--) {\n            if (((value >> j) & 1) == 1) {\n                result.add(Enum.valueOf(enumClass, i * Long.SIZE + j));\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        long value = values[i];\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((value & (1L << j)) != 0) {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    Validate.notNull(enumClass);\n    Validate.noNullElements(values);\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (long value : values) {\n        for (int i = 0; i < Long.SIZE; i++) {\n            if (((value >> i) & 1) == 1) {\n                result.add(enumClass.getEnumConstants()[(int) (value & ((1L << i) - 1))]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    Validate.notNull(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        long value = values[i];\n        for (int j = Long.SIZE - 1; j >= 0; j--) {\n            if ((value & (1 << j)) != 0) {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    Validate.notNull(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        long value = values[i];\n        for (int j = Long.SIZE - 1; j >= 0; j--) {\n            if (((value >> j) & 1) == 1) {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}"
    ],
    [
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    long instantLocal = oldInstant + getOffset(oldInstant);\n    if ((instantLocal ^ oldInstant) < 0 && (instantLocal ^ getOffset(oldInstant)) >= 0) {\n        throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n    }\n    long instantUTC = instantLocal - getOffset(instantLocal);\n    if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ getOffset(instantLocal)) < 0) {\n        throw new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n    }\n    if (newZone != null) {\n        int offset = newZone.getOffset(instantLocal);\n        instantLocal = instantLocal - offset;\n        instantUTC = instantLocal - getOffset(instantLocal);\n    }\n    return instantUTC;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = getDefaultZone();\n    }\n    int offsetOriginal = getOffset(oldInstant);\n    long instantLocal = oldInstant + offsetOriginal;\n    int offsetLocalFromOriginal = getOffset(instantLocal);\n    if (offsetLocalFromOriginal == offsetOriginal) {\n        return oldInstant;\n    }\n    return convertLocalToUTC(instantLocal, true, oldInstant);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = getDefaultZone();\n    }\n    long instantLocal = oldInstant + getOffset(oldInstant);\n    int offsetLocalFromNew = getOffset(instantLocal);\n    if (offsetLocalFromNew == getOffset(oldInstant)) {\n        return oldInstant;\n    }\n    return oldInstant - offsetLocalFromNew + getOffset(oldInstant);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = this;\n    }\n    int offsetOriginal = getOffset(oldInstant);\n    long instantLocal = oldInstant + offsetOriginal;\n    int offsetLocalFromOriginal = getOffset(instantLocal);\n    if (offsetLocalFromOriginal == offsetOriginal) {\n        return oldInstant;\n    }\n    long instantUTC = convertLocalToUTC(instantLocal, true, oldInstant);\n    return instantUTC;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = getDefaultZone();\n    }\n    int offset = getOffset(oldInstant);\n    long instantLocal = oldInstant + offset;\n    int offsetNew = newZone.getOffset(instantLocal);\n    if (offset != offsetNew) {\n        return convertLocalToUTC(instantLocal, true, oldInstant);\n    } else {\n        return oldInstant;\n    }\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = this;\n    }\n    long instantLocal = oldInstant + getOffset(oldInstant);\n    int offsetLocalFromNew = getOffset(instantLocal);\n    if (offsetLocalFromNew == getOffset(oldInstant)) {\n        return oldInstant;\n    }\n    return convertLocalToUTC(instantLocal, true, oldInstant);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = this;\n    }\n    int offset = getOffset(oldInstant);\n    long instantLocal = oldInstant + offset;\n    int offsetNew = newZone.getOffset(instantLocal);\n    if (offset != offsetNew) {\n        return convertLocalToUTC(instantLocal, true, oldInstant);\n    } else {\n        return instantLocal;\n    }\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = this;\n    }\n    int offset = getOffset(oldInstant);\n    long instantLocal = oldInstant + offset;\n    long instantUTC = instantLocal - offset;\n    long instantNewLocal = newZone.getOffset(instantUTC) + instantUTC;\n    return instantNewLocal;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = getDefaultZone();\n    }\n    int offset = getOffset(oldInstant);\n    long instantLocal = oldInstant + offset;\n    int offsetNew = newZone.getOffset(instantLocal);\n    long instantUTC = instantLocal - offsetNew;\n    return instantUTC;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = this;\n    }\n    int offset = getOffset(oldInstant);\n    long instantLocal = oldInstant + offset;\n    long instantUTC = instantLocal - offset;\n    int offsetNew = newZone.getOffset(instantUTC);\n    long instantLocalNew = instantUTC + offsetNew;\n    return instantLocalNew;\n}"
    ],
    [
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance();\n    calendar.setTime(date);\n    int value = 0;\n    int years = calendar.get(Calendar.YEAR);\n    int months = calendar.get(Calendar.MONTH);\n    int days = calendar.get(Calendar.DAY_OF_MONTH);\n    int hours = calendar.get(Calendar.HOUR_OF_DAY);\n    int minutes = calendar.get(Calendar.MINUTE);\n    int seconds = calendar.get(Calendar.SECOND);\n\n    if (unit.equals(DateTickUnitType.DAY)) {\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, months, value + 1, hours, minutes, seconds);\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.HOUR)) {\n        calendar.clear(Calendar.MINUTE);\n        calendar.clear(Calendar.SECOND);\n        calendar.set(years, months, days, value + 1, 0, 0);\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.MINUTE)) {\n        calendar.clear(Calendar.SECOND);\n        calendar.set(years, months, days, hours, value + 1, 0);\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.SECOND)) {\n        calendar.set(years, months, days, hours, minutes, value + 1);\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.DAY_OF_WEEK)) {\n        int dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK);\n        if (dayOfWeek == Calendar.SUNDAY) {\n            value = Calendar.MONDAY;\n        }\n        else {\n            value = dayOfWeek + 1;\n        }\n        calendar.set(Calendar.DAY_OF_WEEK, value);\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.DAY_OF_MONTH)) {\n        int dayOfMonth = calendar.get(Calendar.DAY_OF_MONTH);\n        if (dayOfMonth == calendar.getActualMaximum(Calendar.DAY_OF_MONTH)) {\n            value = 1;\n        }\n        else {\n            value = dayOfMonth + 1;\n        }\n        calendar.set(Calendar.DAY_OF_MONTH, value);\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.MONTH)) {\n        int month = calendar.get(Calendar.MONTH);\n        int maxMonth = calendar.getActualMaximum(Calendar.MONTH);\n        if (month == maxMonth) {\n            value = 1;\n        }\n        else {\n            value = month + 1;\n        }\n        calendar.set(Calendar.MONTH, value);\n        return calendar.getTime();\n    }\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone);\n    calendar.setTime(date);\n    int years = calendar.get(Calendar.YEAR);\n    int months = calendar.get(Calendar.MONTH);\n    int days = calendar.get(Calendar.DAY_OF_MONTH);\n    int hours = calendar.get(Calendar.HOUR_OF_DAY);\n    int minutes = calendar.get(Calendar.MINUTE);\n    int seconds = calendar.get(Calendar.SECOND);\n\n    if (unit.equals(DateTickUnitType.DAY)) {\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        if (calendar.getTime().getTime() >= date.getTime()) {\n            calendar.add(Calendar.DAY_OF_YEAR, -1);\n        }\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.HOUR)) {\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        if (calendar.getTime().getTime() >= date.getTime()) {\n            calendar.add(Calendar.HOUR_OF_DAY, -1);\n        }\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.MINUTE)) {\n        calendar.set(Calendar.SECOND, 0);\n        if (calendar.getTime().getTime() >= date.getTime()) {\n            calendar.add(Calendar.MINUTE, -1);\n        }\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.SECOND)) {\n        if (calendar.getTime().getTime() >= date.getTime()) {\n            calendar.add(Calendar.SECOND, -1);\n        }\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.MONTH)) {\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        if (calendar.getTime().getTime() >= date.getTime()) {\n            calendar.add(Calendar.MONTH, -1);\n        }\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.YEAR)) {\n        calendar.set(Calendar.MONTH, 0);\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        if (calendar.getTime().getTime() >= date.getTime()) {\n            calendar.add(Calendar.YEAR, -1);\n        }\n        return calendar.getTime();\n    }\n    else {\n        return null;\n    }\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone);\n    calendar.setTime(date);\n    int years = calendar.get(Calendar.YEAR);\n    int months = calendar.get(Calendar.MONTH);\n    int days = calendar.get(Calendar.DAY_OF_MONTH);\n    int hours = calendar.get(Calendar.HOUR_OF_DAY);\n    int minutes = calendar.get(Calendar.MINUTE);\n    int seconds = calendar.get(Calendar.SECOND);\n\n    if (unit.equals(DateTickUnitType.DAY)) {\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        if (calendar.getTime().getTime() >= date.getTime()) {\n            calendar.add(Calendar.DAY_OF_MONTH, -1);\n        }\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.HOUR)) {\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        if (calendar.getTime().getTime() >= date.getTime()) {\n            calendar.add(Calendar.HOUR_OF_DAY, -1);\n        }\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.MINUTE)) {\n        calendar.set(Calendar.SECOND, 0);\n        if (calendar.getTime().getTime() >= date.getTime()) {\n            calendar.add(Calendar.MINUTE, -1);\n        }\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.SECOND)) {\n        if (calendar.getTime().getTime() >= date.getTime()) {\n            calendar.add(Calendar.SECOND, -1);\n        }\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.MONTH)) {\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        Month month = new Month(calendar.getTime(), this.timeZone, this.locale);\n        Date standardDate = calculateDateForPosition(month, this.tickMarkPosition);\n        long millis = standardDate.getTime();\n        if (millis >= date.getTime()) {\n            month = month.previous();\n            month.peg(Calendar.getInstance(this.timeZone));\n            standardDate = calculateDateForPosition(month, this.tickMarkPosition);\n        }\n        return standardDate;\n    }\n    else if (unit.equals(DateTickUnitType.YEAR)) {\n        if (this.tickMarkPosition == DateTickMarkPosition.START) {\n            calendar.set(Calendar.MONTH, 0);\n}\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance();\n    calendar.setTime(date);\n    int value = 0;\n    int years = calendar.get(Calendar.YEAR);\n    int months = calendar.get(Calendar.MONTH);\n    int days = calendar.get(Calendar.DAY_OF_MONTH);\n    int hours = calendar.get(Calendar.HOUR_OF_DAY);\n    int minutes = calendar.get(Calendar.MINUTE);\n    int seconds = calendar.get(Calendar.SECOND);\n\n    if (unit.equals(DateTickUnitType.DAY)) {\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, months, value + 1, hours, minutes, seconds);\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.HOUR)) {\n        calendar.clear(Calendar.MINUTE);\n        calendar.clear(Calendar.SECOND);\n        calendar.set(years, months, days, value + 1, 0, 0);\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.MINUTE)) {\n        calendar.clear(Calendar.SECOND);\n        calendar.set(years, months, days, hours, value + 1, 0);\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.SECOND)) {\n        calendar.set(years, months, days, hours, minutes, value + 1);\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.DAY_OF_WEEK)) {\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, months, value + 1, hours, minutes, seconds);\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.DAY_OF_MONTH)) {\n        calendar.clear(Calendar.HOUR_OF_DAY);\n        calendar.clear(Calendar.MINUTE);\n        calendar.clear(Calendar.SECOND);\n        calendar.set(years, months, value + 1, 0, 0, 0);\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.DAY_OF_YEAR)) {\n        calendar.clear(Calendar.HOUR_OF_DAY);\n        calendar.clear(Calendar.MINUTE);\n        calendar.clear(Calendar.SECOND);\n        calendar.set(years, Calendar.JANUARY, value + 1, 0, 0, 0);\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.MONTH)) {\n        calendar.clear(Calendar.DAY_OF_MONTH);\n        calendar.clear(Calendar.HOUR_OF_DAY);\n        calendar.clear(Calendar.MINUTE);\n        calendar.clear(Calendar.SECOND);\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance();\n    calendar.setTime(date);\n    int years = calendar.get(Calendar.YEAR);\n    int months = calendar.get(Calendar.MONTH);\n    int days = calendar.get(Calendar.DAY_OF_MONTH);\n    int hours = calendar.get(Calendar.HOUR_OF_DAY);\n    int minutes = calendar.get(Calendar.MINUTE);\n    int seconds = calendar.get(Calendar.SECOND);\n\n    if (unit.equals(DateTickUnitType.DAY)) {\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        Date d = calendar.getTime();\n        if (d.getTime() >= date.getTime()) {\n            calendar.add(Calendar.DAY_OF_MONTH, -1);\n            d = calendar.getTime();\n        }\n        return d;\n    }\n    else if (unit.equals(DateTickUnitType.HOUR)) {\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        Date d = calendar.getTime();\n        if (d.getTime() >= date.getTime()) {\n            calendar.add(Calendar.HOUR_OF_DAY, -1);\n            d = calendar.getTime();\n        }\n        return d;\n    }\n    else if (unit.equals(DateTickUnitType.MINUTE)) {\n        calendar.set(Calendar.SECOND, 0);\n        Date d = calendar.getTime();\n        if (d.getTime() >= date.getTime()) {\n            calendar.add(Calendar.MINUTE, -1);\n            d = calendar.getTime();\n        }\n        return d;\n    }\n    else if (unit.equals(DateTickUnitType.SECOND)) {\n        Date d = calendar.getTime();\n        if (d.getTime() >= date.getTime()) {\n            calendar.add(Calendar.SECOND, -1);\n            d = calendar.getTime();\n        }\n        return d;\n    }\n    else if (unit.equals(DateTickUnitType.MONTH)) {\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        Date d = calendar.getTime();\n        if (d.getTime() >= date.getTime()) {\n            calendar.add(Calendar.MONTH, -1);\n            d = calendar.getTime();\n        }\n        return d;\n    }\n    else if (unit.equals(DateTickUnitType.YEAR)) {\n        calendar.set(Calendar.MONTH, 0);\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance();\n    calendar.setTime(date);\n    int value = 0;\n    int years = calendar.get(Calendar.YEAR);\n    int months = calendar.get(Calendar.MONTH);\n    int days = calendar.get(Calendar.DAY_OF_MONTH);\n    int hours = calendar.get(Calendar.HOUR_OF_DAY);\n    int minutes = calendar.get(Calendar.MINUTE);\n    int seconds = calendar.get(Calendar.SECOND);\n\n    if (unit.equals(DateTickUnitType.DAY)) {\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, months, value + 1, hours, minutes, seconds);\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.HOUR)) {\n        calendar.clear(Calendar.MINUTE);\n        calendar.clear(Calendar.SECOND);\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, months, days, value + 1, 0, 0);\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.MINUTE)) {\n        calendar.clear(Calendar.SECOND);\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, months, days, hours, value + 1, 0);\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.SECOND)) {\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, months, days, hours, minutes, value + 1);\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.DAY_OF_WEEK)) {\n        calendar.add(Calendar.DAY_OF_WEEK, 1);\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.DAY_OF_MONTH)) {\n        calendar.add(Calendar.DAY_OF_MONTH, 1);\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.MONTH)) {\n        calendar.add(Calendar.MONTH, 1);\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.YEAR)) {\n        calendar.add(Calendar.YEAR, 1);\n        return calendar.getTime();\n    }\n    else {\n        return null;\n    }\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance();\n    calendar.setTime(date);\n    int value = 0;\n    int years = calendar.get(Calendar.YEAR);\n    int months = calendar.get(Calendar.MONTH);\n    int days = calendar.get(Calendar.DAY_OF_MONTH);\n    int hours = calendar.get(Calendar.HOUR_OF_DAY);\n    int minutes = calendar.get(Calendar.MINUTE);\n    int seconds = calendar.get(Calendar.SECOND);\n\n    if (unit.equals(DateTickUnitType.DAY)) {\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, months, value + 1, 0, 0, 0);\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.HOUR)) {\n        calendar.clear(Calendar.MINUTE);\n        calendar.clear(Calendar.SECOND);\n        calendar.set(years, months, days, value + 1, 0, 0);\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.MINUTE)) {\n        calendar.clear(Calendar.SECOND);\n        calendar.set(years, months, days, hours, value + 1, 0);\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.SECOND)) {\n        calendar.set(years, months, days, hours, minutes, value + 1);\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.MONTH)) {\n        calendar.clear(Calendar.DAY_OF_MONTH);\n        calendar.set(years, value, 1, 0, 0, 0);\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.YEAR)) {\n        calendar.clear(Calendar.MONTH);\n        calendar.set(value + 1, 0, 1, 0, 0, 0);\n        return calendar.getTime();\n    }\n    else {\n        return null;\n    }\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance();\n    calendar.setTime(date);\n    int value = 0;\n    int years = calendar.get(Calendar.YEAR);\n    int months = calendar.get(Calendar.MONTH);\n    int days = calendar.get(Calendar.DAY_OF_MONTH);\n    int hours = calendar.get(Calendar.HOUR_OF_DAY);\n    int minutes = calendar.get(Calendar.MINUTE);\n    int seconds = calendar.get(Calendar.SECOND);\n\n    if (unit.equals(DateTickUnitType.DAY)) {\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, months, value, hours, minutes, seconds);\n        if (calendar.getTime().getTime() >= date.getTime()) {\n            calendar.set(Calendar.DAY_OF_MONTH, value + 1);\n        }\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.HOUR)) {\n        calendar.clear(Calendar.MINUTE);\n        calendar.clear(Calendar.SECOND);\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, months, days, value, 0, 0);\n        if (calendar.getTime().getTime() >= date.getTime()) {\n            calendar.set(Calendar.HOUR_OF_DAY, value + 1);\n        }\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.MINUTE)) {\n        calendar.clear(Calendar.SECOND);\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, months, days, hours, value, 0);\n        if (calendar.getTime().getTime() >= date.getTime()) {\n            calendar.set(Calendar.MINUTE, value + 1);\n        }\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.SECOND)) {\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, months, days, hours, minutes, value);\n        if (calendar.getTime().getTime() >= date.getTime()) {\n            calendar.set(Calendar.SECOND, value + 1);\n        }\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.MONTH)) {\n        calendar.clear(Calendar.DAY_OF_MONTH);\n        calendar.clear(Calendar.HOUR_OF_DAY);\n        calendar.clear(Calendar.MINUTE);\n        calendar.clear(Calendar.SECOND);\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, value, 1, 0, 0, 0);\n        if (calendar.getTime().getTime() >= date.getTime()) {\n            calendar.set(Calendar.MONTH, value + 1);\n        }\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.YEAR)) {\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone);\n    calendar.setTime(date);\n    int value = 0;\n    int years = calendar.get(Calendar.YEAR);\n    int months = calendar.get(Calendar.MONTH);\n    int days = calendar.get(Calendar.DAY_OF_MONTH);\n    int hours = calendar.get(Calendar.HOUR_OF_DAY);\n    int minutes = calendar.get(Calendar.MINUTE);\n    int seconds = calendar.get(Calendar.SECOND);\n\n    if (unit.equals(DateTickUnitType.SECOND)) {\n        seconds = (seconds + 1) % 60;\n        if (seconds == 0) {\n            minutes = (minutes + 1) % 60;\n            if (minutes == 0) {\n                hours = (hours + 1) % 24;\n                if (hours == 0) {\n                    days = (days + 1) % daysInMonth(years, months);\n                    if (days == 1) {\n                        months = (months + 1) % 12;\n                        if (months == 0) {\n                            years = years + 1;\n                        }\n                    }\n                }\n            }\n        }\n        calendar.set(years, months, days, hours, minutes, seconds);\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.MINUTE)) {\n        minutes = (minutes + 1) % 60;\n        if (minutes == 0) {\n            hours = (hours + 1) % 24;\n            if (hours == 0) {\n                days = (days + 1) % daysInMonth(years, months);\n                if (days == 1) {\n                    months = (months + 1) % 12;\n                    if (months == 0) {\n                        years = years + 1;\n                    }\n                }\n            }\n        }\n        calendar.set(years, months, days, hours, minutes, 0);\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.HOUR)) {\n        hours = (hours + 1) % 24;\n        if (hours == 0) {\n            days = (days + 1) % daysInMonth(years, months);\n            if (days == 1) {\n                months = (months + 1) % 12;\n                if (months == 0) {\n                    years = years + 1;\n                }\n            }\n        }\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance();\n    calendar.setTime(date);\n    int years = calendar.get(Calendar.YEAR);\n    int months = calendar.get(Calendar.MONTH);\n    int days = calendar.get(Calendar.DAY_OF_MONTH);\n    int hours = calendar.get(Calendar.HOUR_OF_DAY);\n    int minutes = calendar.get(Calendar.MINUTE);\n    int seconds = calendar.get(Calendar.SECOND);\n\n    if (unit.equals(DateTickUnitType.DAY)) {\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        if (calendar.getTime().getTime() >= date.getTime()) {\n            calendar.add(Calendar.DAY_OF_YEAR, -1);\n        }\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.HOUR)) {\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        if (calendar.getTime().getTime() >= date.getTime()) {\n            calendar.add(Calendar.HOUR_OF_DAY, -1);\n        }\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.MINUTE)) {\n        calendar.set(Calendar.SECOND, 0);\n        if (calendar.getTime().getTime() >= date.getTime()) {\n            calendar.add(Calendar.MINUTE, -1);\n        }\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.SECOND)) {\n        if (calendar.getTime().getTime() >= date.getTime()) {\n            calendar.add(Calendar.SECOND, -1);\n        }\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.MONTH)) {\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        if (calendar.getTime().getTime() >= date.getTime()) {\n            calendar.add(Calendar.MONTH, -1);\n        }\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.YEAR)) {\n        calendar.set(Calendar.MONTH, 0);\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        if (calendar.getTime().getTime() >= date.getTime()) {\n            calendar.add(Calendar.YEAR, -1);\n        }\n        return calendar.getTime();\n    }\n    return null;\n}"
    ],
    [
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    // implement the logic to resolve the variable\n    // you can use the variableName, buf, startPos, and endPos as needed\n    // you can also use other methods or variables from the class if necessary\n    // for example, you can use the getVariableResolver() method to get the variable resolver\n    // and then use it to resolve the variable\n    // you can also use the buf.replace() method to replace the variable with its value\n    // you can also use the startPos and endPos to get the substring of the buffer\n    // and then replace it with the variable's value\n    // you can also use the variableName to get the variable's value from a map or a database\n    // and then return it\n    // for example:\n    // Map<String, String> variables = getVariables();\n    // return variables.get(variableName);\n    // or\n    // return getVariableResolver().resolve(variableName);\n    // or\n    // String value = getVariableValue(variableName);\n    // return value;\n    // you can also throw an exception if the variable is unknown\n    // for example:\n    // throw new UnknownVariableException(variableName);\n    // you can also return null if the variable is unknown\n    // for example:\n    // return null;\n    // you can also use a default value if the variable is unknown\n    // for example:\n    // return defaultValue;\n    // you can also use a custom logic to resolve the variable\n    // for example:\n    // return customResolveVariable(variableName);\n    // you can also use a combination of the above methods\n    // for example:\n    // String value = getVariableResolver().resolve(variableName);\n    // if (value == null) {\n    // value = getVariableValue(variableName);\n    // }\n    // return value;\n    // you can also use a try-catch block to handle any exceptions\n    // for example:\n    // try {\n    // String value = getVariableResolver().resolve(variableName);\n    // return value;\n    // } catch (Exception e) {\n    // return null;\n    // }\n    // you can also use a finally block to release any resources\n    // for example:\n    // try {\n    // String value = getVariableResolver().resolve(variableName);\n    // return value;\n    // } finally {\n    // releaseResources();\n    // }\n    // you can also use a custom exception class\n    // for example:\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final VariableResolver resolver = getVariableResolver();\n    if (resolver == null) {\n        return null;\n    }\n    return resolver.resolve(variableName);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    // implement the logic to resolve the variable here\n    // you can use the provided context if necessary\n    // for example, you can use the variableName to get the value from a map\n    // or a database, or use the buf to get the value from a context\n    // you can also use the startPos and endPos to get the value from a specific range\n    // you can also use the getVariableResolver() method to get the value\n    // you can also use the resolveVariable() method to recursively resolve the variable\n    // you can also use the priorVariables list to check for cyclic substitution\n    // you can also use the altered variable to check if the variable is already resolved\n    // you can also use the lengthChange variable to check if the variable is already resolved\n    // you can also use the chars variable to get the value from a specific range\n    // you can also use the offset and length variables to get the value from a specific range\n    // you can also use the bufEnd variable to get the value from a specific range\n    // you can also use the lengthChange variable to get the value from a specific range\n    // you can also use the altered variable to get the value from a specific range\n    // you can also use the priorVariables list to get the value from a specific range\n    // you can also use the nestedVarCount variable to get the value from a specific range\n    // you can also use the startPos variable to get the value from a specific range\n    // you can also use the endPos variable to get the value from a specific range\n    // you can also use the buf variable to get the value from a specific range\n    // you can also use the variableName variable to get the value from a specific range\n    // you can also use the variableName variable to get the value from a specific range\n    // you can also use the variableName variable to get the value from a specific range\n    // you can also use the variableName variable to get the value from a specific range\n    // you can also use the variableName variable to get the value from a specific range\n    // you can also use the variableName variable to get the value from a specific range\n    // you can also use the variableName variable to get the value from a specific range\n    // you can also use the variableName variable to get the value from a specific range\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final VariableResolver resolver = getVariableResolver();\n    if (resolver == null) {\n        return null;\n    }\n    return resolver.resolveVariable(variableName);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    // Check if the variable is a predefined variable\n    if (isPredefinedVariable(variableName)) {\n        return getPredefinedVariable(variableName);\n    }\n\n    // Check if the variable is a system property\n    if (isSystemProperty(variableName)) {\n        return System.getProperty(variableName);\n    }\n\n    // Check if the variable is a user-defined variable\n    if (isUserDefinedVariable(variableName)) {\n        return getUserDefinedVariable(variableName);\n    }\n\n    // If none of the above, return null\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    // This method is not implemented. It should return the value of the variable\n    // with the given name. The variable name is in the scope of the current\n    // buffer.\n    // For example, you could use a HashMap to store the variables and their\n    // values.\n    // You could also use a custom resolver to resolve the variable.\n    // For simplicity, let's assume that the variable is a simple key-value pair.\n    // In this case, you would need to implement a custom resolver.\n    // For example, you could use a HashMap to store the variables and their\n    // values.\n    // Here is a simple example:\n    final Map<String, String> variables = new HashMap<String, String>();\n    variables.put(\"myVariable\", \"Hello, World!\");\n    return variables.get(variableName);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    // Use the variable resolver to get the value of the variable\n    final VariableResolver resolver = getVariableResolver();\n    if (resolver == null) {\n        return null;\n    }\n    return resolver.resolveVariable(variableName);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final VariableResolver resolver = getVariableResolver();\n    if (resolver == null) {\n        return null;\n    }\n    return resolver.resolve(variableName);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    Map<String, String> variableResolver = getVariableResolver();\n    return variableResolver.get(variableName);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    // Implement your logic here\n    // For example, you can use a HashMap to store variables and their values\n    // and then retrieve the value based on the variable name\n    // You can also use a custom resolver or a database to resolve the variable\n    // The logic depends on your specific requirements\n    // For simplicity, let's assume we have a HashMap to store variables and their values\n    final Map<String, String> variables = getVariables();\n    if (variables.containsKey(variableName)) {\n        return variables.get(variableName);\n    } else {\n        return null;\n    }\n}"
    ],
    [
      "public String soundex(String str)  {\n    if (str == null) {\n        return \"\";\n    }\n    str = str.toUpperCase();\n    StringBuilder sb = new StringBuilder();\n    sb.append(str.charAt(0));\n    char prev = str.charAt(0);\n    for (int i = 1; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        if (ch == 'H' || ch == 'W' || ch == 'X' || ch == 'Y') {\n            continue;\n        }\n        if (ch == prev) {\n            continue;\n        }\n        sb.append(map(ch));\n        prev = ch;\n    }\n    while (sb.length() < 4) {\n        sb.append('0');\n    }\n    return sb.toString().substring(0, 4);\n}",
      "public String soundex(String str)  {\n    if (str == null || str.length() == 0) {\n        return \"\";\n    }\n    char[] chars = str.toUpperCase().toCharArray();\n    StringBuilder sb = new StringBuilder();\n    sb.append(chars[0]);\n    for (int i = 1; i < chars.length; i++) {\n        char ch = chars[i];\n        if (Character.isLetter(ch)) {\n            char mapped = map(ch);\n            if (!sb.toString().endsWith(mapped + \"\")) {\n                sb.append(mapped);\n            }\n        }\n    }\n    return sb.toString().substring(0, 4);\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return \"\";\n    }\n    str = str.toUpperCase();\n    char[] soundexCode = new char[4];\n    soundexCode[0] = map(str.charAt(0));\n    int i = 1;\n    for (; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        if (ch == 'H' || ch == 'W' || ch == 'X' || ch == 'Y') {\n            break;\n        }\n        char mappedChar = map(ch);\n        if (mappedChar != soundexCode[0]) {\n            if (i < 3) {\n                soundexCode[1] = mappedChar;\n            } else {\n                break;\n            }\n        }\n    }\n    for (; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        if (ch == 'H' || ch == 'W' || ch == 'X' || ch == 'Y') {\n            break;\n        }\n        char mappedChar = map(ch);\n        if (mappedChar != soundexCode[0] && mappedChar != soundexCode[1]) {\n            break;\n        }\n    }\n    for (; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        if (ch == 'H' || ch == 'W' || ch == 'X' || ch == 'Y') {\n            break;\n        }\n    }\n    for (int j = 0; j < 4; j++) {\n        if (j < i) {\n            soundexCode[j] = map(soundexCode[j]);\n        } else {\n            soundexCode[j] = '0';\n        }\n    }\n    return new String(soundexCode);\n}",
      "public String soundex(String str)  {\n    if (str == null || str.isEmpty()) {\n        return \"\";\n    }\n\n    char[] charArray = str.toUpperCase().toCharArray();\n    StringBuilder soundexCode = new StringBuilder();\n    soundexCode.append(charArray[0]);\n    int i = 1;\n    while (i < charArray.length) {\n        char ch = charArray[i];\n        if (ch == 'H' || ch == 'W' || ch == 'X' || ch == 'Y') {\n            i++;\n            continue;\n        }\n        char mappedChar = map(ch);\n        if (mappedChar != '0') {\n            soundexCode.append(mappedChar);\n            i++;\n            while (i < charArray.length && charArray[i] == '0') {\n                i++;\n            }\n        }\n    }\n    while (soundexCode.length() < 4) {\n        soundexCode.append('0');\n    }\n    return soundexCode.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null || str.isEmpty()) {\n        return \"\";\n    }\n    char[] chars = str.toUpperCase().toCharArray();\n    StringBuilder soundexCode = new StringBuilder();\n    soundexCode.append(chars[0]);\n    for (int i = 1; i < chars.length; i++) {\n        char ch = chars[i];\n        if (ch == ' ') {\n            continue;\n        }\n        if (ch == 'X' || ch == 'Z') {\n            soundexCode.append('X');\n        } else if (ch == 'K') {\n            soundexCode.append('K');\n        } else if (ch == 'S' || ch == 'C' || ch == 'F' || ch == 'V') {\n            soundexCode.append('0');\n        } else if (ch == 'B' || ch == 'P' || ch == 'M' || ch == 'W') {\n            soundexCode.append('1');\n        } else if (ch == 'H') {\n            soundexCode.append('H');\n        } else if (ch == 'G') {\n            soundexCode.append('G');\n        } else if (ch == 'J') {\n            soundexCode.append('J');\n        } else if (ch == 'D' || ch == 'T') {\n            soundexCode.append('3');\n        } else if (ch == 'L') {\n            soundexCode.append('4');\n        } else if (ch == 'N') {\n            soundexCode.append('5');\n        } else if (ch == 'R') {\n            soundexCode.append('6');\n        }\n    }\n    return soundexCode.toString().substring(0, 4);\n}",
      "public String soundex(String str)  {\n    if (str == null || str.length() == 0) {\n        return \"\";\n    }\n\n    char[] chars = str.toUpperCase().toCharArray();\n    StringBuilder soundexCode = new StringBuilder();\n    soundexCode.append(chars[0]);\n    int i = 1;\n    while (i < chars.length && soundexCode.length() < 4) {\n        if (chars[i] == 'X' || chars[i] == 'Z') {\n            soundexCode.append('X');\n        } else if (chars[i] == 'B' || chars[i] == 'F' || chars[i] == 'P' || chars[i] == 'V') {\n            soundexCode.append('1');\n        } else if (chars[i] == 'C' || chars[i] == 'G' || chars[i] == 'J' || chars[i] == 'K' || chars[i] == 'Q' || chars[i] == 'S' || chars[i] == 'Y') {\n            soundexCode.append('2');\n        } else if (chars[i] == 'D' || chars[i] == 'T') {\n            soundexCode.append('3');\n        } else if (chars[i] == 'L') {\n            soundexCode.append('4');\n        } else if (chars[i] == 'M' || chars[i] == 'N') {\n            soundexCode.append('5');\n        } else if (chars[i] == 'R') {\n            soundexCode.append('6');\n        }\n        i++;\n    }\n    while (i < chars.length) {\n        if (chars[i] == 'X' || chars[i] == 'Z') {\n            soundexCode.append('X');\n        } else {\n            soundexCode.append('0');\n        }\n        i++;\n    }\n    return soundexCode.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null || str.isEmpty()) {\n        return \"\";\n    }\n    char[] chars = str.toUpperCase().toCharArray();\n    StringBuilder soundexCode = new StringBuilder();\n    soundexCode.append(chars[0]);\n    for (int i = 1; i < chars.length; i++) {\n        char ch = chars[i];\n        if (ch == ' ') {\n            continue;\n        }\n        if (ch == 'X' || ch == 'Z') {\n            soundexCode.append('0');\n        } else if (ch == 'B' || ch == 'F' || ch == 'P' || ch == 'V') {\n            soundexCode.append('1');\n        } else if (ch == 'C' || ch == 'G' || ch == 'J' || ch == 'K' || ch == 'Q' || ch == 'S' || ch == 'Y') {\n            soundexCode.append('2');\n        } else if (ch == 'D' || ch == 'T') {\n            soundexCode.append('3');\n        } else if (ch == 'L') {\n            soundexCode.append('4');\n        } else if (ch == 'M' || ch == 'N') {\n            soundexCode.append('5');\n        } else if (ch == 'R') {\n            soundexCode.append('6');\n        }\n    }\n    return soundexCode.toString().substring(0, 4);\n}",
      "public String soundex(String str)  {\n    if (str == null || str.length() == 0) {\n        return \"\";\n    }\n    char[] chars = str.toUpperCase().toCharArray();\n    StringBuilder sb = new StringBuilder();\n    sb.append(chars[0]);\n    for (int i = 1; i < chars.length; i++) {\n        char ch = chars[i];\n        if (Character.isLetter(ch)) {\n            char mappedChar = map(ch);\n            if (sb.length() < 4) {\n                sb.append(mappedChar);\n            }\n        }\n    }\n    return sb.toString().substring(0, 4).replace('#', '0');\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return \"\";\n    }\n    str = str.toUpperCase();\n    char[] soundexCode = new char[4];\n    soundexCode[0] = map(str.charAt(0));\n    int count = 1;\n    for (int i = 1; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        if (ch == 'H' || ch == 'W' || ch == 'X' || ch == 'Y') {\n            continue;\n        }\n        if (ch == soundexCode[0]) {\n            continue;\n        }\n        soundexCode[count++] = map(ch);\n        if (count == 4) {\n            break;\n        }\n    }\n    if (count == 1) {\n        for (int i = 1; i < 4; i++) {\n            soundexCode[i] = '0';\n        }\n    } else if (count == 2) {\n        for (int i = 2; i < 4; i++) {\n            soundexCode[i] = '0';\n        }\n    }\n    return new String(soundexCode);\n}",
      "public String soundex(String str)  {\n    char[] soundexCode = new char[4];\n    soundexCode[0] = map(str.charAt(0));\n    int i = 1;\n    for (; i < str.length() && i < 4; i++) {\n        char ch = str.charAt(i);\n        if (ch == 'X' || ch == 'x') {\n            soundexCode[i] = '000';\n            break;\n        }\n        if (ch == ' ') {\n            continue;\n        }\n        char mappedChar = map(ch);\n        if (mappedChar != soundexCode[0]) {\n            soundexCode[i] = mappedChar;\n        } else {\n            break;\n        }\n    }\n    while (i < 4) {\n        soundexCode[i] = '0';\n        i++;\n    }\n    return new String(soundexCode);\n}"
    ],
    [
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == Integer.class || clz == int.class) {\n        return CORE_TYPE_INT;\n    } else if (clz == Boolean.class || clz == boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    } else if (clz == Byte.class || clz == byte.class) {\n        return CORE_TYPE_BYTE;\n    } else if (clz == Short.class || clz == short.class) {\n        return CORE_TYPE_SHORT;\n    } else if (clz == Long.class || clz == long.class) {\n        return CORE_TYPE_LONG;\n    } else if (clz == Float.class || clz == float.class) {\n        return CORE_TYPE_FLOAT;\n    } else if (clz == Double.class || clz == double.class) {\n        return CORE_TYPE_DOUBLE;\n    } else if (clz == Character.class || clz == char.class) {\n        return CORE_TYPE_CHAR;\n    } else if (clz == Void.class) {\n        return CORE_TYPE_VOID;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == Integer.class) {\n        return CORE_TYPE_INT;\n    } else if (clz == Boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    } else if (clz == Byte.class) {\n        return CORE_TYPE_BYTE;\n    } else if (clz == Short.class) {\n        return CORE_TYPE_SHORT;\n    } else if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    } else if (clz == Float.class) {\n        return CORE_TYPE_FLOAT;\n    } else if (clz == Double.class) {\n        return CORE_TYPE_DOUBLE;\n    } else if (clz == Character.class) {\n        return CORE_TYPE_CHAR;\n    } else if (clz == Void.class) {\n        return CORE_TYPE_VOID;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == Integer.class) {\n        return CORE_TYPE_INT;\n    } else if (clz == Boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    } else if (clz == Double.class) {\n        return CORE_TYPE_DOUBLE;\n    } else if (clz == Byte.class) {\n        return CORE_TYPE_BYTE;\n    } else if (clz == Short.class) {\n        return CORE_TYPE_SHORT;\n    } else if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    } else if (clz == Float.class) {\n        return CORE_TYPE_FLOAT;\n    } else if (clz == Character.class) {\n        return CORE_TYPE_CHAR;\n    } else if (clz == Void.class) {\n        return CORE_TYPE_VOID;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == Integer.class) {\n        return CORE_TYPE_INT;\n    } else if (clz == Boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    } else if (clz == Byte.class) {\n        return CORE_TYPE_BYTE;\n    } else if (clz == Short.class) {\n        return CORE_TYPE_SHORT;\n    } else if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    } else if (clz == Float.class) {\n        return CORE_TYPE_FLOAT;\n    } else if (clz == Double.class) {\n        return CORE_TYPE_DOUBLE;\n    } else if (clz == Character.class) {\n        return CORE_TYPE_CHAR;\n    } else if (clz == Void.class) {\n        return CORE_TYPE_VOID;\n    } else {\n        return null;\n    }\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == Integer.class) {\n        return CORE_TYPE_INT;\n    } else if (clz == Boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    } else if (clz == Byte.class) {\n        return CORE_TYPE_BYTE;\n    } else if (clz == Short.class) {\n        return CORE_TYPE_SHORT;\n    } else if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    } else if (clz == Float.class) {\n        return CORE_TYPE_FLOAT;\n    } else if (clz == Double.class) {\n        return CORE_TYPE_DOUBLE;\n    } else if (clz == Character.class) {\n        return CORE_TYPE_CHAR;\n    } else if (clz == Void.class) {\n        return CORE_TYPE_VOID;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == Integer.class) {\n        return CORE_TYPE_INT;\n    } else if (clz == Boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    } else if (clz == Byte.class) {\n        return CORE_TYPE_BYTE;\n    } else if (clz == Short.class) {\n        return CORE_TYPE_SHORT;\n    } else if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    } else if (clz == Float.class) {\n        return CORE_TYPE_FLOAT;\n    } else if (clz == Double.class) {\n        return CORE_TYPE_DOUBLE;\n    } else if (clz == Character.class) {\n        return CORE_TYPE_CHAR;\n    } else if (clz == Void.class) {\n        return CORE_TYPE_VOID;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == Integer.class) {\n        return CORE_TYPE_INT;\n    } else if (clz == Boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    } else if (clz == Double.class) {\n        return CORE_TYPE_DOUBLE;\n    } else if (clz == Byte.class) {\n        return CORE_TYPE_BYTE;\n    } else if (clz == Short.class) {\n        return CORE_TYPE_SHORT;\n    } else if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    } else if (clz == Float.class) {\n        return CORE_TYPE_FLOAT;\n    } else if (clz == Character.class) {\n        return CORE_TYPE_CHAR;\n    } else if (clz == Void.class) {\n        return CORE_TYPE_VOID;\n    } else {\n        return null;\n    }\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == Integer.class) {\n        return CORE_TYPE_INT;\n    } else if (clz == Boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    } else if (clz == Byte.class) {\n        return CORE_TYPE_BYTE;\n    } else if (clz == Short.class) {\n        return CORE_TYPE_SHORT;\n    } else if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    } else if (clz == Float.class) {\n        return CORE_TYPE_FLOAT;\n    } else if (clz == Double.class) {\n        return CORE_TYPE_DOUBLE;\n    } else if (clz == Character.class) {\n        return CORE_TYPE_CHAR;\n    } else if (clz == Void.class) {\n        return CORE_TYPE_VOID;\n    } else {\n        return null;\n    }\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == Integer.class || clz == int.class) {\n        return CORE_TYPE_INT;\n    } else if (clz == Boolean.class || clz == boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    } else if (clz == Byte.class || clz == byte.class) {\n        return CORE_TYPE_BYTE;\n    } else if (clz == Short.class || clz == short.class) {\n        return CORE_TYPE_SHORT;\n    } else if (clz == Long.class || clz == long.class) {\n        return CORE_TYPE_LONG;\n    } else if (clz == Double.class || clz == double.class) {\n        return CORE_TYPE_DOUBLE;\n    } else if (clz == Float.class || clz == float.class) {\n        return CORE_TYPE_FLOAT;\n    } else if (clz == Character.class || clz == char.class) {\n        return CORE_TYPE_CHAR;\n    } else if (clz == Void.class || clz == void.class) {\n        return CORE_TYPE_VOID;\n    } else if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == Integer.class || clz == int.class) {\n        return CORE_TYPE_INT;\n    } else if (clz == Boolean.class || clz == boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    } else if (clz == Byte.class || clz == byte.class) {\n        return CORE_TYPE_BYTE;\n    } else if (clz == Short.class || clz == short.class) {\n        return CORE_TYPE_SHORT;\n    } else if (clz == Long.class || clz == long.class) {\n        return CORE_TYPE_LONG;\n    } else if (clz == Float.class || clz == float.class) {\n        return CORE_TYPE_FLOAT;\n    } else if (clz == Double.class || clz == double.class) {\n        return CORE_TYPE_DOUBLE;\n    } else if (clz == Character.class || clz == char.class) {\n        return CORE_TYPE_CHAR;\n    } else if (clz == Void.class) {\n        return CORE_TYPE_VOID;\n    }\n    return null;\n}"
    ],
    [
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isFunction()) {\n        return null;\n    }\n    if (n.isPrototypeProperty()) {\n        return new PrototypeMemberDeclaration(n.getLHS(), n);\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isPrototypePropertyDeclaration()) {\n        return new PrototypeMemberDeclaration(n.getLhs(), n);\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isFunction()) {\n        return null;\n    }\n    if (n.isPrototypeProperty()) {\n        return new PrototypeMemberDeclaration(n.getLhs(), n);\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isPrototypeProperty()) {\n        Node lhs = n.getLhs();\n        return new PrototypeMemberDeclaration(lhs, n);\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isPrototypePropertyDeclaration()) {\n        return new PrototypeMemberDeclaration(n.getLhs(), n);\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n instanceof PrototypeMemberDeclaration) {\n        return (PrototypeMemberDeclaration) n;\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n instanceof PrototypeMemberDeclaration) {\n        return (PrototypeMemberDeclaration) n;\n    } else if (n instanceof FunctionDeclaration) {\n        return null;\n    } else if (n instanceof VariableDeclaration) {\n        return null;\n    } else if (n instanceof Statement) {\n        return null;\n    } else if (n instanceof Block) {\n        return null;\n    } else if (n instanceof IfStatement) {\n        return null;\n    } else if (n instanceof WhileStatement) {\n        return null;\n    } else if (n instanceof ForStatement) {\n        return null;\n    } else if (n instanceof SwitchStatement) {\n        return null;\n    } else if (n instanceof TryStatement) {\n        return null;\n    } else if (n instanceof CatchClause) {\n        return null;\n    } else if (n instanceof ExpressionStatement) {\n        return null;\n    } else if (n instanceof ThrowStatement) {\n        return null;\n    } else if (n instanceof ContinueStatement) {\n        return null;\n    } else if (n instanceof BreakStatement) {\n        return null;\n    } else if (n instanceof ReturnStatement) {\n        return null;\n    } else if (n instanceof SynchronizedStatement) {\n        return null;\n    } else if (n instanceof LambdaExpression) {\n        return null;\n    } else if (n instanceof MethodReferenceExpression) {\n        return null;\n    } else if (n instanceof ArrayInitializerExpression) {\n        return null;\n    } else if (n instanceof ClassLiteralExpression) {\n        return null;\n    } else if (n instanceof AnnotationExpression) {\n        return null;\n    } else if (n instanceof MemberReferenceExpression) {\n        return null;\n    } else if (n instanceof PrimaryExpression) {\n        return null;\n    } else if (n instanceof QualifiedName) {\n        return null;\n    } else if (n instanceof SimpleName) {\n        return null;\n    } else if (n instanceof ArrayAccess) {\n        return null;\n    } else if (n instanceof ArrayCreation) {\n        return null;\n    } else if (n instanceof ArrayInitializer) {\n        return null;\n    } else if (n instanceof Assignment) {\n        return null;\n    } else if (n instanceof BinaryOperation) {\n        return null;\n    } else if (n instanceof CastExpression) {\n        return null;\n    } else if (n instanceof ConditionalExpression) {\n        return null;\n}\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isPrototypePropertyDeclaration()) {\n        return new PrototypeMemberDeclaration(n.getLhs(), n);\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n instanceof PrototypeMemberDeclaration) {\n        return (PrototypeMemberDeclaration) n;\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n instanceof PrototypeMemberDeclaration) {\n        return (PrototypeMemberDeclaration) n;\n    } else if (n instanceof Node && n.getNext() != null) {\n        for (Node cur = n.getNext(); cur != null; cur = cur.getNext()) {\n            if (cur instanceof PrototypeMemberDeclaration) {\n                return (PrototypeMemberDeclaration) cur;\n            }\n        }\n    }\n    return null;\n}"
    ],
    [
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final int rows = mat.getRowDimension();\n    final int cols = mat.getColumnDimension();\n    final double[][] d = new double[rows * n][cols * m];\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            for (int k = 0; k < n; k++) {\n                for (int l = 0; l < m; l++) {\n                    d[i * n + k][j * m + l] = mat.getEntry(i, j);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    int rows = mat.getRowDimension();\n    int cols = mat.getColumnDimension();\n    RealMatrix result = zeros(n * rows, m * cols);\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            copyColumn(mat, j, result, j * m);\n            for (int k = 1; k < n; k++) {\n                copyColumn(mat, j, result, j * m + k * cols);\n            }\n        }\n        for (int j = 0; j < cols; j++) {\n            copyColumn(mat, j, result, j + k * cols);\n            for (int k = 1; k < m; k++) {\n                copyColumn(mat, j, result, j * m + k * cols);\n            }\n        }\n    }\n    return result;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    int rows = mat.getRowDimension();\n    int cols = mat.getColumnDimension();\n    RealMatrix result = zeros(n * rows, m * cols);\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            copyColumn(mat, j, result, j * m);\n            for (int k = 1; k < n; k++) {\n                copyColumn(mat, j, result, j * m + k * cols);\n            }\n        }\n        for (int j = 0; j < cols; j++) {\n            copyColumn(mat, j, result, j + k * cols);\n            for (int k = 1; k < m; k++) {\n                copyColumn(mat, j, result, j * m + k * cols);\n            }\n        }\n    }\n    return result;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    int rows = mat.getRowDimension();\n    int cols = mat.getColumnDimension();\n    RealMatrix result = zeros(n * rows, m * cols);\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            copyColumn(mat, j, result, j);\n            copyColumn(mat, j, result, j + cols);\n        }\n    }\n    for (int i = 0; i < rows; i++) {\n        copyColumn(result, i * cols, result, i * cols);\n        copyColumn(result, i * cols, result, i * cols + cols);\n    }\n    return result;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final int rows = mat.getRowDimension();\n    final int cols = mat.getColumnDimension();\n    final double[][] d = new double[rows * n][cols * m];\n    for (int r = 0; r < rows; r++) {\n        for (int c = 0; c < cols; c++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    d[r * n + i][c * m + j] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    int rows = mat.getRowDimension();\n    int cols = mat.getColumnDimension();\n    RealMatrix result = zeros(n * rows, m * cols);\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            copyColumn(mat, j, result, j * m);\n            copyColumn(mat, j, result, j * m + 1);\n            copyColumn(mat, j, result, j * m + 2);\n            copyColumn(mat, j, result, j * m + 3);\n            // copyColumn(mat, j, result, j * m + k);\n            // for k from 4 to m\n        }\n    }\n    return result;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    int rows = mat.getRowDimension();\n    int cols = mat.getColumnDimension();\n    RealMatrix result = zeros(n * rows, m * cols);\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            copyColumn(mat, j, result, j * m);\n            if (i > 0) {\n                copyColumn(mat, j, result, j * m + cols);\n            }\n        }\n    }\n    return result;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    int rows = mat.getRowDimension();\n    int cols = mat.getColumnDimension();\n    RealMatrix result = zeros(n * rows, m * cols);\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            copyColumn(mat, j, result, j * m);\n            for (int k = 1; k < n; k++) {\n                copyColumn(mat, j, result, j * m + k * cols);\n            }\n        }\n        for (int j = 0; j < cols; j++) {\n            copyColumn(mat, j, result, j + k * cols);\n        }\n    }\n    return result;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final int rows = mat.getRowDimension();\n    final int cols = mat.getColumnDimension();\n    final double[][] result = new double[rows * n][cols * m];\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            for (int k = 0; k < n; k++) {\n                for (int l = 0; l < m; l++) {\n                    result[i * n + k][j * m + l] = mat.getEntry(i, j);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(result, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final int rows = mat.getRowDimension();\n    final int cols = mat.getColumnDimension();\n    final double[][] d = new double[rows * n][cols * m];\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            for (int k = 0; k < n; k++) {\n                for (int l = 0; l < m; l++) {\n                    d[i * n + k][j * m + l] = mat.getEntry(i, j);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}"
    ],
    [
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null; node = node.getNext()) {\n        if (node.element.compareTo(reference) > 0) {\n            return candidate;\n        } else {\n            candidate = node;\n        }\n    }\n    return candidate;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null; node = node.getNext()) {\n        if (node.element.compareTo(reference) > 0) {\n            return candidate;\n        } else {\n            candidate = node;\n        }\n    }\n    return candidate;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null; node = node.getNext()) {\n        if (node.element.compareTo(reference) > 0) {\n            return candidate;\n        } else {\n            candidate = node;\n        }\n    }\n    return candidate;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null; node = node.getNext()) {\n        if (node.element.compareTo(reference) > 0) {\n            return candidate;\n        } else {\n            candidate = node;\n        }\n    }\n    return candidate;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null; node = node.getNext()) {\n        if (node.element.compareTo(reference) > 0) {\n            return candidate;\n        } else {\n            candidate = node;\n        }\n    }\n    return candidate;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null; node = node.getNext()) {\n        if (node.element.compareTo(reference) > 0) {\n            return candidate;\n        } else {\n            candidate = node;\n        }\n    }\n    return candidate;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}"
    ],
    [
      "private long getBytesInflated()  {\n    long bytesInflated = current.entry.getCompressedSize();\n    if (bytesInflated > current.bytesReadFromStream) {\n        bytesInflated = current.bytesReadFromStream;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = current.entry.getCompressedSize();\n    if (current.bytesReadFromStream > bytesInflated) {\n        bytesInflated = current.bytesReadFromStream;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = current.entry.getCompressedSize();\n    if (bytesInflated > current.bytesReadFromStream) {\n        bytesInflated = current.bytesReadFromStream;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED ? current.entry.getCompressedSize() : current.bytesRead;\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long bytesRead = current.bytesReadFromStream;\n    long inflatedBytes = inf.getBytesWritten();\n    return Math.min(bytesRead, inflatedBytes);\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = current.entry.getCompressedSize();\n    if (bytesInflated > current.bytesReadFromStream) {\n        bytesInflated = current.bytesReadFromStream;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long bytesRead = current.bytesReadFromStream;\n    long inflatedBytes = inf.getBytesWritten();\n    return Math.min(bytesRead, inflatedBytes);\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED\n            ? inf.getBytesWritten() : current.bytesRead;\n    if (bytesInflated > current.bytesRead) {\n        bytesInflated = current.bytesRead;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long bytesRead = current.bytesReadFromStream;\n    long inflated = inf.getBytesWritten();\n    if (inflated > bytesRead) {\n        return bytesRead;\n    } else {\n        return inflated;\n    }\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED\n            ? current.inflatedBytes : current.bytesRead;\n    return bytesInflated;\n}"
    ],
    [
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return !IterableUtils.size((Iterable<?>) object) > 0;\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !IteratorUtils.hasNext((Iterator<?>) object);\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return !IterableUtils.size((Iterable<?>) object) > 0;\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !IteratorUtils.hasNext((Iterator<?>) object);\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return !IterableUtils.size((Iterable<?>) object) > 0;\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return !IterableUtils.size((Iterable<?>) object) > 0;\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !IteratorUtils.hasNext((Iterator<?>) object);\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return !IterableUtils.size((Iterable<?>) object) > 0;\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !IteratorUtils.hasNext((Iterator<?>) object);\n    } else if (object instanceof Enumeration<?>) {\n        final Enumeration<?> it = (Enumeration<?>) object;\n        return !it.hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return !IterableUtils.size((Iterable<?>) object) > 0;\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !IteratorUtils.hasNext((Iterator<?>) object);\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}"
    ],
    [
      "public static boolean isValidQualifiedName(String name)  {\n    if (name == null || name.isEmpty()) {\n        return false;\n    }\n    String[] parts = name.split(\"\\\\.\");\n    for (String part : parts) {\n        if (!isValidSimpleName(part)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    String[] parts = name.split(\"\\\\.\");\n    for (String part : parts) {\n        if (!isValidSimpleName(part)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    return name.contains(\".\") && isValidSimpleName(name.split(\"\\\\.\")[0]) && isValidSimpleName(name.split(\"\\\\.\")[1]);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    String[] parts = name.split(\"\\\\.\");\n    for (String part : parts) {\n        if (!isValidSimpleName(part)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    String[] parts = name.split(\"\\\\.\");\n    for (String part : parts) {\n        if (!isValidSimpleName(part)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    if (name.indexOf('.') != -1) {\n        String[] parts = name.split(\"\\\\.\");\n        for (String part : parts) {\n            if (!isValidSimpleName(part)) {\n                return false;\n            }\n        }\n        return true;\n    } else {\n        return isValidSimpleName(name);\n    }\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    if (!isValidSimpleName(name)) {\n        return false;\n    }\n    int lastDotIndex = name.lastIndexOf('.');\n    if (lastDotIndex == -1) {\n        return true;\n    }\n    String simpleName = name.substring(lastDotIndex + 1);\n    return isValidSimpleName(simpleName);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidSimpleName(name) && !name.contains(\".\");\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidSimpleName(name);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidSimpleName(name);\n}"
    ],
    [
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int idx = il - 1;\n    double s = FastMath.abs(matrixT[idx][idx]) + FastMath.abs(matrixT[idx + 1][idx + 1]);\n    double tau = 0.0;\n    if (s == 0.0) {\n        s = shift.x;\n    }\n    tau = matrixT[idx][idx - 1] / s;\n    tau = tau * tau;\n    if (idx > 0) {\n        tau = tau * (1.0 + tau);\n    }\n    tau = FastMath.sqrt(tau);\n    if (idx > 0) {\n        tau = -tau;\n    }\n    hVec[idx] = tau;\n    hVec[idx - 1] = -matrixT[idx][idx - 1] / s;\n    return idx;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int idx = iu;\n    int l = il;\n    double scale = 0.0;\n    double h = 0.0;\n    double g = 0.0;\n\n    // Compute the Householder vector\n    for (int j = l; j <= idx; j++) {\n        double s = 0.0;\n        for (int k = l; k <= idx; k++) {\n            s += matrixT[j][k] * matrixT[j][k];\n        }\n        s = FastMath.sqrt(s);\n        if (s == 0.0) {\n            s = 1.0;\n        }\n        scale += s;\n        g = matrixT[j][idx] / s;\n        h += g * g;\n        for (int k = l; k <= idx; k++) {\n            matrixT[j][k] -= g * matrixT[j][k];\n        }\n    }\n\n    // Form the Householder vector\n    hVec[0] = scale;\n    hVec[1] = h;\n    hVec[2] = g;\n\n    return idx;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int idx = il - 1;\n    double scale = 0.0;\n    double sum = 0.0;\n    int k = il;\n\n    // Compute the householder vector\n    while (k <= iu) {\n        scale += FastMath.abs(matrixT[k][k]) + FastMath.abs(matrixT[k][k - 1]);\n        k++;\n    }\n    scale = FastMath.max(scale, epsilon * FastMath.abs(matrixT[il][il]));\n\n    // Normalize the householder vector\n    k = il;\n    while (k <= iu) {\n        hVec[k - il] = matrixT[k][k - 1] / scale;\n        sum += hVec[k - il] * hVec[k - il];\n        k++;\n    }\n    sum = FastMath.sqrt(sum);\n    k = il;\n    while (k <= iu) {\n        hVec[k - il] /= sum;\n        k++;\n    }\n\n    // Apply the householder transformation\n    k = il;\n    while (k <= iu) {\n        double t = 0.0;\n        int j = k;\n        while (j <= iu) {\n            t += hVec[j - il] * matrixT[j][k - 1];\n            j++;\n        }\n        t /= scale;\n        for (j = k; j <= iu; j++) {\n            matrixT[j][k - 1] -= t * hVec[j - il];\n        }\n        k++;\n    }\n\n    // Update the shift\n    shift.x = matrixT[iu][iu];\n    shift.y = shift.w = 0.0;\n    if (il < iu) {\n        shift.y = matrixT[iu - 1][iu - 1];\n        shift.w = matrixT[iu][iu - 1] * matrixT[iu - 1][iu];\n    }\n\n    return il;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int idx = il - 1;\n    int startIdx = idx;\n    double scale = 0.0;\n    double h = 0.0;\n    for (int i = idx; i >= 0; i--) {\n        double t = 0.0;\n        if (i < iu) {\n            t = matrixT[i][i];\n        }\n        double s = t - shift.x;\n        if (i < il) {\n            s -= shift.y;\n        }\n        if (s != 0.0) {\n            scale = FastMath.abs(s);\n            if (scale < epsilon) {\n                break;\n            }\n            h = s / scale;\n            hVec[i] = scale;\n            for (int j = i + 1; j <= iu; j++) {\n                matrixT[j][i] -= h * matrixT[j][i];\n            }\n        }\n    }\n    return startIdx;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int idx = iu;\n    int startIdx = idx;\n    while (idx > il) {\n        double s = FastMath.abs(matrixT[idx - 1][idx - 1]) + FastMath.abs(matrixT[idx][idx]);\n        if (s == 0.0) {\n            s = getNorm();\n        }\n        double tau = matrixT[idx][idx - 1] / s;\n        double h = FastMath.sqrt(tau * tau + 1.0);\n        tau /= h;\n        hVec[idx - 1] = -h;\n        hVec[idx] = tau;\n        for (int j = idx - 1; j >= il; j--) {\n            double t = matrixT[j][idx - 1];\n            matrixT[j][idx - 1] = t - tau * t;\n        }\n        idx--;\n    }\n    return startIdx;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int idx = il - 1;\n    double s = 0.0;\n    double t = 0.0;\n    double h = 0.0;\n    int startIdx = il;\n    while (idx >= 0) {\n        s = matrixT[idx][idx];\n        t = matrixT[idx][il];\n        h = t / FastMath.sqrt(s * s + t * t);\n        hVec[idx] = h;\n        for (int j = il; j < matrixT.length; j++) {\n            matrixT[idx][j] -= h * (t + s * h);\n        }\n        idx--;\n    }\n    return startIdx;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int idx = il - 1;\n    double s = FastMath.abs(matrixT[idx][idx]) + FastMath.abs(matrixT[idx + 1][idx + 1]);\n    if (s == 0.0) {\n        s = getNorm();\n    }\n    double tau = 0.0;\n    if (idx > 0) {\n        tau = matrixT[idx][idx - 1] / (matrixT[idx][idx] + s);\n        matrixT[idx][idx - 1] -= tau * (matrixT[idx][idx] + s);\n    }\n    tau = 2.0 / (1.0 + FastMath.sqrt(1.0 + tau * tau));\n    tau = matrixT[idx][idx] - tau * s;\n    hVec[idx] = tau;\n    for (int j = idx - 1; j >= 0; j--) {\n        double t = 0.0;\n        for (int k = j + 1; k <= idx; k++) {\n            t += matrixT[j][k] * hVec[k];\n        }\n        double h = t;\n        if (j > 0) {\n            hVec[j - 1] = h / matrixT[j - 1][j - 1];\n        } else {\n            hVec[0] = h;\n        }\n        for (int k = j + 1; k <= idx; k++) {\n            matrixT[j][k] -= h * hVec[k];\n        }\n    }\n    return idx;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int idx = iu;\n    double s = 0.0;\n    double t = 0.0;\n    int startIdx = idx + 1;\n    for (int i = startIdx; i < matrixT.length; i++) {\n        double v = 0.0;\n        for (int j = 0; j < i; j++) {\n            v += matrixT[i][j] * hVec[j];\n        }\n        if (i > idx) {\n            s += v * v;\n        }\n        if (i > idx) {\n            t += v * matrixT[i][i];\n        }\n        hVec[i] = v;\n    }\n    if (s > 0.0) {\n        s = FastMath.sqrt(s);\n        for (int i = startIdx; i < matrixT.length; i++) {\n            hVec[i] /= s;\n        }\n    }\n    if (t > 0.0) {\n        t = FastMath.sqrt(t);\n        for (int i = startIdx; i < matrixT.length; i++) {\n            hVec[i] -= t * hVec[i];\n        }\n    }\n    return startIdx;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int idx = iu;\n    int startIdx = il;\n    double[] v = new double[matrixT.length];\n    double s = 0.0;\n    double tau = 0.0;\n    for (int j = startIdx; j <= idx; j++) {\n        v[j] = matrixT[j][j];\n        s += v[j] * v[j];\n    }\n    s = FastMath.sqrt(s);\n    tau = v[idx] / s;\n    for (int j = startIdx; j <= idx; j++) {\n        v[j] = v[j] / s;\n    }\n    for (int j = startIdx; j <= idx; j++) {\n        for (int k = j; k <= idx; k++) {\n            hVec[j * matrixT.length + k] = matrixT[j][k] - tau * v[j] * v[k];\n        }\n    }\n    return startIdx;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int idx = iu;\n    double s = 0.0;\n    if (il < idx) {\n        s = matrixT[idx - 1][idx - 1];\n    }\n    double h = 0.0;\n    if (il < idx) {\n        h = matrixT[idx][idx - 1];\n    }\n    double t = 0.0;\n    if (il < idx) {\n        t = matrixT[idx - 1][idx - 1] - s;\n    }\n    double g = 0.0;\n    if (il < idx) {\n        g = h * h / t;\n    }\n    double f = 0.0;\n    if (il < idx) {\n        f = g * g / t;\n    }\n    double alpha = 0.0;\n    if (il < idx) {\n        alpha = h * g / t;\n    }\n    double beta = 0.0;\n    if (il < idx) {\n        beta = f * g / t;\n    }\n    double gamma = 0.0;\n    if (il < idx) {\n        gamma = alpha * alpha / (alpha * alpha + beta * beta);\n    }\n    double tau = 0.0;\n    if (il < idx) {\n        tau = alpha * gamma / (alpha * alpha + beta * beta);\n    }\n    double hVec[il + 1];\n    for (int i = 0; i < il; i++) {\n        hVec[i] = matrixT[i][i];\n    }\n    for (int i = 0; i < il; i++) {\n        for (int j = i + 1; j < il; j++) {\n            hVec[j] -= tau * (hVec[j] - hVec[i]);\n        }\n    }\n    return il;\n}"
    ],
    [
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes()) {\n        if (node instanceof TextNode) {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return textNodes;\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes()) {\n        if (node instanceof TextNode) {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return textNodes;\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes()) {\n        if (node instanceof TextNode) {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return textNodes;\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode) {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return textNodes;\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes()) {\n        if (node instanceof TextNode) {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return textNodes;\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes()) {\n        if (node instanceof TextNode) {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return textNodes;\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode) {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return textNodes;\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof Text) {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return textNodes;\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes()) {\n        if (node instanceof TextNode) {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return textNodes;\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes()) {\n        if (node instanceof TextNode) {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return textNodes;\n}"
    ],
    [
      "public boolean inIncludeSegments()  {\n    Segment start = getSegment(segmentStart);\n    Segment end = getSegment(segmentEnd);\n    for (long i = start.getSegmentNumber(); i <= end.getSegmentNumber(); i++) {\n        if (!start.getSegment(i).isIncluded()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    Segment start = getSegment(segmentStart);\n    Segment end = getSegment(segmentEnd);\n    for (long i = start.getSegmentNumber(); i <= end.getSegmentNumber(); i++) {\n        if (!start.getSegment(i).isIncluded()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    Segment start = getSegment(this.segmentStart);\n    Segment end = getSegment(this.segmentEnd);\n    return start.isIncluded() && end.isIncluded();\n}",
      "public boolean inIncludeSegments()  {\n    Segment start = getSegment(segmentStart);\n    Segment end = getSegment(segmentEnd);\n    for (long i = start.getSegmentNumber(); i <= end.getSegmentNumber(); i++) {\n        if (!start.getSegment(i).isIncluded()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    Segment start = getSegment(this.segmentStart);\n    Segment end = getSegment(this.segmentEnd);\n    for (long i = start.getSegmentNumber(); i <= end.getSegmentNumber(); i++) {\n        if (!start.getSegment(i).isIncluded()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    Segment start = getSegment(segmentStart);\n    Segment end = getSegment(segmentEnd);\n    for (long i = start.getSegmentNumber(); i <= end.getSegmentNumber(); i++) {\n        if (!start.getSegment(i).isIncluded()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    Segment start = getSegment(segmentStart);\n    Segment end = getSegment(segmentEnd);\n    for (long i = start.getSegmentNumber(); i <= end.getSegmentNumber(); i++) {\n        if (!start.getSegment(i).isIncluded()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    Segment start = getSegment(segmentStart);\n    Segment end = getSegment(segmentEnd);\n    for (long i = start.getSegmentNumber(); i <= end.getSegmentNumber(); i++) {\n        if (!start.getSegment(i).isIncluded()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    Segment start = getSegment(segmentStart);\n    Segment end = getSegment(segmentEnd);\n    for (long i = start.getSegmentNumber(); i <= end.getSegmentNumber(); i++) {\n        if (!start.getSegment(i).isIncluded()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (long i = this.segmentStart; i <= this.segmentEnd; i++) {\n        Segment segment = getSegment(i);\n        if (!segment.isIncluded()) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null || zeroInstance == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        Chronology chrono = DateTimeUtils.getInstantChronology(start);\n        int amount = zeroInstance.getField(chrono).getDifference(end.getMillis(), start.getMillis());\n        return amount;\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null || zeroInstance == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        Chronology chrono = ISOChronology.getInstance();\n        int amount = zeroInstance.getFieldAmount(chrono);\n        return amount;\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null || zeroInstance == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        Chronology chrono = ISOChronology.getInstance();\n        int amount = zeroInstance.getFieldAmount(chrono);\n        int startAmount = start.get(chrono.getFieldType(amount));\n        int endAmount = end.get(chrono.getFieldType(amount));\n        return endAmount - startAmount;\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null || zeroInstance == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        Chronology chrono = DateTimeUtils.getInstantChronology(start);\n        int amount = zeroInstance.getFieldType().getField(chrono).getDifference(end.getMillis(), start.getMillis());\n        return amount;\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null || zeroInstance == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        Chronology chrono = DateTimeUtils.getInstantChronology(start);\n        int amount = zeroInstance.getField(chrono).getDifference(end.getMillis(), start.getMillis());\n        return amount;\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null || zeroInstance == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        Chronology chrono = DateTimeUtils.getInstantChronology(start);\n        int amount = zeroInstance.getFieldType().getField(chrono).getDifference(end.getMillis(), start.getMillis());\n        return amount;\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null || zeroInstance == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        Chronology chrono = DateTimeUtils.getInstantChronology(start);\n        int amount = zeroInstance.getPeriodType().getDurationField().getDifference(end.getMillis(), start.getMillis());\n        return amount;\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null || zeroInstance == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        Chronology chrono = DateTimeUtils.getInstantChronology(start);\n        int amount = zeroInstance.getPeriodType().getDurationField().getDifference(end.getMillis(), start.getMillis());\n        return amount;\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null || zeroInstance == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        Chronology chrono = DateTimeUtils.getInstantChronology(start);\n        int amount = zeroInstance.getPeriodType().getDurationField().getDifference(end.getMillis(), start.getMillis());\n        return amount;\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null || zeroInstance == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        Chronology chrono = DateTimeUtils.getInstantChronology(start);\n        int amount = zeroInstance.getField(chrono).getDifference(end.getMillis(), start.getMillis());\n        return amount;\n    }"
    ],
    [
      "public LegendTitle getLegend(int index)  {\n    return (LegendTitle) this.subtitles.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0) {\n        throw new IndexOutOfBoundsException(\"Index must be zero or greater.\");\n    }\n    if (index >= this.legends.size()) {\n        return null;\n    }\n    return this.legends.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    return (LegendTitle) this.subtitles.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= this.subtitles.size()) {\n        return null;\n    }\n    return (LegendTitle) this.subtitles.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    return this.subtitles.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= this.subtitles.size()) {\n        return null;\n    }\n    return (LegendTitle) this.subtitles.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    return this.subtitles.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    return (LegendTitle) this.subtitles.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    return this.subtitles.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    return (LegendTitle) this.subtitles.get(index);\n}"
    ],
    [
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    List<ZipArchiveEntry> entriesList = new ArrayList<>();\n    SeekableByteChannel channel = archive;\n    try {\n        ZipArchiveEntry entry;\n        while ((entry = getNextEntry(channel)) != null) {\n            entriesList.add(entry);\n        }\n    } catch (IOException e) {\n        throw new RuntimeException(\"Error reading entries\", e);\n    } finally {\n        IOUtils.closeQuietly(channel);\n    }\n    return Collections.enumeration(entriesList);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    List<ZipArchiveEntry> entriesList = new ArrayList<>();\n    SeekableByteChannel channel = archive;\n    ZipArchiveEntry entry;\n    while ((entry = readNextEntry(channel)) != null) {\n        entriesList.add(entry);\n    }\n    return Collections.enumeration(entriesList);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    List<ZipArchiveEntry> entriesList = new ArrayList<>();\n    SeekableByteChannel channel = archive;\n    ZipArchiveEntry entry;\n    while ((entry = getNextEntry(channel)) != null) {\n        entriesList.add(entry);\n    }\n    return Collections.enumeration(entriesList);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n}"
    ],
    [
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) {\n      skipEOLs();\n      if (match(JsDocToken.RC)) {\n        next();\n        return null;\n      }\n\n      if (match(JsDocToken.DOTDOT)) {\n        Node typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) {\n          skipEOLs();\n          if (!match(JsDocToken.RC)) {\n            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n          } else {\n            next();\n          }\n        }\n        return typeNode;\n      }\n\n      Node optionalParameterType = parseOptionalParameterType(next());\n      if (optionalParameterType != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n\n      return optionalParameterType;\n    } else {\n      return parseTopLevelTypeExpression(token);\n    }\n  }",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) {\n      skipEOLs();\n      Node node = null;\n      if (match(JsDocToken.OPTIONAL_PARAMETER_TYPE)) {\n        node = parseOptionalParameterType(next());\n      } else {\n        node = parseTopLevelTypeExpression(next());\n      }\n      if (node != null) {\n        skipEOLs();\n        if (match(JsDocToken.RC)) {\n          next();\n        } else {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        }\n      }\n      return node;\n    } else {\n      return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) {\n      skipEOLs();\n      if (match(JsDocToken.RC)) {\n        next();\n        return null;\n      }\n      Node typeNode = parseOptionalParameterType(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      } else {\n        typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) {\n          skipEOLs();\n          if (match(JsDocToken.RC)) {\n            next();\n          } else {\n            if (match(JsDocToken.Ellipsis)) {\n              typeNode = parseEllipsisTypeExpression(next());\n              if (typeNode != null) {\n                skipEOLs();\n                if (!match(JsDocToken.RC)) {\n                  reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } else {\n                  next();\n                }\n              }\n            } else {\n              reportTypeSyntaxWarning(\"msg.jsdoc.missing.ellipsis\");\n            }\n          }\n        }\n      }\n      return typeNode;\n    } else {\n      return parseTypeExpression(token);\n    }\n  }",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node paramTypeNode = parseOptionalParameterType(next());\n    if (paramTypeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    } else {\n      paramTypeNode = parseTopLevelTypeExpression(next());\n      if (paramTypeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      } else if (match(JsDocToken.Ellipsis)) {\n        next();\n        paramTypeNode = parseTopLevelTypeExpression(next());\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n    }\n    return paramTypeNode;\n  } else {\n    return parseTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) {\n      skipEOLs();\n      if (match(JsDocToken.RC)) {\n        next();\n        return null;\n      }\n      Node typeNode = parseOptionalParameterType(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      } else {\n        typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) {\n          skipEOLs();\n          if (!match(JsDocToken.RC)) {\n            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n          } else {\n            next();\n          }\n        } else if (match(JsDocToken.Ellipsis)) {\n          next();\n          typeNode = parseTopLevelTypeExpression(next());\n          if (typeNode != null) {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) {\n              reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } else {\n              next();\n            }\n          }\n        }\n      }\n      return typeNode;\n    } else {\n      return parseOptionalParameterType(token);\n    }\n  }",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    if (match(JsDocToken.RC)) {\n      next();\n      return null;\n    }\n    Node typeNode = parseOptionalParameterType(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    } else {\n      typeNode = parseTopLevelTypeExpression(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      } else if (match(JsDocToken.Ellipsis)) {\n        next();\n        typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) {\n          skipEOLs();\n          if (!match(JsDocToken.RC)) {\n            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n          } else {\n            next();\n          }\n        }\n      }\n    }\n    return typeNode;\n  } else {\n    return parseTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    if (match(JsDocToken.RC)) {\n      next();\n      return null;\n    }\n\n    Node typeNode = parseOptionalParameterType(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    } else {\n      typeNode = parseTopLevelTypeExpression(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      } else if (match(JsDocToken.Ellipsis)) {\n        next();\n        typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) {\n          skipEOLs();\n          if (!match(JsDocToken.RC)) {\n            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n          } else {\n            next();\n          }\n        }\n      }\n    }\n\n    return typeNode;\n  } else {\n    return parseTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node paramTypeNode = null;\n    if (match(JsDocToken.RC)) {\n      next();\n      return null;\n    }\n    if (match(JsDocToken.OPTIONAL_PARAMETER_TYPE)) {\n      paramTypeNode = parseOptionalParameterType(next());\n      if (paramTypeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n    } else {\n      paramTypeNode = parseTopLevelTypeExpression(next());\n      if (paramTypeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n    }\n    return paramTypeNode;\n  } else {\n    return parseTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    if (match(JsDocToken.RC)) {\n      next();\n      return null;\n    }\n    Node typeNode = parseOptionalParameterType(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    } else {\n      typeNode = parseTopLevelTypeExpression(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      } else if (match(JsDocToken.Ellipsis)) {\n        next();\n        typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) {\n          skipEOLs();\n          if (!match(JsDocToken.RC)) {\n            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n          } else {\n            next();\n          }\n        }\n      }\n    }\n    return typeNode;\n  } else {\n    return parseTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    if (match(JsDocToken.RC)) {\n      next();\n      return null;\n    }\n    Node typeNode = parseOptionalParameterType(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    } else {\n      typeNode = parseTopLevelTypeExpression(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      } else if (match(JsDocToken.Ellipsis)) {\n        next();\n        typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) {\n          skipEOLs();\n          if (!match(JsDocToken.RC)) {\n            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n          } else {\n            next();\n          }\n        }\n      }\n    }\n    return typeNode;\n  } else {\n    return parseTypeExpression(token);\n  }\n}"
    ],
    [
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> frames = new ArrayList<String>();\n    String[] stackFrames = getStackFrames(t);\n    for (String frame : stackFrames) {\n        if (!frame.startsWith(\"at \")) {\n            frames.add(frame);\n        } else {\n            break;\n        }\n    }\n    return removeCommonFrames(getStackFrames(t.getCause()), frames);\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    if (t == null) {\n        return new ArrayList<String>();\n    }\n    List<String> frames = getStackFrames(getStackTrace(t));\n    removeCommonFrames(frames, getStackFrames(getStackTrace(t.getCause())));\n    return frames;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> frames = getStackFrames(t);\n    if (t.getCause() != null) {\n        frames = removeCommonFrames(getStackFrames(t.getCause()), frames);\n    }\n    return frames;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> stackFrames = getStackFrames(t);\n    return removeCommonFrames(getStackFrames(t.getCause()), stackFrames);\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> frames = getStackFrames(t);\n    List<String> result = new ArrayList<String>();\n    for (String frame : frames) {\n        if (!frame.startsWith(\"at \")) {\n            result.add(frame);\n        } else {\n            break;\n        }\n    }\n    return removeCommonFrames(getStackFrames(t), result);\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> stackFrames = getStackFrames(t);\n    return removeCommonFrames(getStackFrames(t.getCause()), stackFrames);\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    return getStackFrames(getStackTrace(t));\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    return getStackFrames(getStackTrace(t)).subList(1, getStackFrames(getStackTrace(t)).length);\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> stackFrames = getStackFrames(t);\n    return removeCommonFrames(getStackFrames(t.getCause()), stackFrames);\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    return getStackFrames(getStackTrace(t));\n}"
    ],
    [
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n        peeked = PEEKED_NONE;\n        return true;\n    } else if (p == PEEKED_FALSE) {\n        peeked = PEEKED_NONE;\n        return false;\n    } else if (p == PEEKED_NUMBER) {\n        int value = parseInt(buffer, pos, peekedNumberLength);\n        peeked = PEEKED_NONE;\n        if (value == 0) {\n            return false;\n        } else {\n            return true;\n        }\n    } else {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    return true;\n  } else if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    return false;\n  } else {\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n  }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE || p == PEEKED_FALSE) {\n    boolean result = p == PEEKED_TRUE;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  } else {\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n  }\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    boolean result = true;\n    peeked = PEEKED_NONE;\n    return result;\n  } else if (p == PEEKED_FALSE) {\n    boolean result = false;\n    peeked = PEEKED_NONE;\n    return result;\n  } else {\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n  }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      return false;\n    } else if (p == PEEKED_NUMBER) {\n      String s = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n      peeked = PEEKED_NONE;\n      if (s.equals(\"true\")) {\n        return true;\n      } else if (s.equals(\"false\")) {\n        return false;\n      } else {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    return true;\n  } else if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    return false;\n  } else if (p == PEEKED_BUFFERED) {\n    if (peekedString.equals(\"true\")) {\n      peekedString = null;\n      return true;\n    } else if (peekedString.equals(\"false\")) {\n      peekedString = null;\n      return false;\n    }\n  } else if (p == PEEKED_NUMBER) {\n    if (peekedLong == 1L) {\n      pos += peekedNumberLength;\n      peeked = PEEKED_NONE;\n      return true;\n    } else if (peekedLong == 0L) {\n      pos += peekedNumberLength;\n      peeked = PEEKED_NONE;\n      return false;\n    }\n  }\n  throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    return true;\n  } else if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    return false;\n  } else {\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n  }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      return false;\n    } else if (p == PEEKED_NUMBER) {\n      if (peekedLong == 1) {\n        peeked = PEEKED_NONE;\n        return true;\n      } else if (peekedLong == 0) {\n        peeked = PEEKED_NONE;\n        return false;\n      } else {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE || p == PEEKED_FALSE) {\n    boolean result = p == PEEKED_TRUE;\n    peeked = PEEKED_NONE;\n    return result;\n  } else {\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n  }\n}"
    ],
    [
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null) {\n        return null;\n    }\n    if (size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads == 0) {\n        return str;\n    }\n    final char[] padding = new char[pads];\n    for (int i = 0; i < pads; i++) {\n        padding[i] = padChar;\n    }\n    return new String(padding) + str + new String(padding);\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null) {\n        return null;\n    }\n    if (size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads == 0) {\n        return str;\n    }\n    final char[] padding = new char[pads];\n    for (int i = 0; i < pads; i++) {\n        padding[i] = padChar;\n    }\n    return new String(padding) + str + new String(padding);\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null) {\n        return null;\n    }\n    if (size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads == 0) {\n        return str;\n    }\n    final char[] padding = new char[pads];\n    for (int i = 0; i < pads; i++) {\n        padding[i] = padChar;\n    }\n    return new String(padding) + str + new String(padding);\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null) {\n        return null;\n    }\n    if (size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads == 0) {\n        return str;\n    }\n    if (pads < 0) {\n        return str;\n    }\n    final char[] padding = new char[pads];\n    for (int i = 0; i < pads; i++) {\n        padding[i] = padChar;\n    }\n    return new String(padding).concat(str).concat(new String(padding));\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null) {\n        return null;\n    }\n    if (size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads == 0) {\n        return str;\n    }\n    if (pads < 0) {\n        return str;\n    }\n    final char[] padding = new char[pads];\n    for (int i = 0; i < pads; i++) {\n        padding[i] = padChar;\n    }\n    return new String(padding).concat(str).concat(new String(padding));\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null) {\n        return null;\n    }\n    if (size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads == 0) {\n        return str;\n    }\n    final char[] padding = new char[pads];\n    for (int i = 0; i < pads; i++) {\n        padding[i] = padChar;\n    }\n    return new String(padding) + str + new String(padding);\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null) {\n        return null;\n    }\n    if (size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads == 0) {\n        return str;\n    }\n    final char[] padding = new char[pads];\n    for (int i = 0; i < pads; i++) {\n        padding[i] = padChar;\n    }\n    return new String(padding) + str + new String(padding);\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null) {\n        return null;\n    }\n    if (size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads == 0) {\n        return str;\n    }\n    final char[] padding = new char[pads];\n    for (int i = 0; i < pads; i++) {\n        padding[i] = padChar;\n    }\n    return new String(padding).concat(str).concat(new String(padding));\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null) {\n        return null;\n    }\n    if (size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads == 0) {\n        return str;\n    }\n    final char[] padding = new char[pads];\n    for (int i = 0; i < pads; i++) {\n        padding[i] = padChar;\n    }\n    return new String(padding).concat(str).concat(new String(padding));\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null) {\n        return null;\n    }\n    if (size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads == 0) {\n        return str;\n    }\n    final char[] padding = new char[pads];\n    for (int i = 0; i < pads; i++) {\n        padding[i] = padChar;\n    }\n    return new String(padding) + str + new String(padding);\n}"
    ],
    [
      "private boolean argsMayHaveSideEffects(Node call)  {\n    if (call.getChildCount() != 3) {\n      return false;\n    }\n\n    Node expectedBlock = call.getLastChild();\n    return !NodeUtil.isEmptyBlock(expectedBlock);\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node callee = call.getLastChild();\n    if (!callee.isMethod()) {\n        return false;\n    }\n    Node expectedBlock = getMethodBlock(callee);\n    if (expectedBlock == null) {\n        return false;\n    }\n    return !isEmptyMethod(callee) || !NodeUtil.isEmptyBlock(expectedBlock);\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    if (call.getLastChild().isBlock()) {\n        return true;\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    if (call.getLastChild().isBlock()) {\n        return true;\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    if (call.getFirstChild().getFirstChild().isString()) {\n        return false;\n    }\n    return true;\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node method = call.getFirstChild();\n    if (!method.isName()) {\n        return true;\n    }\n    Node methodBlock = getMethodBlock(method);\n    if (methodBlock == null) {\n        return true;\n    }\n    return !isEmptyMethod(methodBlock);\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    if (!NodeUtil.isExprCall(call)) {\n        return false;\n    }\n    Node callee = call.getFirstChild();\n    if (!callee.isMethodCall()) {\n        return false;\n    }\n    Node method = callee.getFirstChild();\n    if (!method.isMethod()) {\n        return false;\n    }\n    if (isEmptyMethod(method)) {\n        return false;\n    }\n    return !allDefinitionsEquivalent(getMethodBlock(method).getChildren());\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    if (!expectedReturn.hasOneChild()) {\n      return false;\n    }\n\n    return !NodeUtil.isEmptyBlock(expectedReturn.getLastChild());\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node method = call.getFirstChild();\n    if (!method.isName()) {\n        return true;\n    }\n    Node obj = method.getNext();\n    if (!obj.isGetProp()) {\n        return true;\n    }\n    Node prop = obj.getLastChild();\n    if (!prop.isString()) {\n        return true;\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    if (call.getChildCount() == 0) {\n        return false;\n    }\n    Node arg = call.getFirstChild();\n    return !isEmptyMethod(arg);\n}"
    ],
    [
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i] - 1, field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n            for (int j = 0; j < m; ++j) {\n                if (i != j) {\n                    cachedP.setEntry(i, j, field.getZero());\n                }\n            }\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n            for (int j = 0; j < m; ++j) {\n                if (i != j) {\n                    cachedP.setEntry(i, j, field.getZero());\n                }\n            }\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; i++) {\n            cachedP.setEntry(i, pivot[i] - 1, field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n            for (int j = 0; j < m; ++j) {\n                if (j != pivot[i]) {\n                    cachedP.setEntry(i, j, field.getZero());\n                }\n            }\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; i++) {\n            cachedP.setEntry(i, pivot[i] - 1, field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(pivot[i], i, field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; i++) {\n            cachedP.setEntry(pivot[i], i, field.getOne());\n            for (int j = 0; j < m; j++) {\n                if (j != i) {\n                    cachedP.setEntry(i, j, field.getZero());\n                }\n            }\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i] - 1, field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(pivot[i], i, field.getOne());\n        }\n    }\n    return cachedP;\n}"
    ],
    [
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    int length = 0;\n    for (ZipExtraField ze : data) {\n        if (ze instanceof LocalFileData) {\n            length += ((LocalFileData) ze).getLength();\n        }\n    }\n    byte[] result = new byte[length];\n    int offset = 0;\n    for (ZipExtraField ze : data) {\n        if (ze instanceof LocalFileData) {\n            ((LocalFileData) ze).write(result, offset);\n            offset += ((LocalFileData) ze).getLength();\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    byte[] result = new byte[0];\n    for (ZipExtraField ze : data) {\n        if (ze instanceof LocalFileData) {\n            byte[] localFileData = ((LocalFileData) ze).getData();\n            byte[] newResult = new byte[result.length + localFileData.length];\n            System.arraycopy(result, 0, newResult, 0, result.length);\n            System.arraycopy(localFileData, 0, newResult, result.length, localFileData.length);\n            result = newResult;\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    byte[] result = new byte[0];\n    for (ZipExtraField ze : data) {\n        if (ze instanceof LocalFileData) {\n            byte[] localFileData = ((LocalFileData) ze).getLocalFileData();\n            byte[] mergedData = new byte[result.length + localFileData.length];\n            System.arraycopy(result, 0, mergedData, 0, result.length);\n            System.arraycopy(localFileData, 0, mergedData, result.length, localFileData.length);\n            result = mergedData;\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    if (data == null || data.length == 0) {\n        return new byte[0];\n    }\n    byte[] result = new byte[0];\n    for (ZipExtraField ze : data) {\n        if (ze instanceof LocalFileData) {\n            LocalFileData lfd = (LocalFileData) ze;\n            byte[] lfdData = lfd.getLocalFileData();\n            if (result.length == 0) {\n                result = lfdData;\n            } else {\n                byte[] newResult = new byte[result.length + lfdData.length];\n                System.arraycopy(result, 0, newResult, 0, result.length);\n                System.arraycopy(lfdData, 0, newResult, result.length, lfdData.length);\n                result = newResult;\n            }\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    int length = 0;\n    for (ZipExtraField ze : data) {\n        if (ze instanceof LocalFileData) {\n            length += ((LocalFileData) ze).getLength();\n        }\n    }\n    byte[] result = new byte[length];\n    int pos = 0;\n    for (ZipExtraField ze : data) {\n        if (ze instanceof LocalFileData) {\n            ((LocalFileData) ze).write(result, pos);\n            pos += ((LocalFileData) ze).getLength();\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    int totalLength = 0;\n    for (ZipExtraField ze : data) {\n        if (ze instanceof LocalFileData) {\n            totalLength += WORD + ((LocalFileData) ze).getData().length;\n        }\n    }\n    byte[] result = new byte[totalLength];\n    int offset = 0;\n    for (ZipExtraField ze : data) {\n        if (ze instanceof LocalFileData) {\n            ZipShort headerId = new ZipShort(result, offset);\n            ZipShort length = new ZipShort(result, offset + 2);\n            length.setValue(((LocalFileData) ze).getData().length);\n            offset += WORD + length.getValue();\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    byte[] result = new byte[0];\n    for (ZipExtraField ze : data) {\n        if (ze instanceof LocalFileData) {\n            byte[] localData = ((LocalFileData) ze).getData();\n            byte[] newData = new byte[result.length + localData.length];\n            System.arraycopy(result, 0, newData, 0, result.length);\n            System.arraycopy(localData, 0, newData, result.length, localData.length);\n            result = newData;\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    int length = 0;\n    for (ZipExtraField ze : data) {\n        if (ze instanceof LocalFileData) {\n            length += WORD + ((LocalFileData) ze).getLength();\n        }\n    }\n    byte[] result = new byte[length];\n    int start = 0;\n    for (ZipExtraField ze : data) {\n        if (ze instanceof LocalFileData) {\n            byte[] zeData = ((LocalFileData) ze).getBytes();\n            System.arraycopy(zeData, WORD, result, start, zeData.length - WORD);\n            start += zeData.length - WORD;\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    if (data == null || data.length == 0) {\n        return new byte[0];\n    }\n    byte[] result = new byte[0];\n    for (ZipExtraField ze : data) {\n        if (ze instanceof LocalFileData) {\n            byte[] localData = ((LocalFileData) ze).getLocalFileData();\n            byte[] newData = new byte[result.length + localData.length];\n            System.arraycopy(result, 0, newData, 0, result.length);\n            System.arraycopy(localData, 0, newData, result.length, localData.length);\n            result = newData;\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    byte[] result = new byte[0];\n    for (ZipExtraField ze : data) {\n        if (ze instanceof LocalFileData) {\n            LocalFileData lfd = (LocalFileData) ze;\n            byte[] lfdData = lfd.getLocalFileData();\n            result = add(result, lfdData);\n        }\n    }\n    return result;\n}"
    ],
    [
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? sup : Double.POSITIVE_INFINITY;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? sup : Double.POSITIVE_INFINITY;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? sup : Double.POSITIVE_INFINITY;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? sup : Double.POSITIVE_INFINITY;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? sup : Double.POSITIVE_INFINITY;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? sup : Double.POSITIVE_INFINITY;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? sup : Double.POSITIVE_INFINITY;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? sup : Double.POSITIVE_INFINITY;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? sup : Double.POSITIVE_INFINITY;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? sup : Double.POSITIVE_INFINITY;\n}"
    ],
    [
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    token.content.append((char) ch);\n    boolean eol = readEndOfLine(ch);\n    while (!eol && !isEndOfFile(ch) && !isDelimiter(ch)) {\n        ch = reader.read();\n        eol = readEndOfLine(ch);\n        token.content.append((char) ch);\n    }\n    if (isEndOfFile(ch)) {\n        token.type = EOF;\n    } else if (eol) {\n        token.type = EORECORD;\n    } else {\n        token.type = TOKEN;\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    token.content.append((char) ch);\n    while (true) {\n        ch = reader.read();\n        if (isEndOfFile(ch)) {\n            token.type = EOF;\n            return token;\n        }\n        if (eol = readEndOfLine(ch)) {\n            token.type = EORECORD;\n            return token;\n        }\n        if (isDelimiter(ch)) {\n            if (!isEscaped(ch)) {\n                token.type = TOKEN;\n                return token;\n            }\n            // consume escaped delimiter\n            ch = reader.read();\n            if (isEndOfFile(ch)) {\n                token.type = EOF;\n                return token;\n            }\n            if (eol = readEndOfLine(ch)) {\n                token.type = EORECORD;\n                return token;\n            }\n        }\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    token.content.append((char) ch);\n    while (true) {\n        ch = reader.read();\n        if (isEndOfFile(ch)) {\n            token.type = EOF;\n            return token;\n        }\n        if (eol = readEndOfLine(ch)) {\n            token.type = EORECORD;\n            return token;\n        }\n        if (isDelimiter(ch)) {\n            if (!isEscaped(ch)) {\n                token.type = TOKEN;\n                return token;\n            }\n            // handle escaped delimiter\n            ch = reader.read();\n            if (isEndOfFile(ch)) {\n                token.type = EOF;\n                return token;\n            }\n            if (isDelimiter(ch)) {\n                token.content.append((char) ch);\n            }\n        }\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    if (isEndOfFile(ch)) {\n        token.type = EOF;\n        token.isReady = true; // there is data at EOF\n        return token;\n    }\n\n    if (isDelimiter(ch)) {\n        if (!isEscaped(ch)) {\n            token.type = TOKEN;\n        } else {\n            // consume the escaped delimiter\n            ch = reader.read();\n            if (isEndOfFile(ch)) {\n                token.type = EOF;\n                token.isReady = true; // there is data at EOF\n                return token;\n            }\n        }\n    } else if (isEndOfLine(ch)) {\n        token.type = EORECORD;\n    } else {\n        // add the character to the token content\n        token.content.append((char) ch);\n    }\n\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    token.content.append((char) ch);\n    while (true) {\n        ch = reader.read();\n        if (isEndOfFile(ch)) {\n            token.type = EOF;\n            return token;\n        }\n        if (isEndOfLine(ch)) {\n            token.type = EORECORD;\n            return token;\n        }\n        if (isDelimiter(ch)) {\n            if (!isEscaped(ch)) {\n                token.type = TOKEN;\n                return token;\n            }\n            // consume escaped delimiter\n            ch = reader.read();\n            if (isEndOfFile(ch)) {\n                token.type = EOF;\n                return token;\n            }\n        }\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    token.content.append((char) ch);\n    while (true) {\n        ch = reader.read();\n        if (isEndOfFile(ch)) {\n            token.type = EOF;\n            return token;\n        }\n        if (isEndOfLine(ch)) {\n            token.type = EORECORD;\n            return token;\n        }\n        if (isDelimiter(ch)) {\n            if (!isEscapedDelimiter(ch)) {\n                token.type = TOKEN;\n                return token;\n            }\n            token.content.append((char) ch);\n        } else if (isQuoteChar(ch)) {\n            // consume encapsulated token\n            parseEncapsulatedToken(token);\n        }\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    token.content.append((char) ch);\n    while (true) {\n        ch = reader.read();\n        if (isEndOfFile(ch)) {\n            token.type = EOF;\n            return token;\n        }\n        if (isEndOfLine(ch)) {\n            token.type = EORECORD;\n            return token;\n        }\n        if (isDelimiter(ch)) {\n            if (!isEscaped(ch)) {\n                token.type = TOKEN;\n                return token;\n            }\n        }\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    token.content.append((char) ch);\n    while (true) {\n        ch = reader.read();\n        if (isEndOfFile(ch)) {\n            token.type = EOF;\n            return token;\n        }\n        if (isEndOfLine(ch)) {\n            token.type = EORECORD;\n            return token;\n        }\n        if (isDelimiter(ch)) {\n            if (!isEscapedDelimiter(ch)) {\n                token.type = TOKEN;\n                return token;\n            }\n            token.content.append((char) ch);\n        } else if (isQuoteChar(ch)) {\n            // consume encapsulated token\n            parseEncapsulatedToken(token);\n        }\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    token.content.append((char) ch);\n    while (true) {\n        ch = reader.read();\n        if (isEndOfFile(ch)) {\n            token.type = EOF;\n            return token;\n        }\n        if (isEndOfLine(ch)) {\n            token.type = EORECORD;\n            return token;\n        }\n        if (isDelimiter(ch)) {\n            if (!isEscaped(ch)) {\n                token.type = TOKEN;\n                return token;\n            }\n        }\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    token.content.append((char) ch);\n    boolean eol = readEndOfLine(ch);\n    while (!eol) {\n        if (isEndOfFile(ch)) {\n            token.type = EOF;\n            return token;\n        }\n        if (isDelimiter(ch)) {\n            if (!isEscapedDelimiter(ch)) {\n                token.type = TOKEN;\n                return token;\n            }\n        }\n        ch = reader.read();\n        eol = readEndOfLine(ch);\n    }\n    token.type = EORECORD;\n    return token;\n}"
    ],
    [
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(\"Index \" + index + \" is out of range\");\n    }\n\n    int[] counts = new int[dimension];\n    int tempIndex = index;\n\n    for (int i = dimension - 1; i >= 0; i--) {\n        counts[i] = tempIndex % size[i];\n        tempIndex /= size[i];\n    }\n\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if(index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(\"Index is out of range\");\n    }\n    int[] counts = new int[dimension];\n    int i = last;\n    while(i >= 0) {\n        counts[i] = index % size[i];\n        index = index / size[i];\n        i--;\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(\"Index out of range\");\n    }\n    int[] result = new int[dimension];\n    int t = index;\n    for (int i = dimension - 1; i >= 0; i--) {\n        result[i] = t % size[i];\n        t /= size[i];\n    }\n    return result;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(\"Index out of range\");\n    }\n    int[] counts = new int[dimension];\n    int tempIndex = index;\n    for (int i = dimension - 1; i >= 0; i--) {\n        counts[i] = tempIndex % size[i];\n        tempIndex /= size[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(\"Index out of range\");\n    }\n\n    int[] counts = new int[dimension];\n    int tIndex = index;\n\n    for (int i = dimension - 1; i >= 0; i--) {\n        counts[i] = tIndex % size[i];\n        tIndex /= size[i];\n    }\n\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(\"Index out of range\");\n    }\n    int[] counts = new int[dimension];\n    int tIndex = index;\n    for (int i = dimension - 1; i >= 0; i--) {\n        counts[i] = tIndex % size[i];\n        tIndex /= size[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if(index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(\"Index is out of range\");\n    }\n    int[] counts = new int[dimension];\n    int t = index;\n    for(int i = dimension - 1; i >= 0; i--) {\n        counts[i] = t % size[i];\n        t /= size[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(\"Index out of range\");\n    }\n\n    int[] counts = new int[dimension];\n    int tIndex = index;\n\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = tIndex % size[i];\n        tIndex /= size[i];\n    }\n\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(\"Index out of range\");\n    }\n    int[] counts = new int[dimension];\n    int i = last;\n    int t = index;\n    while (i >= 0) {\n        counts[i] = t % size[i];\n        t = t / size[i];\n        i--;\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(\"Index out of range\");\n    }\n\n    int[] counts = new int[dimension];\n    int i = index;\n    for (int j = dimension - 1; j >= 0; j--) {\n        counts[j] = i % size[j];\n        i /= size[j];\n    }\n    return counts;\n}"
    ],
    [
      "public JsonPointer last()  {\n    JsonPointer tail = null;\n    for (JsonPointer context = this; context != null; context = context.getParent()) {\n        if (context.inObject()) {\n            String seg = context.getCurrentName();\n            if (seg == null) { // is this legal?\n                seg = \"\";\n            }\n            tail = new JsonPointer(_fullPath(tail, seg), seg, tail);\n        } else if (context.inArray() || context.inRoot()) {\n            int ix = context.getCurrentIndex();\n            String ixStr = String.valueOf(ix);\n            tail = new JsonPointer(_fullPath(tail, ixStr), ixStr, ix, tail);\n        }\n    }\n    if (tail == null) {\n        return EMPTY;\n    }\n    return tail;\n}",
      "public JsonPointer last()  {\n    JsonPointer tail = null;\n    for (JsonContext context = this; context != null; context = context.getParent()) {\n        if (context.inObject()) {\n            String seg = context.getCurrentName();\n            if (seg == null) {\n                seg = \"\";\n            }\n            tail = new JsonPointer(_fullPath(tail, seg), seg, tail);\n        } else if (context.inArray() || this.inRoot()) {\n            int ix = context.getCurrentIndex();\n            String ixStr = String.valueOf(ix);\n            tail = new JsonPointer(_fullPath(tail, ixStr), ixStr, ix, tail);\n        }\n    }\n    if (tail == null) {\n        return EMPTY;\n    }\n    return tail;\n}",
      "public JsonPointer last()  {\n    JsonPointer tail = null;\n    for (JsonContext context = this; context != null; context = context.getParent()) {\n        if (context.inObject()) {\n            String seg = context.getCurrentName();\n            if (seg == null) {\n                seg = \"\";\n            }\n            tail = new JsonPointer(_fullPath(tail, seg), seg, tail);\n        } else if (context.inArray() || this.inRoot()) {\n            int ix = context.getCurrentIndex();\n            String ixStr = String.valueOf(ix);\n            tail = new JsonPointer(_fullPath(tail, ixStr), ixStr, ix, tail);\n        }\n    }\n    if (tail == null) {\n        return EMPTY;\n    }\n    return tail;\n}",
      "public JsonPointer last()  {\n    JsonPointer tail = null;\n    for (JsonContext context = this; context != null; context = context.getParent()) {\n        if (context.inObject()) {\n            String seg = context.getCurrentName();\n            if (seg == null) {\n                seg = \"\";\n            }\n            tail = new JsonPointer(_fullPath(tail, seg), seg, tail);\n        } else if (context.inArray() || this.inRoot()) {\n            int ix = context.getCurrentIndex();\n            String ixStr = String.valueOf(ix);\n            tail = new JsonPointer(_fullPath(tail, ixStr), ixStr, ix, tail);\n        }\n    }\n    if (tail == null) {\n        return EMPTY;\n    }\n    return tail;\n}",
      "public JsonPointer last()  {\n    JsonPointer tail = null;\n    for (JsonPointer context = this; context != null; context = context.getParent()) {\n        if (context.inObject()) {\n            String seg = context.getCurrentName();\n            if (seg == null) {\n                seg = \"\";\n            }\n            tail = new JsonPointer(_fullPath(tail, seg), seg, tail);\n        } else if (context.inArray() || context.inRoot()) {\n            int ix = context.getCurrentIndex();\n            String ixStr = String.valueOf(ix);\n            tail = new JsonPointer(_fullPath(tail, ixStr), ixStr, ix, tail);\n        }\n    }\n    return tail;\n}",
      "public JsonPointer last()  {\n    JsonPointer tail = null;\n    for (JsonPointer context = this; context != null; context = context.getParent()) {\n        if (context.inObject()) {\n            String seg = context.getCurrentName();\n            if (seg == null) {\n                seg = \"\";\n            }\n            tail = new JsonPointer(_fullPath(tail, seg), seg, tail);\n        } else if (context.inArray() || context.inRoot()) {\n            int ix = context.getCurrentIndex();\n            String ixStr = String.valueOf(ix);\n            tail = new JsonPointer(_fullPath(tail, ixStr), ixStr, ix, tail);\n        }\n    }\n    return tail;\n}",
      "public JsonPointer last()  {\n    JsonPointer tail = null;\n    for (JsonPointer context = this; context != null; context = context.getParent()) {\n        if (context.inObject()) {\n            String seg = context.getCurrentName();\n            if (seg == null) {\n                seg = \"\";\n            }\n            tail = new JsonPointer(_fullPath(tail, seg), seg, tail);\n        } else if (context.inArray() || context.inRoot()) {\n            int ix = context.getCurrentIndex();\n            String ixStr = String.valueOf(ix);\n            tail = new JsonPointer(_fullPath(tail, ixStr), ixStr, ix, tail);\n        }\n    }\n    return tail;\n}",
      "public JsonPointer last()  {\n    JsonPointer tail = null;\n    for (JsonContext context = this; context != null; context = context.getParent()) {\n        if (context.inObject()) {\n            String seg = context.getCurrentName();\n            if (seg == null) {\n                seg = \"\";\n            }\n            tail = new JsonPointer(_fullPath(tail, seg), seg, tail);\n        } else if (context.inArray() || this.inRoot()) {\n            int ix = context.getCurrentIndex();\n            String ixStr = String.valueOf(ix);\n            tail = new JsonPointer(_fullPath(tail, ixStr), ixStr, ix, tail);\n        }\n    }\n    if (tail == null) {\n        return EMPTY;\n    }\n    return tail;\n}",
      "public JsonPointer last()  {\n    JsonPointer tail = null;\n    for (JsonPointer context = this; context != null; context = context.getParent()) {\n        if (context.inObject()) {\n            String seg = context.getCurrentName();\n            if (seg == null) { // is this legal?\n                seg = \"\";\n            }\n            tail = new JsonPointer(_fullPath(tail, seg), seg, tail);\n        } else if (context.inArray() || context.inRoot()) {\n            int ix = context.getCurrentIndex();\n            String ixStr = String.valueOf(ix);\n            tail = new JsonPointer(_fullPath(tail, ixStr), ixStr, ix, tail);\n        }\n    }\n    return tail;\n}",
      "public JsonPointer last()  {\n    JsonPointer tail = null;\n    for (JsonPointer context = this; context != null; context = context.getParent()) {\n        if (context.inObject()) {\n            String seg = context.getCurrentName();\n            if (seg == null) { // is this legal?\n                seg = \"\";\n            }\n            tail = new JsonPointer(_fullPath(tail, seg), seg, tail);\n        } else if (context.inArray() || context == this) {\n            int ix = context.getCurrentIndex();\n            String ixStr = String.valueOf(ix);\n            tail = new JsonPointer(_fullPath(tail, ixStr), ixStr, ix, tail);\n        }\n    }\n    if (tail == null) {\n        return EMPTY;\n    }\n    return tail;\n}"
    ],
    [
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    byte[] buffer = new byte[1024];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[1024];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    byte[] buffer = new byte[1024];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    byte[] buffer = new byte[1024];\n    int nRead;\n    do {\n        nRead = data.read(buffer);\n        if (nRead > 0) {\n            digest.update(buffer, 0, nRead);\n        }\n    } while (nRead > 0);\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[1024];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[1024];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    byte[] buffer = new byte[1024];\n    int nRead;\n    do {\n        nRead = data.read(buffer);\n        if (nRead > 0) {\n            digest.update(buffer, 0, nRead);\n        }\n    } while (nRead > 0);\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[1024];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    byte[] buffer = new byte[1024];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    byte[] buffer = new byte[1024];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}"
    ],
    [
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        try {\n            return (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n        } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {\n            throw new CloneFailedException(\"Failed to clone object\", e);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        try {\n            return (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n        } catch (IllegalAccessException e) {\n            throw new CloneFailedException(\"Clone operation failed\", e);\n        } catch (InvocationTargetException e) {\n            throw new CloneFailedException(\"Clone operation failed\", e);\n        } catch (NoSuchMethodException e) {\n            throw new CloneFailedException(\"Clone operation failed\", e);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        }\n        try {\n            return (T) obj.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new CloneFailedException(\"Failed to clone object: \" + e.getMessage());\n        }\n    }",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        }\n        try {\n            return (T) obj.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new CloneFailedException(e);\n        }\n    }",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        try {\n            return (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n        } catch (Exception e) {\n            throw new CloneFailedException(\"Clone operation failed\", e);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    try {\n        return (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n    } catch (Exception e) {\n        throw new CloneFailedException(\"Failed to clone object\", e);\n    }\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    try {\n        return (T) obj.clone();\n    } catch (CloneNotSupportedException e) {\n        throw new CloneFailedException(\"Failed to clone \" + obj.getClass().getName(), e);\n    }\n}",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        }\n        try {\n            return (T) obj.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new CloneFailedException(e);\n        }\n    }",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        try {\n            return (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n        } catch (NoSuchMethodException e) {\n            throw new CloneFailedException(\"Object does not implement Cloneable and has no clone method\");\n        } catch (IllegalAccessException e) {\n            throw new CloneFailedException(\"Clone operation failed due to IllegalAccessException\");\n        } catch (InvocationTargetException e) {\n            throw new CloneFailedException(\"Clone operation failed due to InvocationTargetException\");\n        }\n    } else {\n        return null;\n    }\n}",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        }\n        try {\n            return (T) obj.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new CloneFailedException(\"Failed to clone object\", e);\n        }\n    }"
    ],
    [
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.isFunction()) {\n        List<Symbol> params = sym.getParameters();\n        for (Symbol param : params) {\n            if (param.getName().equals(paramName)) {\n                return param;\n            }\n        }\n    }\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.isFunction()) {\n        for (Map.Entry<String, Symbol> entry : sym.parameters.entrySet()) {\n            if (entry.getKey().equals(paramName)) {\n                return entry.getValue();\n            }\n        }\n    }\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.isFunction()) {\n        List<Symbol> params = sym.getParameters();\n        for (Symbol param : params) {\n            if (param.getName().equals(paramName)) {\n                return param;\n            }\n        }\n    }\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.isFunction()) {\n        List<Parameter> parameters = sym.getFunction().getParameters();\n        for (Parameter parameter : parameters) {\n            if (parameter.getName().equals(paramName)) {\n                return parameter.getSymbol();\n            }\n        }\n    }\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym instanceof FunctionSymbol) {\n        FunctionSymbol functionSymbol = (FunctionSymbol) sym;\n        for (Symbol param : functionSymbol.getParameters()) {\n            if (param.getName().equals(paramName)) {\n                return param;\n            }\n        }\n    }\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.isFunction()) {\n        for (Symbol param : sym.getParameters()) {\n            if (param.getName().equals(paramName)) {\n                return param;\n            }\n        }\n    }\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym instanceof FunctionSymbol) {\n        FunctionSymbol func = (FunctionSymbol) sym;\n        for (ParameterSymbol param : func.getParameters()) {\n            if (param.getName().equals(paramName)) {\n                return param;\n            }\n        }\n    }\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym instanceof FunctionSymbol) {\n        FunctionSymbol func = (FunctionSymbol) sym;\n        for (Symbol param : func.getParameters()) {\n            if (param.getName().equals(paramName)) {\n                return param;\n            }\n        }\n    }\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym instanceof FunctionSymbol) {\n        FunctionSymbol func = (FunctionSymbol) sym;\n        for (ParameterSymbol param : func.getParameters()) {\n            if (param.getName().equals(paramName)) {\n                return param;\n            }\n        }\n    }\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.isFunction()) {\n        List<Parameter> parameters = sym.getFunction().getParameters();\n        for (Parameter param : parameters) {\n            if (param.getName().equals(paramName)) {\n                return param.getSymbol();\n            }\n        }\n    }\n    return null;\n}"
    ],
    [
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    int rows = matrix.getRowDimension();\n    int cols = matrix.getColumnDimension();\n\n    if (rows < 2 || cols < 1) {\n        throw new MathIllegalArgumentException(\"The input matrix must have at least one column and two rows\");\n    }\n\n    double[] means = new double[cols];\n    for (int j = 0; j < cols; j++) {\n        double sum = 0;\n        for (int i = 0; i < rows; i++) {\n            sum += matrix.getEntry(i, j);\n        }\n        means[j] = sum / rows;\n    }\n\n    RealMatrix covarianceMatrix = new Array2DRowRealMatrix(rows, cols);\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            double sum = 0;\n            for (int k = 0; k < rows; k++) {\n                sum += (matrix.getEntry(k, j) - means[j]) * (matrix.getEntry(k, i) - means[i]);\n            }\n            if (biasCorrected) {\n                sum /= rows - 1;\n            } else {\n                sum /= rows;\n            }\n            covarianceMatrix.setEntry(i, j, sum);\n        }\n    }\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    int rows = matrix.getRowDimension();\n    int cols = matrix.getColumnDimension();\n    if(rows < 2 || cols < 1) {\n        throw new MathIllegalArgumentException(\"The input matrix must have at least one column and two rows\");\n    }\n    double[] means = new double[cols];\n    for(int j = 0; j < cols; j++) {\n        double sum = 0;\n        for(int i = 0; i < rows; i++) {\n            sum += matrix.getEntry(i, j);\n        }\n        means[j] = sum / rows;\n    }\n    double[][] covarianceMatrix = new double[cols][cols];\n    for(int i = 0; i < cols; i++) {\n        for(int j = 0; j < cols; j++) {\n            double sum = 0;\n            for(int k = 0; k < rows; k++) {\n                sum += (matrix.getEntry(k, i) - means[i]) * (matrix.getEntry(k, j) - means[j]);\n            }\n            covarianceMatrix[i][j] = sum / (rows - 1);\n        }\n    }\n    return new Array2DRowRealMatrix(covarianceMatrix);\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    int rows = matrix.getRowDimension();\n    int cols = matrix.getColumnDimension();\n    if (rows < 2 || cols < 1) {\n        throw new MathIllegalArgumentException(\"The input matrix must have at least one column and two rows\");\n    }\n\n    double[] means = new double[cols];\n    for (int j = 0; j < cols; j++) {\n        double sum = 0;\n        for (int i = 0; i < rows; i++) {\n            sum += matrix.getEntry(i, j);\n        }\n        means[j] = sum / rows;\n    }\n\n    double[][] covariances = new double[cols][cols];\n    for (int i = 0; i < cols; i++) {\n        for (int j = 0; j < cols; j++) {\n            double sum = 0;\n            for (int k = 0; k < rows; k++) {\n                double diff = matrix.getEntry(k, i) - means[i];\n                sum += diff * (matrix.getEntry(k, j) - means[j]);\n            }\n            covariances[i][j] = sum / (rows - 1);\n            if (biasCorrected) {\n                covariances[i][j] -= means[i] * means[j];\n            }\n        }\n    }\n\n    return new Array2DRowRealMatrix(covariances);\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    int n = matrix.getRowDimension();\n    int p = matrix.getColumnDimension();\n\n    if (n < 2 || p < 1) {\n        throw new MathIllegalArgumentException(\"Matrix must have at least one column and two rows\");\n    }\n\n    double[] means = new double[p];\n    for (int j = 0; j < p; j++) {\n        means[j] = 0;\n        for (int i = 0; i < n; i++) {\n            means[j] += matrix.getEntry(i, j);\n        }\n        means[j] /= n;\n    }\n\n    double[][] covarianceMatrix = new double[p][p];\n    for (int i = 0; i < p; i++) {\n        for (int j = 0; j < p; j++) {\n            double sum = 0;\n            for (int k = 0; k < n; k++) {\n                double x = matrix.getEntry(k, i) - means[i];\n                double y = matrix.getEntry(k, j) - means[j];\n                sum += x * y;\n            }\n            covarianceMatrix[i][j] = sum / (n - 1);\n        }\n    }\n\n    return new BlockRealMatrix(covarianceMatrix);\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    int n = matrix.getRowDimension();\n    int p = matrix.getColumnDimension();\n    double[] mean = new double[p];\n    double[] sum = new double[p];\n    double[] sumSquare = new double[p];\n    double[] sumProduct = new double[p];\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < p; j++) {\n            sum[j] += matrix.getEntry(i, j);\n            sumSquare[j] += matrix.getEntry(i, j) * matrix.getEntry(i, j);\n            for (int k = 0; k < p; k++) {\n                sumProduct[k] += matrix.getEntry(i, j) * matrix.getEntry(i, k);\n            }\n        }\n    }\n\n    for (int j = 0; j < p; j++) {\n        mean[j] = sum[j] / n;\n        sum[j] = 0;\n        sumSquare[j] = 0;\n        sumProduct[j] = 0;\n    }\n\n    RealMatrix covarianceMatrix = new BlockRealMatrix(p, p);\n    for (int i = 0; i < p; i++) {\n        for (int j = 0; j < p; j++) {\n            double sumij = 0;\n            for (int k = 0; k < n; k++) {\n                sumij += (matrix.getEntry(k, i) - mean[i]) * (matrix.getEntry(k, j) - mean[j]);\n            }\n            if (biasCorrected) {\n                sumij /= n - 1;\n            } else {\n                sumij /= n;\n            }\n            covarianceMatrix.setEntry(i, j, sumij);\n        }\n    }\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    int n = matrix.getRowDimension();\n    int p = matrix.getColumnDimension();\n    if (n < 2 || p < 1) {\n        throw new MathIllegalArgumentException(\"Matrix must have at least two rows and one column\");\n    }\n    double[] means = new double[p];\n    for (int j = 0; j < p; j++) {\n        means[j] = matrix.getColumnMeans().getEntry(0, j);\n    }\n    double[][] data = new double[n][p];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < p; j++) {\n            data[i][j] = matrix.getEntry(i, j) - means[j];\n        }\n    }\n    RealMatrix covMatrix = new BlockRealMatrix(p, p);\n    for (int i = 0; i < p; i++) {\n        for (int j = 0; j < p; j++) {\n            double sum = 0;\n            for (int k = 0; k < n; k++) {\n                sum += data[k][i] * data[k][j];\n            }\n            if (biasCorrected) {\n                sum /= n - 1;\n            } else {\n                sum /= n;\n            }\n            covMatrix.setEntry(i, j, sum);\n        }\n    }\n    return covMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    int n = matrix.getRowDimension();\n    int p = matrix.getColumnDimension();\n\n    if (n < 2 || p < 1) {\n        throw new MathIllegalArgumentException(\"Matrix must have at least one column and two rows\");\n    }\n\n    double[] means = new double[p];\n    for (int j = 0; j < p; j++) {\n        means[j] = 0;\n        for (int i = 0; i < n; i++) {\n            means[j] += matrix.getEntry(i, j);\n        }\n        means[j] /= n;\n    }\n\n    RealMatrix covarianceMatrix = new Array2DRowRealMatrix(p, p);\n    for (int i = 0; i < p; i++) {\n        for (int j = 0; j < p; j++) {\n            double sum = 0;\n            for (int k = 0; k < n; k++) {\n                double diff = matrix.getEntry(k, i) - means[i];\n                sum += diff * (matrix.getEntry(k, j) - means[j]);\n            }\n            if (biasCorrected) {\n                sum /= n - 1;\n            } else {\n                sum /= n;\n            }\n            covarianceMatrix.setEntry(i, j, sum);\n        }\n    }\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    int n = matrix.getRowDimension();\n    int p = matrix.getColumnDimension();\n    if (n < 2 || p < 1) {\n        throw new MathIllegalArgumentException(\"Matrix must have at least two rows and one column\");\n    }\n    double[] means = new double[p];\n    for (int j = 0; j < p; j++) {\n        double sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += matrix.getEntry(i, j);\n        }\n        means[j] = sum / n;\n    }\n    double[][] covarianceMatrix = new double[p][p];\n    for (int i = 0; i < p; i++) {\n        for (int j = 0; j < p; j++) {\n            double sum = 0;\n            for (int k = 0; k < n; k++) {\n                double diff = matrix.getEntry(k, i) - means[i];\n                sum += diff * (matrix.getEntry(k, j) - means[j]);\n            }\n            covarianceMatrix[i][j] = sum / (n - 1);\n        }\n    }\n    return new Array2DRowRealMatrix(covarianceMatrix);\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    int rows = matrix.getRowDimension();\n    int cols = matrix.getColumnDimension();\n\n    if (rows < 2 || cols < 1) {\n        throw new MathIllegalArgumentException(\"The input matrix must have at least one column and two rows\");\n    }\n\n    double[] means = new double[cols];\n    for (int i = 0; i < cols; i++) {\n        double sum = 0;\n        for (int j = 0; j < rows; j++) {\n            sum += matrix.getEntry(j, i);\n        }\n        means[i] = sum / rows;\n    }\n\n    RealMatrix result = new Array2DRowRealMatrix(rows, cols);\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            double sum = 0;\n            for (int k = 0; k < rows; k++) {\n                sum += (matrix.getEntry(k, j) - means[j]) * (matrix.getEntry(k, i) - means[i]);\n            }\n            if (biasCorrected) {\n                sum /= rows - 1;\n            } else {\n                sum /= rows;\n            }\n            result.setEntry(i, j, sum);\n        }\n    }\n    return result;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    int n = matrix.getRowDimension();\n    int p = matrix.getColumnDimension();\n    double[] means = new double[p];\n    double[][] deviations = new double[n][p];\n\n    // compute means\n    for (int j = 0; j < p; j++) {\n        double sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += matrix.getEntry(i, j);\n        }\n        means[j] = sum / n;\n    }\n\n    // compute deviations\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < p; j++) {\n            deviations[i][j] = matrix.getEntry(i, j) - means[j];\n        }\n    }\n\n    // compute covariance matrix\n    double[][] covarianceMatrixArray = new double[p][p];\n    for (int i = 0; i < p; i++) {\n        for (int j = 0; j < p; j++) {\n            double sum = 0;\n            for (int k = 0; k < n; k++) {\n                sum += deviations[k][i] * deviations[k][j];\n            }\n            covarianceMatrixArray[i][j] = sum / (n - 1);\n        }\n    }\n\n    return new BlockRealMatrix(covarianceMatrixArray);\n}"
    ],
    [
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IOException(\"Invalid bit count: \" + count);\n    }\n\n    long bits = 0;\n    int bitsNeeded = count;\n\n    while (bitsNeeded > 0) {\n        if (bitsCachedSize == 0) {\n            int bytesRead = in.read();\n            if (bytesRead == -1) {\n                return -1;\n            }\n            bitsCached = (long) bytesRead & 0xFF;\n            bitsCachedSize = 8;\n        }\n\n        int bitsToRead = Math.min(bitsNeeded, bitsCachedSize);\n        bits |= (bitsCached >>> (bitsCachedSize - bitsToRead)) & MASKS[bitsToRead];\n        bitsCachedSize -= bitsToRead;\n        bitsNeeded -= bitsToRead;\n\n        if (bitsCachedSize == 0) {\n            bitsCached = 0;\n        }\n    }\n\n    if (byteOrder == ByteOrder.BIG_ENDIAN) {\n        bits = ByteOrder.nativeOrder().equals(ByteOrder.BIG_ENDIAN) ? bits : Long.reverseBytes(bits);\n    } else if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n        bits = ByteOrder.nativeOrder().equals(ByteOrder.LITTLE_ENDIAN) ? bits : Long.reverseBytes(bits);\n    }\n\n    return bits;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IOException(\"Invalid bit count: \" + count);\n    }\n\n    long bits = 0;\n    int bitsLeft = count;\n\n    while (bitsLeft > 0) {\n        if (bitsCachedSize == 0) {\n            int bytes = (bitsLeft + 7) / 8;\n            byte[] buffer = new byte[bytes];\n            int bytesRead = in.read(buffer);\n            if (bytesRead == -1) {\n                return -1;\n            }\n            bitsCached = 0;\n            bitsCachedSize = bytesRead * 8;\n            for (int i = 0; i < bytesRead; i++) {\n                if (byteOrder == ByteOrder.BIG_ENDIAN) {\n                    bitsCached |= (buffer[i] & 0xFF) << (7 - i * 8);\n                } else {\n                    bitsCached |= (buffer[i] & 0xFF) << (i * 8);\n                }\n            }\n        }\n\n        bitsLeft -= Math.min(bitsLeft, bitsCachedSize);\n        bitsCachedSize -= Math.min(bitsLeft, bitsCachedSize);\n        bits |= (bitsCached & MASKS[bitsLeft]) >> (bitsLeft - bitsCachedSize);\n        bitsCached &= ~MASKS[bitsLeft];\n    }\n\n    return bits;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > MAXIMUM_CACHE_SIZE) {\n        throw new IOException(\"Requested bit count exceeds maximum cache size\");\n    }\n    long result = 0;\n    int bitsNeeded = count;\n    while (bitsNeeded > 0) {\n        if (bitsCachedSize == 0) {\n            int bytesNeeded = (bitsNeeded + 7) / 8;\n            byte[] buffer = new byte[bytesNeeded];\n            int bytesRead = in.read(buffer);\n            if (bytesRead == -1) {\n                return -1;\n            }\n            bitsCachedSize = bytesRead * 8;\n            bitsCached = 0;\n            for (int i = 0; i < bytesRead; i++) {\n                bitsCached |= (buffer[i] & 0xFF) << (7 - (i * 8));\n            }\n        }\n        int bitsAvailable = bitsCachedSize;\n        if (bitsAvailable > bitsNeeded) {\n            bitsAvailable = bitsNeeded;\n        }\n        result |= (bitsCached >>> (bitsCachedSize - bitsAvailable)) & MASKS[bitsAvailable];\n        bitsCachedSize -= bitsAvailable;\n        bitsCached <<= bitsAvailable;\n        bitsNeeded -= bitsAvailable;\n    }\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > 63) {\n        throw new IOException(\"Invalid bit count: \" + count);\n    }\n\n    long bits = 0;\n    int bitsRead = 0;\n\n    while (bitsRead < count) {\n        if (bitsCachedSize == 0) {\n            if (in.available() == 0) {\n                return -1;\n            }\n            bitsCached = in.read() & 0xFF;\n            bitsCachedSize = 8;\n        }\n\n        bitsCachedSize -= ByteOrder.BYTES;\n        bits |= (bitsCached >>> bitsCachedSize) & MASKS[count - bitsRead];\n        bitsRead += ByteOrder.BYTES;\n\n        if (bitsCachedSize == 0) {\n            bitsCached = 0;\n            bitsCachedSize = 0;\n        }\n    }\n\n    return bits;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > MAXIMUM_CACHE_SIZE) {\n        throw new IOException(\"Too many bits to read\");\n    }\n    long bits = 0;\n    int bitsLeft = count;\n    while (bitsLeft > 0) {\n        if (bitsCachedSize == 0) {\n            int bytesRead = in.read();\n            if (bytesRead == -1) {\n                return -1;\n            }\n            bitsCached = (long) bytesRead & MASKS[bitsCachedSize];\n            bitsCachedSize++;\n        }\n        bits |= (bitsCached >> (bitsCachedSize - bitsLeft)) & MASKS[bitsLeft];\n        bitsLeft -= bitsCachedSize;\n        bitsCachedSize = Math.min(bitsCachedSize, bitsLeft);\n    }\n    return bits;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > MAXIMUM_CACHE_SIZE) {\n        throw new IOException(\"Cannot read more than 63 bits at once\");\n    }\n\n    long bits = 0;\n    int bitsRead = 0;\n\n    while (bitsRead < count) {\n        if (bitsCachedSize == 0) {\n            int bytesToRead = (count - bitsRead) / 8 + 1;\n            byte[] buffer = new byte[bytesToRead];\n            int bytesRead = in.read(buffer);\n            if (bytesRead == -1) {\n                return -1;\n            }\n            bitsCached = 0;\n            bitsCachedSize = bytesRead * 8;\n            for (int i = 0; i < bytesRead; i++) {\n                if (byteOrder == ByteOrder.BIG_ENDIAN) {\n                    bitsCached |= (buffer[i] & 0xFF) << (7 - i * 8);\n                } else {\n                    bitsCached |= (buffer[i] & 0xFF) << (i * 8);\n                }\n            }\n        }\n\n        bits |= (bitsCached & MASKS[count - bitsRead]) >> (bitsCachedSize - count + bitsRead);\n        bitsRead += count - bitsRead;\n        bitsCachedSize -= count - bitsRead;\n        bitsCached <<= count - bitsRead;\n    }\n\n    return bits;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"Count must be between 1 and \" + MAXIMUM_CACHE_SIZE);\n    }\n\n    long bits = bitsCached;\n    int bitsLeft = bitsCachedSize;\n\n    // Read from cache first\n    while (bitsLeft >= count) {\n        bits &= MASKS[count];\n        bitsCachedSize -= count;\n        bitsLeft -= count;\n        break;\n    }\n\n    // Read from stream\n    while (bitsLeft > 0) {\n        int bytesToRead = (bitsLeft + 7) / 8;\n        byte[] buffer = new byte[bytesToRead];\n        int bytesRead = in.read(buffer);\n        if (bytesRead < 0) {\n            return -1;\n        }\n        if (bytesRead < bytesToRead) {\n            throw new IOException(\"Premature end of file\");\n        }\n\n        long mask = MASKS[bitsLeft];\n        bits = (bits & ~(mask << bitsCachedSize)) | ((buffer[0] & ((mask >> (bitsCachedSize - bitsLeft)) | (mask >> (bitsCachedSize - bitsLeft + 8)))) << bitsCachedSize);\n        bitsCachedSize += bytesToRead * 8 - bitsLeft;\n        bitsLeft = 0;\n    }\n\n    // Update bitsCached and bitsCachedSize\n    bitsCached = bits;\n    bitsCachedSize = bitsLeft;\n\n    return bits;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > 63) {\n        throw new IOException(\"Invalid bit count: \" + count);\n    }\n\n    long bits = 0;\n    int bitsToRead = count;\n\n    while (bitsToRead > 0) {\n        if (bitsCachedSize == 0) {\n            bitsCached = in.read();\n            if (bitsCached == -1) {\n                return -1;\n            }\n            bitsCachedSize = 8;\n        }\n\n        int bitsToReadFromCache = Math.min(bitsToRead, bitsCachedSize);\n        bitsCachedSize -= bitsToReadFromCache;\n\n        if (byteOrder == ByteOrder.BIG_ENDIAN) {\n            bits |= (bitsCached >> (bitsCachedSize - bitsToReadFromCache)) & MASKS[bitsToReadFromCache];\n        } else {\n            bits |= (bitsCached & MASKS[bitsToReadFromCache]) << (bitsCachedSize - bitsToReadFromCache);\n        }\n\n        bitsToRead -= bitsToReadFromCache;\n\n        if (bitsToRead == 0) {\n            break;\n        }\n\n        if (bitsCachedSize == 0) {\n            bitsCached = in.read();\n            if (bitsCached == -1) {\n                return -1;\n            }\n            bitsCachedSize = 8;\n        }\n    }\n\n    return bits;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"Invalid count: \" + count);\n    }\n\n    long bits = bitsCached;\n    int bitsLeft = bitsCachedSize;\n\n    // Read the remaining bits from the cache\n    while (bitsLeft < count) {\n        int bytesRead = in.read();\n        if (bytesRead == -1) {\n            return -1;\n        }\n        bits |= (long) (bytesRead & 0xFF) << bitsLeft;\n        bitsLeft += 8;\n        if (byteOrder == ByteOrder.BIG_ENDIAN) {\n            bits |= (long) (bytesRead >>> 24) << bitsLeft;\n            bitsLeft += 8;\n        }\n    }\n\n    // Read the remaining bits from the stream\n    bitsLeft -= count;\n    while (bitsLeft > 0) {\n        int bytesRead = in.read();\n        if (bytesRead == -1) {\n            return -1;\n        }\n        bits |= (long) (bytesRead & 0xFF) << bitsLeft;\n        bitsLeft -= 8;\n        if (byteOrder == ByteOrder.BIG_ENDIAN) {\n            bits |= (long) (bytesRead >>> 24) << bitsLeft;\n            bitsLeft -= 8;\n        }\n    }\n\n    // Update the cache\n    bitsCached = bits & MASKS[count];\n    bitsCachedSize = count;\n\n    return bits;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > MAXIMUM_CACHE_SIZE) {\n        throw new IOException(\"Requested bit count exceeds maximum cache size\");\n    }\n    long bits = 0;\n    int bitsToRead = count;\n    while (bitsToRead > 0) {\n        if (bitsCachedSize == 0) {\n            int bytesToRead = (bitsToRead + 7) / 8;\n            byte[] buffer = new byte[bytesToRead];\n            int bytesRead = in.read(buffer);\n            if (bytesRead == -1) {\n                return -1;\n            }\n            bitsCached = 0;\n            bitsCachedSize = bytesRead * 8;\n            for (int i = 0; i < bytesRead; i++) {\n                if (byteOrder == ByteOrder.BIG_ENDIAN) {\n                    bitsCached |= (buffer[i] & 0xFF) << (bitsCachedSize - 8);\n                } else {\n                    bitsCached |= (buffer[i] & 0xFF) << (7 - (bitsCachedSize % 8));\n                }\n                bitsCachedSize -= 8;\n            }\n        }\n        bits |= (bitsCached & MASKS[bitsToRead]) >> (bitsCachedSize - bitsToRead);\n        bitsCached &= ~(MASKS[bitsToRead] << (bitsCachedSize - bitsToRead));\n        bitsCachedSize -= bitsToRead;\n        bitsToRead = 0;\n    }\n    return bits;\n}"
    ],
    [
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}"
    ],
    [
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    if (target instanceof Label) {\n        return ((Label) target).getName().equals(label);\n    }\n    return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    if (target instanceof LabelNode) {\n        return ((LabelNode) target).getName().equals(label);\n    }\n    return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    if (target.getType() == Token.LABEL) {\n        return ((Label) target).getName().equals(label);\n    }\n    return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    if (target.getType() == Token.LABEL) {\n        return ((LabelNode) target).getLabel().equals(label);\n    }\n    return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    if (target instanceof Label) {\n        return ((Label) target).getName().equals(label);\n    }\n    return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    if (target instanceof LabelStatement) {\n        return ((LabelStatement) target).getName().equals(label);\n    }\n    return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    if (target instanceof Node.Label) {\n        return ((Node.Label) target).getName().equals(label);\n    }\n    return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    if (target instanceof Label) {\n        if (((Label) target).getName().equals(label)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    if (target instanceof Node.Label) {\n        if (((Node.Label) target).getName().equals(label)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    if (target.getType() == Token.LABEL) {\n        return ((LabelNode) target).getLabel().equals(label);\n    }\n    return false;\n}"
    ],
    [
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        return (String) urls.get(item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        return (String) urls.get(item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null && item < urls.size()) {\n        return (String) urls.get(item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    List urls = (List) urlSeries.get(series);\n    if (urls != null) {\n        return (String) urls.get(item);\n    } else {\n        return null;\n    }\n}",
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        return (String) urls.get(item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        return (String) urls.get(item);\n    } else {\n        return null;\n    }\n}",
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null && item < urls.size()) {\n        return (String) urls.get(item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null && item < urls.size()) {\n        return (String) urls.get(item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    List urls = (List) urlSeries.get(series);\n    if (urls != null && item < urls.size()) {\n        return (String) urls.get(item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        return (String) urls.get(item);\n    }\n    return null;\n}"
    ],
    [
      "private final static int _parseIndex(String str)  {\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}",
      "private final static int _parseIndex(String str)  {\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}",
      "private final static int _parseIndex(String str)  {\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}",
      "private final static int _parseIndex(String str)  {\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}",
      "private final static int _parseIndex(String str)  {\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}",
      "private final static int _parseIndex(String str)  {\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}",
      "private final static int _parseIndex(String str)  {\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}",
      "private final static int _parseIndex(String str)  {\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}",
      "private final static int _parseIndex(String str)  {\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}",
      "private final static int _parseIndex(String str)  {\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}"
    ],
    [
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_EXCEEDS_COLLECTION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE, k);\n    }\n\n    int[] index = getNatural(c.size());\n    MathArrays.shuffle(index, getRandomGenerator());\n\n    Object[] sample = new Object[k];\n    for (int i = 0; i < k; i++) {\n        sample[i] = c.toArray()[index[i]];\n    }\n\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_EXCEEDS_COLLECTION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE, k);\n    }\n\n    int[] index = getNatural(c.size());\n    MathArrays.shuffle(index, getRandomGenerator());\n\n    Object[] sample = new Object[k];\n    int i = 0;\n    for (Object obj : c) {\n        sample[index[i]] = obj;\n        i++;\n    }\n\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_EXCEEDS_COLLECTION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE, k);\n    }\n\n    int[] index = getNatural(c.size());\n    MathArrays.shuffle(index, getRandomGenerator());\n\n    Object[] sample = new Object[k];\n    int j = 0;\n    for (int i : index) {\n        sample[j++] = c.toArray()[i];\n    }\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_EXCEEDS_COLLECTION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE, k);\n    }\n\n    int[] indices = nextPermutation(c.size(), k);\n    Object[] sample = new Object[k];\n    int i = 0;\n    for (Object o : c) {\n        sample[indices[i]] = o;\n        i++;\n    }\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_EXCEEDS_COLLECTION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE, k);\n    }\n\n    int[] indices = nextPermutation(c.size(), k);\n    Object[] sample = new Object[k];\n    int i = 0;\n    for (Object obj : c) {\n        sample[indices[i]] = obj;\n        i++;\n    }\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_EXCEEDS_COLLECTION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE, k);\n    }\n\n    int[] indices = nextPermutation(c.size(), k);\n    Object[] sample = new Object[k];\n    int i = 0;\n    for (Object o : c) {\n        sample[i++] = o;\n    }\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_EXCEEDS_COLLECTION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE, k);\n    }\n\n    int[] index = new int[c.size()];\n    for (int i = 0; i < c.size(); i++) {\n        index[i] = i;\n    }\n\n    MathArrays.shuffle(index, getRandomGenerator());\n\n    Object[] sample = new Object[k];\n    for (int i = 0; i < k; i++) {\n        sample[i] = c.toArray()[index[i]];\n    }\n\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_EXCEEDS_COLLECTION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE, k);\n    }\n\n    int[] indices = nextPermutation(c.size(), k);\n    Object[] sample = new Object[k];\n    int i = 0;\n    for (Object obj : c) {\n        sample[indices[i]] = obj;\n        i++;\n    }\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_EXCEEDS_COLLECTION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE, k);\n    }\n\n    int[] index = new int[c.size()];\n    for (int i = 0; i < c.size(); i++) {\n        index[i] = i;\n    }\n\n    MathArrays.shuffle(index, getRandomGenerator());\n\n    Object[] sample = new Object[k];\n    for (int i = 0; i < k; i++) {\n        sample[i] = c.toArray()[index[i]];\n    }\n\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_EXCEEDS_COLLECTION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE, k);\n    }\n\n    int[] indices = nextPermutation(c.size(), k);\n    Object[] sample = new Object[k];\n    int i = 0;\n    for (Object obj : c) {\n        sample[indices[i]] = obj;\n        i++;\n    }\n    return sample;\n}"
    ],
    [
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node methodCall = NodeUtil.createMethodCall(methodName, argumentNode);\n    Node call = NodeUtil.createCall(methodCall, srcref);\n    return call;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = NodeUtil.createMethodCall(methodName, argumentNode);\n    if (srcref != null) {\n        callNode.setSourceInfo(srcref);\n    }\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = compiler.newNode(NodeType.CALL);\n    callNode.setMethod(methodName);\n    callNode.setArgument(argumentNode);\n    callNode.setSourceInfo(srcref);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = NodeFactory.createCall(methodName);\n    callNode.setArgument(0, argumentNode);\n    callNode.setSourceInfo(srcref);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = NodeUtil.createMethodCall(methodName, argumentNode, srcref);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node methodCall = NodeFactory.createCall(methodName, argumentNode);\n    methodCall.setSourceref(srcref);\n    return methodCall;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = NodeFactory.createCall(methodName, srcref);\n    callNode.appendChild(NodeFactory.createArg(argumentNode));\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node methodCall = NodeUtil.createMethodCall(methodName, argumentNode);\n    Node callNode = NodeUtil.createCall(methodCall, srcref);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = compiler.getFactory().createCall(methodName);\n    callNode.setArgument(0, argumentNode);\n    callNode.setSourceInfo(srcref);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = NodeUtil.createMethodCall(methodName, argumentNode);\n    callNode.setSourceInfo(srcref);\n    return callNode;\n}"
    ],
    [
      "private int[] sortedIndices(final double[] doubles)  {\n    int[] indices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, (i, j) -> Double.compare(doubles[j], doubles[i]));\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int n = doubles.length;\n    final int[] indices = new int[n];\n    for (int i = 0; i < n; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, (i, j) -> Double.compare(doubles[i], doubles[j]));\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int n = doubles.length;\n    final int[] indices = new int[n];\n    for (int i = 0; i < n; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, (i, j) -> Double.compare(doubles[i], doubles[j]));\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    int[] indices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, (i, j) -> Double.compare(doubles[i], doubles[j]));\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int n = doubles.length;\n    final int[] indices = new int[n];\n    for (int i = 0; i < n; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, (i, j) -> Double.compare(doubles[i], doubles[j]));\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int n = doubles.length;\n    final int[] indices = new int[n];\n    for (int i = 0; i < n; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, (i, j) -> Double.compare(doubles[i], doubles[j]));\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, (i, j) -> Double.compare(doubles[j], doubles[i]));\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, (i, j) -> Double.compare(doubles[i], doubles[j]));\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    int[] indices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, (i1, i2) -> Double.compare(doubles[i1], doubles[i2]));\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, (i1, i2) -> Double.compare(doubles[i1], doubles[i2]));\n    return indices;\n}"
    ],
    [
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = RealMatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = RealMatrixIdentity.getIdentity(householderVectors.length);\n        for (int i = 0; i < householderVectors.length; i++) {\n            double[] vector = householderVectors[i];\n            double norm = FastMath.sqrt(FastMath.sum(Arrays.stream(vector).mapToDouble(Math::square).sum()));\n            if (norm > 1e-12) {\n                double[] v = new double[vector.length];\n                for (int j = 0; j < vector.length; j++) {\n                    v[j] = vector[j] / norm;\n                }\n                cachedQt = cachedQt.multiply(new Array2DRowRealMatrix(new double[][]{v, v}));\n            }\n        }\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = RealMatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = getQ().transpose();\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = getQ().transpose();\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = getQ().transpose();\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = getQ().transpose();\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = RealMatrixFactory1D.createRealMatrix(main);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = RealMatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = getQ().transpose();\n    }\n    return cachedQt;\n}"
    ],
    [
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) {\n        return this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) {\n        return this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) {\n        return this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) {\n        return this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) {\n        return this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) {\n        return this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) {\n        return this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) {\n        return this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) {\n        return this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) {\n        return this.defaultGroup;\n    }\n    return result;\n}"
    ],
    [
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<>(set, transformer);\n}"
    ],
    [
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        buffer = Arrays.copyOf(buffer, capacity);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        buffer = Arrays.copyOf(buffer, capacity);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        int newCapacity = buffer.length * 2;\n        if (newCapacity < capacity) {\n            newCapacity = capacity;\n        }\n        buffer = Arrays.copyOf(buffer, newCapacity);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        buffer = Arrays.copyOf(buffer, capacity);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        int newCapacity = buffer.length * 2 + 1;\n        if (newCapacity < capacity) {\n            newCapacity = capacity;\n        }\n        buffer = Arrays.copyOf(buffer, newCapacity);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        buffer = Arrays.copyOf(buffer, capacity);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        int newCapacity = buffer.length * 2 + 1;\n        if (newCapacity < capacity) {\n            newCapacity = capacity;\n        }\n        buffer = Arrays.copyOf(buffer, newCapacity);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        buffer = Arrays.copyOf(buffer, capacity);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        buffer = Arrays.copyOf(buffer, capacity);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        int newCapacity = buffer.length * 2;\n        if (newCapacity < capacity) {\n            newCapacity = capacity;\n        }\n        buffer = Arrays.copyOf(buffer, newCapacity);\n    }\n    return this;\n}"
    ],
    [
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double maximum = 0.0;\n    double total = 0.0;\n    hasValidData = false;\n    for (int itemNo = 0; itemNo < dataset.getItemCount(); itemNo++) {\n        total = 0.0;\n        for (int seriesNo = 0; seriesNo < dataset.getSeriesCount(); seriesNo++) {\n            double y = dataset.getYValue(seriesNo, itemNo);\n            if (!Double.isNaN(y)) {\n                total += y;\n                if (total > maximum) {\n                    maximum = total;\n                }\n            }\n        }\n        if (total > maximum) {\n            maximum = total;\n        }\n        if (total > 0.0) {\n            hasValidData = true;\n        }\n    }\n    if (hasValidData) {\n        result = new Double(maximum);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.MAX_VALUE;\n    double maximum = 0.0;\n    for (int itemNo = 0; itemNo < dataset.getItemCount(); itemNo++) {\n        double total = calculateStackTotal(dataset, itemNo);\n        if (total > maximum) {\n            maximum = total;\n        }\n        if (total < minimum) {\n            minimum = total;\n        }\n    }\n    if (minimum <= maximum) {\n        return new Range(minimum, maximum);\n    }\n    else {\n        return null;\n    }\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double maximum = 0.0;\n    double total = 0.0;\n    hasValidData = false;\n    for (int itemNo = 0; itemNo < dataset.getItemCount(); itemNo++) {\n        total = 0.0;\n        for (int seriesNo = 0; seriesNo < dataset.getSeriesCount(); seriesNo++) {\n            double y = dataset.getYValue(seriesNo, itemNo);\n            if (!Double.isNaN(y)) {\n                total += y;\n                if (total > maximum) {\n                    maximum = total;\n                }\n            }\n        }\n        if (total > maximum) {\n            maximum = total;\n        }\n        if (total > 0.0) {\n            hasValidData = true;\n        }\n    }\n    if (hasValidData) {\n        result = new Double(maximum);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double maximum = 0.0;\n    double total = 0.0;\n    for (int itemNo = 0; itemNo < dataset.getItemCount(); itemNo++) {\n        double cumulative = total;\n        int seriesCount = dataset.getSeriesCount();\n        for (int seriesNo = 0; seriesNo < seriesCount; seriesNo++) {\n            double y = dataset.getYValue(seriesNo, itemNo);\n            if (!Double.isNaN(y)) {\n                cumulative += y;\n            }\n        }\n        total = cumulative;\n        maximum = Math.max(maximum, total);\n    }\n    if (maximum > 0.0) {\n        return new Range(0.0, maximum);\n    }\n    else {\n        return null;\n    }\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double maximum = 0.0;\n    double total = 0.0;\n    for (int itemNo = 0; itemNo < dataset.getItemCount(); itemNo++) {\n        total = 0.0;\n        for (int seriesNo = 0; seriesNo < dataset.getSeriesCount(); seriesNo++) {\n            double y = dataset.getYValue(seriesNo, itemNo);\n            if (!Double.isNaN(y)) {\n                total += y;\n            }\n        }\n        if (total > maximum) {\n            maximum = total;\n        }\n    }\n    if (maximum > 0.0) {\n        return new Range(0.0, maximum);\n    }\n    else {\n        return null;\n    }\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double maximum = 0.0;\n    double total = 0.0;\n    hasValidData = false;\n    for (int itemNo = 0; itemNo < dataset.getItemCount(); itemNo++) {\n        total = 0.0;\n        for (int seriesNo = 0; seriesNo < dataset.getSeriesCount(); seriesNo++) {\n            double y = dataset.getYValue(seriesNo, itemNo);\n            if (!Double.isNaN(y)) {\n                total += y;\n                maximum = Math.max(maximum, total);\n            }\n        }\n        if (total > 0.0) {\n            hasValidData = true;\n        }\n    }\n    if (hasValidData) {\n        result = new Double(maximum);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double maximum = 0.0;\n    double total = 0.0;\n    hasValidData = false;\n    for (int itemNo = 0; itemNo < dataset.getItemCount(); itemNo++) {\n        total = 0.0;\n        for (int seriesNo = 0; seriesNo < dataset.getSeriesCount(); seriesNo++) {\n            double y = dataset.getYValue(seriesNo, itemNo);\n            if (!Double.isNaN(y)) {\n                total += y;\n                if (total > maximum) {\n                    maximum = total;\n                }\n            }\n        }\n        if (total > maximum) {\n            maximum = total;\n        }\n        if (total > 0.0) {\n            hasValidData = true;\n        }\n    }\n    if (hasValidData) {\n        result = new Double(maximum);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double maximum = 0.0;\n    double total = 0.0;\n    hasValidData = false;\n    for (int itemNo = 0; itemNo < dataset.getItemCount(); itemNo++) {\n        total = 0.0;\n        for (int seriesNo = 0; seriesNo < dataset.getSeriesCount(); seriesNo++) {\n            double y = dataset.getYValue(seriesNo, itemNo);\n            if (!Double.isNaN(y)) {\n                total += y;\n                if (total > maximum) {\n                    maximum = total;\n                }\n            }\n        }\n        if (total > 0.0) {\n            hasValidData = true;\n        }\n    }\n    if (hasValidData) {\n        result = new Double(maximum);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = 0.0;\n    double maximum = 0.0;\n    for (int itemNo = 0; itemNo < dataset.getItemCount(); itemNo++) {\n        double total = calculateStackTotal(dataset, itemNo);\n        if (total > maximum) {\n            maximum = total;\n        }\n        if (total < minimum) {\n            minimum = total;\n        }\n    }\n    if (minimum <= maximum) {\n        return new Range(minimum, maximum);\n    }\n    else {\n        return null;\n    }\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double maximum = 0.0;\n    double total = 0.0;\n    for (int itemNo = 0; itemNo < dataset.getItemCount(); itemNo++) {\n        double cumulative = total;\n        int seriesCount = dataset.getSeriesCount();\n        for (int seriesNo = 0; seriesNo < seriesCount; seriesNo++) {\n            double y = dataset.getYValue(seriesNo, itemNo);\n            if (!Double.isNaN(y)) {\n                cumulative += y;\n            }\n        }\n        total = cumulative;\n        maximum = Math.max(maximum, total);\n    }\n    if (maximum > 0.0) {\n        return new Range(0.0, maximum);\n    }\n    else {\n        return null;\n    }\n}"
    ],
    [
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"The hours offset must be in the range -23 to +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"The minutes offset must be in the range -59 to +59\");\n    }\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return DateTimeZone.UTC;\n    }\n    String id = printOffset(hoursOffset * 60 + minutesOffset);\n    return fixedOffsetZone(id, hoursOffset * 60 + minutesOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"The hours offset must be in the range -23 to +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"The minutes offset must be in the range -59 to +59\");\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"The minutes cannot be negative when the hours are positive\");\n    }\n    long offset = hoursOffset * 60 * 60 * 1000 + minutesOffset * 60 * 1000;\n    if (offset < -23 * 60 * 60 * 1000 || offset > 23 * 60 * 60 * 1000) {\n        throw new IllegalArgumentException(\"The resulting offset exceeds +/- 23:59:59.000\");\n    }\n    return fixedOffsetZone(printOffset(offset), offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"The hours offset must be in the range -23 to +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"The minutes offset must be in the range -59 to +59\");\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"The minutes cannot be negative when the hours are positive\");\n    }\n    long offset = hoursOffset * 60 * 60 * 1000L + minutesOffset * 60 * 1000L;\n    if (offset < -23 * 60 * 60 * 1000L || offset > 23 * 60 * 60 * 1000L) {\n        throw new IllegalArgumentException(\"The resulting offset exceeds +/- 23:59:59.000\");\n    }\n    return fixedOffsetZone(printOffset(offset), offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"The hours offset must be in the range -23 to +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"The minutes offset must be in the range -59 to +59\");\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"The minutes cannot be negative when the hours are positive\");\n    }\n    long offset = hoursOffset * 60 * 60 * 1000L + minutesOffset * 60 * 1000L;\n    if (offset < -23 * 60 * 60 * 1000L || offset > 23 * 60 * 60 * 1000L) {\n        throw new IllegalArgumentException(\"The resulting offset exceeds +/- 23:59:59.000\");\n    }\n    return fixedOffsetZone(printOffset(offset), offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"The hours offset must be in the range -23 to +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"The minutes offset must be in the range -59 to +59\");\n    }\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return DateTimeZone.UTC;\n    }\n    String id = printOffset(hoursOffset, minutesOffset);\n    return fixedOffsetZone(id, hoursOffset * 60 * 60 * 1000L + minutesOffset * 60 * 1000L);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"The hours offset must be in the range -23 to +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"The minutes offset must be in the range -59 to +59\");\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"The minutes cannot be negative when the hours are positive\");\n    }\n    long offset = hoursOffset * 60 * 60 * 1000 + minutesOffset * 60 * 1000;\n    if (offset < -23 * 60 * 60 * 1000 - 59 * 60 * 1000 || offset > 23 * 60 * 60 * 1000 + 59 * 60 * 1000) {\n        throw new IllegalArgumentException(\"The resulting offset exceeds +/- 23:59:59.000\");\n    }\n    return fixedOffsetZone(printOffset(offset), offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"The hours offset must be in the range -23 to +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"The minutes offset must be in the range -59 to +59\");\n    }\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return DateTimeZone.UTC;\n    }\n    if (hoursOffset < 0) {\n        return fixedOffsetZone(\"-\" + printOffset(hoursOffset * 60 + minutesOffset), hoursOffset * 60 + minutesOffset);\n    }\n    return fixedOffsetZone(\"+\" + printOffset(hoursOffset * 60 + minutesOffset), hoursOffset * 60 + minutesOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"The hours offset must be in the range -23 to +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"The minutes offset must be in the range -59 to +59\");\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"The minutes cannot be negative when the hours are positive\");\n    }\n    long offset = hoursOffset * 60 * 60 * 1000L + minutesOffset * 60 * 1000L;\n    if (offset < -23 * 60 * 60 * 1000L || offset > 23 * 60 * 60 * 1000L) {\n        throw new IllegalArgumentException(\"The resulting offset exceeds +/- 23:59:59.000\");\n    }\n    return fixedOffsetZone(printOffset(offset), offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"The hours offset must be in the range -23 to +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"The minutes offset must be in the range -59 to +59\");\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"The minutes cannot be negative when the hours are positive\");\n    }\n    long offset = hoursOffset * 60 * 60 * 1000 + minutesOffset * 60 * 1000;\n    if (offset < -23 * 60 * 60 * 1000 - 59 * 60 * 1000 || offset > 23 * 60 * 60 * 1000 + 59 * 60 * 1000) {\n        throw new IllegalArgumentException(\"The resulting offset exceeds +/- 23:59:59.000\");\n    }\n    return fixedOffsetZone(printOffset(offset), offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"The hours offset must be in the range -23 to +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"The minutes offset must be in the range -59 to +59\");\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"The minutes cannot be negative when the hours are positive\");\n    }\n    long offset = hoursOffset * 60 * 60 * 1000L + minutesOffset * 60 * 1000L;\n    if (offset < -23 * 60 * 60 * 1000L || offset > 23 * 60 * 60 * 1000L) {\n        throw new IllegalArgumentException(\"The resulting offset exceeds +/- 23:59:59.000\");\n    }\n    return fixedOffsetZone(printOffset(offset), offset);\n}"
    ],
    [
      "public String chompBalanced(char open, char close)  {\n    int start = pos;\n    int openCount = 0;\n    while (!isEmpty()) {\n        if (queue.charAt(pos) == open) {\n            openCount++;\n        } else if (queue.charAt(pos) == close) {\n            if (openCount > 0) {\n                openCount--;\n            } else {\n                break;\n            }\n        }\n        pos++;\n    }\n    return queue.substring(start, pos);\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = pos;\n    int depth = 1;\n    while (!isEmpty()) {\n        char c = queue.charAt(pos);\n        if (c == open) {\n            depth++;\n        } else if (c == close) {\n            depth--;\n            if (depth == 0) {\n                pos++;\n                return queue.substring(start, pos);\n            }\n        }\n        pos++;\n    }\n    return queue.substring(start, pos);\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = pos;\n    int depth = 0;\n    while (!isEmpty()) {\n        char c = queue.charAt(pos);\n        if (c == open) {\n            depth++;\n        } else if (c == close) {\n            if (depth > 0) {\n                depth--;\n            } else {\n                break;\n            }\n        }\n        pos++;\n    }\n    if (depth > 0) {\n        throw new IllegalStateException(\"Unbalanced opener\");\n    }\n    return queue.substring(start, pos);\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = pos;\n    int openCount = 0;\n    while (!isEmpty()) {\n        int offset = queue.indexOf(open, pos);\n        if (offset != -1) {\n            openCount++;\n            pos = offset + 1;\n        } else {\n            break;\n        }\n    }\n    if (openCount == 0) {\n        return \"\";\n    }\n    while (!isEmpty()) {\n        int offset = queue.indexOf(close, pos);\n        if (offset != -1) {\n            openCount--;\n            if (openCount == 0) {\n                String data = queue.substring(start, offset + 1);\n                pos = offset + 1;\n                return data;\n            }\n            pos = offset + 1;\n        } else {\n            break;\n        }\n    }\n    return queue.substring(start, pos);\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = pos;\n    int openCount = 0;\n    int closeCount = 0;\n    while (!isEmpty()) {\n        char c = queue.charAt(pos);\n        if (c == open) {\n            openCount++;\n        } else if (c == close) {\n            closeCount++;\n            if (openCount == closeCount) {\n                String data = queue.substring(start, pos + 1);\n                pos += 1;\n                return data;\n            }\n        }\n        pos++;\n    }\n    return queue.substring(start, pos);\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = pos;\n    int depth = 1;\n    while (!isEmpty()) {\n        char c = queue.charAt(pos);\n        if (c == open) {\n            depth++;\n        } else if (c == close) {\n            depth--;\n            if (depth == 0) {\n                break;\n            }\n        }\n        pos++;\n    }\n    return queue.substring(start, pos);\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = pos;\n    int openCount = 0;\n    while (!isEmpty()) {\n        int offset = queue.indexOf(open, pos);\n        if (offset != -1) {\n            pos = offset + 1;\n            openCount++;\n        } else {\n            if (openCount == 0)\n                return queue.substring(start, pos);\n            break;\n        }\n        int closeOffset = queue.indexOf(close, pos);\n        if (closeOffset != -1) {\n            pos = closeOffset + 1;\n            if (--openCount == 0)\n                return queue.substring(start, pos);\n        } else {\n            if (openCount == 0)\n                return queue.substring(start);\n            break;\n        }\n    }\n    return queue.substring(start, pos);\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = pos;\n    int depth = 0;\n    while (!isEmpty()) {\n        char c = queue.charAt(pos);\n        if (c == open) {\n            depth++;\n        } else if (c == close) {\n            if (depth == 0) {\n                return queue.substring(start, pos);\n            }\n            depth--;\n        }\n        pos++;\n    }\n    return queue.substring(start, pos);\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = pos;\n    int openCount = 0;\n    while (!isEmpty()) {\n        if (queue.charAt(pos) == open) {\n            openCount++;\n        } else if (queue.charAt(pos) == close) {\n            if (openCount > 0) {\n                openCount--;\n            } else {\n                pos++;\n                break;\n            }\n        }\n        pos++;\n    }\n    return queue.substring(start, pos);\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = pos;\n    int openCount = 0;\n    while (!isEmpty()) {\n        if (queue.charAt(pos) == open) {\n            openCount++;\n        } else if (queue.charAt(pos) == close) {\n            if (openCount > 0) {\n                openCount--;\n            } else {\n                break;\n            }\n        }\n        pos++;\n    }\n    if (openCount > 0) {\n        throw new IllegalStateException(\"Unbalanced opener\");\n    }\n    return queue.substring(start, pos);\n}"
    ],
    [
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix xTx = qr.getR().transpose().multiply(qr.getR());\n        return xTx.inverse().getSubMatrix(0, getX().getColumnDimension() - 1, 0, getX().getColumnDimension() - 1);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final RealMatrix XTX = qr.getR().transpose().multiply(qr.getR());\n        final int p = getX().getColumnDimension();\n        return XTX.copySubMatrix(0, 0, p, p);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final QRDecomposition qrDecomposition = new QRDecomposition(getX());\n        final RealMatrix xTX = qrDecomposition.getR().transpose().multiply(qrDecomposition.getR());\n        return xTX.inverse().getSubMatrix(0, getX().getColumnDimension() - 1, 0, getX().getColumnDimension() - 1);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix xTx = qr.getR().transpose().multiply(qr.getR());\n        return xTx.inverse().getSubMatrix(0, getX().getColumnDimension() - 1, 0, getX().getColumnDimension() - 1);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final RealMatrix XTX = qr.getR().transpose().multiply(qr.getR());\n        final int p = getBeta().getDimension();\n        return XTX.copySubMatrix(0, p - 1, 0, p - 1);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final RealMatrix XTX = qr.getR().transpose().multiply(qr.getR());\n        final RealMatrix XTXInverse = XTX.inverse();\n        return XTXInverse;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final QRDecomposition qrDecomposition = new QRDecomposition(getX());\n        final RealMatrix xTX = qrDecomposition.getR().transpose().multiply(qrDecomposition.getR());\n        return xTX.inverse().getSubMatrix(0, getX().getColumnDimension() - 1, 0, getX().getColumnDimension() - 1);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final QRDecomposition qrDecomposition = qr;\n        final int p = getX().getColumnDimension();\n        final RealMatrix rT = qrDecomposition.getR().transpose();\n        final RealMatrix rTtimesR = rT.multiply(rT);\n        return rTtimesR.inverse().getSubMatrix(0, p - 1, 0, p - 1);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final RealMatrix xTx = qr.getR().transpose().multiply(qr.getR());\n        return xTx.inverse().getSubMatrix(0, getX().getColumnDimension() - 1, 0, getX().getColumnDimension() - 1);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix XtX = qr.getR().transpose().multiply(qr.getR());\n        RealMatrix inverseXtX = XtX.inverse();\n        return inverseXtX;\n    }"
    ],
    [
      "private static String printOffset(int offset)  {\n}",
      "private static String printOffset(int offset)  {\n}",
      "private static String printOffset(int offset)  {\n}",
      "private static String printOffset(int offset)  {\n}",
      "private static String printOffset(int offset)  {\n}",
      "private static String printOffset(int offset)  {\n}",
      "private static String printOffset(int offset)  {\n}",
      "private static String printOffset(int offset)  {\n}",
      "private static String printOffset(int offset)  {\n}",
      "private static String printOffset(int offset)  {\n}"
    ],
    [
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Key cannot be null\");\n    }\n    return this.indexMap.containsKey(key) ? (Integer) this.indexMap.get(key) : -1;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Key cannot be null\");\n    }\n    return this.indexMap.containsKey(key) ? this.indexMap.get(key) : -1;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Key cannot be null\");\n    }\n    return this.indexMap.containsKey(key) ? this.indexMap.get(key) : -1;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Key cannot be null\");\n    }\n    return this.indexMap.containsKey(key) ? this.indexMap.get(key) : -1;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Key cannot be null\");\n    }\n    return (int) this.indexMap.get(key);\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Key cannot be null\");\n    }\n    return this.indexMap.containsKey(key) ? this.indexMap.get(key) : -1;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Key cannot be null\");\n    }\n    return this.indexMap.containsKey(key) ? (Integer) this.indexMap.get(key) : -1;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Key cannot be null\");\n    }\n    return (int) this.indexMap.get(key);\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Key cannot be null\");\n    }\n    return (int) this.indexMap.get(key);\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Key cannot be null\");\n    }\n    return (int) this.indexMap.get(key);\n}"
    ],
    [
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    return cache.allFlowSlots();\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    return cache.getFlowSlots();\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    return cache.getFlowSlots();\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> flowSlots = new HashMap<>();\n    for (Map.Entry<String, StaticSlot<JSType>> entry : cache.getFlowSlots().entrySet()) {\n        if (!cache.isDirty(entry.getKey())) {\n            flowSlots.put(entry.getKey(), entry.getValue());\n        }\n    }\n    return flowSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    return cache.getFlowSlots();\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> flowSlots = new HashMap<>();\n    for (Map.Entry<String, StaticSlot<JSType>> entry : cache.getFlowScope().getFlowSlots().entrySet()) {\n        if (!cache.getFlowScope().getFlowSlots().get(entry.getKey()).isDirty()) {\n            flowSlots.put(entry.getKey(), entry.getValue());\n        }\n    }\n    return flowSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    return cache.allFlowSlots();\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> flowSlots = new HashMap<>();\n    for (String name : cache.dirtySymbols) {\n        flowSlots.put(name, getSlot(name));\n    }\n    return flowSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> flowSlots = new HashMap<>();\n    for (Map.Entry<String, StaticSlot<JSType>> entry : cache.getFlowSlots().entrySet()) {\n        if (!entry.getValue().isDirty()) {\n            flowSlots.put(entry.getKey(), entry.getValue());\n        }\n    }\n    return flowSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    return cache.getFlowSlots();\n}"
    ],
    [
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}"
    ],
    [
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < -1.0 || a > 1.0) {\n        throw new ArithmeticException(\"Argument out of range\");\n    }\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n\n    double absAtanh;\n    if (a > 0.5) {\n        absAtanh = FastMath.log((1.0 + a) / (1.0 - a));\n    } else {\n        double a2 = a * a;\n        if (a > 0.25) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.0625) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.00390625) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else {\n}\n}\n}",
      "public static double atanh(double a)  {\n    if (a == 1) {\n        return Double.POSITIVE_INFINITY;\n    }\n    if (a == -1) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    if (a > 1 || a < -1) {\n        throw new ArithmeticException(\"Argument out of range\");\n    }\n\n    double absAtanh;\n    if (a > 0.5) {\n        absAtanh = FastMath.log((1 + a) / (1 - a));\n    } else {\n        double a2 = a * a;\n        if (a > 0.25) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.0625) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.00390625) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else {\n}\n}\n}",
      "public static double atanh(double a)  {\n    if (a < -1.0 || a > 1.0) {\n        throw new ArithmeticException(\"Argument out of range\");\n    }\n\n    boolean negate = false;\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n\n    double absAtanh;\n    if (a > 0.5) {\n        absAtanh = FastMath.log((1 + a) / (1 - a));\n    } else {\n        double a2 = a * a;\n        double a4 = a2 * a2;\n        double a6 = a4 * a2;\n        double a8 = a6 * a2;\n        double a10 = a8 * a2;\n        double a12 = a10 * a2;\n        double a14 = a12 * a2;\n        double a16 = a14 * a2;\n        double a18 = a16 * a2;\n        double a20 = a18 * a2;\n        double a22 = a20 * a2;\n        double a24 = a22 * a2;\n        double a26 = a24 * a2;\n        double a28 = a26 * a2;\n        double a30 = a28 * a2;\n        double a32 = a30 * a2;\n        double a34 = a32 * a2;\n        double a36 = a34 * a2;\n        double a38 = a36 * a2;\n        double a40 = a38 * a2;\n        double a42 = a40 * a2;\n        double a44 = a42 * a2;\n        double a46 = a44 * a2;\n        double a48 = a46 * a2;\n        double a50 = a48 * a2;\n        double a52 = a50 * a2;\n        double a54 = a52 * a2;\n        double a56 = a54 * a2;\n        double a58 = a56 * a2;\n        double a60 = a58 * a2;\n        double a62 = a60 * a2;\n        double a64 = a62 * a2;\n        double a66 = a64 * a2;\n        double a68 = a66 * a2;\n        double a70 = a68 * a2;\n        double a72 = a70 * a2;\n        double a74 = a72 * a2;\n}\n}",
      "public static double atanh(double a)  {\n    if (Math.abs(a) > 1) {\n        throw new ArithmeticException(\"Argument is out of range\");\n    }\n\n    double result;\n    if (a == 1) {\n        result = Math.log(1 + 1);\n    } else if (a == -1) {\n        result = -Math.log(1 + 1);\n    } else {\n        double x = a;\n        double hiPrec[] = new double[2];\n        expm1(x*2.0, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        /* Numerator */\n        double na = ya;\n        double nb = yb;\n\n        /* Denominator */\n        double da = 2.0 + ya;\n        double db = -(da - 2.0 - ya);\n        double temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n\n        temp = da * HEX_40000000;\n        double daa = da + temp - temp;\n        double dab = da - daa;\n\n        // ratio = na/da\n        double ratio = na/da;\n        temp = ratio * HEX_40000000;\n        double ratioa = ratio + temp - temp;\n        double ratiob = ratio - ratioa;\n\n        // Correct for rounding in division\n        ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n        // Account for nb\n        ratiob += nb / da;\n        // Account for db\n        ratiob += -db * na / da / da;\n\n        result = ratioa + ratiob;\n    }\n\n    if (a < 0) {\n        result = -result;\n    }\n\n    return result;\n}",
      "public static double atanh(double a)  {\n    if (Math.abs(a) > 1) {\n        throw new ArithmeticException(\"Argument out of range\");\n    }\n\n    double result;\n    if (a == 1) {\n        result = Double.POSITIVE_INFINITY;\n    } else if (a == -1) {\n        result = -Double.POSITIVE_INFINITY;\n    } else {\n        double hiPrec[] = new double[2];\n        expm1(a*2.0, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        /* Numerator */\n        double na = ya;\n        double nb = yb;\n\n        /* Denominator */\n        double da = 2.0 + ya;\n        double db = -(da - 2.0 - ya);\n        double temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n\n        temp = da * HEX_40000000;\n        double daa = da + temp - temp;\n        double dab = da - daa;\n\n        // ratio = na/da\n        double ratio = na/da;\n        temp = ratio * HEX_40000000;\n        double ratioa = ratio + temp - temp;\n        double ratiob = ratio - ratioa;\n\n        // Correct for rounding in division\n        ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n        // Account for nb\n        ratiob += nb / da;\n        // Account for db\n        ratiob += -db * na / da / da;\n\n        result = ratioa + ratiob;\n    }\n\n    if (a < 0) {\n        result = -result;\n    }\n\n    return result;\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < -1.0 || a > 1.0) {\n        throw new ArithmeticException(\"Argument out of range\");\n    }\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n\n    double absAtanh;\n    if (a > 0.5) {\n        absAtanh = FastMath.log((1.0 + a) / (1.0 - a));\n    } else {\n        double a2 = a * a;\n        if (a > 0.25) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.0625) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.00390625) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else {\n}\n}\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < -1.0 || a > 1.0) {\n        throw new ArithmeticException(\"Argument out of range: |a| > 1\");\n    }\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n\n    double ratio;\n    if (a < 0.167) {\n        double hiPrec[] = new double[2];\n        expm1(a*2.0, hiPrec);\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        double na = ya;\n        double nb = yb;\n\n        double da = 2.0 + ya;\n        double db = -(da - 2.0 - ya);\n        double temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n\n        temp = da * HEX_40000000;\n        double daa = da + temp - temp;\n        double dab = da - daa;\n\n        ratio = na / da;\n        temp = ratio * HEX_40000000;\n        double ratioa = ratio + temp - temp;\n        double ratiob = ratio - ratioa;\n\n        ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n        ratiob += nb / da;\n        ratiob += -db * na / da / da;\n\n        ratio = ratioa + ratiob;\n    } else {\n        ratio = (Math.log(1 + a) - Math.log(1 - a)) / 2.0;\n    }\n\n    if (negate) {\n        ratio = -ratio;\n    }\n\n    return ratio;\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < -1.0 || a > 1.0) {\n        throw new ArithmeticException(\"Argument out of range: -1 <= a <= 1\");\n    }\n\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n\n    double absAtanh;\n    if (a > 0.5) {\n        absAtanh = FastMath.log((1.0 + a) / (1.0 - a));\n    } else {\n        double a2 = a * a;\n        double a4 = a2 * a2;\n        double a6 = a4 * a2;\n        double a8 = a6 * a2;\n        double a10 = a8 * a2;\n        double a12 = a10 * a2;\n        double a14 = a12 * a2;\n        double a16 = a14 * a2;\n        double a18 = a16 * a2;\n        double a20 = a18 * a2;\n        double a22 = a20 * a2;\n        double a24 = a22 * a2;\n        double a26 = a24 * a2;\n        double a28 = a26 * a2;\n        double a30 = a28 * a2;\n        double a32 = a30 * a2;\n        double a34 = a32 * a2;\n        double a36 = a34 * a2;\n        double a38 = a36 * a2;\n        double a40 = a38 * a2;\n        double a42 = a40 * a2;\n        double a44 = a42 * a2;\n        double a46 = a44 * a2;\n        double a48 = a46 * a2;\n        double a50 = a48 * a2;\n        double a52 = a50 * a2;\n        double a54 = a52 * a2;\n        double a56 = a54 * a2;\n        double a58 = a56 * a2;\n        double a60 = a58 * a2;\n        double a62 = a60 * a2;\n        double a64 = a62 * a2;\n        double a66 = a64 * a2;\n        double a68 = a66 * a2;\n        double a70 = a68 * a2;\n        double a72 = a70 * a2;\n}\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < -1.0 || a > 1.0) {\n        throw new ArithmeticException(\"Argument out of range: |a| > 1\");\n    }\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n\n    double ratioa, ratiob, na, da, db, temp, daa, dab;\n    if (a < 0.5) {\n        double hiPrec[] = new double[2];\n        expm1(a * 2.0, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        na = ya;\n        db = yb;\n        da = 2.0 + ya;\n        temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n\n        temp = da * HEX_40000000;\n        daa = da + temp - temp;\n        dab = da - daa;\n\n        ratioa = na / da;\n        temp = ratioa * HEX_40000000;\n        ratioa = ratioa + temp - temp;\n        ratiob = ratioa - ratioa;\n\n        ratiob += (na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob) / da;\n        ratiob += nb / da;\n        ratiob += -db * na / da / da;\n\n        result = ratioa + ratiob;\n    } else {\n        double absAtanh;\n        if (a > 0.5) {\n            absAtanh = FastMath.log((1 + a) / (1 - a));\n        } else {\n}\n}\n}",
      "public static double atanh(double a)  {\n    if (Math.abs(a) > 1) {\n        throw new ArithmeticException(\"Argument out of range\");\n    }\n\n    boolean negate = false;\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n\n    double absAtanh;\n    if (a > 0.5) {\n        absAtanh = FastMath.log((1 + a) / (1 - a));\n    } else {\n        double a2 = a * a;\n        if (a > 0.25) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.0625) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.00390625) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else {\n}\n}\n}"
    ],
    [
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"normalizedSum is infinite or NaN\");\n    }\n    double sum = 0;\n    for (double value : values) {\n        if (Double.isInfinite(value)) {\n            throw new MathArithmeticException(\"Input array contains infinite elements\");\n        }\n        if (!Double.isNaN(value)) {\n            sum += value;\n        }\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(\"Input array sums to zero\");\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] * normalizedSum / sum;\n        } else {\n            result[i] = values[i];\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Target sum is infinite or NaN\");\n    }\n    double sum = 0;\n    for (double value : values) {\n        if (Double.isInfinite(value)) {\n            throw new MathArithmeticException(\"Input array contains infinite elements\");\n        }\n        if (!Double.isNaN(value)) {\n            sum += value;\n        }\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(\"Input array sums to zero\");\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] * normalizedSum / sum;\n        } else {\n            result[i] = values[i];\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Target sum is infinite or NaN\");\n    }\n    double sum = 0;\n    for (double value : values) {\n        if (Double.isInfinite(value)) {\n            throw new MathArithmeticException(\"Input array contains infinite elements\");\n        }\n        if (!Double.isNaN(value)) {\n            sum += value;\n        }\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(\"Input array sums to zero\");\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] * normalizedSum / sum;\n        } else {\n            result[i] = values[i];\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"normalizedSum is infinite or NaN\");\n    }\n    double sum = 0;\n    for (double value : values) {\n        if (Double.isInfinite(value)) {\n            throw new MathArithmeticException(\"Input array contains infinite elements\");\n        }\n        if (!Double.isNaN(value)) {\n            sum += value;\n        }\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(\"Input array sums to zero\");\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] * normalizedSum / sum;\n        } else {\n            result[i] = values[i];\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Target sum is infinite or NaN\");\n    }\n    double sum = 0;\n    for (double value : values) {\n        if (Double.isInfinite(value)) {\n            throw new MathArithmeticException(\"Input array contains infinite elements\");\n        }\n        if (!Double.isNaN(value)) {\n            sum += value;\n        }\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(\"Input array sums to zero\");\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] * normalizedSum / sum;\n        } else {\n            result[i] = values[i];\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Target sum is infinite or NaN\");\n    }\n    double sum = 0;\n    for (double value : values) {\n        if (Double.isInfinite(value)) {\n            throw new MathArithmeticException(\"Input array contains infinite elements\");\n        }\n        if (!Double.isNaN(value)) {\n            sum += value;\n        }\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(\"Input array sums to zero\");\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] * normalizedSum / sum;\n        } else {\n            result[i] = values[i];\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Target sum is infinite or NaN\");\n    }\n    double sum = 0;\n    for (double value : values) {\n        if (Double.isInfinite(value)) {\n            throw new MathArithmeticException(\"Input array contains infinite elements\");\n        }\n        if (!Double.isNaN(value)) {\n            sum += value;\n        }\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(\"Input array sums to zero\");\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] * normalizedSum / sum;\n        } else {\n            result[i] = values[i];\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Target sum is infinite or NaN\");\n    }\n    double sum = 0;\n    for (double value : values) {\n        if (Double.isInfinite(value)) {\n            throw new MathArithmeticException(\"Input array contains infinite elements\");\n        }\n        if (!Double.isNaN(value)) {\n            sum += value;\n        }\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(\"Input array sums to zero\");\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] * normalizedSum / sum;\n        } else {\n            result[i] = values[i];\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Target sum is infinite or NaN\");\n    }\n    double sum = 0;\n    for (double value : values) {\n        if (Double.isInfinite(value)) {\n            throw new MathArithmeticException(\"Input array contains infinite elements\");\n        }\n        if (!Double.isNaN(value)) {\n            sum += value;\n        }\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(\"Input array sums to zero\");\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] * normalizedSum / sum;\n        } else {\n            result[i] = values[i];\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Target sum is infinite or NaN\");\n    }\n    double sum = 0;\n    for (double value : values) {\n        if (Double.isInfinite(value)) {\n            throw new MathArithmeticException(\"Input array contains infinite elements\");\n        }\n        if (!Double.isNaN(value)) {\n            sum += value;\n        }\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(\"Input array sums to zero\");\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] * normalizedSum / sum;\n        } else {\n            result[i] = values[i];\n        }\n    }\n    return result;\n}"
    ],
    [
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    StringBuilder result = new StringBuilder();\n    boolean capitalizeNext = true;\n    for (char c : str.toCharArray()) {\n        if (Arrays.asList(delimiters).contains(c)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            result.append(Character.toUpperCase(c));\n            capitalizeNext = false;\n        } else {\n            result.append(c);\n        }\n    }\n    return result.toString();\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    StringBuilder result = new StringBuilder();\n    boolean capitalizeNext = true;\n\n    for (char c : str.toCharArray()) {\n        if (delimiters != null && ArrayUtils.contains(delimiters, c)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            result.append(Character.toUpperCase(c));\n            capitalizeNext = false;\n        } else {\n            result.append(c);\n        }\n    }\n    return result.toString();\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    StringBuilder sb = new StringBuilder();\n    boolean capitalizeNext = true;\n    for (char c : str.toCharArray()) {\n        if (delimiters != null && Arrays.binarySearch(delimiters, c) >= 0) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            sb.append(Character.toUpperCase(c));\n            capitalizeNext = false;\n        } else {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    StringBuilder sb = new StringBuilder();\n    boolean capitalizeNext = true;\n    for (char c : str.toCharArray()) {\n        if (delimiters != null && Arrays.binarySearch(delimiters, c) >= 0) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            sb.append(Character.toUpperCase(c));\n            capitalizeNext = false;\n        } else {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    StringBuilder result = new StringBuilder();\n    boolean capitalizeNext = true;\n\n    for (char c : str.toCharArray()) {\n        if (delimiters != null && Arrays.binarySearch(delimiters, c) >= 0) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            result.append(Character.toUpperCase(c));\n            capitalizeNext = false;\n        } else {\n            result.append(c);\n        }\n    }\n    return result.toString();\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    StringBuilder result = new StringBuilder();\n    boolean capitalizeNext = true;\n    for (char c : str.toCharArray()) {\n        if (delimiters != null && Arrays.binarySearch(delimiters, c) >= 0) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            result.append(Character.toUpperCase(c));\n            capitalizeNext = false;\n        } else {\n            result.append(c);\n        }\n    }\n    return result.toString();\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    StringBuilder sb = new StringBuilder();\n    boolean capitalizeNext = true;\n    for (char c : str.toCharArray()) {\n        if (delimiters != null && ArrayUtils.contains(delimiters, c)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            sb.append(Character.toUpperCase(c));\n            capitalizeNext = false;\n        } else {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    StringBuilder sb = new StringBuilder();\n    boolean capitalizeNext = true;\n    for (char c : str.toCharArray()) {\n        if (Arrays.binarySearch(delimiters, c) >= 0) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            sb.append(Character.toUpperCase(c));\n            capitalizeNext = false;\n        } else {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    StringBuilder sb = new StringBuilder();\n    boolean capitalizeNext = true;\n    for (char c : str.toCharArray()) {\n        if (delimiters != null && ArrayUtils.contains(delimiters, c)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            sb.append(Character.toUpperCase(c));\n            capitalizeNext = false;\n        } else {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    StringBuilder result = new StringBuilder();\n    boolean capitalizeNext = true;\n\n    for (char c : str.toCharArray()) {\n        if (delimiters != null && ArrayUtils.contains(delimiters, c)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            result.append(Character.toUpperCase(c));\n            capitalizeNext = false;\n        } else {\n            result.append(c);\n        }\n    }\n    return result.toString();\n}"
    ],
    [
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.toDateTime().withZone(iZone).toMutableDateTime();\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.toDateTime().withZone(iZone).toMutableDateTime();\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}"
    ],
    [
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix X = getX();\n        RealVector y = getY();\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealMatrix XTranspose = X.transpose();\n        RealMatrix XTransposeOmegaInverseX = XTranspose.multiply(OmegaInverse).multiply(X);\n        RealMatrix XTransposeOmegaInverse = XTranspose.multiply(OmegaInverse);\n        RealVector XTransposeOmegaInverseY = XTransposeOmegaInverse.multiply(y);\n        RealMatrix XTransposeOmegaInverseXInverse = XTransposeOmegaInverseX.inverse();\n        return XTransposeOmegaInverseXInverse.multiply(XTransposeOmegaInverseY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix X = getX();\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealVector y = getYSampleData();\n        RealMatrix XOmegaInverseX = X.multiply(OmegaInverse).multiply(X.transpose());\n        RealMatrix XOmegaInverseY = X.multiply(OmegaInverse).multiply(y);\n        return XOmegaInverseX.solve(XOmegaInverseY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix X = getX();\n        RealVector y = gety();\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealMatrix XTOmegaInverseX = X.transpose().multiply(OmegaInverse).multiply(X);\n        RealMatrix XTOmegaInverseY = X.transpose().multiply(OmegaInverse).multiply(y);\n        return XTOmegaInverseX.solve(XTOmegaInverseY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix X = getX();\n        RealVector y = gety();\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealMatrix XTOmegaInverseX = X.multiply(OmegaInverse).multiply(X.transpose());\n        RealMatrix XTOmegaInverseXInverse = XTOmegaInverseX.inverse();\n        RealMatrix XTOmegaInverseY = X.multiply(OmegaInverse).multiply(y);\n        return XTOmegaInverseXInverse.multiply(XTOmegaInverseY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix X = getX();\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealVector y = getYSampleData();\n        RealMatrix XOmegaInverseX = X.transpose().multiply(OmegaInverse).multiply(X);\n        RealMatrix XOmegaInverseY = X.transpose().multiply(OmegaInverse).multiply(y);\n        return XOmegaInverseX.solve(XOmegaInverseY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix X = getX();\n        RealVector y = getY();\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealMatrix XTranspose = X.transpose();\n        RealMatrix XTransposeOmegaInverseX = XTranspose.multiply(OmegaInverse).multiply(X);\n        RealMatrix XTransposeOmegaInverse = XTranspose.multiply(OmegaInverse);\n        RealVector beta = XTransposeOmegaInverseX.solve(XTransposeOmegaInverse).multiply(XTransposeOmegaInverse).multiply(y);\n        return beta;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix X = getX();\n        RealVector y = getY();\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealMatrix XTX = X.transpose().multiply(OmegaInverse).multiply(X);\n        RealVector Xty = X.transpose().multiply(OmegaInverse).multiply(y);\n        return XTX.solve(Xty);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix X = getX();\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealMatrix XTX = X.transpose().multiply(OmegaInverse).multiply(X);\n        RealMatrix XTY = X.transpose().multiply(OmegaInverse).multiply(getY());\n        return XTX.solve(XTY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix XTransposeOmegaInverseX = X.transpose().multiply(getOmegaInverse()).multiply(X);\n        RealMatrix XTransposeOmegaInverseY = X.transpose().multiply(getOmegaInverse()).multiply(Y);\n        return XTransposeOmegaInverseX.solve(XTransposeOmegaInverseY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix XTransposeOmegaInverseX = getX().multiply(getOmegaInverse()).multiply(getX().transpose());\n        RealMatrix XTransposeOmegaInverseY = getX().multiply(getOmegaInverse()).multiply(getY());\n        return XTransposeOmegaInverseX.solve(XTransposeOmegaInverseY);\n    }"
    ],
    [
      "public Element getElementById(String id)  {\n    if (getAttribute(\"id\").equals(id)) {\n        return this;\n    } else {\n        List<Element> children = childElementsList();\n        for (Element child : children) {\n            Element result = child.getElementById(id);\n            if (result != null) {\n                return result;\n            }\n        }\n    }\n    return null;\n}",
      "public Element getElementById(String id)  {\n    if (getAttribute(\"id\").equals(id)) {\n        return this;\n    } else {\n        return getElementsById(id).get(0);\n    }\n}",
      "public Element getElementById(String id)  {\n    if (getId().equals(id)) {\n        return this;\n    }\n    List<Element> children = childElementsList();\n    for (Element child : children) {\n        Element result = child.getElementById(id);\n        if (result != null) {\n            return result;\n        }\n    }\n    return null;\n}",
      "public Element getElementById(String id)  {\n    return Collector.collect(new Evaluator.Id(id), this);\n}",
      "public Element getElementById(String id)  {\n    if (getId().equals(id)) {\n        return this;\n    }\n    if (parentNode == null) {\n        return null;\n    }\n    return parentNode.getElementById(id);\n}",
      "public Element getElementById(String id)  {\n    return Collector.collect(new Evaluator.Id(id), this);\n}",
      "public Element getElementById(String id)  {\n    if (getAttribute(\"id\").equals(id)) {\n        return this;\n    } else {\n        Elements children = childElements();\n        for (Element child : children) {\n            Element result = child.getElementById(id);\n            if (result != null) {\n                return result;\n            }\n        }\n    }\n    return null;\n}",
      "public Element getElementById(String id)  {\n    if (getAttribute(\"id\").equals(id)) {\n        return this;\n    }\n    if (parentNode == null) {\n        return null;\n    }\n    return parentNode.getElementById(id);\n}",
      "public Element getElementById(String id)  {\n    return Collector.collect(new Evaluator.Id(id), this);\n}",
      "public Element getElementById(String id)  {\n    if (getId().equals(id)) {\n        return this;\n    }\n    if (parentNode == null) {\n        return null;\n    }\n    return parentNode.getElementById(id);\n}"
    ],
    [
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder();\n    int pos = 0;\n    while (pos < pattern.length()) {\n        int start = pos;\n        while (pos < pattern.length() && pattern.charAt(pos) != START_FE) {\n            result.append(pattern.charAt(pos));\n            pos++;\n        }\n        if (pos < pattern.length()) {\n            result.append(START_FE);\n            pos++;\n            int depth = 1;\n            while (pos < pattern.length()) {\n                char c = pattern.charAt(pos);\n                if (c == START_FE) {\n                    depth++;\n                } else if (c == END_FE) {\n                    depth--;\n                    if (depth == 0) {\n                        break;\n                    }\n                }\n                result.append(c);\n                pos++;\n            }\n            if (pos < pattern.length()) {\n                result.append(END_FE);\n                pos++;\n            }\n            if (customPatterns != null) {\n                for (String customPattern : customPatterns) {\n                    result.append(customPattern);\n                }\n            }\n        }\n        result.append(pattern.substring(start, pos));\n        pos++;\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    int pos = 0;\n    StringBuilder result = new StringBuilder();\n    while (pos < pattern.length()) {\n        int start = pos;\n        while (pos < pattern.length() && pattern.charAt(pos) != START_FE) {\n            result.append(pattern.charAt(pos));\n            pos++;\n        }\n        if (pos < pattern.length()) {\n            result.append(START_FE);\n            pos++;\n            int depth = 1;\n            while (pos < pattern.length()) {\n                char c = pattern.charAt(pos);\n                if (c == START_FE) {\n                    depth++;\n                } else if (c == END_FE) {\n                    depth--;\n                    if (depth == 0) {\n                        break;\n                    }\n                }\n                result.append(c);\n                pos++;\n            }\n            result.append(END_FE);\n        }\n        if (pos < pattern.length()) {\n            char c = pattern.charAt(pos);\n            if (c == QUOTE) {\n                int quotePos = pos;\n                pos++;\n                while (pos < pattern.length() && pattern.charAt(pos) != QUOTE) {\n                    pos++;\n                }\n                if (pos < pattern.length()) {\n                    result.append(pattern.substring(quotePos, pos));\n                    pos++;\n                }\n            } else {\n                result.append(pattern.substring(start, pos));\n            }\n        }\n        if (customPatterns != null) {\n            for (String customPattern : customPatterns) {\n                if (pattern.startsWith(customPattern, pos)) {\n                    result.append(customPattern);\n                    pos += customPattern.length();\n                    break;\n                }\n            }\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder();\n    int start = 0;\n    for (int i = 0; i < pattern.length(); i++) {\n        char c = pattern.charAt(i);\n        if (c == START_FMT) {\n            result.append(pattern.substring(start, i));\n            start = i + 1;\n            while (i < pattern.length() && pattern.charAt(i) != END_FE) {\n                i++;\n            }\n            if (i < pattern.length()) {\n                result.append(END_FE);\n            }\n            start = i + 1;\n        }\n    }\n    result.append(pattern.substring(start));\n    for (String customPattern : customPatterns) {\n        result.append(START_FMT).append(customPattern).append(END_FE);\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder();\n    int pos = 0;\n    while (pos < pattern.length()) {\n        if (pattern.startsWith(START_FE, pos)) {\n            int end = pattern.indexOf(END_FE, pos);\n            if (end == -1) {\n                throw new IllegalArgumentException(\"Unterminated format element at position \" + pos);\n            }\n            result.append(pattern.substring(pos, end));\n            pos = end + 1;\n            String desc = parseFormatDescription(pattern.substring(pos), new ParsePosition(0));\n            int index = readArgumentIndex(pattern, new ParsePosition(pos));\n            pos += end - pos + 1;\n            if (customPatterns != null) {\n                for (String customPattern : customPatterns) {\n                    if (customPattern.equals(desc)) {\n                        result.append(customPattern);\n                        break;\n                    }\n                }\n            }\n            result.append(desc);\n            pos += desc.length();\n        } else {\n            result.append(pattern.charAt(pos));\n            pos++;\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder();\n    int pos = 0;\n    while (pos < pattern.length()) {\n        int start = pos;\n        while (pos < pattern.length() && pattern.charAt(pos) != START_FE) {\n            result.append(pattern.charAt(pos));\n            pos++;\n        }\n        if (pos < pattern.length()) {\n            result.append(START_FE);\n            pos++;\n            int end = pos;\n            while (pos < pattern.length() && pattern.charAt(pos) != END_FE) {\n                pos++;\n            }\n            if (pos < pattern.length()) {\n                result.append(END_FE);\n                pos++;\n            }\n            String format = pattern.substring(start + 1, end - 1);\n            if (customPatterns != null) {\n                for (String customPattern : customPatterns) {\n                    if (format.equals(customPattern)) {\n                        result.append(customPattern);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder();\n    int pos = 0;\n    while (pos < pattern.length()) {\n        int start = pos;\n        while (pos < pattern.length() && Character.isWhitespace(pattern.charAt(pos))) {\n            pos++;\n        }\n        if (pos < pattern.length() && pattern.charAt(pos) == START_FMT) {\n            int end = pos + 1;\n            while (end < pattern.length() && !Character.isWhitespace(pattern.charAt(end))) {\n                end++;\n            }\n            String name = pattern.substring(start, end).trim();\n            result.append(pattern.substring(start, end));\n            if (customPatterns != null && customPatterns.contains(name)) {\n                int index = readArgumentIndex(pattern, new ParsePosition(end));\n                String args = parseFormatDescription(pattern, new ParsePosition(end));\n                Format format = getFormat(name);\n                if (format != null) {\n                    result.append(format.toPattern(index, args));\n                }\n            } else {\n                result.append(pattern.substring(end, pattern.length()));\n            }\n            pos = end;\n        } else {\n            result.append(pattern.substring(start, pos));\n            pos++;\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder();\n    int start = 0;\n    for (int i = 0; i < pattern.length(); i++) {\n        char c = pattern.charAt(i);\n        if (c == START_FE) {\n            result.append(pattern.substring(start, i));\n            String desc = parseFormatDescription(pattern, new ParsePosition(i));\n            int index = readArgumentIndex(pattern, new ParsePosition(i));\n            Format format = getFormat(desc);\n            if (format != null) {\n                if (customPatterns != null && customPatterns.contains(desc)) {\n                    result.append(desc);\n                } else {\n                    result.append(format.toPattern());\n                }\n            } else {\n                result.append(desc);\n            }\n            start = i + 1;\n        }\n    }\n    result.append(pattern.substring(start));\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder();\n    int pos = 0;\n    while (pos < pattern.length()) {\n        if (pattern.charAt(pos) == START_FMT) {\n            int start = pos + 1;\n            int end = pattern.indexOf(END_FE, start);\n            if (end == -1) {\n                throw new IllegalArgumentException(\"Unterminated format element at position \" + pos);\n            }\n            String desc = pattern.substring(start, end);\n            Format format = getFormat(desc);\n            if (format != null) {\n                result.append(pattern.substring(pos, start));\n                if (customPatterns != null) {\n                    for (String customPattern : customPatterns) {\n                        if (customPattern.equals(desc)) {\n                            result.append(customPattern);\n                            break;\n                        }\n                    }\n                }\n                result.append(format.toPattern());\n            } else {\n                result.append(pattern.substring(pos, end + 1));\n            }\n            pos = end + 1;\n        } else {\n            result.append(pattern.charAt(pos));\n            pos++;\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    int pos = 0;\n    StringBuilder result = new StringBuilder();\n    while (pos < pattern.length()) {\n        int start = pos;\n        while (pos < pattern.length() && pattern.charAt(pos) != START_FE) {\n            pos++;\n        }\n        if (pos < pattern.length()) {\n            result.append(pattern.substring(start, pos));\n            pos++;\n            while (pos < pattern.length() && pattern.charAt(pos) != END_FE) {\n                pos++;\n            }\n            if (pos < pattern.length()) {\n                result.append(pattern.substring(pos, pos + 1));\n                pos++;\n            }\n            if (customPatterns != null && !customPatterns.isEmpty()) {\n                String customPattern = customPatterns.remove(0);\n                result.append(customPattern);\n            }\n        } else {\n            result.append(pattern.substring(start));\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder();\n    int pos = 0;\n    while (pos < pattern.length()) {\n        if (pattern.charAt(pos) == START_FMT) {\n            int end = pattern.indexOf(END_FE, pos);\n            if (end == -1) {\n                throw new RuntimeException(\"Unmatched START_FMT at position \" + pos);\n            }\n            String fmt = pattern.substring(pos, end + 1);\n            result.append(pattern.substring(pos, fmt.indexOf(START_FMT)));\n            String desc = parseFormatDescription(fmt, new ParsePosition(0));\n            int argIndex = readArgumentIndex(fmt, new ParsePosition(0));\n            Format format = getFormat(desc);\n            if (format != null) {\n                if (customPatterns != null) {\n                    for (String customPattern : customPatterns) {\n                        if (customPattern.equals(desc)) {\n                            format = new Format(customPattern, argIndex);\n                            break;\n                        }\n                    }\n                }\n                result.append(format.toPattern());\n            } else {\n                result.append(fmt);\n            }\n            pos = end + 1;\n        } else {\n            result.append(pattern.charAt(pos));\n            pos++;\n        }\n    }\n    return result.toString();\n}"
    ],
    [
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}"
    ],
    [
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n      if (fromArg instanceof TypeVariable<?>) {\n        fromArg = typeVarMap.get(((TypeVariable<?>) fromArg).getName());\n      }\n      if (toArg instanceof TypeVariable<?>) {\n        toArg = typeVarMap.get(((TypeVariable<?>) toArg).getName());\n      }\n      if (!typeEquals(fromArg, toArg)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getActualTypeArguments().length != to.getActualTypeArguments().length) {\n      return false;\n    }\n    for (int i = 0; i < from.getActualTypeArguments().length; i++) {\n      Type fromArg = from.getActualTypeArguments()[i];\n      Type toArg = to.getActualTypeArguments()[i];\n      if (fromArg instanceof TypeVariable<?>) {\n        fromArg = typeVarMap.get(((TypeVariable<?>) fromArg).getName());\n      }\n      if (toArg instanceof TypeVariable<?>) {\n        toArg = typeVarMap.get(((TypeVariable<?>) toArg).getName());\n      }\n      if (!typeEquals(fromArg, toArg)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getActualTypeArguments().length != to.getActualTypeArguments().length) {\n      return false;\n    }\n    for (int i = 0; i < from.getActualTypeArguments().length; i++) {\n      Type fromType = from.getActualTypeArguments()[i];\n      Type toType = to.getActualTypeArguments()[i];\n      if (fromType instanceof TypeVariable<?>) {\n        fromType = typeVarMap.get(((TypeVariable<?>) fromType).getName());\n      }\n      if (toType instanceof TypeVariable<?>) {\n        toType = typeVarMap.get(((TypeVariable<?>) toType).getName());\n      }\n      if (!typeEquals(fromType, toType)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n      if (fromArg instanceof TypeVariable<?>) {\n        fromArg = typeVarMap.get(((TypeVariable<?>) fromArg).getName());\n      }\n      if (toArg instanceof TypeVariable<?>) {\n        toArg = typeVarMap.get(((TypeVariable<?>) toArg).getName());\n      }\n      if (!typeEquals(fromArg, toArg)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n\n      if (fromArg instanceof TypeVariable<?>) {\n        fromArg = typeVarMap.get(((TypeVariable<?>) fromArg).getName());\n      }\n\n      if (toArg instanceof TypeVariable<?>) {\n        toArg = typeVarMap.get(((TypeVariable<?>) toArg).getName());\n      }\n\n      if (!typeEquals(fromArg, toArg)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n    Type[] fromTypeArgs = from.getActualTypeArguments();\n    Type[] toTypeArgs = to.getActualTypeArguments();\n    if (fromTypeArgs.length != toTypeArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromTypeArgs.length; i++) {\n      Type fromArg = fromTypeArgs[i];\n      Type toArg = toTypeArgs[i];\n      if (fromArg instanceof TypeVariable<?>) {\n        fromArg = typeVarMap.get(((TypeVariable<?>) fromArg).getName());\n      }\n      if (toArg instanceof TypeVariable<?>) {\n        toArg = typeVarMap.get(((TypeVariable<?>) toArg).getName());\n      }\n      if (!typeEquals(fromArg, toArg)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n    Type[] fromTypeArguments = from.getActualTypeArguments();\n    Type[] toTypeArguments = to.getActualTypeArguments();\n    if (fromTypeArguments.length != toTypeArguments.length) {\n      return false;\n    }\n    for (int i = 0; i < fromTypeArguments.length; i++) {\n      Type fromTypeArgument = fromTypeArguments[i];\n      Type toTypeArgument = toTypeArguments[i];\n      if (fromTypeArgument instanceof TypeVariable<?>) {\n        fromTypeArgument = typeVarMap.get(((TypeVariable<?>) fromTypeArgument).getName());\n      }\n      if (toTypeArgument instanceof TypeVariable<?>) {\n        toTypeArgument = typeVarMap.get(((TypeVariable<?>) toTypeArgument).getName());\n      }\n      if (!typeEquals(fromTypeArgument, toTypeArgument)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n\n    Type[] fromTypeArgs = from.getActualTypeArguments();\n    Type[] toTypeArgs = to.getActualTypeArguments();\n\n    if (fromTypeArgs.length != toTypeArgs.length) {\n      return false;\n    }\n\n    for (int i = 0; i < fromTypeArgs.length; i++) {\n      Type fromArg = fromTypeArgs[i];\n      Type toArg = toTypeArgs[i];\n\n      if (fromArg instanceof TypeVariable<?>) {\n        fromArg = typeVarMap.get(((TypeVariable<?>) fromArg).getName());\n      }\n\n      if (toArg instanceof TypeVariable<?>) {\n        toArg = typeVarMap.get(((TypeVariable<?>) toArg).getName());\n      }\n\n      if (!typeEquals(fromArg, toArg)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getActualTypeArguments().length != to.getActualTypeArguments().length) {\n      return false;\n    }\n\n    for (int i = 0; i < from.getActualTypeArguments().length; i++) {\n      Type fromArg = from.getActualTypeArguments()[i];\n      Type toArg = to.getActualTypeArguments()[i];\n      if (fromArg instanceof TypeVariable<?>) {\n        fromArg = typeVarMap.get(((TypeVariable<?>) fromArg).getName());\n      }\n      if (toArg instanceof TypeVariable<?>) {\n        toArg = typeVarMap.get(((TypeVariable<?>) toArg).getName());\n      }\n      if (!typeEquals(fromArg, toArg)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getActualTypeArguments().length != to.getActualTypeArguments().length) {\n      return false;\n    }\n    for (int i = 0; i < from.getActualTypeArguments().length; i++) {\n      Type fromArg = from.getActualTypeArguments()[i];\n      Type toArg = to.getActualTypeArguments()[i];\n      if (fromArg instanceof TypeVariable<?>) {\n        fromArg = typeVarMap.get(((TypeVariable<?>) fromArg).getName());\n      }\n      if (toArg instanceof TypeVariable<?>) {\n        toArg = typeVarMap.get(((TypeVariable<?>) toArg).getName());\n      }\n      if (!typeEquals(fromArg, toArg)) {\n        return false;\n      }\n    }\n    return true;\n  }"
    ],
    [
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n        if (iterator instanceof Unmodifiable) {\n            return (Iterator<E>) iterator;\n        }\n        return new Iterator<E>() {\n}\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n        if (iterator instanceof Unmodifiable) {\n            return iterator;\n        }\n        return new UnmodifiableIterator<>(iterator);\n    }",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n        if (iterator instanceof Unmodifiable) {\n            return (Iterator<E>) iterator;\n        }\n        return new UnmodifiableIterator<>(iterator);\n    }",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n        if (iterator instanceof Unmodifiable) {\n            return (Iterator<E>) iterator;\n        }\n        return new Iterator<E>() {\n}\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n        if (iterator instanceof Unmodifiable) {\n            return iterator;\n        }\n        return new UnmodifiableIterator<>(iterator);\n    }",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n        if (iterator instanceof Unmodifiable) {\n            return iterator;\n        }\n        return new UnmodifiableIterator<>(iterator);\n    }",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n        if (iterator instanceof Unmodifiable) {\n            return iterator;\n        }\n        return new UnmodifiableIterator<>(iterator);\n    }",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n        if (iterator instanceof Unmodifiable) {\n            return iterator;\n        }\n        return new UnmodifiableIterator<>(iterator);\n    }",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n        if (iterator instanceof Unmodifiable) {\n            return (Iterator<E>) iterator;\n        }\n        return new UnmodifiableIterator<>(iterator);\n    }",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n        if (iterator instanceof Unmodifiable) {\n            return iterator;\n        }\n        return new UnmodifiableIterator<>(iterator);\n    }"
    ],
    [
      "public N getPartitionSuperNode(N node)  {\n    int color = graph.getNodeAnnotation(node).getColor();\n    return colorToNodeMap[color];\n}",
      "public N getPartitionSuperNode(N node)  {\n    int color = getColor(node);\n    return colorToNodeMap[color];\n}",
      "public N getPartitionSuperNode(N node)  {\n    int color = getColor(node);\n    return colorToNodeMap[color];\n}",
      "public N getPartitionSuperNode(N node)  {\n    int color = graph.getAnnotation(node);\n    return colorToNodeMap[color];\n  }",
      "public N getPartitionSuperNode(N node)  {\n    int color = graph.getNodeAnnotation(node).getColor();\n    return colorToNodeMap[color];\n}",
      "public N getPartitionSuperNode(N node)  {\n    int color = getColor(node);\n    return colorToNodeMap[color];\n}",
      "public N getPartitionSuperNode(N node)  {\n    int color = getColor(node);\n    return colorToNodeMap[color];\n}",
      "public N getPartitionSuperNode(N node)  {\n    int color = graph.getAnnotation(node);\n    return colorToNodeMap[color];\n  }",
      "public N getPartitionSuperNode(N node)  {\n    int color = getColor(node);\n    return colorToNodeMap[color];\n}",
      "public N getPartitionSuperNode(N node)  {\n    int color = getColor(node);\n    return colorToNodeMap[color];\n}"
    ],
    [
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}"
    ],
    [
      "public double integrate(UnivariateFunction f)  {\n    double integral = 0.0;\n    for (int i = 0; i < points.length; i++) {\n        integral += f.value(points[i]) * weights[i];\n    }\n    return integral;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double integral = 0.0;\n    for (int i = 0; i < points.length; i++) {\n        integral += weights[i] * f.value(points[i]);\n    }\n    return integral;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double integral = 0;\n    for (int i = 0; i < points.length; i++) {\n        integral += weights[i] * f.value(points[i]);\n    }\n    return integral;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double integral = 0.0;\n    for (int i = 0; i < points.length; i++) {\n        integral += f.value(points[i]) * weights[i];\n    }\n    return integral;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double integral = 0;\n    for (int i = 0; i < points.length; i++) {\n        integral += f.value(points[i]) * weights[i];\n    }\n    return integral;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double integral = 0;\n    for (int i = 0; i < points.length; i++) {\n        integral += f.value(points[i]) * weights[i];\n    }\n    return integral;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double integral = 0;\n    for (int i = 0; i < points.length; i++) {\n        integral += f.value(points[i]) * weights[i];\n    }\n    return integral;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double integral = 0.0;\n    for (int i = 0; i < points.length; i++) {\n        integral += weights[i] * f.value(points[i]);\n    }\n    return integral;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double integral = 0;\n    for (int i = 0; i < points.length; i++) {\n        integral += f.value(points[i]) * weights[i];\n    }\n    return integral;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double integral = 0;\n    for (int i = 0; i < points.length; i++) {\n        integral += weights[i] * f.value(points[i]);\n    }\n    return integral;\n}"
    ],
    [
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Iterator iterator1 = map1.keySet().iterator();\n    Iterator iterator2 = map2.keySet().iterator();\n    while (iterator1.hasNext()) {\n        Comparable key1 = (Comparable) iterator1.next();\n        Comparable key2 = (Comparable) iterator2.next();\n        if (!key1.equals(key2)) {\n            return false;\n        }\n        Paint paint1 = (Paint) map1.get(key1);\n        Paint paint2 = (Paint) map2.get(key2);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    if (!keys1.equals(keys2)) {\n        return false;\n    }\n    Iterator iterator1 = keys1.iterator();\n    while (iterator1.hasNext()) {\n        Comparable key = (Comparable) iterator1.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Iterator iterator1 = map1.keySet().iterator();\n    Iterator iterator2 = map2.keySet().iterator();\n    while (iterator1.hasNext() && iterator2.hasNext()) {\n        Comparable key1 = (Comparable) iterator1.next();\n        Comparable key2 = (Comparable) iterator2.next();\n        if (!key1.equals(key2)) {\n            return false;\n        }\n        Paint paint1 = (Paint) map1.get(key1);\n        Paint paint2 = (Paint) map2.get(key2);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    if (!keys1.equals(keys2)) {\n        return false;\n    }\n    Iterator iterator1 = keys1.iterator();\n    while (iterator1.hasNext()) {\n        Comparable key = (Comparable) iterator1.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Iterator iterator1 = map1.keySet().iterator();\n    Iterator iterator2 = map2.keySet().iterator();\n    while (iterator1.hasNext() && iterator2.hasNext()) {\n        Comparable key1 = (Comparable) iterator1.next();\n        Comparable key2 = (Comparable) iterator2.next();\n        if (!key1.equals(key2)) {\n            return false;\n        }\n        Paint paint1 = (Paint) map1.get(key1);\n        Paint paint2 = (Paint) map2.get(key2);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Iterator iterator1 = map1.keySet().iterator();\n    Iterator iterator2 = map2.keySet().iterator();\n    while (iterator1.hasNext()) {\n        Comparable key1 = (Comparable) iterator1.next();\n        Comparable key2 = (Comparable) iterator2.next();\n        if (!key1.equals(key2)) {\n            return false;\n        }\n        Paint paint1 = (Paint) map1.get(key1);\n        Paint paint2 = (Paint) map2.get(key2);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Iterator iterator1 = map1.keySet().iterator();\n    Iterator iterator2 = map2.keySet().iterator();\n    while (iterator1.hasNext()) {\n        Comparable key1 = (Comparable) iterator1.next();\n        Comparable key2 = (Comparable) iterator2.next();\n        if (!key1.equals(key2)) {\n            return false;\n        }\n        Paint paint1 = (Paint) map1.get(key1);\n        Paint paint2 = (Paint) map2.get(key2);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Iterator iterator1 = map1.keySet().iterator();\n    Iterator iterator2 = map2.keySet().iterator();\n    while (iterator1.hasNext()) {\n        Comparable key1 = (Comparable) iterator1.next();\n        Comparable key2 = (Comparable) iterator2.next();\n        if (!key1.equals(key2)) {\n            return false;\n        }\n        Paint paint1 = (Paint) map1.get(key1);\n        Paint paint2 = (Paint) map2.get(key2);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Iterator iterator1 = map1.keySet().iterator();\n    Iterator iterator2 = map2.keySet().iterator();\n    while (iterator1.hasNext()) {\n        Comparable key1 = (Comparable) iterator1.next();\n        Comparable key2 = (Comparable) iterator2.next();\n        if (!key1.equals(key2)) {\n            return false;\n        }\n        Paint paint1 = (Paint) map1.get(key1);\n        Paint paint2 = (Paint) map2.get(key2);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Iterator iterator1 = map1.keySet().iterator();\n    Iterator iterator2 = map2.keySet().iterator();\n    while (iterator1.hasNext() && iterator2.hasNext()) {\n        Comparable key1 = (Comparable) iterator1.next();\n        Comparable key2 = (Comparable) iterator2.next();\n        if (!key1.equals(key2)) {\n            return false;\n        }\n        Paint paint1 = (Paint) map1.get(key1);\n        Paint paint2 = (Paint) map2.get(key2);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) {\n        String str = expr.getString();\n        if (str.length() > 20) {\n            String encodedStr = Base64.encodeBytes(str.getBytes());\n            Node encodedNode = t.createStringNode(encodedStr);\n            expr.replaceWith(encodedNode);\n            return encodedNode;\n        }\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) {\n        String value = expr.getString();\n        if (value.length() > 100) {\n            // Encode the string\n            String encoded = Base64.encodeBase64String(value.getBytes());\n            Node newNode = t.createString(encoded);\n            parent.replaceChild(expr, newNode);\n            return newNode;\n        }\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) {\n        String str = expr.getString();\n        if (str.startsWith(\"Error('\")) {\n            int end = str.indexOf('') + 1;\n            String msg = str.substring(end);\n            expr.replaceWith(t.createString(\"Error('\" + encodeString(msg) + \"')\"));\n        }\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) {\n        String str = expr.getString();\n        if (str.length() > 50) {\n            String encodedStr = encodeString(str);\n            Node newNode = t.createStringNode(encodedStr);\n            parent.replaceChild(expr, newNode);\n            return newNode;\n        }\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) {\n        String str = expr.getString();\n        if (str.startsWith(\"Error('\") && str.endsWith(\"')\")) {\n            str = str.substring(7, str.length() - 1);\n            Node newNode = t.createStringLiteral(str);\n            parent.replaceChild(expr, newNode);\n            return newNode;\n        }\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) {\n        String str = expr.getString();\n        if (str.length() > 100) {\n            // Encode the string.\n            String encoded = Base64.encodeBytes(str.getBytes());\n            Node newNode = t.createStringNode(encoded);\n            parent.replaceChild(expr, newNode);\n            return newNode;\n        }\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) {\n        String value = expr.getString();\n        if (value.length() > 1) {\n            String shortEncoded = ShortEncoder.encode(value);\n            Node newNode = t.createString(shortEncoded);\n            parent.replaceChild(expr, newNode);\n            return newNode;\n        }\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) {\n        String value = expr.getString();\n        if (value.length() > 20) {\n            value = encodeShortString(value);\n        }\n        return t.createStringLiteral(value);\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) {\n        String value = expr.getString();\n        if (value.length() > 10) {\n            String shortValue = value.substring(0, 5) + \"...\" + value.substring(value.length() - 5);\n            Node newNode = t.createString(shortValue);\n            parent.replaceChild(expr, newNode);\n            return newNode;\n        }\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) {\n        String value = expr.getString();\n        if (value.length() > 100) {\n            String shortEncodedValue = ShortStringEncoder.encode(value);\n            Node newNode = t.createString(shortEncodedValue);\n            parent.replaceChild(expr, newNode);\n            return newNode;\n        }\n    }\n    return expr;\n}"
    ],
    [
      "public double[] getCoefficients()  {\n    double[] out = new double[this.a.length];\n    System.arraycopy(this.a, 0, out, 0, this.a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[this.a.length];\n    System.arraycopy(this.a, 0, out, 0, this.a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[this.a.length];\n    System.arraycopy(this.a, 0, out, 0, this.a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[this.a.length];\n    System.arraycopy(this.a, 0, out, 0, this.a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[this.a.length];\n    System.arraycopy(this.a, 0, out, 0, this.a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}"
    ],
    [
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    if (node != null) {\n        Node jsDocNode = node.getFirstChild();\n        while (jsDocNode != null) {\n            if (jsDocNode.isTag()) {\n                String tagName = jsDocNode.getTag();\n                if (tagName.equals(\"desc\")) {\n                    Node descNode = jsDocNode.getNext();\n                    if (descNode.isString()) {\n                        String desc = descNode.getString();\n                        builder.setDesc(desc);\n                        return true;\n                    }\n                }\n            }\n            jsDocNode = jsDocNode.getNext();\n        }\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    if (node.isComment()) {\n        Node commentNode = node.getFirstChild();\n        while (commentNode != null) {\n            if (commentNode.isTag()) {\n                Node tagNode = commentNode.getFirstChild();\n                if (tagNode.isName() && tagNode.getString().equals(\"desc\")) {\n                    Node valueNode = tagNode.getNext();\n                    if (valueNode.isString()) {\n                        String desc = extractStringFromStringExprNode(valueNode);\n                        builder.setDesc(desc);\n                        return true;\n                    }\n                }\n            }\n            commentNode = commentNode.getNext();\n        }\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    if (node.isComment()) {\n        Node commentNode = node.getFirstChild();\n        if (commentNode.isTag()) {\n            Node tagNode = commentNode.getFirstChild();\n            if (tagNode.isTagName()) {\n                String tagName = tagNode.getString();\n                if (tagName.equals(\"desc\")) {\n                    Node valueNode = tagNode.getNext();\n                    if (valueNode.isStringLiteral()) {\n                        String desc = valueNode.getStringLiteral();\n                        builder.setDesc(desc);\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    if (node.isComment()) {\n        String comment = node.getComment();\n        int start = comment.indexOf(\"@desc\");\n        if (start != -1) {\n            int end = comment.indexOf(\")\", start);\n            if (end != -1) {\n                String desc = comment.substring(start + 5, end).trim();\n                builder.setDesc(desc);\n                return true;\n            }\n        }\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    if (node.isComment()) {\n        Node commentNode = node.getFirstChild();\n        if (commentNode.isTag()) {\n            Node tagNode = commentNode.getFirstChild();\n            if (tagNode.isTagName() && tagNode.getString().equals(\"desc\")) {\n                Node valueNode = tagNode.getNext();\n                if (valueNode.isStringLiteral()) {\n                    String desc = valueNode.getString();\n                    builder.setDesc(desc);\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    Node jsDocNode = node.getFirstChild();\n    while (jsDocNode != null) {\n        if (jsDocNode.isTag()) {\n            String tagName = jsDocNode.getTag().getName();\n            if (tagName.equals(\"desc\")) {\n                Node valueNode = jsDocNode.getTag().getValue();\n                if (valueNode.isString()) {\n                    String desc = valueNode.getString();\n                    builder.setDesc(desc);\n                    return true;\n                }\n            }\n        }\n        jsDocNode = jsDocNode.getNext();\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    if (node.isComment()) {\n        Node commentNode = node.getFirstChild();\n        while (commentNode != null) {\n            if (commentNode.isTag()) {\n                Node tagNode = commentNode.getFirstChild();\n                if (tagNode.isTagName() && tagNode.getString().equals(\"desc\")) {\n                    Node valueNode = tagNode.getNext();\n                    if (valueNode.isStringLiteral()) {\n                        builder.setDesc(extractStringFromStringExprNode(valueNode));\n                        return true;\n                    }\n                }\n            }\n            commentNode = commentNode.getNext();\n        }\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    if (node.isComment()) {\n        String comment = node.getComment();\n        if (comment != null) {\n            int descIndex = comment.indexOf(\"@desc\");\n            if (descIndex != -1) {\n                int endDescIndex = comment.indexOf(\")\", descIndex);\n                if (endDescIndex != -1) {\n                    String desc = comment.substring(descIndex + 5, endDescIndex);\n                    builder.setDesc(desc);\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    Node jsDocNode = node.getFirstChild();\n    while (jsDocNode != null) {\n        if (jsDocNode.isTag()) {\n            String tagName = jsDocNode.getTag();\n            if (tagName.equals(\"desc\")) {\n                Node descNode = jsDocNode.getNext();\n                if (descNode.isString()) {\n                    String desc = descNode.getString();\n                    builder.setDesc(desc);\n                    return true;\n                }\n            }\n        }\n        jsDocNode = jsDocNode.getNext();\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    if (node.isComment()) {\n        Node commentNode = node.getFirstChild();\n        while (commentNode != null) {\n            if (commentNode.isTag()) {\n                String tagName = commentNode.getTag().getName();\n                if (tagName.equals(\"desc\")) {\n                    String desc = extractStringFromStringExprNode(commentNode.getNext());\n                    builder.setDesc(desc);\n                    return true;\n                }\n            }\n            commentNode = commentNode.getNext();\n        }\n    }\n    return false;\n}"
    ],
    [
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int changes = 0;\n    for (int i = 0; i < points.size(); i++) {\n        T point = points.iterator().next();\n        double minDistance = Double.MAX_VALUE;\n        int closestCluster = -1;\n        for (int j = 0; j < clusters.size(); j++) {\n            CentroidCluster<T> cluster = clusters.get(j);\n            double distance = cluster.getCenter().distance(point);\n            if (distance < minDistance) {\n                minDistance = distance;\n                closestCluster = j;\n            }\n        }\n        if (assignments[i] != closestCluster) {\n            changes++;\n        }\n        assignments[i] = closestCluster;\n    }\n    return changes;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int changes = 0;\n    for (int i = 0; i < points.size(); i++) {\n        T point = points.iterator().next();\n        double minDistance = Double.MAX_VALUE;\n        int closestClusterIndex = -1;\n        for (int j = 0; j < clusters.size(); j++) {\n            CentroidCluster<T> cluster = clusters.get(j);\n            double distance = calculateDistance(point, cluster.getCenter().getPoint());\n            if (distance < minDistance) {\n                minDistance = distance;\n                closestClusterIndex = j;\n            }\n        }\n        if (closestClusterIndex != assignments[i]) {\n            changes++;\n        }\n        assignments[i] = closestClusterIndex;\n    }\n    return changes;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int changes = 0;\n    for (int i = 0; i < points.size(); i++) {\n        T point = points.iterator().next();\n        double minDistance = Double.MAX_VALUE;\n        int closestClusterIndex = -1;\n        for (int j = 0; j < clusters.size(); j++) {\n            CentroidCluster<T> cluster = clusters.get(j);\n            double distance = cluster.getCenter().distance(point);\n            if (distance < minDistance) {\n                minDistance = distance;\n                closestClusterIndex = j;\n            }\n        }\n        if (assignments[i] != closestClusterIndex) {\n            assignments[i] = closestClusterIndex;\n            changes++;\n        }\n    }\n    return changes;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int changes = 0;\n    for (int i = 0; i < points.size(); i++) {\n        T point = points.iterator().next();\n        int closestClusterIndex = getClosestClusterIndex(point, clusters);\n        if (assignments[i] != closestClusterIndex) {\n            changes++;\n        }\n        assignments[i] = closestClusterIndex;\n    }\n    return changes;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int changes = 0;\n    for (int i = 0; i < points.size(); i++) {\n        T point = points.iterator().next();\n        double minDistance = Double.MAX_VALUE;\n        int closestClusterIndex = -1;\n        for (int j = 0; j < clusters.size(); j++) {\n            double distance = distance(point, clusters.get(j).getCenter().getPoint());\n            if (distance < minDistance) {\n                minDistance = distance;\n                closestClusterIndex = j;\n            }\n        }\n        if (assignments[i] != closestClusterIndex) {\n            changes++;\n        }\n        assignments[i] = closestClusterIndex;\n    }\n    return changes;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int changes = 0;\n    for (int i = 0; i < points.size(); i++) {\n        T point = points.iterator().next();\n        int closestClusterIndex = -1;\n        double minDistance = Double.MAX_VALUE;\n        for (int j = 0; j < clusters.size(); j++) {\n            CentroidCluster<T> cluster = clusters.get(j);\n            double distance = distance(point, cluster.getCenter().getPoint());\n            if (distance < minDistance) {\n                minDistance = distance;\n                closestClusterIndex = j;\n            }\n        }\n        if (assignments[i] != closestClusterIndex) {\n            changes++;\n        }\n        assignments[i] = closestClusterIndex;\n    }\n    return changes;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int changes = 0;\n    for (int i = 0; i < points.size(); i++) {\n        T point = points.iterator().next();\n        double minDistance = Double.MAX_VALUE;\n        int closestClusterIndex = -1;\n        for (int j = 0; j < clusters.size(); j++) {\n            double distance = distance(point, clusters.get(j).getCenter().getPoint());\n            if (distance < minDistance) {\n                minDistance = distance;\n                closestClusterIndex = j;\n            }\n        }\n        if (assignments[i] != closestClusterIndex) {\n            changes++;\n        }\n        assignments[i] = closestClusterIndex;\n    }\n    return changes;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int changes = 0;\n    for (int i = 0; i < points.size(); i++) {\n        T point = points.iterator().next();\n        double minDistance = Double.MAX_VALUE;\n        int closestClusterIndex = -1;\n        for (int j = 0; j < clusters.size(); j++) {\n            double distance = distance(point, clusters.get(j).getCenter().getPoint());\n            if (distance < minDistance) {\n                minDistance = distance;\n                closestClusterIndex = j;\n            }\n        }\n        if (assignments[i] != closestClusterIndex) {\n            changes++;\n        }\n        assignments[i] = closestClusterIndex;\n    }\n    return changes;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int changes = 0;\n    for (int i = 0; i < points.size(); i++) {\n        T point = points.iterator().next();\n        double minDistance = Double.MAX_VALUE;\n        int closestCluster = -1;\n        for (int j = 0; j < clusters.size(); j++) {\n            CentroidCluster<T> cluster = clusters.get(j);\n            double distance = calculateDistance(point, cluster.getCenter().getPoint());\n            if (distance < minDistance) {\n                minDistance = distance;\n                closestCluster = j;\n            }\n        }\n        if (assignments[i] != closestCluster) {\n            changes++;\n        }\n        assignments[i] = closestCluster;\n    }\n    return changes;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int changes = 0;\n    for (int i = 0; i < points.size(); i++) {\n        T point = points.iterator().next();\n        double minDistance = Double.MAX_VALUE;\n        int closestCluster = -1;\n        for (int j = 0; j < clusters.size(); j++) {\n            CentroidCluster<T> cluster = clusters.get(j);\n            double distance = calculateDistance(point, cluster.getCenter().getPoint());\n            if (distance < minDistance) {\n                minDistance = distance;\n                closestCluster = j;\n            }\n        }\n        if (assignments[i] != closestCluster) {\n            changes++;\n        }\n        assignments[i] = closestCluster;\n    }\n    return changes;\n}"
    ],
    [
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"Array lengths must match\");\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"There is insufficient data\");\n    }\n    double sumX = 0;\n    double sumY = 0;\n    double sumXY = 0;\n    double sumX2 = 0;\n    double sumY2 = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXY += xArray[i] * yArray[i];\n        sumX2 += xArray[i] * xArray[i];\n        sumY2 += yArray[i] * yArray[i];\n    }\n    double meanX = sumX / xArray.length;\n    double meanY = sumY / xArray.length;\n    double cov = 0;\n    if (biasCorrected) {\n        cov = (sumXY - sumX * meanY) / (xArray.length - 1);\n    } else {\n        cov = (sumXY - sumX * meanY) / xArray.length;\n    }\n    return cov;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"Array lengths must match\");\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"There is insufficient data\");\n    }\n    double sumX = 0;\n    double sumY = 0;\n    double sumXY = 0;\n    double sumX2 = 0;\n    double sumY2 = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXY += xArray[i] * yArray[i];\n        sumX2 += xArray[i] * xArray[i];\n        sumY2 += yArray[i] * yArray[i];\n    }\n    double meanX = sumX / xArray.length;\n    double meanY = sumY / xArray.length;\n    double cov = 0;\n    if (biasCorrected) {\n        cov = (sumXY - sumX * meanY) / (xArray.length - 1);\n    } else {\n        cov = (sumXY - sumX * meanY) / xArray.length;\n    }\n    return cov;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"Array lengths must match\");\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"There is insufficient data\");\n    }\n    double sumXY = 0;\n    double sumX = 0;\n    double sumY = 0;\n    double sumXSq = 0;\n    double sumYSq = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sumXY += xArray[i] * yArray[i];\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXSq += xArray[i] * xArray[i];\n        sumYSq += yArray[i] * yArray[i];\n    }\n    double meanX = sumX / xArray.length;\n    double meanY = sumY / xArray.length;\n    double cov = 0;\n    if (biasCorrected) {\n        cov = (sumXY - sumX * meanY) / (xArray.length - 1);\n    } else {\n        cov = (sumXY - sumX * meanY) / xArray.length;\n    }\n    return cov;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"Array lengths must match\");\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"There is insufficient data\");\n    }\n    double sumXX = 0;\n    double sumXY = 0;\n    double sumYY = 0;\n    double meanX = 0;\n    double meanY = 0;\n\n    for (int i = 0; i < xArray.length; i++) {\n        sumXX += xArray[i] * xArray[i];\n        sumXY += xArray[i] * yArray[i];\n        sumYY += yArray[i] * yArray[i];\n    }\n    meanX = sumXX / xArray.length;\n    meanY = sumYY / xArray.length;\n\n    double cov = 0;\n    if (biasCorrected) {\n        cov = (sumXY - sumXX * meanY / xArray.length - sumYY * meanX / xArray.length) / (xArray.length - 1);\n    } else {\n        cov = sumXY / xArray.length;\n    }\n    return cov;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"Array lengths must match\");\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"There is insufficient data\");\n    }\n    double sumXX = 0;\n    double sumYY = 0;\n    double sumXY = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sumXX += xArray[i] * xArray[i];\n        sumYY += yArray[i] * yArray[i];\n        sumXY += xArray[i] * yArray[i];\n    }\n    double meanX = sumXX / xArray.length;\n    double meanY = sumYY / yArray.length;\n    double cov = 0;\n    if (biasCorrected) {\n        cov = (sumXY - sumXX * sumYY / xArray.length / yArray.length) / (xArray.length - 1);\n    } else {\n        cov = sumXY / xArray.length - meanX * meanY;\n    }\n    return cov;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"Array lengths must match\");\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"There is insufficient data\");\n    }\n    double sumX = 0;\n    double sumY = 0;\n    double sumXY = 0;\n    double sumXSq = 0;\n    double sumYSq = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXY += xArray[i] * yArray[i];\n        sumXSq += xArray[i] * xArray[i];\n        sumYSq += yArray[i] * yArray[i];\n    }\n    double meanX = sumX / xArray.length;\n    double meanY = sumY / xArray.length;\n    double cov = 0;\n    if (biasCorrected) {\n        cov = (sumXY - sumX * meanY - sumY * meanX + sumX * sumY / xArray.length) / (xArray.length - 1);\n    } else {\n        cov = (sumXY - sumX * meanY - sumY * meanX + sumX * sumY / xArray.length) / xArray.length;\n    }\n    return cov;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    int length = xArray.length;\n    if (length != yArray.length) {\n        throw new MathIllegalArgumentException(\"Array lengths must match\");\n    }\n    if (length < 2) {\n        throw new MathIllegalArgumentException(\"There is insufficient data\");\n    }\n\n    double sumX = 0;\n    double sumY = 0;\n    double sumXY = 0;\n    double sumX2 = 0;\n    double sumY2 = 0;\n\n    for (int i = 0; i < length; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXY += xArray[i] * yArray[i];\n        sumX2 += xArray[i] * xArray[i];\n        sumY2 += yArray[i] * yArray[i];\n    }\n\n    double meanX = sumX / length;\n    double meanY = sumY / length;\n\n    double numerator = sumXY - (sumX * sumY / length);\n    double denominatorX = sumX2 - (sumX * sumX / length);\n    double denominatorY = sumY2 - (sumY * sumY / length);\n\n    double cov = numerator / Math.sqrt(denominatorX * denominatorY);\n\n    if (biasCorrected) {\n        cov -= (denominatorX / (length - 1)) / (denominatorY / (length - 1));\n    }\n\n    return cov;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"Array lengths must match\");\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"There is insufficient data\");\n    }\n    double sumX = 0;\n    double sumY = 0;\n    double sumXY = 0;\n    double sumX2 = 0;\n    double sumY2 = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXY += xArray[i] * yArray[i];\n        sumX2 += xArray[i] * xArray[i];\n        sumY2 += yArray[i] * yArray[i];\n    }\n    double meanX = sumX / xArray.length;\n    double meanY = sumY / xArray.length;\n    double cov = 0;\n    if (biasCorrected) {\n        cov = (sumXY - sumX * meanY - sumY * meanX + sumX * sumY / xArray.length) / (xArray.length - 1);\n    } else {\n        cov = (sumXY - sumX * meanY - sumY * meanX + sumX * sumY / xArray.length) / xArray.length;\n    }\n    return cov;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"Array lengths must match\");\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"There is insufficient data\");\n    }\n    double sumXX = 0;\n    double sumXY = 0;\n    double sumYY = 0;\n    double meanX = 0;\n    double meanY = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sumXX += xArray[i] * xArray[i];\n        sumXY += xArray[i] * yArray[i];\n        sumYY += yArray[i] * yArray[i];\n    }\n    meanX = sumXX / xArray.length;\n    meanY = sumYY / xArray.length;\n    double numerator = sumXY - (xArray.length * meanX * meanY);\n    double denominatorX = sumXX - (xArray.length * meanX * meanX);\n    double denominatorY = sumYY - (xArray.length * meanY * meanY);\n    if (biasCorrected) {\n        numerator /= (denominatorX * denominatorY);\n    } else {\n        numerator /= (xArray.length - 1);\n    }\n    return numerator;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    int length = xArray.length;\n    if (length != yArray.length) {\n        throw new MathIllegalArgumentException(\"Array lengths must match\");\n    }\n    if (length < 2) {\n        throw new MathIllegalArgumentException(\"There is insufficient data\");\n    }\n    double sumXX = 0;\n    double sumYY = 0;\n    double sumXY = 0;\n    for (int i = 0; i < length; i++) {\n        sumXX += xArray[i] * xArray[i];\n        sumYY += yArray[i] * yArray[i];\n        sumXY += xArray[i] * yArray[i];\n    }\n    double meanX = sumXX / length;\n    double meanY = sumYY / length;\n    double cov = sumXY / length - meanX * meanY;\n    if (biasCorrected) {\n        cov = (cov * (length - 1.0)) / (length - 2.0);\n    }\n    return cov;\n}"
    ],
    [
      "private void realSkip(final long value) throws IOException  {\n    long total = 0;\n    while (total < value) {\n        int bytes = in.read(buf);\n        if (bytes == -1) {\n            throw new ZipException(\"Unexpected end of file\");\n        }\n        total += bytes;\n    }\n    bytesRead += total;\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value <= 0) {\n        return;\n    }\n    long total = 0;\n    while (total < value) {\n        final int bytes = (int) Math.min(value - total, Integer.MAX_VALUE);\n        in.readFully(buf, 0, bytes);\n        total += bytes;\n    }\n    bytesRead += value;\n}",
      "private void realSkip(final long value) throws IOException  {\n    long totalBytesRead = 0;\n    while (totalBytesRead < value) {\n        int bytesToRead = (int) Math.min(value - totalBytesRead, MAX_SKIP);\n        totalBytesRead += bytesToRead;\n        in.skip(bytesToRead);\n    }\n    bytesRead += value;\n}",
      "private void realSkip(final long value) throws IOException  {\n    long totalBytes = 0;\n    while (totalBytes < value) {\n        int bytesRead = in.read(buf);\n        if (bytesRead == -1) {\n            throw new ZipException(\"Premature end of file\");\n        }\n        totalBytes += bytesRead;\n    }\n    bytesRead += (int) (totalBytes - value);\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) {\n        int bytesToSkip = (int) Math.min(value - skipped, MAX_SKIP);\n        in.skip(bytesToSkip);\n        skipped += bytesToSkip;\n        bytesRead += bytesToSkip;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value <= 0) {\n        return;\n    }\n    long skipped = 0;\n    while (skipped < value) {\n        int bytesToSkip = (int) Math.min(value - skipped, MAX_SKIP);\n        skipped += bytesToSkip;\n        in.skip(bytesToSkip);\n    }\n    bytesRead += value;\n}",
      "private void realSkip(final long value) throws IOException  {\n    long total = 0;\n    while (total < value) {\n        int bytes = in.read(buf);\n        if (bytes == -1) {\n            throw new EOFException();\n        }\n        total += bytes;\n    }\n    bytesRead += total;\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value > 0) {\n        long bytesToSkip = value;\n        while (bytesToSkip > 0) {\n            int bytesAvailable = (int) Math.min(bytesToSkip, in.available());\n            in.skip(bytesAvailable);\n            bytesToSkip -= bytesAvailable;\n            bytesRead += bytesAvailable;\n        }\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long bytesToSkip = value;\n    while (bytesToSkip > 0) {\n        int bytesAvailable = (int) Math.min(bytesToSkip, Integer.MAX_VALUE);\n        bytesToSkip -= bytesAvailable;\n        in.readFully(buf, 0, bytesAvailable);\n        pushedBackBytes(bytesAvailable);\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long bytesToSkip = value;\n    while (bytesToSkip > 0) {\n        int bytesAvailable = in.available();\n        if (bytesAvailable > bytesToSkip) {\n            in.skip(bytesToSkip);\n            bytesRead += bytesToSkip;\n            bytesToSkip = 0;\n        } else {\n            in.skip(bytesAvailable);\n            bytesRead += bytesAvailable;\n            bytesToSkip -= bytesAvailable;\n        }\n    }\n}"
    ],
    [
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    if (fieldName == null) {\n        throw new IllegalArgumentException(\"fieldName must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalAccessException(\"Cannot locate declared field \" + fieldName + \" on \" + cls);\n    }\n    return readField(field, target, forceAccess);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null || fieldName == null) {\n        throw new IllegalArgumentException(\"target object and field name must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalAccessException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n    }\n    return readField(field, target, forceAccess);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null || fieldName == null) {\n        throw new IllegalArgumentException(\"target object and field name must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalAccessException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n    }\n    return readField(field, target, forceAccess);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null || fieldName == null) {\n        throw new IllegalArgumentException(\"target object and field name must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalAccessException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n    }\n    return readField(field, target, forceAccess);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    if (fieldName == null) {\n        throw new IllegalArgumentException(\"fieldName must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalAccessException(\"Cannot locate declared field \" + fieldName + \" on \" + cls);\n    }\n    return readField(field, target, forceAccess);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null || fieldName == null) {\n        throw new IllegalArgumentException(\"target or fieldName must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalAccessException(\"Cannot locate declared field \" + fieldName + \" on \" + cls);\n    }\n    return readField(field, target, forceAccess);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + fieldName + \" on \" + cls);\n    }\n    return readField(field, target, forceAccess);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    if (fieldName == null) {\n        throw new IllegalArgumentException(\"fieldName must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalAccessException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n    }\n    return readField(field, target, forceAccess);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null || fieldName == null) {\n        throw new IllegalArgumentException(\"target or fieldName must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalAccessException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n    }\n    return readField(field, target, forceAccess);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + fieldName + \" on \" + cls);\n    }\n    return readField(field, target, forceAccess);\n}"
    ],
    [
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    MessageDigest md;\n    try {\n        md = MessageDigest.getInstance(\"SHA-1\");\n    } catch (NoSuchAlgorithmException e) {\n        throw new RuntimeException(e);\n    }\n    byte[] hashBytes = new byte[0];\n    for (CharSequence part : messageParts) {\n        byte[] partBytes = part.toString().getBytes();\n        hashBytes = combineHashes(hashBytes, md.digest(partBytes));\n    }\n    return bytesToHex(hashBytes).substring(0, 8);\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    MessageDigest md = null;\n    try {\n        md = MessageDigest.getInstance(\"SHA-1\");\n    } catch (NoSuchAlgorithmException e) {\n        throw new RuntimeException(e);\n    }\n    byte[] hashBytes = new byte[0];\n    for (CharSequence part : messageParts) {\n        byte[] partBytes = part.toString().getBytes();\n        hashBytes = combineHashes(hashBytes, md.digest(partBytes));\n    }\n    return bytesToHex(hashBytes).substring(0, 8);\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    MessageDigest md = null;\n    try {\n        md = MessageDigest.getInstance(\"SHA-1\");\n    } catch (NoSuchAlgorithmException e) {\n        throw new RuntimeException(e);\n    }\n    byte[] bytes = new byte[0];\n    for (CharSequence part : messageParts) {\n        bytes = combineBytes(bytes, part.toString().getBytes());\n    }\n    byte[] digest = md.digest(bytes);\n    StringBuilder sb = new StringBuilder();\n    for (byte b : digest) {\n        sb.append(String.format(\"%02x\", b));\n    }\n    return sb.toString().substring(0, 8);\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        sb.append(part.toString().hashCode());\n    }\n    return sb.toString().substring(0, 8);\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n    byte[] hashBytes = md.digest();\n    StringBuilder sb = new StringBuilder();\n    for (byte b : hashBytes) {\n        sb.append(String.format(\"%02x\", b));\n    }\n    return sb.toString().substring(0, 8);\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        sb.append(part.toString().hashCode());\n    }\n    return sb.toString();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        byte[] bytes = part.toString().getBytes();\n        md.update(bytes);\n        byte[] digest = md.digest();\n        for (byte b : digest) {\n            sb.append(String.format(\"%02x\", b));\n        }\n    }\n    return sb.toString().substring(0, 8);\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        sb.append(part.toString().hashCode());\n    }\n    return sb.toString();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        sb.append(part.toString().hashCode());\n    }\n    return sb.toString();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        sb.append(part.toString().hashCode());\n    }\n    return sb.toString();\n}"
    ],
    [
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentPos = archive.length() - 1;\n    while (currentPos >= minDistanceFromEnd && currentPos <= maxDistanceFromEnd) {\n        archive.position(currentPos--);\n        if (IOUtils.readFully(archive, sig)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long position = archive.length() - 1;\n    while (position >= minDistanceFromEnd && position <= maxDistanceFromEnd) {\n        archive.position(position);\n        byte[] buffer = new byte[sig.length];\n        IOUtils.readFully(archive, buffer);\n        if (Arrays.equals(sig, buffer)) {\n            archive.position(position - sig.length);\n            return true;\n        }\n        position--;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long position = archive.length() - 1;\n    while (position >= minDistanceFromEnd && position <= maxDistanceFromEnd) {\n        archive.position(position);\n        byte[] buffer = new byte[sig.length];\n        IOUtils.readFully(archive, buffer);\n        if (Arrays.equals(buffer, sig)) {\n            archive.position(position - sig.length);\n            return true;\n        }\n        position--;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long position = archive.length() - 1;\n    while (position >= minDistanceFromEnd && position <= maxDistanceFromEnd) {\n        archive.position(position);\n        byte[] buffer = new byte[sig.length];\n        IOUtils.readFully(archive, buffer);\n        if (Arrays.equals(buffer, sig)) {\n            archive.position(position - sig.length + 1);\n            return true;\n        }\n        position--;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long position = archive.length() - 1;\n    while (position >= minDistanceFromEnd && position <= maxDistanceFromEnd) {\n        archive.position(position);\n        byte[] buffer = new byte[sig.length];\n        IOUtils.readFully(archive, buffer);\n        if (Arrays.equals(sig, buffer)) {\n            archive.position(position);\n            return true;\n        }\n        position--;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long position = archive.length() - 1;\n    while (position >= minDistanceFromEnd && position <= maxDistanceFromEnd) {\n        archive.position(position);\n        byte[] buffer = new byte[sig.length];\n        IOUtils.readFully(archive, buffer);\n        if (Arrays.equals(sig, buffer)) {\n            archive.position(position - sig.length);\n            return true;\n        }\n        position--;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long position = archive.length() - 1;\n    while (position >= minDistanceFromEnd && position <= maxDistanceFromEnd) {\n        archive.position(position);\n        byte[] buffer = new byte[sig.length];\n        IOUtils.readFully(archive, buffer);\n        if (Arrays.equals(buffer, sig)) {\n            archive.position(position);\n            return true;\n        }\n        position--;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long position = archive.length() - 1;\n    while (position >= minDistanceFromEnd && position <= maxDistanceFromEnd) {\n        archive.position(position);\n        byte[] buffer = new byte[sig.length];\n        IOUtils.readFully(archive, buffer);\n        if (Arrays.equals(buffer, sig)) {\n            archive.position(position - sig.length);\n            return true;\n        }\n        position--;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long position = archive.length() - 1;\n    while (position >= minDistanceFromEnd && position <= maxDistanceFromEnd) {\n        archive.position(position);\n        byte[] buffer = new byte[sig.length];\n        IOUtils.readFully(archive, buffer);\n        if (Arrays.equals(buffer, sig)) {\n            archive.position(position - sig.length + 1);\n            return true;\n        }\n        position--;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long position = archive.length() - 1;\n    while (position >= minDistanceFromEnd && position <= maxDistanceFromEnd) {\n        archive.position(position);\n        byte[] buffer = new byte[sig.length];\n        IOUtils.readFully(archive, buffer);\n        if (Arrays.equals(buffer, sig)) {\n            archive.position(position - sig.length);\n            return true;\n        }\n        position--;\n    }\n    return false;\n}"
    ],
    [
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    return location.getOpposite() == AxisLocation.TOP_LEFT ?\n            RectangleEdge.TOP : (location.getOpposite() == AxisLocation.BOTTOM_RIGHT ?\n            RectangleEdge.BOTTOM : (location.getOpposite() == AxisLocation.BOTTOM_LEFT ?\n            RectangleEdge.LEFT : RectangleEdge.RIGHT));\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    return location.getEdge();\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    if (location == AxisLocation.TOP) {\n        return RectangleEdge.TOP;\n    } else if (location == AxisLocation.BOTTOM) {\n        return RectangleEdge.BOTTOM;\n    } else if (location == AxisLocation.LEFT) {\n        return RectangleEdge.LEFT;\n    } else {\n        return RectangleEdge.RIGHT;\n    }\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    if (location == AxisLocation.TOP || location == AxisLocation.BOTTOM) {\n        return RectangleEdge.BOTTOM;\n    } else {\n        return RectangleEdge.LEFT;\n    }\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    return location.getEdge();\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    return location.getEdge();\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    if (location == AxisLocation.TOP) {\n        return RectangleEdge.TOP;\n    } else if (location == AxisLocation.BOTTOM) {\n        return RectangleEdge.BOTTOM;\n    } else if (location == AxisLocation.LEFT) {\n        return RectangleEdge.LEFT;\n    } else {\n        return RectangleEdge.RIGHT;\n    }\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    if (location == AxisLocation.TOP) {\n        return RectangleEdge.TOP;\n    } else if (location == AxisLocation.BOTTOM) {\n        return RectangleEdge.BOTTOM;\n    } else if (location == AxisLocation.LEFT) {\n        return RectangleEdge.LEFT;\n    } else {\n        return RectangleEdge.RIGHT;\n    }\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    return location.getOppositeEdge();\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    return location.getEdge();\n}"
    ],
    [
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "public InputStream getDataStream()  {\n    return new DataInputStream(new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength));\n}",
      "public InputStream getDataStream()  {\n    return new DataInputStream(new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength));\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    return new DataInputStream(new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength));\n}",
      "public InputStream getDataStream()  {\n    return new DataInputStream(new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength));\n}",
      "public InputStream getDataStream()  {\n    return new DataInputStream(new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength));\n}",
      "public InputStream getDataStream()  {\n    if (_bufferedData == null) {\n        return _originalStream;\n    }\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    return new DataInputStream(new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength));\n}",
      "public InputStream getDataStream()  {\n    return new DataInputStream(new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength));\n}",
      "public InputStream getDataStream()  {\n    return new DataInputStream(new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength));\n}"
    ],
    [
      "protected Comparable getSectionKey(int section)  {\n    Comparable[] keys = this.sectionKeys;\n    if (section < 0 || section >= keys.length) {\n        Comparable key = new Comparable();\n        keys[section] = key;\n        return key;\n    }\n    return keys[section];\n}",
      "protected Comparable getSectionKey(int section)  {\n    if (section >= 0 && section < this.getSectionCount()) {\n        return this.getSections().get(section);\n    } else {\n}\n}",
      "protected Comparable getSectionKey(int section)  {\n    if (section < 0 || section >= this.sectionCount) {\n        return generateSectionKey();\n    }\n    return this.sections.get(section);\n}",
      "protected Comparable getSectionKey(int section)  {\n    return new Integer(section);\n}",
      "protected Comparable getSectionKey(int section)  {\n    if (section < 0 || section >= this.getSectionCount()) {\n}\n}",
      "protected Comparable getSectionKey(int section)  {\n    if (section >= 0 && section < this.sectionCount) {\n        return this.sections[section];\n    } else {\n}\n}",
      "protected Comparable getSectionKey(int section)  {\n    if (section < 0 || section >= this.sectionCount) {\n}\n}",
      "protected Comparable getSectionKey(int section)  {\n    if (section < 0 || section >= this.sectionCount) {\n}\n}",
      "protected Comparable getSectionKey(int section)  {\n    if (section < 0 || section >= this.getSectionCount()) {\n        return Comparable.valueOf(section);\n    }\n    return this.getSectionKey(section);\n}",
      "protected Comparable getSectionKey(int section)  {\n    return new Integer(section);\n}"
    ],
    [
      "@Override\n        public boolean isNaN()  {\n            return _currToken == JsonToken.VALUE_NUMBER_FLOAT && Float.isNaN(((Float)_currentObject()).floatValue());\n        }",
      "@Override\n        public boolean isNaN()  {\n            return _currToken == JsonToken.VALUE_NUMBER_FLOAT && Float.isNaN(((Float)_currentObject()).floatValue());\n        }",
      "@Override\n        public boolean isNaN()  {\n            return _currToken == JsonToken.VALUE_NUMBER_FLOAT && Float.isNaN(((Float) _currentObject()).floatValue());\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Object obj = _currentObject();\n                if (obj instanceof Number) {\n                    return ((Number) obj).isNaN();\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                return ((Float)_currentObject()).isNaN();\n            }\n            if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n                return ((Integer)_currentObject()).isNaN();\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            return _currToken == JsonToken.VALUE_NUMBER_FLOAT && ((Float)_currentObject()).isNaN();\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                return ((Float)_currentObject()).isNaN();\n            }\n            if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n                return ((Integer)_currentObject()).isNaN();\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                return ((Float)_currentObject()).isNaN();\n            }\n            if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n                return ((Integer)_currentObject()).isNaN();\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                return ((Float)_currentObject()).isNaN();\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            return _currToken == JsonToken.VALUE_NUMBER_FLOAT && Float.isNaN(((Float)_currentObject()).floatValue());\n        }"
    ],
    [
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null) {\n        return prefix == null;\n    }\n\n    if (prefix == null) {\n        return true;\n    }\n\n    int n = str.length();\n    int p = prefix.length();\n\n    if (n < p) {\n        return false;\n    }\n\n    if (ignoreCase) {\n        for (int i = 0; i < p; i++) {\n            if (Character.toLowerCase(str.charAt(i)) != Character.toLowerCase(prefix.charAt(i))) {\n                return false;\n            }\n        }\n    } else {\n        for (int i = 0; i < p; i++) {\n            if (str.charAt(i) != prefix.charAt(i)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == prefix;\n    }\n\n    int n = str.length();\n    int m = prefix.length();\n\n    if (m > n) {\n        return false;\n    }\n\n    int i = 0;\n    int j = 0;\n\n    while (i < n && j < m) {\n        char ch = str.charAt(i);\n        char pch = prefix.charAt(j);\n\n        if (ignoreCase) {\n            ch = Character.toLowerCase(ch);\n            pch = Character.toLowerCase(pch);\n        }\n\n        if (ch != pch) {\n            return false;\n        }\n\n        i++;\n        j++;\n    }\n\n    return j == m;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == prefix;\n    }\n\n    int strLen = str.length();\n    int prefixLen = prefix.length();\n\n    if (strLen < prefixLen) {\n        return false;\n    }\n\n    int i = 0;\n    int j = 0;\n\n    while (i < strLen && j < prefixLen) {\n        char strChar = str.charAt(i);\n        char prefixChar = prefix.charAt(j);\n\n        if (ignoreCase) {\n            if (Character.toLowerCase(strChar) != Character.toLowerCase(prefixChar)) {\n                return false;\n            }\n        } else {\n            if (strChar != prefixChar) {\n                return false;\n            }\n        }\n\n        i++;\n        j++;\n    }\n\n    return j == prefixLen;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == prefix;\n    }\n\n    int strLen = str.length();\n    int prefixLen = prefix.length();\n\n    for (int i = 0; i <= strLen - prefixLen; i++) {\n        if (ignoreCase) {\n            if (str.regionMatches(ignoreCase, i, prefix, 0, prefixLen)) {\n                return true;\n            }\n        } else {\n            if (str.subSequence(i, i + prefixLen).equals(prefix)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == prefix;\n    }\n\n    int strLen = str.length();\n    int prefixLen = prefix.length();\n\n    if (strLen < prefixLen) {\n        return false;\n    }\n\n    if (ignoreCase) {\n        for (int i = 0; i < prefixLen; i++) {\n            if (Character.toLowerCase(str.charAt(i)) != Character.toLowerCase(prefix.charAt(i))) {\n                return false;\n            }\n        }\n    } else {\n        for (int i = 0; i < prefixLen; i++) {\n            if (str.charAt(i) != prefix.charAt(i)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null) {\n        return prefix == null;\n    }\n    if (prefix == null) {\n        return true;\n    }\n\n    int n = str.length();\n    int pLen = prefix.length();\n\n    if (n < pLen) {\n        return false;\n    }\n\n    int min = Math.max(0, n - pLen);\n    int max = n;\n\n    int[] d = new int[max + 1];\n    int[] p = new int[max + 1];\n\n    for (int i = 0; i <= max; i++) {\n        d[i] = i;\n    }\n\n    for (int j = 0; j < pLen; j++) {\n        if (ignoreCase) {\n            if (Character.toLowerCase(str.charAt(min + j - 1)) != Character.toLowerCase(prefix.charAt(j))) {\n                return false;\n            }\n        } else {\n            if (str.charAt(min + j - 1) != prefix.charAt(j)) {\n                return false;\n            }\n        }\n    }\n\n    if (ignoreCase) {\n        for (int i = min + pLen; i <= max; i++) {\n            if (Character.toLowerCase(str.charAt(i - 1)) != Character.toLowerCase(prefix.charAt(0))) {\n                return false;\n            }\n        }\n    } else {\n        for (int i = min + pLen; i <= max; i++) {\n            if (str.charAt(i - 1) != prefix.charAt(0)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == prefix;\n    }\n\n    int n = str.length();\n    int prefixLength = prefix.length();\n\n    if (n < prefixLength) {\n        return false;\n    }\n\n    if (ignoreCase) {\n        for (int i = 0; i < prefixLength; i++) {\n            if (Character.toLowerCase(str.charAt(i)) != Character.toLowerCase(prefix.charAt(i))) {\n                return false;\n            }\n        }\n    } else {\n        for (int i = 0; i < prefixLength; i++) {\n            if (str.charAt(i) != prefix.charAt(i)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == prefix;\n    }\n\n    int n = str.length();\n    int prefixLength = prefix.length();\n\n    if (n < prefixLength) {\n        return false;\n    }\n\n    if (ignoreCase) {\n        for (int i = 0; i < prefixLength; i++) {\n            if (Character.toLowerCase(str.charAt(i)) != Character.toLowerCase(prefix.charAt(i))) {\n                return false;\n            }\n        }\n    } else {\n        for (int i = 0; i < prefixLength; i++) {\n            if (str.charAt(i) != prefix.charAt(i)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == prefix;\n    }\n\n    int n = str.length();\n    int prefixLength = prefix.length();\n\n    if (prefixLength > n) {\n        return false;\n    }\n\n    int i = 0;\n    int j = 0;\n\n    while (i < n && j < prefixLength) {\n        char c1 = str.charAt(i);\n        char c2 = prefix.charAt(j);\n\n        if (ignoreCase) {\n            c1 = Character.toLowerCase(c1);\n            c2 = Character.toLowerCase(c2);\n        }\n\n        if (c1 != c2) {\n            return false;\n        }\n\n        i++;\n        j++;\n    }\n\n    return j == prefixLength;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null) {\n        return prefix == null;\n    }\n\n    if (prefix == null) {\n        return true;\n    }\n\n    int n = str.length();\n    int prefixLength = prefix.length();\n\n    if (ignoreCase) {\n        for (int i = 0; i < prefixLength; i++) {\n            if (Character.toLowerCase(str.charAt(i)) != Character.toLowerCase(prefix.charAt(i))) {\n                return false;\n            }\n        }\n    } else {\n        for (int i = 0; i < prefixLength; i++) {\n            if (str.charAt(i) != prefix.charAt(i)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}"
    ],
    [
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_STRING) {\n        result = nextQuotedValue('\"');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n        result = nextQuotedValue('\"');\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n        result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_UNQUOTED_NAME) {\n        result = nextUnquotedValue();\n    } else if (p == PEEKED_LONG) {\n        result = Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n        result = Double.toString(peekedNumber);\n    } else {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_STRING) {\n        result = nextQuotedValue('\"');\n    } else if (p == PEEKED_DOUBLE_QUOTED_STRING) {\n        result = nextQuotedValue('\"');\n    } else if (p == PEEKED_SINGLE_QUOTED_STRING) {\n        result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_UNQUOTED_STRING) {\n        result = nextUnquotedValue();\n    } else if (p == PEEKED_NUMBER) {\n        result = Long.toString(peekedLong);\n    } else {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_STRING) {\n        result = nextQuotedValue('\"');\n    } else if (p == PEEKED_NUMBER) {\n        result = Long.toString(peekedLong);\n    } else if (p == PEEKED_UNQUOTED_NAME) {\n        result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n        result = nextQuotedValue('\\'');\n    } else {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_STRING) {\n        result = nextQuotedValue('\"');\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n        result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_UNQUOTED) {\n        result = nextUnquotedValue();\n    } else if (p == PEEKED_NUMBER) {\n        result = Long.toString(peekedLong);\n    } else if (p == PEEKED_LONG) {\n        result = Long.toString(peekedLong);\n    } else {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_STRING) {\n        result = nextQuotedValue('\"');\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n        result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_NUMBER) {\n        result = Long.toString(peekedLong);\n    } else if (p == PEEKED_LONG) {\n        result = Long.toString(peekedLong);\n    } else {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_STRING) {\n        result = nextQuotedValue('\"');\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n        result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_UNQUOTED) {\n        result = nextUnquotedValue();\n    } else if (p == PEEKED_NUMBER) {\n        result = String.valueOf(peekedNumber);\n    } else {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_STRING) {\n        result = nextQuotedValue('\"');\n    } else if (p == PEEKED_NUMBER) {\n        result = Long.toString(peekedLong);\n    } else if (p == PEEKED_LONG) {\n        result = Long.toString(peekedLong);\n    } else {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_STRING) {\n        result = nextQuotedValue('\"');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n        result = nextQuotedValue('\"');\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n        result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_UNQUOTED_NAME) {\n        result = nextUnquotedValue();\n    } else if (p == PEEKED_LONG || p == PEEKED_NUMBER) {\n        result = Long.toString(peekedLong);\n    } else {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_STRING) {\n        result = nextQuotedValue('\"');\n    } else if (p == PEEKED_LONG) {\n        result = Long.toString(peekedLong);\n        peeked = PEEKED_NONE;\n    } else if (p == PEEKED_NUMBER) {\n        result = Long.toString(peekedNumber);\n        peeked = PEEKED_NONE;\n    } else {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_STRING) {\n        result = nextQuotedValue('\"');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n        result = nextQuotedValue('\"');\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n        result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_UNQUOTED_NAME) {\n        result = nextUnquotedValue();\n    } else if (p == PEEKED_LONG) {\n        result = Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n        result = peekedNumber;\n    } else {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    return result;\n}"
    ],
    [
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"maxWidth must be at least 4\");\n    }\n    if (offset < 0) {\n        offset = 0;\n    }\n    if (str.length() <= offset + maxWidth - 3) {\n        return str;\n    }\n    return str.substring(0, offset) + \"...\";\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"maxWidth must be at least 4\");\n    }\n    if (offset < 0) {\n        offset = 0;\n    }\n    if (str.length() <= offset + 3) {\n        return str;\n    }\n    return str.substring(0, offset) + \"...\";\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"maxWidth must be at least 4\");\n    }\n    if (offset < 0) {\n        offset = 0;\n    }\n    if (str.length() <= offset + maxWidth - 3) {\n        return str;\n    }\n    return str.substring(0, offset) + \"...\";\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"maxWidth must be at least 4\");\n    }\n    if (offset < 0) {\n        offset = 0;\n    }\n    if (str.length() <= offset + 3) {\n        return str;\n    }\n    return str.substring(0, offset) + \"...\";\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"maxWidth must be at least 4\");\n    }\n    if (offset < 0) {\n        offset = 0;\n    }\n    if (str.length() <= offset + maxWidth - 3) {\n        return str;\n    }\n    return str.substring(0, offset) + \"...\";\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"maxWidth must be at least 4\");\n    }\n    if (offset < 0) {\n        offset = 0;\n    }\n    if (str.length() <= offset + 3) {\n        return str;\n    }\n    return str.substring(0, offset) + \"...\";\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"maxWidth must be at least 4\");\n    }\n    if (offset < 0) {\n        offset = 0;\n    }\n    if (str.length() <= offset + maxWidth) {\n        return str;\n    }\n    return str.substring(0, offset) + \"...\" + (str.length() - offset - 3 > 0 ? \"...\" : \"\");\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"maxWidth must be at least 4\");\n    }\n    if (offset < 0) {\n        offset = 0;\n    }\n    if (str.length() <= offset + maxWidth - 3) {\n        return str;\n    }\n    return str.substring(0, offset) + \"...\";\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"maxWidth must be at least 4\");\n    }\n    if (offset < 0) {\n        offset = 0;\n    }\n    if (str.length() <= offset + maxWidth - 3) {\n        return str;\n    }\n    return str.substring(0, offset) + \"...\";\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"maxWidth must be at least 4\");\n    }\n    if (offset < 0) {\n        offset = 0;\n    }\n    if (str.length() <= offset + 3) {\n        return str;\n    }\n    return str.substring(0, offset) + \"...\";\n}"
    ],
    [
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null && s2 == null) {\n        return true;\n    }\n    if (s1 == null || s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null && s2 == null) {\n        return true;\n    }\n    if (s1 == null || s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (s1[i] == null && s2[i] == null) {\n            continue;\n        }\n        if (s1[i] == null || s2[i] == null) {\n            return false;\n        }\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null && s2 == null) {\n        return true;\n    }\n    if (s1 == null || s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (s1[i] == null && s2[i] == null) {\n            continue;\n        }\n        if (s1[i] == null || s2[i] == null) {\n            return false;\n        }\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null && s2 == null) {\n        return true;\n    }\n    if (s1 == null || s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null && s2 == null) {\n        return true;\n    }\n    if (s1 == null || s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null && s2 == null) {\n        return true;\n    }\n    if (s1 == null || s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null && s2 == null) {\n        return true;\n    }\n    if (s1 == null || s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null && s2 == null) {\n        return true;\n    }\n    if (s1 == null || s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null && s2 == null) {\n        return true;\n    }\n    if (s1 == null || s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null && s2 == null) {\n        return true;\n    }\n    if (s1 == null || s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) {\n            lastSymbolNameIndex = index;\n        } else {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) {\n            lastSymbolNameIndex = index;\n        } else {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) {\n            lastSymbolNameIndex = index;\n        } else {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) {\n            lastSymbolNameIndex = index;\n        } else {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) {\n            lastSymbolNameIndex = index;\n        } else {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) {\n            lastSymbolNameIndex = index;\n        } else {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) {\n            lastSymbolNameIndex = index;\n        } else {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) {\n            lastSymbolNameIndex = index;\n        } else {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) {\n            lastSymbolNameIndex = index;\n        } else {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) {\n            lastSymbolNameIndex = index;\n        } else {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}"
    ],
    [
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NUMBER) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      String result = nextQuotedValue('\"');\n      try {\n        return Double.parseDouble(result);\n      } catch (NumberFormatException e) {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n      }\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      String result = nextQuotedValue('\\'');\n      try {\n        return Double.parseDouble(result);\n      } catch (NumberFormatException e) {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n  }",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NUMBER) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n    } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_SINGLE_QUOTED) {\n      String result = nextQuotedValue(p == PEEKED_DOUBLE_QUOTED ? '\"' : '\\'');\n      try {\n        return Double.parseDouble(result);\n      } catch (NumberFormatException e) {\n        throw new IllegalStateException(\"Expected a number but was \" + result + locationString());\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n    }\n  }",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_NUMBER) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n  } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_SINGLE_QUOTED) {\n    String str = nextQuotedValue(p == PEEKED_DOUBLE_QUOTED ? '\"' : '\\'');\n    try {\n      return Double.parseDouble(str);\n    } catch (NumberFormatException e) {\n      throw new IllegalStateException(\"Expected a number but was \" + str + locationString());\n    }\n  } else {\n    throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n  }\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_NUMBER) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n  } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_SINGLE_QUOTED) {\n    String str = nextQuotedValue((p == PEEKED_DOUBLE_QUOTED) ? '\"' : '\\'');\n    try {\n      return Double.parseDouble(str);\n    } catch (NumberFormatException e) {\n      throw new IllegalStateException(\"Expected a number but was \" + str + locationString());\n    }\n  } else {\n    throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n  }\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NUMBER) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n    } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_SINGLE_QUOTED) {\n      String value = nextQuotedValue(p == PEEKED_DOUBLE_QUOTED ? '\"' : '\\'');\n      try {\n        return Double.parseDouble(value);\n      } catch (NumberFormatException e) {\n        throw new IllegalStateException(\"Expected a number but was \" + value + locationString());\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n    }\n  }",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NUMBER) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n    } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_SINGLE_QUOTED) {\n      String str = nextQuotedValue(p == PEEKED_DOUBLE_QUOTED ? '\"' : '\\'');\n      try {\n        return Double.parseDouble(str);\n      } catch (NumberFormatException e) {\n        throw new IllegalStateException(\"Expected a number but was \" + str + locationString());\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n    }\n  }",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_NUMBER) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n  } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_SINGLE_QUOTED) {\n    String value = nextQuotedValue((p == PEEKED_DOUBLE_QUOTED) ? '\"' : '\\'');\n    try {\n      return Double.parseDouble(value);\n    } catch (NumberFormatException e) {\n      throw new IllegalStateException(\"Expected a number but was \" + value + locationString());\n    }\n  } else {\n    throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n  }\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_NUMBER) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n  } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_SINGLE_QUOTED) {\n    String value = nextQuotedValue((p == PEEKED_DOUBLE_QUOTED) ? '\"' : '\\'');\n    try {\n      return Double.parseDouble(value);\n    } catch (NumberFormatException e) {\n      throw new IllegalStateException(\"Expected a number but was \" + value + locationString());\n    }\n  } else {\n    throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n  }\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_NUMBER) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n  } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_SINGLE_QUOTED) {\n    String result = nextQuotedValue(p == PEEKED_DOUBLE_QUOTED ? '\"' : '\\'');\n    try {\n      return Double.parseDouble(result);\n    } catch (NumberFormatException e) {\n      throw new IllegalStateException(\"Expected a number but was \" + result + locationString());\n    }\n  } else {\n    throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n  }\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_NUMBER) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n  } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_SINGLE_QUOTED) {\n    String value = nextQuotedValue(p == PEEKED_DOUBLE_QUOTED ? '\"' : '\\'');\n    try {\n      return Double.parseDouble(value);\n    } catch (NumberFormatException e) {\n      throw new IllegalStateException(\"Expected a number but was \" + value + locationString());\n    }\n  } else {\n    throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n  }\n}"
    ],
    [
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < repeat; i++) {\n        sb.append(str);\n    }\n    return sb.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < repeat; i++) {\n        sb.append(str);\n    }\n    return sb.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < repeat; i++) {\n        sb.append(str);\n    }\n    return sb.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < repeat; i++) {\n        sb.append(str);\n    }\n    return sb.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < repeat; i++) {\n        sb.append(str);\n    }\n    return sb.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < repeat; i++) {\n        sb.append(str);\n    }\n    return sb.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final StringBuilder result = new StringBuilder();\n    for (int i = 0; i < repeat; i++) {\n        result.append(str);\n    }\n    return result.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < repeat; i++) {\n        sb.append(str);\n    }\n    return sb.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < repeat; i++) {\n        sb.append(str);\n    }\n    return sb.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    StringBuilder result = new StringBuilder();\n    for (int i = 0; i < repeat; i++) {\n        result.append(str);\n    }\n    return result.toString();\n}"
    ],
    [
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    return createExtraField(headerId, null);\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    return createExtraField(headerId, null);\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    return createExtraField(headerId, null);\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    if (headerId == null) {\n        throw new ZipException(\"Header ID is null\");\n    }\n    Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        return new UnrecognizedExtraField(headerId);\n    }\n    return (ZipExtraField) clazz.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    if (headerId == null) {\n        throw new ZipException(\"headerId is null\");\n    }\n    Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        return new UnrecognizedExtraField(headerId);\n    }\n    return (ZipExtraField) clazz.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    if (implementations.containsKey(headerId)) {\n        return (ZipExtraField) implementations.get(headerId).newInstance();\n    } else {\n        return new UnrecognizedExtraField(headerId);\n    }\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    return (ZipExtraField) implementations.getOrDefault(headerId, UnrecognizedExtraField.class).newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    if (implementations.containsKey(headerId)) {\n        return (ZipExtraField) implementations.get(headerId).newInstance();\n    } else {\n        return new UnrecognizedExtraField(headerId);\n    }\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    return createExtraField(headerId, null);\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    if (headerId == null) {\n        throw new ZipException(\"Header ID is null\");\n    }\n    Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        return new UnrecognizedExtraField(headerId);\n    }\n    return (ZipExtraField) clazz.newInstance();\n}"
    ],
    [
      "public static int count(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        for (final char c : str.toCharArray()) {\n            if (chars.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    }",
      "public static int count(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        final char[] chrs = str.toCharArray();\n        final int sz = chrs.length;\n        for (int i = 0; i < sz; i++) {\n            char ch = chrs[i];\n            if (chars.contains(ch)) {\n                count++;\n            }\n        }\n        return count;\n    }",
      "public static int count(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        final char[] chrs = str.toCharArray();\n        final int sz = chrs.length;\n        for (int i = 0; i < sz; i++) {\n            final char ch = chrs[i];\n            if (chars.contains(ch)) {\n                count++;\n            }\n        }\n        return count;\n    }",
      "public static int count(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        for (final char c : str.toCharArray()) {\n            if (chars.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    }",
      "public static int count(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        for (final char c : str.toCharArray()) {\n            if (chars.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    }",
      "public static int count(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        final char[] chrs = str.toCharArray();\n        final int sz = chrs.length;\n        for (int i = 0; i < sz; i++) {\n            final char ch = chrs[i];\n            if (chars.contains(ch)) {\n                count++;\n            }\n        }\n        return count;\n    }",
      "public static int count(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        for (final char c : str.toCharArray()) {\n            if (chars.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    }",
      "public static int count(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        for (final char c : str.toCharArray()) {\n            if (chars.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    }",
      "public static int count(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        final char[] chrs = str.toCharArray();\n        for (final char c : chrs) {\n            if (chars.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    }",
      "public static int count(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        final char[] chrs = str.toCharArray();\n        for (final char c : chrs) {\n            if (chars.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    }"
    ],
    [
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map cloneMap = new HashMap();\n    for (Object key : map.keySet()) {\n        cloneMap.put(key, ((Map) map.get(key)).clone());\n    }\n    return cloneMap;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clonedMap = new HashMap();\n    for (Object key : map.keySet()) {\n        clonedMap.put(key, ((Map.Entry) map.entrySet().stream()\n                .filter(entry -> entry.getKey().equals(key))\n                .findFirst().get()).getValue());\n    }\n    return clonedMap;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    if (map == null) {\n        return null;\n    }\n    Map cloneMap = new HashMap();\n    for (Map.Entry entry : map.entrySet()) {\n        cloneMap.put(entry.getKey(), ((Map.Entry) entry.clone()).getValue());\n    }\n    return cloneMap;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    if (map == null) {\n        return null;\n    }\n    Map clone = new HashMap();\n    for (Map.Entry entry : map.entrySet()) {\n        clone.put(entry.getKey(), entry.getValue().clone());\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clonedMap = new HashMap();\n    for (Map.Entry entry : map.entrySet()) {\n        clonedMap.put(entry.getKey(), entry.getValue().clone());\n    }\n    return clonedMap;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map cloneMap = new HashMap();\n    for (Map.Entry entry : map.entrySet()) {\n        cloneMap.put(entry.getKey(), entry.getValue().clone());\n    }\n    return cloneMap;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    if (map == null) {\n        return null;\n    }\n    Map clonedMap = new HashMap();\n    for (Map.Entry entry : map.entrySet()) {\n        CategoryItemRenderer renderer = (CategoryItemRenderer) entry.getKey();\n        List markers = (List) entry.getValue();\n        List clonedMarkers = new ArrayList();\n        for (Object marker : markers) {\n            if (marker instanceof PublicCloneable) {\n                PublicCloneable pc = (PublicCloneable) marker;\n                clonedMarkers.add(pc.clone());\n            } else {\n                clonedMarkers.add(marker);\n            }\n        }\n        clonedMap.put(renderer, clonedMarkers);\n    }\n    return clonedMap;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    if (map == null) {\n        return null;\n    }\n    Map clonedMap = new HashMap();\n    for (Map.Entry entry : map.entrySet()) {\n        CategoryItemRenderer renderer = (CategoryItemRenderer) entry.getKey();\n        List markers = (List) entry.getValue();\n        List clonedMarkers = new ArrayList();\n        for (Object marker : markers) {\n            if (marker instanceof PublicCloneable) {\n                PublicCloneable pc = (PublicCloneable) marker;\n                clonedMarkers.add(pc.clone());\n            } else {\n                clonedMarkers.add(marker);\n            }\n        }\n        clonedMap.put(renderer, clonedMarkers);\n    }\n    return clonedMap;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    if (map == null) {\n        return null;\n    }\n    Map clone = new HashMap();\n    for (Object key : map.keySet()) {\n        clone.put(key, ((Map) map.get(key)).clone());\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    if (map == null) {\n        return null;\n    }\n    Map clonedMap = new HashMap();\n    for (Map.Entry entry : map.entrySet()) {\n        CategoryItemRenderer renderer = (CategoryItemRenderer) entry.getKey();\n        Map<String, Marker> clonedMarkers = new HashMap<>();\n        for (Map.Entry<String, Marker> entry2 : entry.getValue().entrySet()) {\n            clonedMarkers.put(entry2.getKey(), (Marker) entry2.getValue().clone());\n        }\n        clonedMap.put(renderer, clonedMarkers);\n    }\n    return clonedMap;\n}"
    ],
    [
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryDataLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryDataLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryDataLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryDataLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryDataLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryDataLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    int sum = WORD;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryDataLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (final ZipExtraField element : data) {\n        System.arraycopy(element.getCentralDirectoryData().getBytes(), 0, result, start, element.getCentralDirectoryDataLength().getValue());\n        start += element.getCentralDirectoryDataLength().getValue();\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryDataLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryDataLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryDataLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}"
    ],
    [
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (E element : coll) {\n            if (!set.contains(element)) {\n                super.add(index++, element);\n                set.add(element);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (E element : coll) {\n            if (!set.contains(element)) {\n                super.add(index++, element);\n                set.add(element);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (E element : coll) {\n            if (!set.contains(element)) {\n                super.add(index++, element);\n                set.add(element);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (E element : coll) {\n            if (!set.contains(element)) {\n                super.add(index++, element);\n                set.add(element);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (E e : coll) {\n            if (!set.contains(e)) {\n                super.add(index++, e);\n                set.add(e);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (E e : coll) {\n            if (!set.contains(e)) {\n                super.add(index++, e);\n                set.add(e);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (E element : coll) {\n            if (!set.contains(element)) {\n                super.add(index++, element);\n                set.add(element);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (E element : coll) {\n            if (!set.contains(element)) {\n                super.add(index++, element);\n                set.add(element);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (E element : coll) {\n            if (!set.contains(element)) {\n                super.add(index++, element);\n                set.add(element);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (E element : coll) {\n            if (!set.contains(element)) {\n                super.add(index++, element);\n                set.add(element);\n                changed = true;\n            }\n        }\n        return changed;\n    }"
    ],
    [
      "private double eval(UnivariateFunction f, double x)  {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    evaluations.incrementCount();\n    return f.value(x);\n}"
    ],
    [
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getRelationship() == Relationship.LEQ) {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(), -constraint.getValue()));\n        } else if (constraint.getRelationship() == Relationship.GEQ) {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(), constraint.getValue()));\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getRelationship() == Relationship.LEQ) {\n            if (constraint.getValue() > 0) {\n                normalizedConstraints.add(constraint);\n            } else {\n                normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(), -constraint.getValue(), Relationship.GEQ));\n            }\n        } else if (constraint.getRelationship() == Relationship.GEQ) {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getRelationship() == Relationship.LEQ && constraint.getValue() > 0) {\n            // Convert LEQ to EQ\n            LinearConstraint newConstraint = new LinearConstraint(constraint.getCoefficients(), Relationship.EQ, constraint.getValue());\n            normalizedConstraints.add(newConstraint);\n        } else if (constraint.getRelationship() == Relationship.GEQ && constraint.getValue() > 0) {\n            // Convert GEQ to EQ\n            LinearConstraint newConstraint = new LinearConstraint(constraint.getCoefficients(), Relationship.EQ, constraint.getValue());\n            normalizedConstraints.add(newConstraint);\n        } else {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getRelationship() == Relationship.LEQ && constraint.getValue() > 0) {\n            // Convert LEQ to EQ by adding slack variable\n            LinearConstraint newConstraint = new LinearConstraint(constraint.getCoefficients(), 1);\n            newConstraint.setRelationship(Relationship.EQ);\n            normalizedConstraints.add(newConstraint);\n        } else if (constraint.getRelationship() == Relationship.GEQ && constraint.getValue() > 0) {\n            // Convert GEQ to EQ by subtracting slack variable\n            LinearConstraint newConstraint = new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -1);\n            newConstraint.setRelationship(Relationship.EQ);\n            normalizedConstraints.add(newConstraint);\n        } else {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getRelationship() == Relationship.LEQ && constraint.getValue() > 0) {\n            constraint.setRelationship(Relationship.EQ);\n            constraint.setValue(constraint.getValue() - 1);\n        } else if (constraint.getRelationship() == Relationship.GEQ && constraint.getValue() > 0) {\n            constraint.setRelationship(Relationship.LEQ);\n            constraint.setValue(constraint.getValue() - 1);\n        }\n        normalizedConstraints.add(constraint);\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getRelationship() == Relationship.LEQ) {\n            double constantTerm = constraint.getValue();\n            if (constantTerm > 0) {\n                normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(), Relationship.EQ, constantTerm));\n            } else {\n                normalizedConstraints.add(constraint);\n            }\n        } else if (constraint.getRelationship() == Relationship.GEQ) {\n            double constantTerm = constraint.getValue();\n            if (constantTerm < 0) {\n                normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(), Relationship.LEQ, -constantTerm));\n            } else {\n                normalizedConstraints.add(constraint);\n            }\n        } else {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getRelationship() == Relationship.LEQ && constraint.getValue() > 0) {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(), Relationship.EQ, -constraint.getValue()));\n        } else if (constraint.getRelationship() == Relationship.GEQ && constraint.getValue() < 0) {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(), Relationship.LEQ, -constraint.getValue()));\n        } else {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getRelationship() == Relationship.LEQ && constraint.getValue() > 0) {\n            // If the constraint is a less than or equal constraint and the RHS is positive,\n            // then we can normalize it by subtracting it from the slack variable.\n            LinearConstraint normalizedConstraint = new LinearConstraint(\n                    constraint.getCoefficients().mapMultiply(-1),\n                    Relationship.GEQ,\n                    -constraint.getValue());\n            normalizedConstraints.add(normalizedConstraint);\n        } else {\n            // If the constraint is not a less than or equal constraint or the RHS is not positive,\n            // then we leave it as is.\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getRelationship() == Relationship.LEQ && constraint.getValue() > 0) {\n            // Convert LEQ to EQ by subtracting RHS from both sides\n            LinearConstraint newConstraint = new LinearConstraint(constraint.getCoefficients(), -constraint.getValue(), 0);\n            newConstraint.setRelationship(Relationship.EQ);\n            normalizedConstraints.add(newConstraint);\n        } else if (constraint.getRelationship() == Relationship.GEQ && constraint.getValue() > 0) {\n            // Convert GEQ to EQ by subtracting RHS from both sides\n            LinearConstraint newConstraint = new LinearConstraint(constraint.getCoefficients(), -constraint.getValue(), 0);\n            newConstraint.setRelationship(Relationship.EQ);\n            normalizedConstraints.add(newConstraint);\n        } else {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getRelationship() == Relationship.LEQ && constraint.getValue() > 0) {\n            // If the constraint is a less than or equal constraint with a positive RHS,\n            // we can replace it with a slack variable and a new constraint that is\n            // equal to the original constraint minus the slack variable.\n            // This is done to avoid the need to have a slack variable in the\n            // tableau, which can make the tableau more difficult to solve.\n            // The new constraint is added to the list of constraints.\n            normalizedConstraints.add(new LinearConstraint(\n                    constraint.getCoefficients().mapMultiply(-1),\n                    Relationship.EQ,\n                    constraint.getValue() - 1));\n            normalizedConstraints.add(new LinearConstraint(\n                    new RealVector(new double[]{1}), Relationship.LEQ, 1));\n        } else {\n            // If the constraint is not a less than or equal constraint with a positive RHS,\n            // or if it is a less than or equal constraint with a negative RHS,\n            // we can add it to the list of constraints as is.\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}"
    ],
    [
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new NullPointerException(\"bin\");\n    }\n    return (bin.getLowerBound() <= this.getUpperBound() && bin.getUpperBound() >= this.getLowerBound());\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new NullPointerException(\"bin\");\n    }\n    return (bin.getLowerBound() <= this.getUpperBound()) && (this.getLowerBound() <= bin.getUpperBound());\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new NullPointerException(\"bin\");\n    }\n    return (bin.getLowerBound() <= this.getUpperBound() && bin.getUpperBound() >= this.getLowerBound());\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new NullPointerException(\"bin\");\n    }\n    return (bin.getLowerBound() <= this.getUpperBound() && bin.getUpperBound() >= this.getLowerBound());\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new NullPointerException(\"bin\");\n    }\n    return (bin.getLowerBound() <= this.getUpperBound() && bin.getUpperBound() >= this.getLowerBound());\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new NullPointerException(\"bin\");\n    }\n    return (bin.getLowerBound() <= this.getUpperBound() && bin.getUpperBound() >= this.getLowerBound());\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new NullPointerException(\"bin\");\n    }\n    return (bin.getLowerBound() <= this.getUpperBound() && bin.getUpperBound() >= this.getLowerBound());\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new NullPointerException(\"bin\");\n    }\n    return (bin.getLowerBound() <= this.getUpperBound() && bin.getUpperBound() >= this.getLowerBound());\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new NullPointerException(\"bin\");\n    }\n    return (bin.getLowerBound() <= this.getUpperBound() && bin.getUpperBound() >= this.getLowerBound());\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new NullPointerException(\"bin\");\n    }\n    return (bin.getLowerBound() <= this.getUpperBound()) && (this.getLowerBound() <= bin.getUpperBound());\n}"
    ],
    [
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return new String[0];\n    }\n    List<String> list = new ArrayList<>();\n    int start = 0;\n    boolean lastMatch = false;\n    boolean match = false;\n    int sizePlus1 = 0;\n    int max = 8192;\n    int len = str.length();\n    char[] separatorChars = new char[Character.MAX_VALUE + 1];\n    for (int i = 0; i <= Character.MAX_VALUE; i++) {\n        separatorChars[i] = (char) i;\n    }\n    while (i < len) {\n        if (Character.isLetter(str.charAt(i))) {\n            if (Character.isUpperCase(str.charAt(i))) {\n                if (camelCase && i > 0 && Character.isLowerCase(str.charAt(i - 1))) {\n                    start = i;\n                    continue;\n                }\n            }\n            match = true;\n            lastMatch = true;\n        } else {\n            if (match || camelCase && lastMatch) {\n                list.add(str.substring(start, i));\n                match = false;\n                lastMatch = false;\n                sizePlus1++;\n                if (sizePlus1 == max) {\n                    i = len;\n                }\n            }\n            start = ++i;\n        }\n    }\n    if (match || camelCase && lastMatch) {\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return new String[0];\n    }\n    List<String> list = new ArrayList<>();\n    int start = 0;\n    int i = 0;\n    int len = str.length();\n    boolean lastMatch = false;\n    boolean match = false;\n    int sizePlus1 = 0;\n    int max = 0;\n\n    while (i < len) {\n        char c = str.charAt(i);\n        int type = Character.getType(c);\n        if (type == Character.UPPERCASE_LETTER) {\n            if (camelCase && i > 0 && Character.getType(str.charAt(i - 1)) == Character.LOWERCASE_LETTER) {\n                i++;\n                continue;\n            }\n        }\n        if (type == Character.LOWERCASE_LETTER || type == Character.DIGIT || type == Character.SPACE_SEPARATOR) {\n            if (match || (camelCase && lastMatch)) {\n                list.add(str.substring(start, i));\n                match = false;\n                lastMatch = false;\n                sizePlus1++;\n                if (sizePlus1 > max) {\n                    max = sizePlus1;\n                }\n            }\n            start = ++i;\n            continue;\n        }\n        lastMatch = false;\n        match = true;\n        i++;\n    }\n    if (match || (camelCase && lastMatch)) {\n        list.add(str.substring(start, i));\n    }\n    String[] result = new String[list.size()];\n    list.toArray(result);\n    return result;\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    List<String> list = new ArrayList<>();\n    int start = 0;\n    int i = 0;\n    int len = str.length();\n    boolean match = false;\n    boolean lastMatch = false;\n    int sizePlus1 = 0;\n    int max = 0;\n    int separatorChars = 0;\n    char c;\n\n    while (i < len) {\n        c = str.charAt(i);\n        int type = Character.getType(c);\n        if (type == Character.UPPERCASE_LETTER) {\n            if (camelCase && i > 0 && Character.getType(str.charAt(i - 1)) == Character.LOWERCASE_LETTER) {\n                i++;\n                continue;\n            }\n        }\n        if (type == Character.LOWERCASE_LETTER || type == Character.DIGIT || type == Character.CONNECTOR_PUNCTUATION || type == Character.OTHER_PUNCTUATION || type == Character.SPACE_SEPARATOR) {\n            if (match || camelCase) {\n                lastMatch = true;\n                if (sizePlus1++ == max) {\n                    i = len;\n                    lastMatch = false;\n                }\n                list.add(str.substring(start, i));\n                match = false;\n            }\n            start = ++i;\n            continue;\n        }\n        lastMatch = false;\n        match = true;\n        i++;\n    }\n    if (match || camelCase && lastMatch) {\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    List<String> list = new ArrayList<>();\n    int start = 0;\n    int i = 0;\n    int len = str.length();\n    boolean match = false;\n    boolean lastMatch = false;\n    int sizePlus1 = 0;\n    int max = 0;\n    char[] separatorChars = new char[Character.MAX_CODE_POINT + 1];\n    for (int type = 0; type <= Character.MAX_CODE_POINT; type++) {\n        separatorChars[type] = (char) type;\n    }\n    while (i < len) {\n        char c = str.charAt(i);\n        int type = Character.getType(c);\n        if (type == Character.UPPERCASE_LETTER && camelCase && i > 0 && Character.getType(str.charAt(i - 1)) == Character.LOWERCASE_LETTER) {\n            i++;\n            continue;\n        }\n        if (match || (type != Character.LOWERCASE_LETTER && type != Character.UPPERCASE_LETTER)) {\n            if (match || preserveAllTokens) {\n                lastMatch = true;\n                if (sizePlus1++ == max) {\n                    i = len;\n                    lastMatch = false;\n                }\n                list.add(str.substring(start, i));\n                match = false;\n            }\n            start = ++i;\n            continue;\n        }\n        lastMatch = false;\n        match = true;\n        i++;\n    }\n    if (match || preserveAllTokens && lastMatch) {\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    List<String> list = new ArrayList<>();\n    int start = 0;\n    int i = 0;\n    int len = str.length();\n    boolean lastMatch = false;\n    boolean match = false;\n    int sizePlus1 = 0;\n    int max = 0;\n    int type = Character.getType(str.charAt(0));\n\n    while (i < len) {\n        int cType = Character.getType(str.charAt(i));\n        if (cType != type) {\n            if (match || (camelCase && lastMatch && type == Character.UPPERCASE_LETTER && cType == Character.LOWERCASE_LETTER)) {\n                list.add(str.substring(start, i));\n                match = false;\n            }\n            start = i;\n            type = cType;\n            lastMatch = match;\n            match = true;\n        } else {\n            lastMatch = match;\n            match = true;\n            i++;\n        }\n    }\n    if (match) {\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return new String[0];\n    }\n    List<String> list = new ArrayList<>();\n    int start = 0;\n    boolean match = false;\n    boolean lastMatch = false;\n    int sizePlus1 = 0;\n    int max = 0;\n    char[] strArray = str.toCharArray();\n    for (int i = 0; i < strArray.length; i++) {\n        int type = Character.getType(strArray[i]);\n        if (type == Character.UPPERCASE_LETTER) {\n            if (camelCase && i > 0 && Character.getType(strArray[i - 1]) == Character.LOWERCASE_LETTER) {\n                i--;\n            }\n        }\n        if (type == Character.LOWERCASE_LETTER || type == Character.DIGIT || type == Character.SPACE_SEPARATOR) {\n            if (match || camelCase) {\n                lastMatch = true;\n                if (sizePlus1++ == max) {\n                    i = strArray.length;\n                    lastMatch = false;\n                }\n                list.add(str.substring(start, i));\n                match = false;\n            }\n            start = ++i;\n            continue;\n        }\n        lastMatch = false;\n        match = true;\n        i++;\n    }\n    if (match || camelCase && lastMatch) {\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return new String[0];\n    }\n    List<String> list = new ArrayList<>();\n    int start = 0;\n    int i = 0;\n    int len = str.length();\n    boolean lastMatch = false;\n    boolean match = false;\n    int sizePlus1 = 0;\n    int max = 0;\n\n    while (i < len) {\n        char c = str.charAt(i);\n        int type = Character.getType(c);\n        if (type == Character.UPPERCASE_LETTER || type == Character.LOWERCASE_LETTER) {\n            if (camelCase && i > 0 && Character.getType(str.charAt(i - 1)) == Character.LOWERCASE_LETTER) {\n                start = i;\n            } else {\n                if (match || preserveAllTokens) {\n                    lastMatch = true;\n                    if (sizePlus1++ == max) {\n                        i = len;\n                        lastMatch = false;\n                    }\n                    list.add(str.substring(start, i));\n                    match = false;\n                }\n                start = ++i;\n                continue;\n            }\n        }\n        lastMatch = false;\n        match = true;\n        i++;\n    }\n    if (match || preserveAllTokens && lastMatch) {\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return new String[0];\n    }\n    List<String> list = new ArrayList<>();\n    int start = 0;\n    int i = 0;\n    int len = str.length();\n    boolean lastMatch = false;\n    boolean match = false;\n    int sizePlus1 = 0;\n    int max = 0;\n    char[] separatorChars = new char[Character.MAX_VALUE + 1];\n    for (int type = 0; type <= Character.MAX_VALUE; type++) {\n        separatorChars[type] = (char) type;\n    }\n    while (i < len) {\n        if (Character.getType(str.charAt(i)) == Character.UPPERCASE_LETTER) {\n            if (camelCase && i > 0 && Character.getType(str.charAt(i - 1)) == Character.LOWERCASE_LETTER) {\n                i++;\n                continue;\n            }\n        }\n        if (Character.getType(str.charAt(i)) == Character.LOWERCASE_LETTER) {\n            if (camelCase && i > 0 && Character.getType(str.charAt(i - 1)) == Character.UPPERCASE_LETTER) {\n                i++;\n                continue;\n            }\n        }\n        if (Character.getType(str.charAt(i)) == Character.DASH_PUNCTUATION || Character.getType(str.charAt(i)) == Character.OTHER_PUNCTUATION || Character.getType(str.charAt(i)) == Character.CURRENCY_SYMBOL || Character.getType(str.charAt(i)) == Character.CONNECTOR_PUNCTUATION || Character.getType(str.charAt(i)) == Character.DIGIT_NUMBER || Character.getType(str.charAt(i)) == Character.SPACE_SEPARATOR || Character.getType(str.charAt(i)) == Character.BREAKING_WHITESPACE) {\n            if (match || camelCase) {\n                lastMatch = true;\n                if (sizePlus1++ == max) {\n                    i = len;\n                    lastMatch = false;\n                }\n                list.add(str.substring(start, i));\n                match = false;\n            }\n            start = ++i;\n            continue;\n        }\n        lastMatch = false;\n        match = true;\n        i++;\n    }\n    if (match || camelCase) {\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    List<String> list = new ArrayList<>();\n    int start = 0;\n    int i = 0;\n    int len = str.length();\n    boolean match = false;\n    boolean lastMatch = false;\n    int sizePlus1 = 0;\n    int max = 0;\n\n    while (i < len) {\n        char c = str.charAt(i);\n        int type = Character.getType(c);\n        if (type == Character.UPPERCASE_LETTER) {\n            if (camelCase && i > 0 && Character.getType(str.charAt(i - 1)) == Character.LOWERCASE_LETTER) {\n                i++;\n                continue;\n            }\n        }\n        if (!match) {\n            start = i;\n            match = true;\n        }\n        if (type == Character.DASH_PUNCTUATION || type == Character.OTHER_PUNCTUATATION || type == Character.CURRENCY_SYMBOL || type == Character.SPACE_SEPARATOR || type == Character.LINE_SEPARATOR || type == Character.CONTROL_CHAR) {\n            if (match || camelCase) {\n                lastMatch = true;\n                if (sizePlus1++ == max) {\n                    i = len;\n                    lastMatch = false;\n                }\n                list.add(str.substring(start, i));\n                match = false;\n            }\n            start = ++i;\n            continue;\n        }\n        match = true;\n        i++;\n    }\n    if (match || camelCase && lastMatch) {\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    List<String> list = new ArrayList<>();\n    int start = 0;\n    int i = 0;\n    int len = str.length();\n    boolean lastMatch = false;\n    boolean match = false;\n    int sizePlus1 = 0;\n    int max = 0;\n\n    while (i < len) {\n        char c = str.charAt(i);\n        int type = Character.getType(c);\n        if (type == Character.UPPERCASE_LETTER) {\n            if (camelCase && i > 0 && Character.getType(str.charAt(i - 1)) == Character.LOWERCASE_LETTER) {\n                i++;\n                continue;\n            }\n        }\n        if (match || preserveAllTokens) {\n            lastMatch = true;\n            if (sizePlus1++ == max) {\n                i = len;\n                lastMatch = false;\n            }\n            list.add(str.substring(start, i));\n            match = false;\n        }\n        start = ++i;\n    }\n    if (match || preserveAllTokens && lastMatch) {\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(new String[list.size()]);\n}"
    ],
    [
      "public long parseMillis(String text)  {\n    ReadWritableInstant instant = ReadWritableInstant.now();\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        instant.getMillis(), ISOChronology.getInstance(), iLocale, iPivotYear, 0);\n    int newPos = parser.parseInto(bucket, text, 0);\n    instant.setMillis(bucket.computeMillis(false, text));\n    if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n        int parsedOffset = bucket.getOffsetInteger();\n        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n        instant.setChronology(ISOChronology.getInstance(parsedZone));\n    } else if (bucket.getZone() != null) {\n        instant.setChronology(ISOChronology.getInstance(bucket.getZone()));\n    }\n    return instant.getMillis();\n}",
      "public long parseMillis(String text)  {\n    ReadWritableInstant instant = new ReadWritableInstant();\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        0, ISOChronology.getInstance(), iLocale, iPivotYear, 0);\n    int newPos = parser.parseInto(bucket, text, 0);\n    instant.setMillis(bucket.computeMillis(false, text));\n    return instant.getMillis();\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        0, ISOChronology.getInstance(), iLocale, iPivotYear, 0);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos < 0) {\n        throw new IllegalArgumentException(\"Invalid date time text: \" + text);\n    }\n    return bucket.getMillis(false, text);\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        0, ISOChronology.getInstance(), iLocale, iPivotYear, 0);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos < 0) {\n        throw new IllegalArgumentException(\"Invalid text to parse\");\n    }\n    return bucket.computeMillis(true, text);\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        0, ISOChronology.getInstance(), iLocale, iPivotYear, 0);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos < 0) {\n        throw new IllegalArgumentException(\"Invalid text to parse\");\n    }\n    return bucket.computeMillis(true, text);\n}",
      "public long parseMillis(String text)  {\n    ReadWritableInstant instant = new ReadWritableInstant();\n    int newPos = parseInto(instant, text, 0);\n    if (newPos < 0) {\n        throw new IllegalArgumentException(\"Invalid date text: \" + text);\n    }\n    return instant.getMillis();\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        0, ISOChronology.getInstance(), iLocale, iPivotYear, 0);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos < 0) {\n        throw new IllegalArgumentException(\"Invalid text to parse\");\n    }\n    return bucket.getMillis();\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        0, ISOChronology.getInstance(), iLocale, iPivotYear, 0);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos < 0) {\n        throw new IllegalArgumentException(\"Invalid text to parse\");\n    }\n    return bucket.computeMillis(true, text);\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        0, ISOChronology.getInstance(), iLocale, iPivotYear, 0);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos < 0) {\n        throw new IllegalArgumentException(\"Invalid text to parse\");\n    }\n    return bucket.getMillis();\n}",
      "public long parseMillis(String text)  {\n    ReadWritableInstant instant = new ReadWritableInstant();\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        0, ISOChronology.getInstance(), iLocale, iPivotYear, 0);\n    int newPos = parser.parseInto(bucket, text, 0);\n    instant.setMillis(bucket.computeMillis(false, text));\n    if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n        int parsedOffset = bucket.getOffsetInteger();\n        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n        instant.setChronology(ISOChronology.getInstance(parsedZone));\n    } else if (bucket.getZone() != null) {\n        instant.setChronology(ISOChronology.getInstance(bucket.getZone()));\n    }\n    return instant.getMillis();\n}"
    ],
    [
      "static MinimizedCondition unoptimized(Node n)  {\n    MeasuredNode positive = new MeasuredNode(n);\n    MeasuredNode negative = new MeasuredNode(new Node(Token.SCRIPT));\n    return new MinimizedCondition(positive, negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    MeasuredNode positive = new MeasuredNode(n);\n    MeasuredNode negative = new MeasuredNode(new Node(Token.SCRIPT));\n    negative.length = Integer.MAX_VALUE;\n    return new MinimizedCondition(positive, negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    MeasuredNode positive = new MeasuredNode(n);\n    MeasuredNode negative = new MeasuredNode(new Node(Token.SCRIPT));\n    negative.length = Integer.MAX_VALUE;\n    return new MinimizedCondition(positive, negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    MeasuredNode positive = new MeasuredNode(n);\n    MeasuredNode negative = new MeasuredNode(new Node(Token.SCRIPT));\n    negative.length = Integer.MAX_VALUE;\n    return new MinimizedCondition(positive, negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    MeasuredNode positive = new MeasuredNode(n);\n    MeasuredNode negative = new MeasuredNode(new Node(Token.SCRIPT));\n    negative.length = Integer.MAX_VALUE;\n    return new MinimizedCondition(positive, negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    return new MinimizedCondition(new MeasuredNode(n), new MeasuredNode(new Node(Token.SCRIPT), 1000000));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    MeasuredNode positive = new MeasuredNode(n);\n    MeasuredNode negative = new MeasuredNode(new Node(Token.SCRIPT));\n    negative.length = Integer.MAX_VALUE;\n    return new MinimizedCondition(positive, negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    MeasuredNode positive = new MeasuredNode(n);\n    MeasuredNode negative = new MeasuredNode(new Node(Token.SCRIPT));\n    return new MinimizedCondition(positive, negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    MeasuredNode positive = new MeasuredNode(n);\n    MeasuredNode negative = new MeasuredNode(new Node(Token.SCRIPT));\n    return new MinimizedCondition(positive, negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    return new MinimizedCondition(new MeasuredNode(n), new MeasuredNode(new Node(Token.SCRIPT), 1000));\n}"
    ],
    [
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    long[] bitVectors = new long[(int) Math.ceil((double) values.spliterator().estimateSize() / 64)];\n    int index = 0;\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        bitVectors[index++] |= 1 << constant.ordinal();\n        if (index == bitVectors.length) {\n            index = 0;\n        }\n    }\n    return bitVectors;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    long[] bitVectors = new long[(int) Math.ceil((double) values.spliterator().estimateSize() / 64)];\n    long currentBitVector = 0;\n    int bitVectorIndex = 0;\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        if ((currentBitVector & (1 << constant.ordinal())) == 0) {\n            currentBitVector |= 1 << constant.ordinal();\n        } else {\n            bitVectors[bitVectorIndex++] = currentBitVector;\n            currentBitVector = 0;\n        }\n        if (bitVectorIndex == bitVectors.length) {\n            bitVectors[bitVectorIndex++] = currentBitVector;\n            break;\n        }\n    }\n    if (bitVectorIndex < bitVectors.length) {\n        bitVectors[bitVectorIndex++] = currentBitVector;\n    }\n    if (bitVectorIndex > 0) {\n        long[] result = new long[bitVectorIndex];\n        System.arraycopy(bitVectors, 0, result, 0, bitVectorIndex);\n        return result;\n    } else {\n        return new long[0];\n    }\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    long[] bitVectors = new long[(int) Math.ceil((double) values.spliterator().estimateSize() / 64)];\n    int index = 0;\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        bitVectors[index++] |= 1 << constant.ordinal();\n        if (index == bitVectors.length) {\n            index = 0;\n        }\n    }\n    return bitVectors;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    long[] bitVectors = new long[(int) Math.ceil(((double) values.spliterator().estimateSize()) / 64)];\n    int index = 0;\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        bitVectors[index++] |= 1 << constant.ordinal();\n        if (index == bitVectors.length) {\n            index = 0;\n        }\n    }\n    return bitVectors;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    long[] bitVectors = new long[(int) Math.ceil((double) values.spliterator().estimateSize() / 64)];\n    long total = 0;\n    int index = 0;\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        total |= 1 << constant.ordinal();\n        if ((total & 0xFFFFFFFFFFFFFFFFL) == 0) {\n            bitVectors[index++] = total;\n            total = 0;\n        }\n    }\n    if (total != 0) {\n        bitVectors[index++] = total;\n    }\n    return Arrays.copyOf(bitVectors, index);\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    long[] bitVectors = new long[(int) Math.ceil((double) values.spliterator().estimateSize() / 64)];\n    int index = 0;\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        bitVectors[index++] |= 1 << constant.ordinal();\n        if (index == bitVectors.length) {\n            index = 0;\n        }\n    }\n    return bitVectors;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    long[] bitVectors = new long[(int) Math.ceil((double) values.spliterator().estimateSize() / 64)];\n    long total = 0;\n    int index = 0;\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        total |= 1 << constant.ordinal();\n        if ((total & 0xFFFFFFFFFFFFFFFFL) == 0) {\n            bitVectors[index++] = total;\n            total = 0;\n        }\n    }\n    if (total != 0) {\n        bitVectors[index++] = total;\n    }\n    long[] result = new long[index];\n    System.arraycopy(bitVectors, 0, result, 0, index);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    long[] bitVectors = new long[(int) Math.ceil((double) values.spliterator().estimateSize() / 64)];\n    int index = 0;\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        bitVectors[index++] |= 1 << constant.ordinal();\n        if (index == bitVectors.length) {\n            index = 0;\n        }\n    }\n    return bitVectors;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    long[] bitVectors = new long[(int) Math.ceil((double) values.spliterator().estimateSize() / 64)];\n    int index = 0;\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        bitVectors[index++] |= 1 << constant.ordinal();\n        if (index == bitVectors.length) {\n            index = 0;\n        }\n    }\n    return bitVectors;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    long[] bitVectors = new long[(int) Math.ceil((double) values.spliterator().estimateSize() / 64)];\n    int index = 0;\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        bitVectors[index++] |= 1 << constant.ordinal();\n        if (index == bitVectors.length) {\n            index = 0;\n        }\n    }\n    return bitVectors;\n}"
    ],
    [
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getDepth();\n  } else if (scope.isPropertyScope()) {\n    int depth = 0;\n    SymbolScope currentScope = scope;\n    while (!currentScope.isLexicalScope()) {\n      depth++;\n      currentScope = currentScope.getPropertyScope();\n    }\n    return depth + currentScope.getDepth();\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getDepth();\n  } else if (scope.isPropertyScope()) {\n    int depth = 0;\n    SymbolScope currentScope = scope;\n    while (!currentScope.isLexicalScope()) {\n      depth++;\n      currentScope = currentScope.getPropertyScope();\n    }\n    return depth + currentScope.getDepth();\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getDepth();\n  } else if (scope.isPropertyScope()) {\n    int depth = 0;\n    SymbolScope currentScope = scope;\n    while (!currentScope.isLexicalScope()) {\n      depth++;\n      currentScope = currentScope.getPropertyScope();\n    }\n    return depth + currentScope.getDepth();\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getScopeDepth();\n  } else if (scope.isPropertyScope()) {\n    int depth = 0;\n    SymbolScope currentScope = scope;\n    while (!currentScope.isLexicalScope()) {\n      depth++;\n      currentScope = currentScope.getPropertyScope();\n    }\n    return depth + currentScope.getScopeDepth();\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getDepth();\n  } else if (scope.isPropertyScope()) {\n    int depth = 0;\n    SymbolScope currentScope = scope;\n    while (!currentScope.isLexicalScope()) {\n      depth++;\n      currentScope = currentScope.getPropertyScope();\n    }\n    return depth + currentScope.getDepth();\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getScopeDepth();\n  } else if (scope.isPropertyScope()) {\n    SymbolScope nearestLexicalScope = scope.getNearestLexicalScope();\n    return nearestLexicalScope.getScopeDepth() + nearestLexicalScope.getScopeDepth();\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getScopeDepth();\n  } else if (scope.isPropertyScope()) {\n    int depth = 0;\n    SymbolScope currentScope = scope;\n    while (!currentScope.isLexicalScope()) {\n      depth++;\n      currentScope = currentScope.getPropertyScope();\n    }\n    return depth + currentScope.getScopeDepth();\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getScopeDepth();\n  } else if (scope.isPropertyScope()) {\n    int depth = 0;\n    SymbolScope currentScope = scope;\n    while (!currentScope.isLexicalScope()) {\n      depth++;\n      currentScope = currentScope.getPropertyScope();\n    }\n    return depth + currentScope.getScopeDepth();\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getScopeDepth();\n  } else if (scope.isPropertyScope()) {\n    int depth = 0;\n    SymbolScope currentScope = scope;\n    while (!currentScope.isLexicalScope()) {\n      depth++;\n      currentScope = currentScope.getPropertyScope();\n    }\n    return depth + currentScope.getScopeDepth();\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getDepth();\n  } else if (scope.isPropertyScope()) {\n    int depth = 0;\n    SymbolScope currentScope = scope;\n    while (!currentScope.isLexicalScope()) {\n      depth++;\n      currentScope = currentScope.getPropertyScope();\n    }\n    return depth + currentScope.getDepth();\n  } else {\n    return 0;\n  }\n}"
    ],
    [
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    if (rawData.length == 0 || rawData[0].length == 0) {\n        return new double[0][];\n    }\n\n    int rows = rawData.length;\n    int columns = rawData[0].length;\n\n    // number of blocks\n    int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocks = new double[blockRows * blockColumns][];\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            int iStart = iBlock * BLOCK_SIZE;\n            int iEnd = Math.min(iStart + BLOCK_SIZE, rows);\n            int jStart = jBlock * BLOCK_SIZE;\n            int jEnd = Math.min(jStart + BLOCK_SIZE, columns);\n            int blockSize = (iEnd - iStart) * (jEnd - jStart);\n            blocks[index] = new double[blockSize];\n            int k = 0;\n            for (int i = iStart; i < iEnd; ++i) {\n                for (int j = jStart; j < jEnd; ++j) {\n                    blocks[index][k++] = rawData[i][j];\n                }\n            }\n        }\n    }\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    if (rawData.length == 0 || rawData[0].length == 0) {\n        return new double[0][];\n    }\n\n    int rows = rawData.length;\n    int columns = rawData[0].length;\n\n    // number of blocks\n    int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocks = new double[blockRows * blockColumns][];\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            int iStart = iBlock * BLOCK_SIZE;\n            int iEnd = Math.min(iStart + BLOCK_SIZE, rows);\n            int jStart = jBlock * BLOCK_SIZE;\n            int jEnd = Math.min(jStart + BLOCK_SIZE, columns);\n            double[] blockData = new double[iHeight * blockWidth(jBlock)];\n            int k = 0;\n            for (int i = iStart; i < iEnd; ++i) {\n                for (int j = jStart; j < jEnd; ++j) {\n                    blockData[k++] = rawData[i][j];\n                }\n            }\n            blocks[index] = blockData;\n        }\n    }\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    if (rawData.length == 0 || rawData[0].length == 0) {\n        return new double[0][];\n    }\n\n    int rows = rawData.length;\n    int columns = rawData[0].length;\n    int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocks = new double[blockRows * blockColumns][];\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            int iStart = iBlock * BLOCK_SIZE;\n            int iEnd = Math.min(iStart + BLOCK_SIZE, rows);\n            int jStart = jBlock * BLOCK_SIZE;\n            int jEnd = Math.min(jStart + BLOCK_SIZE, columns);\n            int height = Math.min(iEnd - iStart, iHeight);\n            int width = Math.min(jEnd - jStart, blockWidth(jBlock));\n            blocks[index] = new double[height * width];\n            int k = 0;\n            for (int i = iStart; i < iEnd; ++i) {\n                for (int j = jStart; j < jEnd; ++j) {\n                    blocks[index][k++] = rawData[i][j];\n                }\n            }\n        }\n    }\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    if (rawData.length == 0 || rawData[0].length == 0) {\n        return new double[0][0];\n    }\n\n    int rows = rawData.length;\n    int columns = rawData[0].length;\n    int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocks = new double[blockRows * blockColumns][];\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            int iStartRow = iBlock * BLOCK_SIZE;\n            int iStartCol = jBlock * BLOCK_SIZE;\n            int iEndRow = Math.min(iStartRow + BLOCK_SIZE, rows);\n            int iEndCol = Math.min(iStartCol + BLOCK_SIZE, columns);\n            int iWidth = iEndCol - iStartCol;\n            int iHeightBlock = iEndRow - iStartRow;\n            blocks[index] = new double[iHeightBlock * iWidth];\n            int k = 0;\n            for (int i = iStartRow; i < iEndRow; ++i) {\n                for (int j = iStartCol; j < iEndCol; ++j) {\n                    blocks[index][k++] = rawData[i][j];\n                }\n            }\n        }\n    }\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    int rows = rawData.length;\n    int columns = rawData[0].length;\n\n    if (rows * columns != rawData.length * rawData[0].length) {\n        throw new DimensionMismatchException(\"rawData\", rows * columns);\n    }\n\n    int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocks = new double[blockRows * blockColumns][];\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            int iStartRow = iBlock * BLOCK_SIZE;\n            int iStartCol = jBlock * BLOCK_SIZE;\n            int iEndRow = Math.min(iStartRow + BLOCK_SIZE, rows);\n            int iEndCol = Math.min(iStartCol + BLOCK_SIZE, columns);\n            int blockWidth = iEndCol - iStartCol;\n            int blockHeight = iEndRow - iStartRow;\n            blocks[index] = new double[blockHeight * blockWidth];\n            int k = 0;\n            for (int i = iStartRow; i < iEndRow; ++i) {\n                for (int j = iStartCol; j < iEndCol; ++j) {\n                    blocks[index][k++] = rawData[i][j];\n                }\n            }\n        }\n    }\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    int rows = rawData.length;\n    int columns = rawData[0].length;\n\n    // number of blocks\n    int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocks = new double[blockRows * blockColumns][];\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            int iStart = iBlock * BLOCK_SIZE;\n            int iEnd = Math.min(iStart + BLOCK_SIZE, rows);\n            int jStart = jBlock * BLOCK_SIZE;\n            int jEnd = Math.min(jStart + BLOCK_SIZE, columns);\n            double[] blockData = new double[iHeight * blockWidth(jBlock)];\n            for (int i = iStart; i < iEnd; ++i) {\n                for (int j = jStart; j < jEnd; ++j) {\n                    blockData[index * BLOCK_SIZE + i - iStart + j - jStart] = rawData[i][j];\n                }\n            }\n            blocks[index] = blockData;\n        }\n    }\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    int rows = rawData.length;\n    int columns = rawData[0].length;\n\n    if (rows == 0 || columns == 0) {\n        return new double[0][0];\n    }\n\n    int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocks = new double[blockRows * blockColumns][];\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            int iStart = iBlock * BLOCK_SIZE;\n            int iEnd = Math.min(iStart + BLOCK_SIZE, rows);\n            int jStart = jBlock * BLOCK_SIZE;\n            int jEnd = Math.min(jStart + BLOCK_SIZE, columns);\n\n            double[] blockData = new double[iHeight * blockWidth(jBlock)];\n            int k = 0;\n            for (int i = iStart; i < iEnd; ++i) {\n                for (int j = jStart; j < jEnd; ++j) {\n                    blockData[k++] = rawData[i][j];\n                }\n            }\n            blocks[index] = blockData;\n        }\n    }\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    if (rawData.length == 0 || rawData[0].length == 0) {\n        return new double[0][0];\n    }\n\n    int rows = rawData.length;\n    int columns = rawData[0].length;\n\n    int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocks = new double[blockRows * blockColumns][];\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            int iStart = iBlock * BLOCK_SIZE;\n            int iEnd = Math.min(iStart + BLOCK_SIZE, rows);\n            int jStart = jBlock * BLOCK_SIZE;\n            int jEnd = Math.min(jStart + BLOCK_SIZE, columns);\n            double[] blockData = new double[iHeight * blockWidth(jBlock)];\n            int k = 0;\n            for (int i = iStart; i < iEnd; ++i) {\n                for (int j = jStart; j < jEnd; ++j) {\n                    blockData[k++] = rawData[i][j];\n                }\n            }\n            blocks[index] = blockData;\n        }\n    }\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    if (rawData.length == 0 || rawData[0].length == 0) {\n        return new double[0][0];\n    }\n\n    int rows = rawData.length;\n    int columns = rawData[0].length;\n\n    // number of blocks\n    int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocks = new double[blockRows * blockColumns][];\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            int iStartRow = iBlock * BLOCK_SIZE;\n            int iStartCol = jBlock * BLOCK_SIZE;\n            int iEndRow = Math.min(iStartRow + BLOCK_SIZE, rows);\n            int iEndCol = Math.min(iStartCol + BLOCK_SIZE, columns);\n            int iWidth = iEndCol - iStartCol;\n            int iHeightActual = iEndRow - iStartRow;\n            blocks[index] = new double[iHeightActual * iWidth];\n            int k = 0;\n            for (int i = iStartRow; i < iEndRow; ++i) {\n                for (int j = iStartCol; j < iEndCol; ++j, ++k) {\n                    blocks[index][k] = rawData[i][j];\n                }\n            }\n        }\n    }\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    if (rawData.length == 0 || rawData[0].length == 0) {\n        return new double[0][];\n    }\n\n    int rows = rawData.length;\n    int columns = rawData[0].length;\n    int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocks = new double[blockRows * blockColumns][];\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            int iStart = iBlock * BLOCK_SIZE;\n            int iEnd = Math.min(iStart + BLOCK_SIZE, rows);\n            int jStart = jBlock * BLOCK_SIZE;\n            int jEnd = Math.min(jStart + BLOCK_SIZE, columns);\n            double[] blockData = new double[iHeight * blockWidth(jBlock)];\n            for (int i = iStart; i < iEnd; ++i) {\n                for (int j = jStart; j < jEnd; ++j) {\n                    blockData[(i - iStart) * blockWidth(jBlock) + j - jStart] = rawData[i][j];\n                }\n            }\n            blocks[index] = blockData;\n        }\n    }\n    return blocks;\n}"
    ],
    [
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null || values == null) {\n        throw new NullPointerException(\"enumClass or values is null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"enumClass is not an enum class\");\n    }\n    long bitVector = 0;\n    for (final E value : values) {\n        bitVector |= 1 << value.ordinal();\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null || values == null) {\n        throw new NullPointerException(\"enumClass or values is null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"enumClass is not an enum class\");\n    }\n    E[] enumConstants = enumClass.getEnumConstants();\n    if (enumConstants.length > 64) {\n        throw new IllegalArgumentException(\"enumClass has more than 64 values\");\n    }\n    long bitVector = 0;\n    for (E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"values contains null\");\n        }\n        bitVector |= 1L << enumConstants.indexOf(value);\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null || values == null) {\n        throw new NullPointerException(\"enumClass or values is null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"enumClass is not an enum class\");\n    }\n    E[] enumConstants = enumClass.getEnumConstants();\n    if (enumConstants == null) {\n        throw new IllegalArgumentException(\"enumClass has no enum constants\");\n    }\n    long bitVector = 0;\n    for (E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"values contains null\");\n        }\n        bitVector |= 1 << enumConstants.indexOf(value);\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null || values == null) {\n        throw new NullPointerException(\"enumClass or values is null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"enumClass is not an enum class\");\n    }\n    if (values.iterator().next() == null) {\n        throw new IllegalArgumentException(\"values contains null\");\n    }\n    long result = 0;\n    for (final E e : values) {\n        result |= 1 << e.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null || values == null) {\n        throw new NullPointerException(\"enumClass or values is null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"enumClass is not an enum class\");\n    }\n    long bitVector = 0;\n    for (E value : values) {\n        bitVector |= 1 << value.ordinal();\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null || values == null) {\n        throw new NullPointerException(\"enumClass or values is null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"enumClass is not an enum class\");\n    }\n    if (values.iterator().next() == null) {\n        throw new IllegalArgumentException(\"values contains null\");\n    }\n    long bitVector = 0;\n    for (final E value : values) {\n        bitVector |= 1L << value.ordinal();\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null || values == null) {\n        throw new NullPointerException(\"enumClass or values is null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"enumClass is not an enum class\");\n    }\n    if (values.iterator().next() == null) {\n        throw new IllegalArgumentException(\"values contains null\");\n    }\n    long bitVector = 0;\n    for (E value : values) {\n        bitVector |= 1 << value.ordinal();\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null || values == null) {\n        throw new NullPointerException(\"enumClass or values is null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"enumClass is not an enum class\");\n    }\n    if (values.iterator().next() == null) {\n        throw new IllegalArgumentException(\"values contains null\");\n    }\n    long result = 0;\n    for (E value : values) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null || values == null) {\n        throw new NullPointerException(\"enumClass or values is null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"enumClass is not an enum class\");\n    }\n    E[] enums = enumClass.getEnumConstants();\n    if (enums.length > 64) {\n        throw new IllegalArgumentException(\"enumClass has more than 64 values\");\n    }\n    long bitVector = 0;\n    for (E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"values contains null\");\n        }\n        bitVector |= 1L << enums.indexOf(value);\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null || values == null) {\n        throw new NullPointerException(\"enumClass or values is null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"enumClass is not an enum class\");\n    }\n    if (values.iterator().next() == null) {\n        throw new IllegalArgumentException(\"values contains null\");\n    }\n    long result = 0;\n    for (E value : values) {\n        result |= 1L << value.ordinal();\n    }\n    return result;\n}"
    ],
    [
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = Dfp.ONE;\n    Dfp term = a;\n    Dfp factorial = Dfp.ONE;\n\n    while (true) {\n        term = term.multiply(a).divide(factorial);\n        result = result.add(term);\n\n        if (term.compareTo(Dfp.ZERO) < 0) {\n            break;\n        }\n\n        factorial = factorial.multiply(Dfp.TWO);\n    }\n\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = Dfp.ONE;\n    Dfp term = a;\n    Dfp factorial = Dfp.ONE;\n\n    while (true) {\n        term = term.multiply(a).divide(factorial);\n        result = result.add(term);\n\n        if (term.compareTo(Dfp.ZERO) == 0) {\n            break;\n        }\n\n        factorial = factorial.multiply(Dfp.TWO.add(Dfp.ONE));\n    }\n\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = a.newInstance(1);\n    Dfp x = a;\n\n    int i = 2;\n    while (true) {\n        Dfp term = x.multiply(x).divide(new Dfp(i).multiply(new Dfp(i)));\n        result = result.add(term);\n        if (x.compareTo(new Dfp(1).divide(new Dfp(i))) < 0) {\n            break;\n        }\n        i++;\n    }\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = a.newInstance(1);\n    Dfp term = a.newInstance(1);\n\n    int n = 2;\n    while (true) {\n        term = term.multiply(a).divide(new Dfp(n).newInstance());\n        if (term.compareTo(Dfp.ZERO) == 0) {\n            break;\n        }\n        result = result.add(term);\n        n++;\n    }\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = a.newInstance();\n    Dfp x = a;\n    Dfp term = a.newInstance();\n    Dfp factorial = a.newInstance(1);\n\n    do {\n        term = term.multiply(x).divide(factorial);\n        result = result.add(term);\n        factorial = factorial.add(a.newInstance(1));\n        x = x.multiply(a);\n    } while (x.compareTo(a.newInstance(1).divide(Dfp.TEN)) > 0);\n\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = a.newInstance(1);\n    Dfp x = a;\n    int n = 1;\n\n    while (true) {\n        Dfp term = x.multiply(x).divide(new Dfp(n).multiply(new Dfp(n)));\n        result = result.add(term);\n        if (x.compareTo(new Dfp(1).divide(new Dfp(n))) < 0) {\n            break;\n        }\n        x = x.multiply(a);\n        n++;\n    }\n\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = a.newInstance(1);\n    Dfp x = a;\n\n    int i = 2;\n    while (true) {\n        Dfp term = x.divide(new Dfp(i).multiply(new Dfp(i)));\n        result = result.add(term);\n        if (x.compareTo(new Dfp(1).divide(new Dfp(i).multiply(new Dfp(i)))) <= 0) {\n            break;\n        }\n        i++;\n    }\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = a.newInstance();\n    Dfp x = a;\n\n    int n = 1;\n    while (true) {\n        Dfp term = x.multiply(x).divide(new Dfp(n).multiply(new Dfp(n)));\n        result = result.add(term);\n        if (Math.abs(term) < Dfp.EPSILON) {\n            break;\n        }\n        n++;\n    }\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = Dfp.ONE;\n    Dfp x = a;\n    int n = 1;\n\n    while (true) {\n        Dfp term = x.divide(new Dfp(n).multiply(new Dfp(n)));\n        if (term.compareTo(Dfp.ZERO) < 0) {\n            break;\n        }\n        result = result.add(term);\n        x = x.multiply(a);\n        n++;\n    }\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = Dfp.ONE;\n    Dfp x = a;\n    int n = 1;\n\n    while (true) {\n        Dfp term = x.divide(new Dfp(n).multiply(new Dfp(n)));\n        if (term.compareTo(Dfp.ZERO) < 0) {\n            break;\n        }\n        result = result.add(term);\n        x = x.multiply(a);\n        n++;\n    }\n\n    return result;\n}"
    ],
    [
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    if (getNorm().getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n    }\n    return new FieldVector3D<T>(y, -x, z);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    return new FieldVector3D<T>(y.multiply(z.getReal()), z.multiply(x.getReal()), x.multiply(y.getReal()));\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    if (getNorm().getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n    }\n    return scalarMultiply(x.getField().getOne()).crossProduct(this);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    if (getNorm().getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n    }\n    return new FieldVector3D<T>(y, -x, 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final T s = getNorm();\n    if (s.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n    }\n    return scalarMultiply(s.reciprocal());\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    if (x.getField().getZero().equals(x)) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n    }\n    return new FieldVector3D<T>(y.getField().getOne(), this, z, -x);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    if (x.getField().getOne().equals(x)) {\n        return new FieldVector3D<T>(y.getField().getOne(), this, y, z);\n    } else if (y.getField().getOne().equals(y)) {\n        return new FieldVector3D<T>(x, this, z, z.getField().getOne());\n    } else {\n        return new FieldVector3D<T>(z.getField().getOne(), this, x, y);\n    }\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    if (x.getField().getZero().equals(x)) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n    }\n    return new FieldVector3D<T>(y.getField().getOne(), this, z.getField().getZero(), x.getField().getZero());\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    if (x.getReal() == 0 && y.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n    }\n    return new FieldVector3D<T>(y, -x, 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    if (x.getField().getZero().equals(x)) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n    }\n    return new FieldVector3D<T>(y.getField().getOne(), this, z, -x);\n}"
    ],
    [
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other) && !other.isOverlappedBy(this)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    T min = Math.max(minimum, other.minimum);\n    T max = Math.min(maximum, other.maximum);\n    return new Range<>(min, max);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other) && !other.isOverlappedBy(this)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    T min = Math.max(minimum, other.minimum);\n    T max = Math.min(maximum, other.maximum);\n    return new Range<>(min, max);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    return new Range<>(Math.max(minimum, other.minimum), Math.min(maximum, other.maximum));\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    int min = Math.max(minimum, other.minimum);\n    int max = Math.min(maximum, other.maximum);\n    return new Range<>(min, max);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other) && !other.isOverlappedBy(this)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    T min = Math.max(minimum, other.minimum);\n    T max = Math.min(maximum, other.maximum);\n    return new Range<>(min, max);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other) && !other.isOverlappedBy(this)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    T min = Math.max(minimum, other.minimum);\n    T max = Math.min(maximum, other.maximum);\n    return new Range<>(min, max);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    return new Range<>(Math.max(minimum, other.minimum), Math.min(maximum, other.maximum));\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    T min = Math.max(minimum, other.minimum);\n    T max = Math.min(maximum, other.maximum);\n    return new Range<>(min, max);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    T min = Math.max(minimum, other.minimum);\n    T max = Math.min(maximum, other.maximum);\n    return new Range<>(min, max);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    return new Range<>(Math.max(minimum, other.minimum), Math.min(maximum, other.maximum));\n}"
    ],
    [
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new OutputStreamJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new OutputStreamJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new OutputStreamJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new OutputStreamJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new OutputStreamJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new OutputStreamJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new OutputStreamJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new OutputStreamJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new OutputStreamJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new OutputStreamJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}"
    ],
    [
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        type = type.getComponentType();\n        return arrayMemberEquals(type, o1, o2);\n    }\n    return type.isPrimitive() ? o1.equals(o2) : o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (o1 == o2) {\n        return true;\n    }\n    if (o1 == null || o2 == null) {\n        return false;\n    }\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isEnum()) {\n        return ((Enum<?>) o1).ordinal() == ((Enum<?>) o2).ordinal();\n    }\n    if (type.isAnnotation()) {\n        return hashCode((Annotation) o1) == hashCode((Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        type = type.getComponentType();\n        return arrayMemberEquals(type, o1, o2);\n    }\n    if (o1 == null) {\n        return o2 == null;\n    }\n    if (o2 == null) {\n        return false;\n    }\n    if (o1 instanceof Annotation) {\n        return hashCode((Annotation) o1) == hashCode((Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (o1 == o2) {\n        return true;\n    }\n    if (o1 == null || o2 == null) {\n        return false;\n    }\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isEnum()) {\n        return ((Enum<?>) o1).ordinal() == ((Enum<?>) o2).ordinal();\n    }\n    if (type.isAnnotation()) {\n        return hashCode((Annotation) o1) == hashCode((Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (o1 == o2) {\n        return true;\n    }\n    if (o1 == null || o2 == null) {\n        return false;\n    }\n    if (type.isArray()) {\n        type = type.getComponentType();\n        return arrayMemberEquals(type, o1, o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        type = type.getComponentType();\n        return arrayMemberEquals(type, o1, o2);\n    }\n    return type.isPrimitive() ? o1 == o2 : o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        type = type.getComponentType();\n        return arrayMemberEquals(type, o1, o2);\n    }\n    if (o1 == null) {\n        return o2 == null;\n    }\n    if (o2 == null) {\n        return false;\n    }\n    if (o1 instanceof Annotation) {\n        return hashCode((Annotation) o1) == hashCode((Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (o1 == o2) {\n        return true;\n    }\n    if (o1 == null || o2 == null) {\n        return false;\n    }\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isEnum()) {\n        return ((Enum<?>) o1).ordinal() == ((Enum<?>) o2).ordinal();\n    }\n    if (type.isAnnotation()) {\n        return hashCode((Annotation) o1) == hashCode((Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        type = type.getComponentType();\n        return arrayMemberEquals(type, o1, o2);\n    }\n    return type.isPrimitive() ? o1 == o2 : o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (o1 == o2) {\n        return true;\n    }\n    if (o1 == null || o2 == null) {\n        return false;\n    }\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    return o1.equals(o2);\n}"
    ],
    [
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n        return type;\n    }\n    return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n        return type;\n    }\n    return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n        return type;\n    }\n    return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n        return type;\n    }\n    return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n        return type;\n    }\n    return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n        return type;\n    }\n    return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n        return type;\n    }\n    return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n        return type;\n    }\n    return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n        return type;\n    }\n    return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n        return type;\n    }\n    return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n}"
    ],
    [
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (originalType == null) {\n      originalType = node.getJSType();\n    }\n    if (restrictedType == null) {\n      restrictedType = originalType;\n    }\n    if (originalType.equals(restrictedType)) {\n      return blindScope;\n    }\n    return blindScope.createChildFlowScope().inferSlotType(node.getName(), restrictedType);\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (originalType == restrictedType) {\n      return blindScope;\n    }\n    FlowScope newScope = blindScope.createChildFlowScope();\n    newScope.inferSlotType(node.getName(), restrictedType);\n    return newScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (originalType == restrictedType) {\n      return blindScope;\n    }\n    FlowScope newScope = blindScope.createChildFlowScope();\n    newScope.inferSlotType(node.getName(), restrictedType);\n    return newScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (originalType != null && originalType.equals(restrictedType)) {\n      return blindScope;\n    }\n    return blindScope.createChildFlowScope();\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (originalType == null || originalType.equals(restrictedType)) {\n      return blindScope;\n    }\n    FlowScope newScope = blindScope.createChildFlowScope();\n    newScope.inferSlotType(node.getName(), restrictedType);\n    return newScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (originalType == null) {\n        originalType = node.getJSType();\n    }\n    if (originalType != restrictedType) {\n        String name = node.getName();\n        FlowScope newScope = blindScope.createChildFlowScope();\n        newScope.inferSlotType(name, restrictedType);\n        return newScope;\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (originalType == null) {\n        return blindScope;\n    }\n    if (restrictedType == null) {\n        return blindScope;\n    }\n    if (originalType.equals(restrictedType)) {\n        return blindScope;\n    }\n    FlowScope newScope = blindScope.createChildFlowScope();\n    newScope.inferSlotType(node.getJSType().getName(), restrictedType);\n    return newScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (originalType != null && restrictedType != null\n        && !originalType.equals(restrictedType)) {\n      return blindScope.createChildFlowScope();\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (originalType == restrictedType) {\n      return blindScope;\n    }\n    FlowScope newScope = blindScope.createChildFlowScope();\n    newScope.inferSlotType(node.getName(), restrictedType);\n    return newScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (originalType == restrictedType) {\n      return blindScope;\n    }\n    FlowScope newScope = blindScope.createChildFlowScope();\n    newScope.inferSlotType(node.getName(), restrictedType);\n    return newScope;\n  }"
    ],
    [
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token != JsDocToken.STRING || !stream.getString().equals(\"function\")) {\n        return reportGenericTypeSyntaxWarning();\n    }\n\n    next();\n    skipEOLs();\n\n    Node typeParameters = parseTypeParameters(next());\n    if (typeParameters == null) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.typeparams\");\n    }\n\n    if (!match(JsDocToken.LP)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    next();\n    skipEOLs();\n\n    if (!match(JsDocToken.STRING) || !stream.getString().equals(\"this\")) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n    }\n\n    next();\n    skipEOLs();\n\n    if (!match(JsDocToken.COLON)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n\n    next();\n    skipEOLs();\n\n    Node typeName = parseTypeName(next());\n    if (typeName == null) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.typename\");\n    }\n\n    if (!match(JsDocToken.COMMA)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.comma\");\n    }\n\n    next();\n    skipEOLs();\n\n    Node parametersType = parseParametersType(next());\n    if (parametersType == null) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.parameters\");\n    }\n\n    if (!match(JsDocToken.RP)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    next();\n    skipEOLs();\n\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.resulttype\");\n    }\n\n    return newNode(Token.FUNCTION_TYPE, typeParameters, parametersType, resultType);\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token != JsDocToken.STRING || !stream.getString().equals(\"function\")) {\n        return reportGenericTypeSyntaxWarning();\n    }\n\n    next();\n    skipEOLs();\n    Node typeParameters = parseTypeParameters(next());\n    if (typeParameters == null) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.typeparameters\");\n    }\n\n    if (!match(JsDocToken.LP)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lparen\");\n    }\n\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.STRING) || !stream.getString().equals(\"this\")) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n    }\n\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n\n    Node typeName = parseTypeName(next());\n    if (typeName == null) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.typename\");\n    }\n\n    if (!match(JsDocToken.COMMA)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.comma\");\n    }\n\n    Node parametersType = parseParametersType(next());\n    if (parametersType == null) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.parameters\");\n    }\n\n    if (!match(JsDocToken.RP)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rparen\");\n    }\n\n    next();\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.resulttype\");\n    }\n\n    return newNode(Token.FUNCTION, typeParameters, parametersType, resultType);\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionTypeNode = newNode(Token.FUNCTION);\n    next();\n\n    if (match(JsDocToken.LT)) {\n        Node typeParameters = parseTypeParameters(next());\n        functionTypeNode.addChildToFront(typeParameters);\n    }\n\n    if (match(JsDocToken.LP)) {\n        next();\n        if (match(JsDocToken.STRING, \"this\")) {\n            next();\n            if (match(JsDocToken.COLON)) {\n                Node typeName = parseTypeName(next());\n                functionTypeNode.addChildToFront(typeName);\n            } else {\n                return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n            }\n        } else {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.invalid.this\");\n        }\n\n        if (match(JsDocToken.RP)) {\n            next();\n        } else {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n        }\n    } else {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    if (match(JsDocToken.RP)) {\n        next();\n    } else {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    return functionTypeNode;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  if (token != JsDocToken.STRING || !stream.getString().equals(\"function\")) {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  next();\n  skipEOLs();\n\n  Node typeParameters = parseTypeParameters(next());\n  if (typeParameters == null) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.typeparameters\");\n  }\n\n  if (!match(JsDocToken.LP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lparen\");\n  }\n\n  next();\n  skipEOLs();\n\n  if (!match(JsDocToken.STRING) || !stream.getString().equals(\"this\")) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n  }\n\n  next();\n  skipEOLs();\n\n  if (!match(JsDocToken.COLON)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n  }\n\n  Node typeName = parseTypeName(next());\n  if (typeName == null) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.typename\");\n  }\n\n  if (!match(JsDocToken.COMMA)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.comma\");\n  }\n\n  Node parametersType = parseParametersType(next());\n  if (parametersType == null) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.parameters\");\n  }\n\n  if (!match(JsDocToken.RP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rparen\");\n  }\n\n  next();\n  skipEOLs();\n\n  Node resultType = parseResultType(next());\n  if (resultType == null) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.resulttype\");\n  }\n\n  return newNode(Token.FUNCTION, typeParameters, parametersType, resultType);\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionTypeNode = newNode(Token.FUNCTION);\n    next();\n\n    if (match(JsDocToken.LT)) {\n        next();\n        Node typeParameters = parseTypeParameters(next());\n        functionTypeNode.addChildToFront(typeParameters);\n    }\n\n    if (match(JsDocToken.LP)) {\n        next();\n        if (match(JsDocToken.STRING, \"this\")) {\n            next();\n            if (match(JsDocToken.COLON)) {\n                next();\n                Node typeName = parseTypeName(next());\n                functionTypeNode.addChildToFront(typeName);\n            }\n        }\n    }\n\n    if (match(JsDocToken.RP)) {\n        next();\n        if (match(JsDocToken.RP)) {\n            next();\n            Node resultType = parseTypeExpression(next());\n            functionTypeNode.addChildToFront(resultType);\n        }\n    }\n\n    return functionTypeNode;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionTypeNode = newNode(Token.FUNCTION);\n    next();\n\n    if (match(JsDocToken.LT)) {\n        next();\n        Node typeParameters = parseTypeParameters(next());\n        if (typeParameters != null) {\n            functionTypeNode.addChildToFront(typeParameters);\n        }\n    }\n\n    if (match(JsDocToken.LP)) {\n        next();\n        functionTypeNode.addChild(newStringNode(\"this\"));\n        if (match(JsDocToken.COLON)) {\n            next();\n            Node typeName = parseTypeName(next());\n            functionTypeNode.addChild(typeName);\n        }\n        if (match(JsDocToken.COMMA)) {\n            next();\n            Node parametersType = parseParametersType(next());\n            functionTypeNode.addChild(parametersType);\n        }\n        if (match(JsDocToken.RP)) {\n            next();\n        } else {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n        }\n    }\n\n    if (match(JsDocToken.RS)) {\n        next();\n        Node resultType = parseResultType(next());\n        if (resultType != null) {\n            functionTypeNode.addChild(resultType);\n        }\n    }\n\n    return functionTypeNode;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionTypeNode = newNode(Token.FUNCTION);\n    if (match(JsDocToken.STRING)) {\n        next();\n        if (!\"function\".equals(stream.getString())) {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.function\");\n        }\n    }\n    if (match(JsDocToken.LT)) {\n        next();\n        Node typeParameters = parseTypeParameters(next());\n        if (typeParameters != null) {\n            functionTypeNode.addChildToFront(typeParameters);\n        }\n    }\n    if (match(JsDocToken.LP)) {\n        next();\n        if (match(JsDocToken.STRING)) {\n            next();\n            if (!\"this\".equals(stream.getString())) {\n                return reportTypeSyntaxWarning(\"msg.jsdoc.this\");\n            }\n        }\n        if (match(JsDocToken.COLON)) {\n            next();\n            Node typeName = parseTypeName(next());\n            if (typeName != null) {\n                functionTypeNode.addChildToFront(typeName);\n            }\n        }\n        if (match(JsDocToken.COMMA)) {\n            next();\n            Node parametersType = parseParametersType(next());\n            if (parametersType != null) {\n                functionTypeNode.addChildToFront(parametersType);\n            }\n        }\n        if (match(JsDocToken.RP)) {\n            next();\n            if (match(JsDocToken.RP)) {\n                next();\n                Node resultType = parseResultType(next());\n                if (resultType != null) {\n                    functionTypeNode.addChildToFront(resultType);\n                }\n            }\n        }\n    }\n    return functionTypeNode;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token != JsDocToken.STRING || !stream.getString().equals(\"function\")) {\n        return reportGenericTypeSyntaxWarning();\n    }\n    next();\n    skipEOLs();\n    Node typeParameters = parseTypeParameters(next());\n    if (typeParameters == null) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.typeparameters\");\n    }\n    if (!match(JsDocToken.LP)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lparen\");\n    }\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.STRING) || !stream.getString().equals(\"this\")) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n    }\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n    Node typeName = parseTypeName(next());\n    if (typeName == null) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.typename\");\n    }\n    if (!match(JsDocToken.COMMA)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.comma\");\n    }\n    next();\n    skipEOLs();\n    Node parametersType = parseParametersType(next());\n    if (parametersType == null) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.parameters\");\n    }\n    if (!match(JsDocToken.RP)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rparen\");\n    }\n    next();\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.resulttype\");\n    }\n    return newNode(Token.FUNCTION, typeParameters, parametersType, resultType);\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  if (token != JsDocToken.STRING || !stream.getString().equals(\"function\")) {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  next();\n  skipEOLs();\n  Node typeParameters = parseTypeParameters(next());\n  if (typeParameters == null) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.typeparameters\");\n  }\n\n  if (!match(JsDocToken.LP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lparen\");\n  }\n\n  next();\n  skipEOLs();\n  if (!match(JsDocToken.STRING) || !stream.getString().equals(\"this\")) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n  }\n\n  next();\n  skipEOLs();\n  if (!match(JsDocToken.COLON)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n  }\n\n  Node typeName = parseTypeName(next());\n  if (typeName == null) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.typename\");\n  }\n\n  if (!match(JsDocToken.COMMA)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.comma\");\n  }\n\n  Node parametersType = parseParametersType(next());\n  if (parametersType == null) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.parameters\");\n  }\n\n  if (!match(JsDocToken.RP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rparen\");\n  }\n\n  next();\n  skipEOLs();\n  Node resultType = parseResultType(next());\n  if (resultType == null) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.resulttype\");\n  }\n\n  return newNode(Token.FUNCTION, typeParameters, parametersType, resultType);\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  if (token != JsDocToken.STRING || !stream.getString().equals(\"function\")) {\n    return reportGenericTypeSyntaxWarning();\n  }\n  next();\n  Node typeParameters = parseTypeParameters(next());\n  if (typeParameters == null) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.typeparameters\");\n  }\n  skipEOLs();\n  if (match(JsDocToken.LP)) {\n    next();\n    skipEOLs();\n    Node thisType = newNode(Token.THIS);\n    thisType.addChildToFront(parseTypeName(next()));\n    skipEOLs();\n    if (!match(JsDocToken.COMMA)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.comma\");\n    }\n    Node parametersType = parseParametersType(next());\n    if (parametersType == null) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.parameters\");\n    }\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.resulttype\");\n    }\n    return newNode(Token.FUNCTION, typeParameters, thisType, parametersType, resultType);\n  } else {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n}"
    ],
    [
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    return str.replaceAll(\"\\\\s\", \"\");\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    return str.replaceAll(\"\\\\s\", \"\");\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    return str.replaceAll(\"\\\\s\", \"\");\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    return str.replaceAll(\"\\\\s\", \"\");\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    return str.replaceAll(\"\\\\s\", \"\");\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    return str.replaceAll(\"\\\\s\", \"\");\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    return str.replaceAll(\"\\\\s\", \"\");\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    return str.replaceAll(\"\\\\s\", \"\");\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    return str.replaceAll(\"\\\\s+\", \"\");\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    return str.replaceAll(\"\\\\s\", \"\");\n}"
    ],
    [
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    double sum = 0;\n    double sumSquares = 0;\n    double sumLogs = 0;\n    int count = 0;\n\n    for (SummaryStatistics stat : statistics) {\n        sum += stat.getSum();\n        sumSquares += stat.getSumsq();\n        sumLogs += stat.getSumOfLogs();\n        count += stat.getN();\n    }\n\n    double mean = sum / count;\n    double variance = (sumSquares - sum * sum / count) / count;\n    double geometricMean = Math.exp(sumLogs / count);\n    double secondMoment = sumSquares - sum * sum / count;\n\n    return new StatisticalSummaryValues(mean, variance, count, \n            stat.getMin(), stat.getMax(), sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    double sum = 0;\n    double sumOfLogs = 0;\n    double sumSquares = 0;\n    double sumOfSquaresOfLogs = 0;\n    int count = 0;\n\n    for (SummaryStatistics stat : statistics) {\n        sum += stat.getSum();\n        sumOfLogs += stat.getSumOfLogs();\n        sumSquares += stat.getSumsq();\n        sumOfSquaresOfLogs += stat.getSumOfSquaresOfLogs();\n        count += stat.getN();\n    }\n\n    double mean = sum / count;\n    double variance = (sumSquares - (sum * sum) / count) / count;\n    double geometricMean = Math.exp(sumOfLogs / count);\n    double secondMoment = sumOfSquaresOfLogs - (sum * sum) / count;\n\n    return new StatisticalSummaryValues(mean, variance, count, \n            stat.getMax(), stat.getMin(), sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    SummaryStatistics aggregatedStatistics = new AggregatingSummaryStatistics();\n\n    for (SummaryStatistics stat : statistics) {\n        aggregatedStatistics.combine(stat);\n    }\n\n    return new StatisticalSummaryValues(aggregatedStatistics.getMean(),\n            aggregatedStatistics.getVariance(), aggregatedStatistics.getN(),\n            aggregatedStatistics.getMax(), aggregatedStatistics.getMin(),\n            aggregatedStatistics.getSum());\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if(statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    double sum = 0;\n    double sumOfLogs = 0;\n    double sumSquares = 0;\n    double sumOfSquaresOfLogs = 0;\n    int count = 0;\n    double max = Double.NEGATIVE_INFINITY;\n    double min = Double.POSITIVE_INFINITY;\n\n    for (SummaryStatistics stat : statistics) {\n        sum += stat.getMean();\n        sumOfLogs += stat.getSumOfLogs();\n        sumSquares += stat.getSumsq();\n        sumOfSquaresOfLogs += stat.getSecondMoment();\n        count += stat.getN();\n        max = Math.max(max, stat.getMax());\n        min = Math.min(min, stat.getMin());\n    }\n\n    double mean = sum / count;\n    double variance = (sumSquares - count * Math.pow(mean, 2)) / (count - 1);\n    double geometricMean = Math.exp(sumOfLogs / count);\n    return new StatisticalSummaryValues(mean, variance, count, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    SummaryStatistics aggregatedStatistics = new AggregatingSummaryStatistics();\n    for (SummaryStatistics stat : statistics) {\n        aggregatedStatistics.combine(stat);\n    }\n\n    return new StatisticalSummaryValues(aggregatedStatistics.getMean(),\n            aggregatedStatistics.getVariance(), aggregatedStatistics.getN(),\n            aggregatedStatistics.getMax(), aggregatedStatistics.getMin(),\n            aggregatedStatistics.getSum());\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    double sum = 0;\n    double sumOfLogs = 0;\n    double sumSquares = 0;\n    double sumOfSquaresOfLogs = 0;\n    int count = 0;\n\n    for (SummaryStatistics stat : statistics) {\n        sum += stat.getSum();\n        sumOfLogs += stat.getSumOfLogs();\n        sumSquares += stat.getSumsq();\n        sumOfSquaresOfLogs += stat.getSecondMoment();\n        count += stat.getN();\n    }\n\n    double mean = sum / count;\n    double variance = (sumSquares - (sum * sum) / count) / count;\n    double geometricMean = Math.exp(sumOfLogs / count);\n    double secondMoment = sumOfSquaresOfLogs - (sum * sum) / count;\n\n    return new StatisticalSummaryValues(mean, variance, count, getMin(statistics), getMax(statistics), sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    double sum = 0;\n    double sumOfLogs = 0;\n    double sumsq = 0;\n    double secondMoment = 0;\n    double sumOfSquaresOfLogs = 0;\n    int n = 0;\n    double max = Double.NEGATIVE_INFINITY;\n    double min = Double.POSITIVE_INFINITY;\n\n    for (SummaryStatistics stat : statistics) {\n        sum += stat.getMean();\n        sumOfLogs += stat.getSumOfLogs();\n        sumsq += stat.getSumsq();\n        secondMoment += stat.getSecondMoment();\n        sumOfSquaresOfLogs += stat.getSumOfLogs() * stat.getSumOfLogs();\n        n += stat.getN();\n        max = Math.max(max, stat.getMax());\n        min = Math.min(min, stat.getMin());\n    }\n\n    double mean = sum / n;\n    double variance = (sumsq / n) - (mean * mean);\n    double geometricMean = Math.exp(sumOfLogs / n);\n    double sumOfLogs2 = sumOfSquaresOfLogs / n;\n\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    double sum = 0;\n    double sumOfLogs = 0;\n    double sumsq = 0;\n    double sumOfSquaresOfLogs = 0;\n    int n = 0;\n    double max = Double.NEGATIVE_INFINITY;\n    double min = Double.POSITIVE_INFINITY;\n\n    for (SummaryStatistics stat : statistics) {\n        sum += stat.getMean();\n        sumOfLogs += stat.getSumOfLogs();\n        sumsq += stat.getSumsq();\n        sumOfSquaresOfLogs += stat.getSecondMoment();\n        n += stat.getN();\n        max = Math.max(max, stat.getMax());\n        min = Math.min(min, stat.getMin());\n    }\n\n    return new StatisticalSummaryValues(sum / n, (sumOfSquaresOfLogs - sum * sum / n) / (n - 1), n,\n            max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if(statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    SummaryStatistics aggregatedStatistics = new AggregatingSummaryStatistics();\n\n    for(SummaryStatistics stat : statistics) {\n        aggregatedStatistics.merge(stat);\n    }\n\n    return new StatisticalSummaryValues(aggregatedStatistics.getMean(), aggregatedStatistics.getVariance(), aggregatedStatistics.getN(),\n            aggregatedStatistics.getMax(), aggregatedStatistics.getMin(), aggregatedStatistics.getSum());\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if(statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    SummaryStatistics aggregatedStatistics = new AggregatingSummaryStatistics();\n    for (SummaryStatistics stat : statistics) {\n        aggregatedStatistics.combine(stat);\n    }\n    return new StatisticalSummaryValues(aggregatedStatistics.getMean(), aggregatedStatistics.getVariance(), aggregatedStatistics.getN(),\n            aggregatedStatistics.getMax(), aggregatedStatistics.getMin(), aggregatedStatistics.getSum());\n}"
    ],
    [
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length < 2) {\n        throw new NumberIsTooSmallException(\"Array length must be at least 2\");\n    }\n    double sumDiffSq = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sumDiffSq += Math.pow(sample1[i] - sample2[i] - meanDifference, 2);\n    }\n    return sumDiffSq / (sample1.length - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length < 2) {\n        throw new NumberIsTooSmallException(\"sample length\");\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += Math.pow(sample1[i] - sample2[i] - meanDifference, 2);\n    }\n    return sum / (sample1.length - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DATA);\n        }\n        double sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += Math.pow(sample1[i] - sample2[i] - meanDifference, 2);\n        }\n        return sum / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException();\n    }\n    double sumDiffSq = 0;\n    for (int i = 0; i < n; i++) {\n        double diff = sample1[i] - sample2[i] - meanDifference;\n        sumDiffSq += diff * diff;\n    }\n    return sumDiffSq / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(\"Array length is less than 2\");\n        }\n        double sumDiffSquare = 0;\n        for (int i = 0; i < n; i++) {\n            double diff = sample1[i] - sample2[i] - meanDifference;\n            sumDiffSquare += diff * diff;\n        }\n        return sumDiffSquare / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length < 2) {\n        throw new NumberIsTooSmallException();\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += Math.pow(sample1[i] - sample2[i] - meanDifference, 2);\n    }\n    return sum / (sample1.length - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(\"Array length is less than 2\");\n        }\n        double sumDiffSq = 0;\n        for (int i = 0; i < n; i++) {\n            double diff = sample1[i] - sample2[i];\n            sumDiffSq += (diff - meanDifference) * (diff - meanDifference);\n        }\n        return sumDiffSq / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(\"Array length is less than 2\");\n    }\n    double sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum += Math.pow(sample1[i] - sample2[i] - meanDifference, 2);\n    }\n    return sum / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException();\n        }\n        double sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += Math.pow(sample1[i] - sample2[i] - meanDifference, 2);\n        }\n        return sum / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException();\n        }\n        double sumDiffSq = 0;\n        for (int i = 0; i < n; i++) {\n            sumDiffSq += Math.pow(sample1[i] - sample2[i] - meanDifference, 2);\n        }\n        return sumDiffSq / (n - 1);\n    }"
    ],
    [
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0;\n    for (int i = 0; i < dataset.getSeriesCount(); i++) {\n        double value = dataset.getValue(i);\n        if (value != null && value >= 0) {\n            total += value;\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0;\n    for (int i = 0; i < dataset.getSeriesCount(); i++) {\n        double value = dataset.getValue(i);\n        if (value != null && value >= 0) {\n            total += value;\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0;\n    for (int i = 0; i < dataset.getCategoryCount(); i++) {\n        double value = dataset.getValue(i);\n        if (value != null && value >= 0) {\n            total += value;\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0;\n    for (int i = 0; i < dataset.getCategoryCount(); i++) {\n        double value = dataset.getValue(i);\n        if (value != null && value >= 0) {\n            total += value;\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0;\n    for (int i = 0; i < dataset.getSeriesCount(); i++) {\n        double value = dataset.getValue(i);\n        if (value != null && value >= 0) {\n            total += value;\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0;\n    for (int i = 0; i < dataset.getSeriesCount(); i++) {\n        double value = dataset.getValue(i);\n        if (value != null && value >= 0) {\n            total += value;\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0;\n    for (int i = 0; i < dataset.getSeriesCount(); i++) {\n        double value = dataset.getValue(i);\n        if (value != null && value >= 0) {\n            total += value;\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0;\n    for (int i = 0; i < dataset.getSeriesCount(); i++) {\n        double value = dataset.getValue(i);\n        if (value != null && value >= 0) {\n            total += value;\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0;\n    for (int i = 0; i < dataset.getCategoryCount(); i++) {\n        double value = dataset.getValue(i);\n        if (value != null && value >= 0) {\n            total += value;\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0;\n    for (int i = 0; i < dataset.getCategoryCount(); i++) {\n        double value = dataset.getValue(i);\n        if (value != null && value >= 0) {\n            total += value;\n        }\n    }\n    return total;\n}"
    ],
    [
      "public String nextName() throws IOException  {\n    int c;\n    int last = NUMBER_CHAR_NONE;\n    int value = 0;\n    boolean fitsInLong = true;\n    boolean negative = false;\n    int peekedNumberLength = 0;\n    long peekedLong = 0;\n    boolean peeked = false;\n    StringBuilder sb = new StringBuilder();\n\n    while ((c = read()) != -1) {\n        switch (c) {\n            case '{':\n                return sb.toString();\n\n            case '}':\n                return sb.toString();\n\n            case ',':\n                return sb.toString();\n\n            case ':':\n                return sb.toString();\n\n            case ' ':\n            case '\\t':\n            case '\\f':\n            case '\\r':\n            case '\\n':\n                continue;\n\n            case '/':\n            case '\\\\':\n            case ';':\n            case '#':\n            case '=':\n                checkLenient(); // fall-through\n            case '{':\n            case '}':\n            case '[':\n            case ']':\n            case ':':\n            case ',':\n            case ' ':\n            case '\\t':\n            case '\\f':\n            case '\\r':\n            case '\\n':\n                return sb.toString();\n\n            default:\n                if (c < 'a' || c > 'z') {\n                    if (c < '0' || c > '9') {\n                        if (!isLiteral(c)) {\n                            break;\n                        }\n                        return sb.toString();\n                    }\n                    if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n                        value = -(c - '0');\n                        last = NUMBER_CHAR_DIGIT;\n                    } else if (last == NUMBER_CHAR_DIGIT) {\n                        if (value == 0) {\n                            return sb.toString(); // Leading '0' prefix is not allowed (since it could be octal).\n                        }\n                        long newValue = value * 10 - (c - '0');\n                        fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n                            || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n                        value = newValue;\n                    } else if (last == NUMBER_CHAR_DECIMAL) {\n                        last = NUMBER_CHAR_FRACTION_DIGIT;\n                    } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n                        last = NUMBER_CHAR_EXP_DIGIT;\n                    }\n                }\n                sb.appendCodePoint(c);\n                last = NUMBER_CHAR_DIGIT;\n        }\n    }\n    return sb.toString();\n}",
      "public String nextName() throws IOException  {\n    StringBuilder sb = new StringBuilder();\n    int last = NUMBER_CHAR_NONE;\n    int value = 0;\n    boolean fitsInLong = true;\n    boolean negative = false;\n    int peekedNumberLength = 0;\n    long peekedLong = 0;\n    JsonToken peeked = PEEKED_NONE;\n\n    while (true) {\n        int c = read();\n        if (c == -1) {\n            throw new EOFException();\n        }\n        switch (c) {\n            case '{':\n            case '}':\n            case '[':\n            case ']':\n            case ':':\n            case ',':\n            case ' ':\n            case '\\t':\n            case '\\f':\n            case '\\r':\n            case '\\n':\n                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n                    || last == NUMBER_CHAR_EXP_DIGIT) {\n                    break charactersOfNumber;\n                }\n                return sb.toString();\n\n            case '\"':\n                return sb.toString();\n\n            case '/':\n            case '\\\\':\n            case ';':\n            case '#':\n            case '=':\n                checkLenient(); // fall-through\n            default:\n                if (!isLiteral((char) c)) {\n                    break charactersOfNumber;\n                }\n                if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n                    value = -(c - '0');\n                    last = NUMBER_CHAR_DIGIT;\n                } else if (last == NUMBER_CHAR_DIGIT) {\n                    if (value == 0) {\n                        return sb.toString(); // Leading '0' prefix is not allowed (since it could be octal).\n                    }\n                    long newValue = value * 10 - (c - '0');\n                    fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n                        || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n                    value = newValue;\n                } else if (last == NUMBER_CHAR_DECIMAL) {\n                    last = NUMBER_CHAR_FRACTION_DIGIT;\n                } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n                    last = NUMBER_CHAR_EXP_DIGIT;\n                }\n                sb.appendCodePoint(c);\n        }\n    }\n\n    // We've read a complete name. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && (value!=0 || false==negative)) {\n}\n}",
      "public String nextName() throws IOException  {\n    StringBuilder sb = new StringBuilder();\n    int last = NUMBER_CHAR_NONE;\n    boolean fitsInLong = true;\n    long value = 0;\n    int peekedNumberLength = 0;\n    boolean negative = false;\n    long peekedLong = 0;\n    int pos = 0;\n    int i = 0;\n    char c;\n    while ((c = read()) != 0) {\n        if (c == '\"') {\n            return sb.toString();\n        }\n        switch (c) {\n            case '{':\n            case '}':\n            case '[':\n            case ']':\n            case ':':\n            case ',':\n            case ' ':\n            case '\\t':\n            case '\\f':\n            case '\\r':\n            case '\\n':\n                return sb.toString();\n            case '/':\n            case '\\\\':\n            case ';':\n            case '#':\n            case '=':\n                checkLenient(); // fall-through\n            default:\n                if (c < '0' || c > '9') {\n                    if (!isLiteral(c)) {\n                        throw new IOException(\"Expected a property name\");\n                    }\n                    return sb.toString();\n                }\n                if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n                    value = -(c - '0');\n                    last = NUMBER_CHAR_DIGIT;\n                } else if (last == NUMBER_CHAR_DIGIT) {\n                    if (value == 0) {\n                        return sb.toString(); // Leading '0' prefix is not allowed (since it could be octal).\n                    }\n                    long newValue = value * 10 - (c - '0');\n                    fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n                        || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n                    value = newValue;\n                } else if (last == NUMBER_CHAR_DECIMAL) {\n                    last = NUMBER_CHAR_FRACTION_DIGIT;\n                } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n                    last = NUMBER_CHAR_EXP_DIGIT;\n                } else {\n                    sb.append(c);\n                    last = NUMBER_CHAR_DIGIT;\n                }\n                break;\n        }\n        i++;\n    }\n    throw new IOException(\"Expected a property name\");\n}",
      "public String nextName() throws IOException  {\n    StringBuilder sb = new StringBuilder();\n    int last = NUMBER_CHAR_NONE;\n    boolean negative = false;\n    long value = 0;\n    boolean fitsInLong = true;\n    boolean peeked = false;\n    long peekedLong = 0;\n    int peekedNumberLength = 0;\n    int pos = 0;\n    int i = 0;\n\n    while (i < buffer.length) {\n        char c = buffer.charAt(i++);\n        switch (c) {\n            case ' ':\n            case '\\t':\n            case '\\f':\n            case '\\r':\n            case '\\n':\n                if (last == NUMBER_CHAR_NONE) {\n                    return sb.toString();\n                }\n                return null;\n            case '-':\n                if (last == NUMBER_CHAR_NONE) {\n                    negative = true;\n                } else {\n                    return null;\n                }\n                last = NUMBER_CHAR_SIGN;\n                continue;\n            case '+':\n                if (last == NUMBER_CHAR_NONE) {\n                    last = NUMBER_CHAR_SIGN;\n                    continue;\n                }\n                return null;\n            case '.':\n                if (last == NUMBER_CHAR_DIGIT) {\n                    last = NUMBER_CHAR_DECIMAL;\n                    continue;\n                }\n                return null;\n            case 'e':\n            case 'E':\n                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n                    last = NUMBER_CHAR_EXP_E;\n                    continue;\n                }\n                return null;\n            default:\n                if (c < '0' || c > '9') {\n                    if (!isLiteral(c)) {\n                        break;\n                    }\n                    return null;\n                }\n                if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n                    value = -(c - '0');\n                    last = NUMBER_CHAR_DIGIT;\n                } else if (last == NUMBER_CHAR_DIGIT) {\n                    if (value == 0) {\n                        return null; // Leading '0' prefix is not allowed (since it could be octal).\n                    }\n                    long newValue = value * 10 - (c - '0');\n                    fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n                        || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n                    value = newValue;\n                } else if (last == NUMBER_CHAR_DECIMAL) {\n                    last = NUMBER_CHAR_FRACTION_DIGIT;\n                } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n                    last = NUMBER_CHAR_EXP_DIGIT;\n                }\n}\n}\n}",
      "public String nextName() throws IOException  {\n    StringBuilder sb = new StringBuilder();\n    int last = NUMBER_CHAR_NONE;\n    boolean negative = false;\n    long value = 0;\n    boolean fitsInLong = true;\n    boolean peeked = false;\n    long peekedLong = 0;\n    int peekedNumberLength = 0;\n    boolean isLiteral = false;\n    int pos = 0;\n\n    while (true) {\n        char c = readChar();\n        if (c == '/') {\n            isLiteral = true;\n        }\n        switch (c) {\n            case ' ':\n            case '\\t':\n            case '\\f':\n            case '\\r':\n            case '\\n':\n                if (last == NUMBER_CHAR_NONE) {\n                    return sb.toString();\n                }\n                break;\n            case '\"':\n                if (last == NUMBER_CHAR_NONE) {\n                    return sb.toString();\n                }\n                break;\n            case '{':\n            case '}':\n            case '[':\n            case ']':\n            case ':':\n            case ',':\n                if (last == NUMBER_CHAR_NONE) {\n                    return sb.toString();\n                }\n                break;\n            case '=':\n                if (last == NUMBER_CHAR_NONE) {\n                    return sb.toString();\n                }\n                break;\n            case '#':\n                if (last == NUMBER_CHAR_NONE) {\n                    return sb.toString();\n                }\n                break;\n            case ';':\n                if (last == NUMBER_CHAR_NONE) {\n                    return sb.toString();\n                }\n                break;\n            default:\n                if (isLiteral(c)) {\n                    sb.append(c);\n                } else {\n                    if (last == NUMBER_CHAR_NONE) {\n                        sb.append(c);\n                    } else {\n                        return sb.toString();\n                    }\n                }\n        }\n        last = NUMBER_CHAR_DIGIT;\n    }\n}",
      "public String nextName() throws IOException  {\n    StringBuilder name = new StringBuilder();\n    int last = NUMBER_CHAR_NONE;\n    int value = 0;\n    boolean fitsInLong = true;\n    boolean negative = false;\n    boolean peeked = false;\n    long peekedLong = 0;\n    int peekedNumberLength = 0;\n    int pos = 0;\n    int i = 0;\n    char c;\n\n    loop:\n    while ((c = next()) != 0) {\n        switch (c) {\n            case '\"':\n                if (last == NUMBER_CHAR_NONE) {\n                    last = NUMBER_CHAR_QUOTE;\n                    continue;\n                }\n                return name.toString();\n\n            case '\\\\':\n                if (last == NUMBER_CHAR_QUOTE) {\n                    last = NUMBER_CHAR_QUOTE_ESCAPE;\n                    continue;\n                }\n                return name.toString();\n\n            case '/':\n                if (last == NUMBER_CHAR_QUOTE) {\n                    last = NUMBER_CHAR_QUOTE_SLASH;\n                    continue;\n                }\n                return name.toString();\n\n            case 'n':\n                if (last == NUMBER_CHAR_QUOTE_ESCAPE) {\n                    name.append('\\n');\n                    last = NUMBER_CHAR_QUOTE;\n                    continue;\n                }\n                return name.toString();\n\n            case 'r':\n                if (last == NUMBER_CHAR_QUOTE_ESCAPE) {\n                    name.append('\\r');\n                    last = NUMBER_CHAR_QUOTE;\n                    continue;\n                }\n                return name.toString();\n\n            case 't':\n                if (last == NUMBER_CHAR_QUOTE_ESCAPE) {\n                    name.append('\\t');\n                    last = NUMBER_CHAR_QUOTE;\n                    continue;\n                }\n                return name.toString();\n\n            case 'b':\n                if (last == NUMBER_CHAR_QUOTE_ESCAPE) {\n                    name.append('\\b');\n                    last = NUMBER_CHAR_QUOTE;\n                    continue;\n                }\n                return name.toString();\n\n            case 'f':\n                if (last == NUMBER_CHAR_QUOTE_ESCAPE) {\n                    name.append('\\f');\n                    last = NUMBER_CHAR_QUOTE;\n                    continue;\n                }\n                return name.toString();\n\n            case 'u':\n                if (last == NUMBER_CHAR_QUOTE_ESCAPE) {\n                    name.append((char) nextUnicodeChar());\n                    last = NUMBER_CHAR_QUOTE;\n                    continue;\n                }\n                return name.toString();\n\n            default:\n                if (Character.isLetterOrDigit(c)) {\n                    if (last == NUMBER_CHAR_NONE) {\n                        last = NUMBER_CHAR_NAME;\n                        name.append(c);\n                    } else if (last == NUMBER_CHAR_NAME) {\n                        name.append(c);\n                    }\n}\n}\n}\n}",
      "public String nextName() throws IOException  {\n    int c;\n    StringBuilder name = new StringBuilder();\n    int last = NUMBER_CHAR_NONE;\n    boolean negative = false;\n    long value = 0;\n    boolean fitsInLong = true;\n    int peekedNumberLength = 0;\n    long peekedLong = 0;\n    int pos = 0;\n    int i = 0;\n    boolean isLiteral = false;\n    while ((c = read()) != -1) {\n        switch (c) {\n            case ' ':\n            case '\\t':\n            case '\\f':\n            case '\\r':\n            case '\\n':\n                if (name.length() > 0) {\n                    return name.toString();\n                } else {\n                    return null;\n                }\n            case '\"':\n                if (last == NUMBER_CHAR_NONE) {\n                    return name.toString();\n                } else {\n                    return null;\n                }\n            case '{':\n            case '}':\n            case '[':\n            case ']':\n            case ':':\n            case ',':\n            case ';':\n            case '#':\n            case '=':\n                if (isLiteral) {\n                    isLiteral = false;\n                } else {\n                    return name.toString();\n                }\n            default:\n                if (c < 'a' || c > 'z' && c < 'A' || c > 'Z' && c < '0' || c > '9' && c != '_') {\n                    if (!isLiteral) {\n                        return name.toString();\n                    }\n                }\n                if (last == NUMBER_CHAR_NONE) {\n                    if (c == '-') {\n                        negative = true;\n                    } else if (c == '+') {\n                        // Ignore\n                    } else {\n                        name.append((char) c);\n                        last = NUMBER_CHAR_DIGIT;\n                    }\n                } else if (last == NUMBER_CHAR_DIGIT) {\n                    if (c == '.') {\n                        last = NUMBER_CHAR_DECIMAL;\n                    } else if (c == 'e' || c == 'E') {\n                        last = NUMBER_CHAR_EXP_E;\n                    } else {\n                        long newValue = value * 10 + (c - '0');\n                        fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n                            || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n                        value = newValue;\n                    }\n                } else if (last == NUMBER_CHAR_DECIMAL) {\n                    last = NUMBER_CHAR_FRACTION_DIGIT;\n                } else if (last == NUMBER_CHAR_EXP_E) {\n}\n}\n}\n}",
      "public String nextName() throws IOException  {\n    StringBuilder sb = new StringBuilder();\n    int last = NUMBER_CHAR_NONE;\n    int value = 0;\n    boolean fitsInLong = true;\n    boolean negative = false;\n    int peekedNumberLength = 0;\n    long peekedLong = 0;\n    int pos = 0;\n    int i = 0;\n    char c;\n\n    while ((c = reader.next()) != 0) {\n        switch (c) {\n            case '{':\n            case '}':\n            case '[':\n            case ']':\n            case ':':\n            case ',':\n            case ' ':\n            case '\\t':\n            case '\\f':\n            case '\\r':\n            case '\\n':\n                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n                    || last == NUMBER_CHAR_EXP_DIGIT) {\n                    return sb.toString();\n                }\n                return null;\n            case '/':\n            case '\\\\':\n            case ';':\n            case '#':\n            case '=':\n                checkLenient(); // fall-through\n                return null;\n            case 'e':\n            case 'E':\n                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n                    last = NUMBER_CHAR_EXP_E;\n                    continue;\n                }\n                return null;\n            case '.':\n                if (last == NUMBER_CHAR_DIGIT) {\n                    last = NUMBER_CHAR_DECIMAL;\n                    continue;\n                }\n                return null;\n            case '+':\n                if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return null;\n            case '-':\n                negative = true;\n                last = NUMBER_CHAR_SIGN;\n                continue;\n            default:\n                if (c < '0' || c > '9') {\n                    if (!isLiteral(c)) {\n                        break;\n                    }\n                    return null;\n                }\n                if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n                    value = -(c - '0');\n                    last = NUMBER_CHAR_DIGIT;\n                } else if (last == NUMBER_CHAR_DIGIT) {\n                    if (value == 0) {\n                        return null; // Leading '0' prefix is not allowed (since it could be octal).\n                    }\n                    long newValue = value * 10 - (c - '0');\n                    fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n                        || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n                    value = newValue;\n}\n}\n}\n}",
      "public String nextName() throws IOException  {\n    int last = NUMBER_CHAR_NONE;\n    int value = 0;\n    boolean fitsInLong = true;\n    boolean negative = false;\n    int peekedNumberLength = 0;\n    long peekedLong = 0;\n    int pos = 0;\n    int i = 0;\n    StringBuilder sb = new StringBuilder();\n    char c;\n\n    while ((c = next()) != 0) {\n        if (Character.isLetter(c)) {\n            if (last == NUMBER_CHAR_NONE) {\n                last = NUMBER_CHAR_NAME;\n            }\n            sb.append(c);\n        } else if (Character.isDigit(c)) {\n            if (last == NUMBER_CHAR_NONE) {\n                last = NUMBER_CHAR_DIGIT;\n                value = c - '0';\n            } else if (last == NUMBER_CHAR_DIGIT) {\n                if (value == 0) {\n                    return sb.toString();\n                }\n                long newValue = value * 10 - (c - '0');\n                fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n                    || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n                value = newValue;\n            } else if (last == NUMBER_CHAR_DECIMAL) {\n                last = NUMBER_CHAR_FRACTION_DIGIT;\n            } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n                last = NUMBER_CHAR_EXP_DIGIT;\n            }\n        } else if (c == '.') {\n            if (last == NUMBER_CHAR_DIGIT) {\n                last = NUMBER_CHAR_DECIMAL;\n            }\n        } else if (c == '+' || c == '-') {\n            if (last == NUMBER_CHAR_NONE) {\n                negative = c == '-';\n                last = NUMBER_CHAR_SIGN;\n            }\n        } else if (c == 'e' || c == 'E') {\n            if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n                last = NUMBER_CHAR_EXP_E;\n            }\n        } else if (c == '{' || c == '}' || c == '[' || c == ']' || c == ':' || c == ',' || c == ' ' || c == '\\t' || c == '\\f' || c == '\\r' || c == '\\n') {\n            if (last == NUMBER_CHAR_NAME) {\n                return sb.toString();\n            }\n            throw new IOException(\"Expected property name but was \" + c);\n        } else {\n            if (last == NUMBER_CHAR_NAME) {\n}\n}\n}\n}",
      "public String nextName() throws IOException  {\n    int last = NUMBER_CHAR_NONE;\n    StringBuilder value = new StringBuilder();\n    boolean negative = false;\n    boolean fitsInLong = true;\n    long peekedLong = 0;\n    int peekedNumberLength = 0;\n    int pos = 0;\n    int i = 0;\n    int c;\n    while ((c = read()) != -1) {\n        switch (c) {\n            case ' ':\n            case '\\t':\n            case '\\f':\n            case '\\r':\n            case '\\n':\n                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n                        || last == NUMBER_CHAR_EXP_DIGIT) {\n                    return value.toString();\n                }\n                return \"\";\n            case '\"':\n                return value.toString();\n            case '{':\n            case '}':\n            case '[':\n            case ']':\n            case ':':\n            case ',':\n                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n                        || last == NUMBER_CHAR_EXP_DIGIT) {\n                    return value.toString();\n                }\n                return \"\";\n            default:\n                if (c < '0' || c > '9') {\n                    if (!isLiteral(c)) {\n                        throw new IOException(\"Expected property name\");\n                    }\n                    return value.toString();\n                }\n                if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n                    negative = c == '-';\n                    last = NUMBER_CHAR_DIGIT;\n                } else if (last == NUMBER_CHAR_DIGIT) {\n                    if (value.length() == 0) {\n                        return value.toString();\n                    }\n                    long newValue = value.length() * 10 - (c - '0');\n                    fitsInLong &= value.length() > MIN_INCOMPLETE_INTEGER\n                            || (value.length() == MIN_INCOMPLETE_INTEGER && newValue < value.length());\n                    value.append(c);\n                } else if (last == NUMBER_CHAR_DECIMAL) {\n                    last = NUMBER_CHAR_FRACTION_DIGIT;\n                } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n                    last = NUMBER_CHAR_EXP_DIGIT;\n                }\n                break;\n        }\n        i++;\n    }\n    return value.toString();\n}"
    ],
    [
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}"
    ],
    [
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        int read = Math.min(uncompressedBytesRemaining, len);\n        if (read == len) {\n            uncompressedBytesRemaining -= read;\n            in.read(b, off, read);\n        } else {\n            uncompressedBytesRemaining -= read;\n            in.read(b, off, read);\n            return read;\n        }\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        int bytesRead = Math.min(uncompressedBytesRemaining, len);\n        if (bytesRead == 0) {\n            inUncompressedChunk = false;\n            inUncompressedChunkBytes = null;\n        } else {\n            System.arraycopy(inUncompressedChunkBytes, uncompressedBytesRead, b, off, bytesRead);\n            uncompressedBytesRead += bytesRead;\n        }\n        return bytesRead;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    } else {\n        return -1;\n    }\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        int bytesRead = Math.min(uncompressedBytesRemaining, len);\n        if (bytesRead == len) {\n            uncompressedBytesRemaining -= bytesRead;\n            return bytesRead;\n        } else {\n            int read = in.read(b, off, bytesRead);\n            if (read == -1) {\n                endReached = true;\n            }\n            return read;\n        }\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    } else {\n        return -1;\n    }\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        int bytesRemaining = Math.min(uncompressedBytesRemaining, len);\n        int bytesRead = in.read(b, off, bytesRemaining);\n        if (bytesRead == -1) {\n            endReached = true;\n        }\n        uncompressedBytesRemaining -= bytesRead;\n        return bytesRead;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        int read = in.read(b, off, Math.min(len, uncompressedBytesRemaining));\n        uncompressedBytesRemaining -= read;\n        if (uncompressedBytesRemaining == 0) {\n            inUncompressedChunk = false;\n        }\n        return read;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        int bytesRead = Math.min(uncompressedBytesRemaining, len);\n        uncompressedBytesRemaining -= bytesRead;\n        in.read(b, off, bytesRead);\n        if (uncompressedBytesRemaining == 0) {\n            inUncompressedChunk = false;\n        }\n        return bytesRead;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    } else {\n        return -1;\n    }\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        int bytesRead = Math.min(uncompressedBytesRemaining, len);\n        if (bytesRead == len) {\n            uncompressedBytesRemaining = 0;\n        } else {\n            uncompressedBytesRemaining -= bytesRead;\n        }\n        in.read(b, off, bytesRead);\n        return bytesRead;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        int read = Math.min(uncompressedBytesRemaining, len);\n        System.arraycopy(in.readNBytes(read), 0, b, off, read);\n        uncompressedBytesRemaining -= read;\n        return read;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        int bytesRead = Math.min(uncompressedBytesRemaining, len);\n        if (bytesRead == len) {\n            uncompressedBytesRemaining -= bytesRead;\n            return bytesRead;\n        } else {\n            int available = in.available();\n            if (available > 0) {\n                bytesRead += in.read(b, off + bytesRead, available);\n                uncompressedBytesRemaining -= bytesRead;\n                return bytesRead;\n            }\n        }\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        int read = in.read(b, off, len);\n        if (read == -1) {\n            inUncompressedChunk = false;\n        }\n        return read;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}"
    ],
    [
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    if (site instanceof DirectCallSite) {\n        DirectCallSite directCallSite = (DirectCallSite) site;\n        return directCallSite.getArguments().get(argIndex);\n    } else if (site instanceof FuncCallSite) {\n        FuncCallSite funcCallSite = (FuncCallSite) site;\n        return funcCallSite.getArguments().get(argIndex);\n    } else if (site instanceof NewCallSite) {\n        NewCallSite newCallSite = (NewCallSite) site;\n        return newCallSite.getArguments().get(argIndex);\n    } else if (site instanceof DotCallSite) {\n        DotCallSite dotCallSite = (DotCallSite) site;\n        return dotCallSite.getArguments().get(argIndex);\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    if (site instanceof CallSite) {\n        CallSite callSite = (CallSite) site;\n        return callSite.getArgument(argIndex);\n    } else if (site instanceof NewCallSite) {\n        NewCallSite newCallSite = (NewCallSite) site;\n        return newCallSite.getArgument(argIndex);\n    } else if (site instanceof DotCallSite) {\n        DotCallSite dotCallSite = (DotCallSite) site;\n        return dotCallSite.getArgument(argIndex);\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    if (site instanceof CallSite) {\n        CallSite callSite = (CallSite) site;\n        Node[] args = callSite.getArguments();\n        if (argIndex < args.length) {\n            return args[argIndex];\n        }\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    if (site instanceof CallSite) {\n        CallSite callSite = (CallSite) site;\n        return callSite.getArgument(argIndex);\n    } else if (site instanceof NewCallSite) {\n        NewCallSite newCallSite = (NewCallSite) site;\n        return newCallSite.getArgument(argIndex);\n    } else if (site instanceof DotCallSite) {\n        DotCallSite dotCallSite = (DotCallSite) site;\n        return dotCallSite.getArgument(argIndex);\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    if (site instanceof CallSite) {\n        CallSite callSite = (CallSite) site;\n        return callSite.getArgument(argIndex);\n    } else if (site instanceof NewCallSite) {\n        NewCallSite newCallSite = (NewCallSite) site;\n        return newCallSite.getArgument(argIndex);\n    } else if (site instanceof DotCallSite) {\n        DotCallSite dotCallSite = (DotCallSite) site;\n        return dotCallSite.getArgument(argIndex);\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    if (site instanceof DirectCallSite) {\n        DirectCallSite directCallSite = (DirectCallSite) site;\n        return directCallSite.getArguments().get(argIndex);\n    } else if (site instanceof FuncCallSite) {\n        FuncCallSite funcCallSite = (FuncCallSite) site;\n        return funcCallSite.getArguments().get(argIndex);\n    } else if (site instanceof NewCallSite) {\n        NewCallSite newCallSite = (NewCallSite) site;\n        return newCallSite.getArguments().get(argIndex);\n    } else if (site instanceof DotCallSite) {\n        DotCallSite dotCallSite = (DotCallSite) site;\n        return dotCallSite.getArguments().get(argIndex);\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    if (site instanceof CallSite) {\n        CallSite callSite = (CallSite) site;\n        return callSite.getArguments().get(argIndex);\n    } else if (site instanceof NewCallSite) {\n        NewCallSite newCallSite = (NewCallSite) site;\n        return newCallSite.getArguments().get(argIndex);\n    } else if (site instanceof DotCallSite) {\n        DotCallSite dotCallSite = (DotCallSite) site;\n        return dotCallSite.getArguments().get(argIndex);\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    if (site instanceof CallSite) {\n        CallSite callSite = (CallSite) site;\n        Node[] args = callSite.getArguments();\n        if (argIndex < args.length) {\n            return args[argIndex];\n        }\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    if (site instanceof CallSite) {\n        CallSite callSite = (CallSite) site;\n        return callSite.getArgument(argIndex);\n    } else if (site instanceof NewCallSite) {\n        NewCallSite newCallSite = (NewCallSite) site;\n        return newCallSite.getArgument(argIndex);\n    } else if (site instanceof DotCallSite) {\n        DotCallSite dotCallSite = (DotCallSite) site;\n        return dotCallSite.getArgument(argIndex);\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    if (site instanceof DirectCallSite) {\n        DirectCallSite directCallSite = (DirectCallSite) site;\n        return directCallSite.getArgument(argIndex);\n    } else if (site instanceof NewCallSite) {\n        NewCallSite newCallSite = (NewCallSite) site;\n        return newCallSite.getArgument(argIndex);\n    } else if (site instanceof DotCallSite) {\n        DotCallSite dotCallSite = (DotCallSite) site;\n        return dotCallSite.getArgument(argIndex);\n    }\n    return null;\n}"
    ],
    [
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type == null) {\n        return null;\n    }\n    String deprecationReason = type.getAnnotation(\"jsdoc.deprecated\");\n    if (deprecationReason == null) {\n        return \"\";\n    }\n    return deprecationReason;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type == null) {\n        return null;\n    }\n    String deprecationReason = type.getAnnotation(\"jsdoc.deprecated\");\n    if (deprecationReason == null) {\n        return \"\";\n    }\n    return deprecationReason;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type != null) {\n        for (Node annotation : type.getAnnotations()) {\n            if (annotation.isTypeAnnotation() && annotation.getName().equals(\"deprecated\")) {\n                for (Node value : annotation.getValues()) {\n                    if (value.isString()) {\n                        return value.getStringValue();\n                    }\n                }\n            }\n        }\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type != null) {\n        String deprecatedReason = type.getAnnotation(\"jsdoc.deprecated\");\n        if (deprecatedReason != null) {\n            return deprecatedReason;\n        }\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type != null) {\n        return type.getDeprecationInfo();\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type == null) {\n        return null;\n    }\n    if (type.isDeprecated()) {\n        return type.getDeprecationReason();\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type == null) {\n        return null;\n    }\n    String deprecationReason = type.getAnnotation(\"jsdoc.deprecated\");\n    if (deprecationReason == null) {\n        return \"\";\n    }\n    return deprecationReason;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type == null) {\n        return null;\n    }\n    // Check if the type is deprecated\n    if (type.isDeprecated()) {\n        // Get the deprecation reason\n        String reason = type.getDeprecationReason();\n        // Return the reason if it is not empty\n        return reason.isEmpty() ? \"\" : reason;\n    }\n    // If the type is not deprecated, return null\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type != null) {\n        for (Node child = type.getFirstChild(); child != null; child = child.getNext()) {\n            if (child.isComment() && child.getFirstChild().getString().startsWith(\"@deprecated\")) {\n                return child.getFirstChild().getString().substring(10);\n            }\n        }\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type == null) {\n        return null;\n    }\n    return type.getAnnotation(\"jsdoc:deprecation\") != null ?\n        type.getAnnotation(\"jsdoc:deprecation\").getDescription() : \"\";\n}"
    ],
    [
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    String result = null;\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    result = cTimeZoneDisplayCache.get(key);\n    if (result == null) {\n        result = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, result);\n    }\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final String key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String result = cTimeZoneDisplayCache.get(key);\n    if (result == null) {\n        result = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, result);\n    }\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    String result = cTimeZoneDisplayCache.get(new TimeZoneDisplayKey(tz, daylight, style, locale));\n    if (result == null) {\n        result = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(new TimeZoneDisplayKey(tz, daylight, style, locale), result);\n    }\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final String key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String result = cTimeZoneDisplayCache.get(key);\n    if (result == null) {\n        result = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, result);\n    }\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final String key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String result = cTimeZoneDisplayCache.get(key);\n    if (result == null) {\n        result = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, result);\n    }\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String result = cTimeZoneDisplayCache.get(key);\n    if (result == null) {\n        result = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, result);\n    }\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String result = cTimeZoneDisplayCache.get(key);\n    if (result == null) {\n        result = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, result);\n    }\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    String key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String result = cTimeZoneDisplayCache.get(key);\n    if (result == null) {\n        result = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, result);\n    }\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final String key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String result = cTimeZoneDisplayCache.get(key);\n    if (result == null) {\n        result = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, result);\n    }\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final String key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String result = cTimeZoneDisplayCache.get(key);\n    if (result == null) {\n        result = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, result);\n    }\n    return result;\n}"
    ],
    [
      "public int getColumnIndex(Comparable key)  {\n    int columnIndex = this.firstCategoryIndex;\n    for (int i = 0; i < this.maximumCategoryCount; i++) {\n        if (this.underlying.getColumnKey(columnIndex).equals(key)) {\n            return columnIndex;\n        }\n        columnIndex++;\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int columnIndex = this.underlying.getColumnIndex(key);\n    if (columnIndex < this.firstCategoryIndex || columnIndex > this.lastCategoryIndex()) {\n        return -1;\n    }\n    return columnIndex - this.firstCategoryIndex;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int index = this.firstCategoryIndex;\n    for (int i = 0; i < this.maximumCategoryCount; i++) {\n        if (this.underlying.getCategory(index).equals(key)) {\n            return index;\n        }\n        index++;\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int columnIndex = this.firstCategoryIndex;\n    for (int i = 0; i < this.maximumCategoryCount; i++) {\n        if (this.underlying.getColumnKey(columnIndex).equals(key)) {\n            return columnIndex;\n        }\n        columnIndex++;\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int columnIndex = this.firstCategoryIndex;\n    while (columnIndex <= this.lastCategoryIndex()) {\n        if (this.underlying.getCategoryKey(columnIndex).equals(key)) {\n            return columnIndex;\n        }\n        columnIndex++;\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int index = this.firstCategoryIndex;\n    for (int i = 0; i < this.maximumCategoryCount; i++) {\n        if (this.underlying.getColumn(index).getKey().equals(key)) {\n            return index;\n        }\n        index++;\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int columnIndex = this.firstCategoryIndex;\n    while (columnIndex <= this.lastCategoryIndex()) {\n        if (this.underlying.getColumnKey(columnIndex).equals(key)) {\n            return columnIndex;\n        }\n        columnIndex++;\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int columnIndex = this.firstCategoryIndex;\n    while (columnIndex <= this.lastCategoryIndex()) {\n        if (this.underlying.getColumnKey(columnIndex).equals(key)) {\n            return columnIndex;\n        }\n        columnIndex++;\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int columnIndex = this.firstCategoryIndex;\n    for (int i = 0; i < this.maximumCategoryCount; i++) {\n        if (this.underlying.getColumnKey(columnIndex).equals(key)) {\n            return columnIndex;\n        }\n        columnIndex++;\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int columnIndex = this.firstCategoryIndex;\n    for (int i = 0; i < this.maximumCategoryCount; i++) {\n        if (this.underlying.getColumnKey(columnIndex).equals(key)) {\n            return columnIndex;\n        }\n        columnIndex++;\n    }\n    return -1;\n}"
    ],
    [
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point >= lower && point <= upper) {\n        return Location.INSIDE;\n    } else {\n        return Location.BOUNDARY;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (Math.abs(point - lower) < tolerance) {\n        return Location.BOUNDARY;\n    }\n    if (Math.abs(point - upper) < tolerance) {\n        return Location.BOUNDARY;\n    }\n    if (point >= lower && point <= upper) {\n        return Location.INSIDE;\n    }\n    return Location.OUTSIDE;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (Math.abs(point - lower) <= tolerance) {\n        return Location.BOUNDARY;\n    } else if (Math.abs(point - upper) <= tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (Math.abs(point - lower) < tolerance) {\n        return Location.BOUNDARY;\n    } else if (Math.abs(point - upper) < tolerance) {\n        return Location.BOUNDARY;\n    } else if (point >= lower && point <= upper) {\n        return Location.INSIDE;\n    } else {\n        return Location.OUTSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point >= lower - tolerance && point <= upper + tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point >= lower && point <= upper) {\n        return Location.INSIDE;\n    } else {\n        return Location.BOUNDARY;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point >= lower - tolerance && point <= upper + tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point >= lower - tolerance && point <= upper + tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (Math.abs(point - lower) < tolerance) {\n        return Location.BOUNDARY;\n    } else if (Math.abs(point - upper) < tolerance) {\n        return Location.BOUNDARY;\n    } else if (point > lower && point < upper) {\n        return Location.INSIDE;\n    } else {\n        return Location.OUTSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (Math.abs(point - lower) < tolerance) {\n        return Location.BOUNDARY;\n    } else if (Math.abs(point - upper) < tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}"
    ],
    [
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnitSource tickUnitSource = new TickUnitSource();\n    tickUnitSource.add(new TickUnit(new DecimalFormatSymbols(locale), \"log10\", 1));\n    tickUnitSource.add(new TickUnit(new DecimalFormatSymbols(locale), \"log10\", 2));\n    tickUnitSource.add(new TickUnit(new DecimalFormatSymbols(locale), \"log10\", 3));\n    tickUnitSource.add(new TickUnit(new DecimalFormatSymbols(locale), \"log10\", 4));\n    tickUnitSource.add(new TickUnit(new DecimalFormatSymbols(locale), \"log10\", 5));\n    tickUnitSource.add(new TickUnit(new DecimalFormatSymbols(locale), \"log10\", 6));\n    tickUnitSource.add(new TickUnit(new DecimalFormatSymbols(locale), \"log10\", 7));\n    tickUnitSource.add(new TickUnit(new DecimalFormatSymbols(locale), \"log10\", 8));\n    tickUnitSource.add(new TickUnit(new DecimalFormatSymbols(locale), \"log10\", 9));\n    tickUnitSource.add(new TickUnit(new DecimalFormatSymbols(locale), \"log10\", 10));\n    return tickUnitSource;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnitSource tickUnitSource = new TickUnitSource();\n    tickUnitSource.add(new TickUnit(new DecimalFormatSymbols(locale), \"log10\", 1.0));\n    tickUnitSource.add(new TickUnit(new DecimalFormatSymbols(locale), \"log10\", 2.0));\n    tickUnitSource.add(new TickUnit(new DecimalFormatSymbols(locale), \"log10\", 3.0));\n    tickUnitSource.add(new TickUnit(new DecimalFormatSymbols(locale), \"log10\", 4.0));\n    tickUnitSource.add(new TickUnit(new DecimalFormatSymbols(locale), \"log10\", 5.0));\n    tickUnitSource.add(new TickUnit(new DecimalFormatSymbols(locale), \"log10\", 6.0));\n    tickUnitSource.add(new TickUnit(new DecimalFormatSymbols(locale), \"log10\", 7.0));\n    tickUnitSource.add(new TickUnit(new DecimalFormatSymbols(locale), \"log10\", 8.0));\n    tickUnitSource.add(new TickUnit(new DecimalFormatSymbols(locale), \"log10\", 9.0));\n    tickUnitSource.add(new TickUnit(new DecimalFormatSymbols(locale), \"log10\", 10.0));\n    return tickUnitSource;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnitSource tickUnits = new TickUnitSource();\n    tickUnits.add(new LogTickUnit(\"log10\", 1, locale));\n    tickUnits.add(new LogTickUnit(\"log100\", 2, locale));\n    tickUnits.add(new LogTickUnit(\"log1000\", 3, locale));\n    tickUnits.add(new LogTickUnit(\"log10000\", 4, locale));\n    tickUnits.add(new LogTickUnit(\"log100000\", 5, locale));\n    tickUnits.add(new LogTickUnit(\"log1000000\", 6, locale));\n    return tickUnits;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnitSource tickUnits = new TickUnitSource();\n    tickUnits.add(new LogTickUnit(1, \"1\", locale));\n    tickUnits.add(new LogTickUnit(10, \"10\", locale));\n    tickUnits.add(new LogTickUnit(100, \"100\", locale));\n    tickUnits.add(new LogTickUnit(1000, \"1000\", locale));\n    return tickUnits;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnitSource tickUnits = new TickUnitSource();\n    tickUnits.add(new LogTickUnit(1, locale));\n    tickUnits.add(new LogTickUnit(2, locale));\n    tickUnits.add(new LogTickUnit(3, locale));\n    tickUnits.add(new LogTickUnit(4, locale));\n    tickUnits.add(new LogTickUnit(5, locale));\n    tickUnits.add(new LogTickUnit(6, locale));\n    tickUnits.add(new LogTickUnit(7, locale));\n    tickUnits.add(new LogTickUnit(8, locale));\n    tickUnits.add(new LogTickUnit(9, locale));\n    tickUnits.add(new LogTickUnit(10, locale));\n    return tickUnits;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnitSource tickUnitSource = new TickUnitSource();\n    tickUnitSource.add(new LogTickUnit(\"log10\", 1, locale));\n    tickUnitSource.add(new LogTickUnit(\"log100\", 2, locale));\n    tickUnitSource.add(new LogTickUnit(\"log1000\", 3, locale));\n    return tickUnitSource;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnitSource tickUnitSource = new TickUnitSource();\n    tickUnitSource.add(new LogTickUnit(\"log10\", \"log10\", locale));\n    return tickUnitSource;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnitSource tickUnits = new TickUnitSource();\n    tickUnits.add(new LogTickUnit(\"0\", 0, locale));\n    tickUnits.add(new LogTickUnit(\"1\", 1, locale));\n    tickUnits.add(new LogTickUnit(\"10\", 10, locale));\n    tickUnits.add(new LogTickUnit(\"100\", 100, locale));\n    tickUnits.add(new LogTickUnit(\"1000\", 1000, locale));\n    return tickUnits;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnitSource tickUnits = new TickUnitSource();\n    tickUnits.add(new LogTickUnit(\"K\", 3));\n    tickUnits.add(new LogTickUnit(\"M\", 6));\n    tickUnits.add(new LogTickUnit(\"B\", 9));\n    tickUnits.add(new LogTickUnit(\"T\", 12));\n    tickUnits.add(new LogTickUnit(\"P\", 15));\n    tickUnits.add(new LogTickUnit(\"E\", 18));\n    tickUnits.add(new LogTickUnit(\"Z\", 21));\n    tickUnits.add(new LogTickUnit(\"Y\", 24));\n    return tickUnits;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnitSource tickUnits = new TickUnitSource();\n    tickUnits.add(new LogTickUnit(\"K\", 3));\n    tickUnits.add(new LogTickUnit(\"M\", 6));\n    tickUnits.add(new LogTickUnit(\"B\", 9));\n    tickUnits.add(new LogTickUnit(\"T\", 12));\n    tickUnits.add(new LogTickUnit(\"P\", 15));\n    tickUnits.add(new LogTickUnit(\"E\", 18));\n    return tickUnits;\n}"
    ],
    [
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotColumn = -1;\n    double maxNegValue = Double.NEGATIVE_INFINITY;\n    for (int i = 0; i < tableau.getColumnCount(); i++) {\n        double value = tableau.getObjectiveFunctionValue(i);\n        if (value < maxNegValue) {\n            maxNegValue = value;\n            pivotColumn = i;\n        }\n    }\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int maxIndex = 0;\n    double maxValue = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getColumnCount(); i++) {\n        if (tableau.getObjCoeff(i) < 0 && Precision.equals(tableau.getObjCoeff(i), maxValue, maxUlps)) {\n            maxIndex = i;\n            maxValue = tableau.getObjCoeff(i);\n        }\n    }\n    return maxIndex;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int maxIndex = 0;\n    double maxValue = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getColumns(); i++) {\n        double value = tableau.getObjCoeff(i);\n        if (value < 0 && Precision.equals(value, maxValue, maxUlps)) {\n            maxIndex = i;\n            maxValue = value;\n        }\n    }\n    return maxIndex;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int maxNegIndex = -1;\n    double maxNegValue = Double.MAX_VALUE;\n\n    for (int j = 0; j < tableau.getColumnCount(); j++) {\n        if (tableau.getObjectiveFunctionCoefficient(j) < 0) {\n            double value = Math.abs(tableau.getObjectiveFunctionCoefficient(j));\n            if (value < maxNegValue) {\n                maxNegIndex = j;\n                maxNegValue = value;\n            }\n        }\n    }\n    return maxNegIndex;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotColumn = -1;\n    double maxNegValue = Double.POSITIVE_INFINITY;\n    for (int i = 0; i < tableau.getColumns(); i++) {\n        double coefficient = tableau.getObjectiveFunctionCoefficient(i);\n        if (coefficient < 0 && Precision.equals(coefficient, maxNegValue, maxUlps)) {\n            maxNegValue = coefficient;\n            pivotColumn = i;\n        }\n    }\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotColumn = -1;\n    double maxNegValue = Double.POSITIVE_INFINITY;\n\n    for (int i = 0; i < tableau.getColumnCount(); i++) {\n        double value = tableau.getObjectiveFunctionValue(i);\n        if (value < maxNegValue && !tableau.isBasic(i)) {\n            maxNegValue = value;\n            pivotColumn = i;\n        }\n    }\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotColumn = -1;\n    double maxNegCoeff = Double.NEGATIVE_INFINITY;\n    for (int i = 0; i < tableau.getColumnCount(); i++) {\n        double coeff = tableau.getObjectiveFunctionCoeff(i);\n        if (coeff < maxNegCoeff) {\n            maxNegCoeff = coeff;\n            pivotColumn = i;\n        }\n    }\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotColumn = -1;\n    double maxNegCoeff = Double.MAX_VALUE;\n\n    for (int j = 0; j < tableau.getNumColumns(); j++) {\n        if (tableau.getObjCoeff(j) < 0 && Math.abs(tableau.getObjCoeff(j)) < maxNegCoeff) {\n            maxNegCoeff = Math.abs(tableau.getObjCoeff(j));\n            pivotColumn = j;\n        }\n    }\n\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int maxIndex = 0;\n    double maxValue = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getColumnCount(); i++) {\n        if (tableau.getObjectiveFunctionCoefficient(i) < 0 && \n            Math.abs(tableau.getObjectiveFunctionCoefficient(i)) < maxValue) {\n            maxIndex = i;\n            maxValue = Math.abs(tableau.getObjectiveFunctionCoefficient(i));\n        }\n    }\n    return maxIndex;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotColumn = -1;\n    double maxNegCoeff = Double.POSITIVE_INFINITY;\n\n    for (int i = 0; i < tableau.getColumns(); i++) {\n        double coeff = tableau.getObjectiveFunction().getCoefficients()[i];\n        if (coeff < 0 && Precision.equals(coeff, maxNegCoeff, maxUlps)) {\n            pivotColumn = i;\n            maxNegCoeff = coeff;\n        } else if (coeff < 0 && coeff < maxNegCoeff) {\n            pivotColumn = i;\n            maxNegCoeff = coeff;\n        }\n    }\n    return pivotColumn;\n}"
    ]
  ]
}