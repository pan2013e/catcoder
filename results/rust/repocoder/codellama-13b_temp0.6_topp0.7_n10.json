{
  "benchmark": "rusteval_repo",
  "lastest_eval": {
    "compile@1": 0.6366666666666667,
    "pass@1": 0.49444444444444446,
    "compile@3": 0.7336111111111112,
    "pass@3": 0.5947222222222223,
    "compile@5": 0.7638888888888888,
    "pass@5": 0.6304232804232804
  },
  "n": 10,
  "k": [
    1,
    3,
    5
  ],
  "fn_codes": [
    [
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let nblocks = nbits / B::bits() + (nbits % B::bits() > 0) as usize;\n    let mut bit_vec = BitVec {\n        storage: Vec::with_capacity(nblocks),\n        nbits: nbits,\n    };\n    bit_vec.set_all(bit);\n    bit_vec\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut bit_vec = BitVec {\n        storage: Vec::new(),\n        nbits: nbits,\n    };\n    bit_vec.set_all(bit);\n    bit_vec\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let nblocks = nbits / B::bits() + (if nbits % B::bits() != 0 { 1 } else { 0 });\n    let mut bit_vec = BitVec { storage: Vec::with_capacity(nblocks), nbits: nbits };\n    bit_vec.storage.resize(nblocks, B::zero());\n    if bit {\n        for i in 0..nbits {\n            bit_vec.set(i, true);\n        }\n    }\n    bit_vec\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut bit_vec = BitVec {\n        storage: Vec::new(),\n        nbits: nbits,\n    };\n    bit_vec.set_all(bit);\n    bit_vec\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut bit_vec = BitVec::new();\n    bit_vec.reserve(nbits);\n    for _ in 0..nbits {\n        bit_vec.push(bit);\n    }\n    bit_vec\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let nblocks = nbits / B::bits();\n    let mut bit_vec = BitVec {\n        storage: Vec::with_capacity(nblocks),\n        nbits: nbits,\n    };\n    bit_vec.storage.resize(nblocks, B::zero());\n    if bit {\n        bit_vec.storage.iter_mut().for_each(|b| *b = !B::zero());\n    }\n    bit_vec\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut bit_vec = BitVec {\n        storage: Vec::new(),\n        nbits: nbits,\n    };\n    if bit {\n        bit_vec.storage.push(B::ones());\n    }\n    bit_vec\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut bit_vec = BitVec {\n        storage: Vec::with_capacity(nbits / B::bits() + 1),\n        nbits: nbits,\n    };\n    for _ in 0..bit_vec.storage.capacity() {\n        bit_vec.storage.push(B::zero());\n    }\n    if bit {\n        for i in 0..bit_vec.nbits {\n            bit_vec.set(i, true);\n        }\n    }\n    bit_vec\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let nblocks = nbits / B::bits() + (nbits % B::bits() > 0) as usize;\n    let mut storage = Vec::with_capacity(nblocks);\n    for _ in 0..nblocks {\n        storage.push(if bit { B::ones() } else { B::zero() });\n    }\n    Self { storage, nbits }\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut bit_vec = BitVec {\n        storage: Vec::new(),\n        nbits: nbits,\n    };\n    if bit {\n        bit_vec.storage.push(B::all_ones());\n    }\n    bit_vec\n}"
    ],
    [
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bit_vec = BitVec::with_capacity(len);\n    for i in 0..len {\n        bit_vec.push(f(i));\n    }\n    bit_vec\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bit_vec = BitVec::with_capacity(len);\n    for i in 0..len {\n        bit_vec.push(f(i));\n    }\n    bit_vec\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bit_vec = BitVec::with_capacity(len);\n    bit_vec.nbits = len;\n    for i in 0..len {\n        bit_vec.push(f(i));\n    }\n    bit_vec\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bit_vec = BitVec::with_capacity(len);\n    bit_vec.nbits = len;\n    for i in 0..len {\n        bit_vec.push(f(i));\n    }\n    bit_vec\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bit_vec = BitVec::with_capacity(len);\n    bit_vec.nbits = len;\n    for i in 0..len {\n        bit_vec.push(f(i));\n    }\n    bit_vec\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bit_vec = BitVec::with_capacity(len);\n    bit_vec.nbits = len;\n    for i in 0..len {\n        bit_vec.push(f(i));\n    }\n    bit_vec\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bit_vec = BitVec::with_capacity(len);\n    bit_vec.nbits = len;\n    for i in 0..len {\n        bit_vec.push(f(i));\n    }\n    bit_vec\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bit_vec = BitVec::with_capacity(len);\n    bit_vec.nbits = len;\n    for i in 0..len {\n        bit_vec.push(f(i));\n    }\n    bit_vec\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bit_vec = BitVec::with_capacity(len);\n    for i in 0..len {\n        bit_vec.push(f(i));\n    }\n    bit_vec\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bit_vec = BitVec::with_capacity(len);\n    bit_vec.nbits = len;\n    for i in 0..len {\n        bit_vec.push(f(i));\n    }\n    bit_vec\n}"
    ],
    [
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i >= self.nbits {\n        return None;\n    }\n    let w = i / B::bits();\n    let b = i % B::bits();\n    Some((self.storage[w] & (B::one() << b)) != B::zero())\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i >= self.len() {\n        return None;\n    }\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let val = self.storage[w];\n    Some((val >> b) & 1 == 1)\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i >= self.nbits {\n        return None;\n    }\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let flag = B::one() << b;\n    Some(self.storage[w] & flag != B::zero())\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i >= self.len() {\n        return None;\n    }\n    let w = i / B::bits();\n    let b = i % B::bits();\n    Some(self.storage[w].get_bit(b))\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i < self.nbits {\n        Some(self[i])\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i >= self.nbits {\n        None\n    } else {\n        Some(self[i])\n    }\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i < self.nbits {\n        let w = i / B::bits();\n        let b = i % B::bits();\n        Some((self.storage[w] & (B::one() << b)) != B::zero())\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    self.ensure_invariant();\n    if i < self.nbits {\n        let w = i / B::bits();\n        let b = i % B::bits();\n        Some(self.storage[w].get_bit(b))\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i >= self.nbits {\n        return None;\n    }\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let flag = B::one() << b;\n    Some((self.storage[w] & flag) != B::zero())\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    self.ensure_invariant();\n    if i < self.nbits {\n        let w = i / B::bits();\n        let b = i % B::bits();\n        Some((self.storage[w] & (B::one() << b)) != B::zero())\n    } else {\n        None\n    }\n}"
    ],
    [
      "pub fn set (&mut self, i: usize, x: bool) {\n    if i >= self.nbits {\n        panic!(\"index out of bounds\");\n    }\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let flag = B::one() << b;\n    let val = if x { self.storage[w] | flag } else { self.storage[w] & !flag };\n    self.storage[w] = val;\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    self.ensure_invariant();\n    if i >= self.nbits {\n        panic!(\"index out of bounds\");\n    }\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let new_block = if x {\n        self.storage[w] | (B::one() << b)\n    } else {\n        self.storage[w] & !(B::one() << b)\n    };\n    self.storage[w] = new_block;\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    self.ensure_invariant();\n    assert!(i < self.nbits, \"index out of bounds\");\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let flag = B::one() << b;\n    if x {\n        self.storage[w] |= flag;\n    } else {\n        self.storage[w] &= !flag;\n    }\n    self.fix_last_block();\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let flag = B::one() << b;\n    let val = if x { self.storage[w] | flag } else { self.storage[w] & !flag };\n    self.storage[w] = val;\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    self.ensure_invariant();\n    assert!(i < self.nbits, \"index out of bounds\");\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let flag = B::one() << b;\n    if x {\n        self.storage[w] |= flag;\n    } else {\n        self.storage[w] &= !flag;\n    }\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    self.ensure_invariant();\n    if i >= self.nbits {\n        panic!(\"index out of bounds\");\n    }\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let mask = B::one() << b;\n    let val = if x { mask } else { B::zero() };\n    self.storage[w] = self.storage[w] & !mask | val;\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let flag = B::one() << b;\n    if x {\n        self.storage[w] |= flag;\n    } else {\n        self.storage[w] &= !flag;\n    }\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    self.ensure_invariant();\n    assert!(i < self.nbits, \"index out of bounds\");\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let new_block = if x {\n        self.storage[w] | (B::one() << b)\n    } else {\n        self.storage[w] & !(B::one() << b)\n    };\n    self.storage[w] = new_block;\n    if b == 0 {\n        self.fix_last_block();\n    }\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    if i >= self.nbits {\n        panic!(\"index out of bounds\");\n    }\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let mask = B::one() << b;\n    if x {\n        self.storage[w] |= mask;\n    } else {\n        self.storage[w] &= !mask;\n    }\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let mask = B::one() << b;\n    let flag = if x { mask } else { B::zero() };\n    self.storage[w] = self.storage[w].wrapping_add(flag.wrapping_sub(self.storage[w] & mask));\n}"
    ],
    [
      "pub fn negate (&mut self) {\n    self.ensure_invariant();\n    for w in &mut self.storage { *w = !*w; }\n    self.fix_last_block();\n}",
      "pub fn negate (&mut self) {\n    self.ensure_invariant();\n    for w in &mut self.storage { *w = !*w; }\n    self.fix_last_block();\n}",
      "pub fn negate (&mut self) {\n    self.ensure_invariant();\n    for w in &mut self.storage { *w = !*w; }\n    self.fix_last_block();\n}",
      "pub fn negate (&mut self) {\n    self.ensure_invariant();\n    for w in &mut self.storage { *w = !*w; }\n    self.fix_last_block();\n}",
      "pub fn negate (&mut self) {\n    self.ensure_invariant();\n    for w in &mut self.storage { *w = !*w; }\n    self.fix_last_block();\n}",
      "pub fn negate (&mut self) {\n    self.ensure_invariant();\n    for w in &mut self.storage { *w = !*w; }\n    self.fix_last_block();\n}",
      "pub fn negate (&mut self) {\n    self.ensure_invariant();\n    for w in &mut self.storage { *w = !*w; }\n    self.fix_last_block();\n}",
      "pub fn negate (&mut self) {\n    self.ensure_invariant();\n    for w in &mut self.storage { *w = !*w; }\n    self.fix_last_block();\n}",
      "pub fn negate (&mut self) {\n    self.ensure_invariant();\n    for w in &mut self.storage { *w = !*w; }\n    self.fix_last_block();\n}",
      "pub fn negate (&mut self) {\n    self.ensure_invariant();\n    for w in &mut self.storage { *w = !*w; }\n    self.fix_last_block();\n}"
    ],
    [
      "pub fn all (&self) -> bool {\n    self.iter().all(|b| b)\n}",
      "pub fn all (&self) -> bool {\n    self.iter().all(|b| b)\n}",
      "pub fn all (&self) -> bool {\n    self.blocks().all(|w| w == B::all_ones())\n}",
      "pub fn all (&self) -> bool {\n    self.blocks().all(|w| w == B::all())\n}",
      "pub fn all (&self) -> bool {\n    self.iter().all(|b| b)\n}",
      "pub fn all (&self) -> bool {\n    self.iter().all(|b| b)\n}",
      "pub fn all (&self) -> bool {\n    self.iter().all(|b| b)\n}",
      "pub fn all (&self) -> bool {\n    self.iter().all(|b| b)\n}",
      "pub fn all (&self) -> bool {\n    self.iter().all(|x| x)\n}",
      "pub fn all (&self) -> bool {\n    self.blocks().all(|w| w == B::all())\n}"
    ],
    [
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = vec![];\n    let mut accumulator = 0;\n    let mut bits_in_accumulator = 0;\n    for (i, &bit) in self.iter().enumerate() {\n        accumulator |= (bit as u8) << (7 - bits_in_accumulator);\n        bits_in_accumulator += 1;\n        if bits_in_accumulator == 8 {\n            bytes.push(accumulator);\n            accumulator = 0;\n            bits_in_accumulator = 0;\n        }\n    }\n    if bits_in_accumulator > 0 {\n        bytes.push(accumulator);\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::with_capacity(self.nbits / 8);\n    for i in 0..self.storage.len() {\n        let mut accumulator = 0;\n        for j in 0..B::bytes() {\n            accumulator |= (self.storage[i] >> (j * 8)) as u8;\n        }\n        bytes.push(accumulator);\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::with_capacity(self.nbits / u8::bits());\n    let mut i = 0;\n    let mut accumulator = 0;\n    let mut n = 0;\n    for bit in self {\n        accumulator |= (bit as u8) << n;\n        n += 1;\n        if n == u8::bits() {\n            bytes.push(accumulator);\n            accumulator = 0;\n            n = 0;\n        }\n        i += 1;\n    }\n    if n > 0 {\n        bytes.push(accumulator);\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::new();\n    let nbytes = self.nbits / 8;\n    let nbits_in_last_byte = self.nbits % 8;\n    let mut byte: u8 = 0;\n    let mut count: u8 = 0;\n    for i in 0..nbytes {\n        for j in 0..8 {\n            if self[i*8+j] {\n                byte |= 1 << (7-j);\n            }\n        }\n        bytes.push(byte);\n        byte = 0;\n    }\n    if nbits_in_last_byte != 0 {\n        for j in 0..nbits_in_last_byte {\n            if self[nbytes*8+j] {\n                byte |= 1 << (7-j);\n            }\n        }\n        bytes.push(byte);\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::with_capacity(self.nbits / 8);\n    for i in 0..self.nbits / 8 {\n        let mut accumulator = 0;\n        for j in 0..8 {\n            accumulator |= (self[i * 8 + j] as u8) << (7 - j);\n        }\n        bytes.push(accumulator);\n    }\n    if self.nbits % 8 != 0 {\n        let mut last_byte = 0;\n        for i in 0..self.nbits % 8 {\n            last_byte |= (self[self.nbits - i - 1] as u8) << (7 - i);\n        }\n        bytes.push(last_byte);\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::new();\n    let mut byte = 0;\n    let mut bit = 0;\n    for i in 0..self.nbits {\n        if self[i] {\n            byte |= 1 << bit;\n        }\n        bit += 1;\n        if bit == 8 {\n            bytes.push(byte);\n            byte = 0;\n            bit = 0;\n        }\n    }\n    if bit > 0 {\n        bytes.push(byte);\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::with_capacity(self.nbits / 8);\n    let mut byte = 0;\n    let mut bit_count = 0;\n    for &block in &self.storage {\n        for i in 0..B::bits() {\n            if block & (B::one() << i) != B::zero() {\n                byte |= 1 << (7 - bit_count);\n            }\n            bit_count += 1;\n            if bit_count == 8 {\n                bytes.push(byte);\n                byte = 0;\n                bit_count = 0;\n            }\n        }\n    }\n    if bit_count > 0 {\n        bytes.push(byte);\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::with_capacity(self.nbits / 8);\n    for i in 0..self.storage.len() {\n        let mut accumulator = 0;\n        for j in 0..B::bytes() {\n            accumulator |= (self.storage[i] >> (j * 8)) as u8;\n        }\n        bytes.push(accumulator);\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = vec![0; self.nbits / 8];\n    let mut i = 0;\n    for w in &self.storage {\n        for b in 0..B::bits() {\n            if i >= self.nbits {\n                break;\n            }\n            let byte = (w >> (B::bits() - 1 - b)) & 1;\n            bytes[i / 8] |= byte << (i % 8);\n            i += 1;\n        }\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = vec![];\n    let nbytes = self.nbits / 8;\n    for i in 0..nbytes {\n        let mut byte = 0;\n        for j in 0..8 {\n            if self[8*i + j] {\n                byte |= 1 << (7 - j);\n            }\n        }\n        bytes.push(byte);\n    }\n    if self.nbits % 8 != 0 {\n        let mut byte = 0;\n        for i in 0..(self.nbits % 8) {\n            if self[nbytes*8 + i] {\n                byte |= 1 << (7 - i);\n            }\n        }\n        bytes.push(byte);\n    }\n    bytes\n}"
    ],
    [
      "pub fn grow (&mut self, n: usize, value: bool) {\n    self.ensure_invariant();\n    let new_nbits = self.nbits.checked_add(n).expect(\"Capacity overflow\");\n    let new_nblocks = blocks_for_bits::<B>(new_nbits);\n    let new_storage = self.storage.len();\n    if new_nblocks > new_storage {\n        self.storage.reserve(new_nblocks - new_storage);\n        for _ in 0..(new_nblocks - new_storage) {\n            self.storage.push(if value { !B::zero() } else { B::zero() });\n        }\n    }\n    self.nbits = new_nbits;\n    self.fix_last_block();\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    self.ensure_invariant();\n    let new_len = self.len().checked_add(n).expect(\"Capacity overflow\");\n    self.storage.reserve(blocks_for_bits::<B>(new_len) - self.storage.len());\n    let mut i = self.len();\n    while i < new_len {\n        self.push(value);\n        i += 1;\n    }\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    let mut i = 0;\n    let mut new_storage = Vec::new();\n    while i < n {\n        let mut block = B::zero();\n        let mut j = 0;\n        while j < B::bits() && i < n {\n            block = block | ((value as B) << j);\n            i += 1;\n            j += 1;\n        }\n        new_storage.push(block);\n    }\n    self.storage.append(&mut new_storage);\n    self.nbits += n;\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    self.ensure_invariant();\n    let mut n = n;\n    while n > 0 {\n        self.push(value);\n        n -= 1;\n    }\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    self.ensure_invariant();\n    let nblocks = blocks_for_bits::<B>(self.nbits + n);\n    self.storage.reserve(nblocks - self.storage.len());\n    let mut i = self.nbits;\n    self.nbits += n;\n    while i < self.nbits {\n        self.push(value);\n        i += 1;\n    }\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    let nblocks = blocks_for_bits::<B>(n);\n    let nbits = self.nbits + n;\n    let new_len = blocks_for_bits::<B>(nbits);\n    self.storage.reserve(nblocks);\n    if value {\n        self.storage.extend(repeat(B::max_value()).take(nblocks));\n    } else {\n        self.storage.extend(repeat(B::zero()).take(nblocks));\n    }\n    self.nbits = nbits;\n    self.fix_last_block();\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    let nblocks = blocks_for_bits::<B>(self.nbits + n);\n    let mut new_storage = Vec::with_capacity(nblocks);\n    new_storage.extend_from_slice(&self.storage);\n    let mut block = B::zero();\n    let mut block_pos = 0;\n    for _ in 0..n {\n        if block_pos == B::bits() {\n            new_storage.push(block);\n            block = B::zero();\n            block_pos = 0;\n        }\n        block |= (value as B) << block_pos;\n        block_pos += 1;\n    }\n    if block_pos > 0 {\n        new_storage.push(block);\n    }\n    self.storage = new_storage;\n    self.nbits += n;\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    let mut new_len = self.len();\n    new_len = new_len.checked_add(n).expect(\"Capacity overflow\");\n    self.nbits = new_len;\n    if self.nbits % B::bits() == 0 {\n        self.storage.push(B::zero());\n    }\n    let insert_pos = self.nbits;\n    self.nbits = self.nbits.checked_add(1).expect(\"Capacity overflow\");\n    self.set(insert_pos, value);\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    self.ensure_invariant();\n    let new_len = self.nbits.checked_add(n).expect(\"Capacity overflow\");\n    let new_words = blocks_for_bits::<B>(new_len);\n    let old_words = blocks_for_bits::<B>(self.nbits);\n    self.storage.reserve(new_words - old_words);\n    for _ in 0..n {\n        self.push(value);\n    }\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    let new_len = self.len().checked_add(n).expect(\"Capacity overflow\");\n    self.storage.reserve(blocks_for_bits::<B>(new_len));\n    for _ in 0..n {\n        self.push(value);\n    }\n}"
    ],
    [
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.is_empty() {\n        None\n    } else {\n        let result = self.get(self.len() - 1).unwrap();\n        self.set(self.len() - 1, false);\n        self.nbits -= 1;\n        Some(result)\n    }\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.is_empty() {\n        None\n    } else {\n        let bit = self.get(self.len() - 1).unwrap();\n        self.set(self.len() - 1, false);\n        self.nbits -= 1;\n        Some(bit)\n    }\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.len() == 0 {\n        return None;\n    }\n    let last_bit = self.get(self.len() - 1).unwrap();\n    self.set(self.len() - 1, false);\n    self.nbits -= 1;\n    Some(last_bit)\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.is_empty() {\n        None\n    } else {\n        let result = self[self.len() - 1];\n        self.set(self.len() - 1, false);\n        Some(result)\n    }\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.is_empty() {\n        return None;\n    }\n    let bit = self.get(self.len() - 1).unwrap();\n    self.set(self.len() - 1, false);\n    self.nbits -= 1;\n    Some(bit)\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.len() == 0 {\n        return None;\n    }\n    let last = self.len() - 1;\n    let ret = self[last];\n    self.set(last, false);\n    Some(ret)\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.is_empty() {\n        None\n    } else {\n        let bit = self.get(self.len() - 1).unwrap();\n        self.set(self.len() - 1, false);\n        self.nbits -= 1;\n        Some(bit)\n    }\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.is_empty() {\n        None\n    } else {\n        let bit = self.get(self.len() - 1).unwrap();\n        self.set(self.len() - 1, false);\n        self.nbits -= 1;\n        Some(bit)\n    }\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.is_empty() {\n        None\n    } else {\n        let bit = self.get(self.len() - 1).unwrap();\n        self.set(self.len() - 1, false);\n        self.nbits -= 1;\n        Some(bit)\n    }\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.len() == 0 {\n        return None;\n    }\n    let bit = self.get(self.len() - 1).unwrap();\n    self.set(self.len() - 1, false);\n    self.nbits -= 1;\n    Some(bit)\n}"
    ],
    [
      "pub fn push (&mut self, elem: bool) {\n    self.ensure_invariant();\n    let new_nbits = self.nbits.checked_add(1).expect(\"capacity overflow\");\n    let new_nblocks = blocks_for_bits::<B>(new_nbits);\n    if new_nblocks > self.storage.len() {\n        self.storage.push(B::zero());\n    }\n    let w = self.nbits / B::bits();\n    let b = self.nbits % B::bits();\n    if b == 0 {\n        self.storage[w] = if elem { !B::zero() } else { B::zero() };\n    } else {\n        let mask = mask_for_bits::<B>(self.nbits);\n        self.storage[w] = (self.storage[w] & mask) | (if elem { B::one() } else { B::zero() } << b);\n    }\n    self.nbits = new_nbits;\n}",
      "pub fn push (&mut self, elem: bool) {\n    self.nbits += 1;\n    let w = self.nbits / B::bits();\n    let b = self.nbits % B::bits();\n    if b == 0 {\n        self.storage.push(if elem { !B::zero() } else { B::zero() });\n    } else {\n        let last = self.storage.last_mut().unwrap();\n        *last = *last | (if elem { B::one() } else { B::zero() } << b);\n    }\n}",
      "pub fn push (&mut self, elem: bool) {\n    self.ensure_invariant();\n    let w = self.nbits / B::bits();\n    let b = self.nbits % B::bits();\n    if b == 0 {\n        self.storage.push(B::zero());\n    }\n    self.storage[w] = self.storage[w] | (elem as B << b);\n    self.nbits += 1;\n}",
      "pub fn push (&mut self, elem: bool) {\n    self.nbits += 1;\n    let w = self.nbits / B::bits();\n    let b = self.nbits % B::bits();\n    if b == 0 {\n        self.storage.push(B::zero());\n    }\n    let flag = B::one() << b;\n    let val = if elem { self.storage[w] | flag }\n              else { self.storage[w] & !flag };\n    self.storage[w] = val;\n}",
      "pub fn push (&mut self, elem: bool) {\n    self.ensure_invariant();\n    if self.nbits % B::bits() == 0 {\n        self.storage.push(B::zero());\n    }\n    let w = self.nbits / B::bits();\n    let b = self.nbits % B::bits();\n    let flag = B::one() << b;\n    let val = if elem { self.storage[w] | flag }\n              else { self.storage[w] & !flag };\n    self.storage[w] = val;\n    self.nbits += 1;\n}",
      "pub fn push (&mut self, elem: bool) {\n    let w = self.nbits / B::bits();\n    let b = self.nbits % B::bits();\n    if b == 0 {\n        self.storage.push(B::zero());\n    }\n    let flag = B::one() << b;\n    if elem {\n        self.storage[w] = self.storage[w] | flag;\n    } else {\n        self.storage[w] = self.storage[w] & !flag;\n    }\n    self.nbits += 1;\n}",
      "pub fn push (&mut self, elem: bool) {\n    let w = self.nbits / B::bits();\n    let b = self.nbits % B::bits();\n    if b == 0 {\n        self.storage.push(B::zero());\n    }\n    let flag = B::one() << b;\n    let val = if elem { self.storage[w] | flag }\n              else { self.storage[w] & !flag };\n    self.storage[w] = val;\n    self.nbits += 1;\n}",
      "pub fn push (&mut self, elem: bool) {\n    self.nbits += 1;\n    if self.nbits % B::bits() == 0 {\n        self.storage.push(B::zero());\n    }\n    let w = self.nbits / B::bits() - 1;\n    let b = self.nbits % B::bits();\n    let flag = B::one() << b;\n    if elem {\n        self.storage[w] = self.storage[w] | flag;\n    } else {\n        self.storage[w] = self.storage[w] & !flag;\n    }\n}",
      "pub fn push (&mut self, elem: bool) {\n    self.nbits += 1;\n    let w = self.nbits / B::bits();\n    let b = self.nbits % B::bits();\n    if b == 0 {\n        self.storage.push(if elem { !B::zero() } else { B::zero() });\n    } else {\n        let mask = (B::one() << b) - B::one();\n        let last = self.storage[w - 1];\n        self.storage[w - 1] = if elem { last | mask } else { last & !mask };\n    }\n}",
      "pub fn push (&mut self, elem: bool) {\n    let len = self.len();\n    self.nbits = len + 1;\n    if len % B::bits() == 0 {\n        self.storage.push(B::zero());\n    }\n    self.set(len, elem);\n}"
    ],
    [
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let mut polynomial = Self::zero();\n    let mut degree_sampled = PolynomialDegree::Infinity;\n    while degree_sampled < degree {\n        let sample = Self::sample();\n        let degree_sample = sample.degree();\n        if degree_sampled + degree_sample <= degree {\n            polynomial = polynomial + sample;\n            degree_sampled = degree_sampled + degree_sample;\n        }\n    }\n    polynomial\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let mut polynomial = Self::zero();\n    for i in 0..=degree.0 {\n        let coefficient = <Self::Coefficient as Randomizable>::random();\n        polynomial = polynomial.add_term(coefficient, i);\n    }\n    polynomial\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let mut rng = rand::thread_rng();\n    let mut coefficients = vec![];\n    for _ in 0..degree.0 {\n        coefficients.push(Scalar::<E>::sample(&mut rng));\n    }\n    Self {\n        coefficients,\n        degree,\n    }\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let mut rng = rand::thread_rng();\n    let mut coeffs = Vec::with_capacity(degree.to_usize() + 1);\n    for _ in 0..=degree.to_usize() {\n        coeffs.push(rng.gen());\n    }\n    Self { coeffs }\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n        let degree = degree.into();\n        let coefficients = match degree {\n            PolynomialDegree::Infinity => vec![],\n            PolynomialDegree::Degree(degree) => {\n                let mut rng = rand::thread_rng();\n                let mut coefficients = vec![];\n                for _ in 0..degree {\n                    coefficients.push(rng.gen());\n                }\n                coefficients\n            }\n        };\n        Self { coefficients }\n    }\n}\n",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let mut coefficients = vec![];\n    for _ in 0..degree.0 {\n        coefficients.push(Self::Scalar::random());\n    }\n    Self::from_coefficients(coefficients)\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let mut coefficients = vec![];\n    for _ in 0..=degree.0 {\n        coefficients.push(Scalar::random(&Secp256k1::new()));\n    }\n    Self {\n        coefficients,\n        degree,\n    }\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n        let degree = degree.into();\n        let mut rng = rand::thread_rng();\n        let mut coefficients = vec![];\n        for _ in 0..degree.as_usize() {\n            coefficients.push(Scalar::random(&mut rng));\n        }\n        Self::from_coefficients(coefficients)\n    }\n}\n\nimpl<E: Curve> From<&[Scalar<E>]> for Polynomial<E> {\n    fn from(coefficients: &[Scalar<E>]) -> Self {\n        Self::from_coefficients(coefficients.to_vec())\n    }\n}\n\nimpl<E: Curve> From<Vec<Scalar<E>>> for Polynomial<E> {\n    fn from(coefficients: Vec<Scalar<E>>) -> Self {\n        Self::from_coefficients(coefficients)\n    }\n}\n\nimpl<E: Curve> From<&[Point<E>]> for Polynomial<E> {\n    fn from(points: &[Point<E>]) -> Self {\n        Self::from_points(points)\n    }\n}\n\nimpl<E: Curve> From<Vec<Point<E>>> for Polynomial<E> {\n    fn from(points: Vec<Point<E>>) -> Self {\n        Self::from_points(points)\n    }\n}\n\nimpl<E: Curve> From<&[Scalar<E>]> for PolynomialDegree {\n    fn from(coefficients: &[Scalar<E>]) -> Self {\n        Self::from_coefficients(coefficients)\n    }\n}\n\nimpl<E: Curve> From<&[Point<E>]> for PolynomialDegree {\n    fn from(points: &[Point<E>]) -> Self {\n        Self::from_points(points)\n    }\n}\n\nimpl<E: Curve> From<&Polynomial<E>> for PolynomialDegree {\n    fn from(polynomial: &Polynomial<E>) -> Self {\n        polynomial.degree()\n    }",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n        let degree = degree.into();\n        let mut rng = rand::thread_rng();\n        let coefficients = (0..=degree)\n            .map(|_| <Curve as CurvePointProjective>::ScalarField::rand(&mut rng))\n            .collect::<Vec<_>>();\n        Self { coefficients, degree }\n    }\n}\n",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n        let degree = degree.into();\n        let mut coefficients = Vec::with_capacity(degree.as_usize());\n        for _ in 0..degree.as_usize() {\n            coefficients.push(Self::Scalar::random());\n        }\n        Self {\n            coefficients,\n            degree,\n        }\n    }"
    ],
    [
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = vec![];\n    coefficients.push(const_term);\n    for i in 1..=n {\n        coefficients.push(Scalar::<E>::random());\n    }\n    Self::from_coefficients(coefficients)\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = Vec::with_capacity(n as usize);\n    coefficients.push(const_term);\n    for i in 1..=n {\n        coefficients.push(Scalar::<E>::random());\n    }\n    Self::from_coefficients(coefficients)\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n        let mut coefficients = Vec::with_capacity(n as usize + 1);\n        coefficients.push(const_term);\n        for i in 1..=n {\n            coefficients.push(Scalar::<E>::random());\n        }\n        Self::from_coefficients(coefficients)\n    }",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n        let mut coefficients = Vec::with_capacity(n as usize + 1);\n        coefficients.push(const_term);\n        for i in 1..(n as usize + 1) {\n            coefficients.push(Scalar::<E>::random());\n        }\n        Self::from_coefficients(coefficients)\n    }",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = Vec::new();\n    coefficients.push(const_term);\n    for i in 1..n+1 {\n        coefficients.push(Scalar::<E>::random());\n    }\n    Self { coefficients }\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = Vec::with_capacity(n as usize);\n    coefficients.push(const_term);\n    for i in 1..=n {\n        coefficients.push(Scalar::<E>::random());\n    }\n    Self::from_coefficients(coefficients)\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n        let mut coefficients = vec![Scalar::zero(); n as usize];\n        coefficients[0] = const_term;\n        Self::from_coefficients(coefficients)\n    }",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = vec![Scalar::zero(); n as usize];\n    coefficients[0] = const_term;\n    Self::from_coefficients(coefficients)\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = Vec::with_capacity(n as usize);\n    coefficients.push(const_term);\n    for _ in 1..n {\n        coefficients.push(Scalar::<E>::random());\n    }\n    Self { coefficients }\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = vec![const_term];\n    for i in 1..n+1 {\n        coefficients.push(Scalar::<E>::random());\n    }\n    Self::from_coefficients(coefficients)\n}"
    ],
    [
      "pub fn degree (&self) -> PolynomialDegree {\n    PolynomialDegree::Finite(self.coefficients.len() - 1)\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    match self.coefficients.last() {\n        Some(coefficient) => {\n            if coefficient.is_zero() {\n                PolynomialDegree::Infinity\n            } else {\n                self.coefficients.len().into()\n            }\n        }\n        None => PolynomialDegree::Infinity,\n    }\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    match self.coefficients.last() {\n        Some(last) => {\n            if last.is_zero() {\n                PolynomialDegree::Infinity\n            } else {\n                self.coefficients.len() - 1\n            }\n        }\n        None => PolynomialDegree::Infinity,\n    }\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    match self.coefficients.last() {\n        Some(coefficient) => {\n            if coefficient.is_zero() {\n                PolynomialDegree::Infinity\n            } else {\n                self.coefficients.len() - 1\n            }\n        }\n        None => PolynomialDegree::Infinity,\n    }\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    self.coefficients.iter().rposition(|&x| x != Scalar::zero()).map_or(PolynomialDegree::Infinity, |i| (i as u32).into())\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    PolynomialDegree::Finite(self.coefficients.len() - 1)\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    self.coefficients.iter().rposition(|x| x != &Scalar::zero()).map_or(PolynomialDegree::Infinity, |i| i.into())\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    match self.coefficients.len() {\n        0 => PolynomialDegree::Infinity,\n        n => (n - 1).into(),\n    }\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    PolynomialDegree::from(self.coefficients.len() - 1)\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    self.coefficients.iter().rposition(|x| !x.is_zero()).map_or(PolynomialDegree::Infinity, |i| i.into())\n}"
    ],
    [
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = Scalar::zero();\n    for (i, c) in self.coefficients().iter().enumerate() {\n        let mut term = c.clone();\n        for j in 0..i {\n            term *= point_x.clone();\n        }\n        result += term;\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = self.coefficients[0].clone();\n    for i in 1..self.coefficients.len() {\n        result = result + &self.coefficients[i] * &point_x.pow(i as u32);\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = self.coefficients[0].clone();\n    let mut point_x_squared = point_x.clone();\n    point_x_squared.mul_assign(&point_x);\n    for i in 1..self.coefficients.len() {\n        let mut term = self.coefficients[i].clone();\n        term.mul_assign(&point_x_squared);\n        result.add_assign(&term);\n        point_x_squared.mul_assign(&point_x);\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = self.coefficients[0].clone();\n    for i in 1..self.coefficients.len() {\n        result += &self.coefficients[i] * point_x;\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = self.coefficients[0].clone();\n    for i in 1..self.coefficients.len() {\n        result += &self.coefficients[i] * &point_x.pow(i as u32);\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = Scalar::zero();\n    for (i, c) in self.coefficients().iter().enumerate() {\n        result += c * point_x.pow(i as u32);\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = self.coefficients[0].clone();\n    let mut point_x_squared = point_x.clone();\n    point_x_squared.mul_assign(&point_x);\n    for i in 1..self.coefficients.len() {\n        let mut tmp = self.coefficients[i].clone();\n        tmp.mul_assign(&point_x_squared);\n        result.add_assign(&tmp);\n        point_x_squared.mul_assign(&point_x);\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = self.coefficients[0].clone();\n    let mut point_x_pow = point_x.clone();\n    for i in 1..self.coefficients.len() {\n        result += &self.coefficients[i] * &point_x_pow;\n        point_x_pow *= point_x;\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = Scalar::zero();\n    for (i, coefficient) in self.coefficients().iter().enumerate() {\n        let mut tmp = Scalar::zero();\n        for j in 0..i {\n            tmp += &self.coefficients()[i-j-1] * &point_x.pow(j as u32);\n        }\n        result += &coefficient * &tmp;\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = Scalar::<E>::zero();\n    for (i, coeff) in self.coefficients().iter().enumerate() {\n        let mut term = coeff.clone();\n        for j in 0..i {\n            term *= point_x.clone();\n        }\n        result += term;\n    }\n    result\n}"
    ],
    [
      "pub fn back (&self) -> Option<&T> {\n    let index = self.tail?.get();\n    match &self.entries[index] {\n        Entry::Occupied(entry) => Some(&entry.value),\n        _ => None,\n    }\n}",
      "pub fn back (&self) -> Option<&T> {\n    let index = self.tail?.get();\n    match &self.entries[index] {\n        Entry::Occupied(entry) => Some(&entry.value),\n        _ => None,\n    }\n}",
      "pub fn back (&self) -> Option<&T> {\n    let index = self.tail?.get();\n    match &self.entries[index] {\n        Entry::Occupied(entry) => Some(&entry.value),\n        _ => None,\n    }\n}",
      "pub fn back (&self) -> Option<&T> {\n    let index = self.tail?.get();\n    match &self.entries[index] {\n        Entry::Occupied(entry) => Some(&entry.value),\n        _ => None,\n    }\n}",
      "pub fn back (&self) -> Option<&T> {\n    let index = self.tail?.get();\n\n    match &self.entries[index] {\n      Entry::Occupied(entry) => Some(&entry.value),\n      _ => None,\n    }\n}",
      "pub fn back (&self) -> Option<&T> {\n    let index = self.tail?.get();\n\n    match &self.entries[index] {\n      Entry::Occupied(entry) => Some(&entry.value),\n      _ => None,\n    }\n  }",
      "pub fn back (&self) -> Option<&T> {\n    let index = self.tail?.get();\n\n    match &self.entries[index] {\n        Entry::Occupied(entry) => Some(&entry.value),\n        _ => None,\n    }\n}",
      "pub fn back (&self) -> Option<&T> {\n    let index = self.tail?.get();\n    match &self.entries[index] {\n        Entry::Occupied(entry) => Some(&entry.value),\n        _ => None,\n    }\n}",
      "pub fn back (&self) -> Option<&T> {\n    let index = self.tail?.get();\n\n    match &self.entries[index] {\n        Entry::Occupied(entry) => Some(&entry.value),\n        _ => None,\n    }\n}",
      "pub fn back (&self) -> Option<&T> {\n    let index = self.tail?.get();\n    match &self.entries[index] {\n        Entry::Occupied(entry) => Some(&entry.value),\n        _ => None,\n    }\n}"
    ],
    [
      "pub fn back_index (&self) -> Option<Index<T>> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    Some(index)\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    Some(index)\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    Some(index)\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    Some(index)\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    Some(index)\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    Some(index)\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    Some(index)\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    Some(index)\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    Some(index)\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    Some(index)\n}"
    ],
    [
      "pub fn clear (&mut self) {\n  self.entries.clear();\n  self.generation = 0;\n  self.head = None;\n  self.length = 0;\n  self.tail = None;\n  self.vacant_head = None;\n}",
      "pub fn clear (&mut self) {\n    self.entries.clear();\n    self.head = None;\n    self.tail = None;\n    self.vacant_head = None;\n    self.generation = 0;\n    self.length = 0;\n}",
      "pub fn clear (&mut self) {\n  self.entries.clear();\n  self.generation = 0;\n  self.head = None;\n  self.length = 0;\n  self.tail = None;\n  self.vacant_head = None;\n}",
      "pub fn clear (&mut self) {\n  self.entries.clear();\n  self.generation = 0;\n  self.head = None;\n  self.length = 0;\n  self.tail = None;\n  self.vacant_head = None;\n}",
      "pub fn clear (&mut self) {\n  self.entries.clear();\n  self.generation = 0;\n  self.head = None;\n  self.length = 0;\n  self.tail = None;\n  self.vacant_head = None;\n}",
      "pub fn clear (&mut self) {\n    self.entries.clear();\n    self.head = None;\n    self.tail = None;\n    self.vacant_head = None;\n    self.generation = 0;\n    self.length = 0;\n}",
      "pub fn clear (&mut self) {\n  self.entries.clear();\n  self.generation = 0;\n  self.head = None;\n  self.length = 0;\n  self.tail = None;\n  self.vacant_head = None;\n}",
      "pub fn clear (&mut self) {\n    self.entries.clear();\n    self.generation = 0;\n    self.head = None;\n    self.length = 0;\n    self.tail = None;\n    self.vacant_head = None;\n}",
      "pub fn clear (&mut self) {\n    self.entries.clear();\n    self.generation = 0;\n    self.head = None;\n    self.length = 0;\n    self.tail = None;\n    self.vacant_head = None;\n}",
      "pub fn clear (&mut self) {\n  self.entries.clear();\n  self.generation = 0;\n  self.head = None;\n  self.length = 0;\n  self.tail = None;\n  self.vacant_head = None;\n}"
    ],
    [
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?;\n    match &mut self.entries[index.get()] {\n        Entry::Occupied(entry) => Some(&mut entry.value),\n        _ => None,\n    }\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?.get();\n    match &mut self.entries[index] {\n        Entry::Occupied(entry) => Some(&mut entry.value),\n        _ => None,\n    }\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?;\n    match &mut self.entries[index.get()] {\n        Entry::Occupied(entry) => Some(&mut entry.value),\n        _ => None,\n    }\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?.get();\n    match &mut self.entries[index] {\n        Entry::Occupied(entry) => Some(&mut entry.value),\n        _ => None,\n    }\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?;\n    match &mut self.entries[index.get()] {\n        Entry::Occupied(entry) => Some(&mut entry.value),\n        _ => None,\n    }\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?.get();\n    match &mut self.entries[index] {\n        Entry::Occupied(entry) => Some(&mut entry.value),\n        _ => None,\n    }\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?;\n    match &mut self.entries[index.get()] {\n        Entry::Occupied(entry) => Some(&mut entry.value),\n        _ => None,\n    }\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?;\n    let entry = self.entries[index.get()].occupied_mut();\n    Some(&mut entry.value)\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?;\n    match &mut self.entries[index.get()] {\n        Entry::Occupied(entry) => Some(&mut entry.value),\n        _ => None,\n    }\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?;\n    let entry = self.entries[index.get()].occupied_mut();\n    Some(&mut entry.value)\n}"
    ],
    [
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let entry = self.entries[index.index()].occupied_ref();\n    if entry.generation == index.generation {\n        Some(&entry.value)\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let entry = self.entries[index.index()].occupied_ref();\n    if entry.generation == index.generation {\n        Some(&entry.value)\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let entry = self.entries[index.index()].occupied_ref();\n    if entry.generation == index.generation {\n        Some(&entry.value)\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let entry = match &self.entries[index.index()] {\n        Entry::Occupied(entry) if entry.generation == index.generation => entry,\n        _ => return None,\n    };\n    Some(&entry.value)\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let index = match &self.entries[index.index()] {\n      Entry::Occupied(entry) if entry.generation == index.generation => Some(index.index),\n      _ => None,\n    };\n    index.map(|index| &self.entries[index].occupied_ref().value)\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let entry = self.entries[index.index()].occupied_ref();\n    if entry.generation == index.generation {\n        Some(&entry.value)\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let entry = self.entries[index.index()].occupied_ref();\n    if entry.generation == index.generation {\n        Some(&entry.value)\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let entry = self.entries[index.index()].occupied_ref();\n    if entry.generation == index.generation {\n        Some(&entry.value)\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let entry = match &self.entries[index.index()] {\n        Entry::Occupied(entry) if entry.generation == index.generation => entry,\n        _ => return None,\n    };\n    Some(&entry.value)\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let entry = self.entries[index.index()].occupied_ref();\n    if entry.generation == index.generation {\n        Some(&entry.value)\n    } else {\n        None\n    }\n}"
    ],
    [
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    match self.entries.get(index.index())? {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            let next_index = entry.next?;\n            let next_entry = self.entries[next_index.get()].occupied_ref();\n            Some(Index::new(next_index, next_entry.generation))\n        }\n        _ => None,\n    }\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    match self.entries.get(index.index())? {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            let next_index = entry.next?;\n            let next_entry = self.entries[next_index.get()].occupied_ref();\n            Some(Index::new(next_index, next_entry.generation))\n        }\n        _ => None,\n    }\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    match self.entries.get(index.index())? {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            let next_index = entry.next?;\n            let next_entry = self.entries[next_index.get()].occupied_ref();\n            Some(Index::new(next_index, next_entry.generation))\n        }\n        _ => None,\n    }\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    match self.entries.get(index.index())? {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            let next_index = entry.next?;\n            let next_entry = self.entries[next_index.get()].occupied_ref();\n            Some(Index::new(next_index, next_entry.generation))\n        }\n        _ => None,\n    }\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    match self.entries.get(index.index())? {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            let next_index = entry.next?;\n            let next_entry = self.entries[next_index.get()].occupied_ref();\n            Some(Index::new(next_index, next_entry.generation))\n        }\n        _ => None,\n    }\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    match self.entries.get(index.index())? {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            let next_index = entry.next?;\n            let next_entry = self.entries[next_index.get()].occupied_ref();\n            Some(Index::new(next_index, next_entry.generation))\n        }\n        _ => None,\n    }\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    match self.entries.get(index.index())? {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            let next_index = entry.next?;\n            let next_entry = self.entries[next_index.get()].occupied_ref();\n            Some(Index::new(next_index, next_entry.generation))\n        }\n        _ => None,\n    }\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    match self.entries.get(index.index())? {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            let next_index = entry.next?;\n            let next_entry = self.entries[next_index.get()].occupied_ref();\n            Some(Index::new(next_index, next_entry.generation))\n        }\n        _ => None,\n    }\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    match self.entries.get(index.index())? {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            let next_index = entry.next?;\n            let next_entry = self.entries[next_index.get()].occupied_ref();\n            Some(Index::new(next_index, next_entry.generation))\n        }\n        _ => None,\n    }\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    match self.entries.get(index.index())? {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            let next_index = entry.next?;\n            let next_entry = self.entries[next_index.get()].occupied_ref();\n            Some(Index::new(next_index, next_entry.generation))\n        }\n        _ => None,\n    }\n}"
    ],
    [
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    let (previous_index, next_index) = match &self.entries[index.index()] {\n      Entry::Occupied(entry) if entry.generation == index.generation => {\n        (entry.previous, entry.next)\n      }\n      _ => panic!(\"expected occupied entry with correct generation at `index`\"),\n    };\n    let target_next_index = match &self.entries[target.index()] {\n      Entry::Occupied(entry) if entry.generation == target.generation => entry.next,\n      _ => panic!(\"expected occupied entry with correct generation at `target`\"),\n    };\n    if target.index == index.index {\n      panic!(\"cannot move after `index` itself\");\n    }\n    if previous_index == Some(target.index) {\n      // Already in the right place\n      return;\n    }\n    self.update_link(previous_index, next_index);\n    self.update_link(Some(index.index), Some(target.index));\n    self.update_link(target_next_index, Some(index.index));\n  }",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    let (previous_index, next_index) = match &self.entries[index.index()] {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            (entry.previous, entry.next)\n        }\n        _ => panic!(\"expected occupied entry with correct generation at `index`\"),\n    };\n    let target_next_index = match &self.entries[target.index()] {\n        Entry::Occupied(entry) if entry.generation == target.generation => entry.next,\n        _ => panic!(\"expected occupied entry with correct generation at `target`\"),\n    };\n    if target.index == index.index {\n        panic!(\"cannot move after `index` itself\");\n    }\n    if previous_index == Some(target.index) {\n        // Already in the right place\n        return;\n    }\n    self.update_link(previous_index, next_index);\n    self.update_link(Some(index.index), Some(target.index));\n    self.update_link(target_next_index, Some(index.index));\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    let (previous_index, next_index) = match &self.entries[index.index()] {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            (entry.previous, entry.next)\n        }\n        _ => panic!(\"expected occupied entry with correct generation at `index`\"),\n    };\n    let target_next_index = match &self.entries[target.index()] {\n        Entry::Occupied(entry) if entry.generation == target.generation => entry.next,\n        _ => panic!(\"expected occupied entry with correct generation at `target`\"),\n    };\n    if target.index == index.index {\n        panic!(\"cannot move after `index` itself\");\n    }\n    if previous_index == Some(target.index) {\n        // Already in the right place\n        return;\n    }\n    self.update_link(previous_index, next_index);\n    self.update_link(Some(index.index), Some(target.index));\n    self.update_link(target_next_index, Some(index.index));\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    let (previous_index, next_index) = match &self.entries[index.index()] {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            (entry.previous, entry.next)\n        }\n        _ => panic!(\"expected occupied entry with correct generation at `index`\"),\n    };\n    let target_next_index = match &self.entries[target.index()] {\n        Entry::Occupied(entry) if entry.generation == target.generation => entry.next,\n        _ => panic!(\"expected occupied entry with correct generation at `target`\"),\n    };\n    if target.index == index.index {\n        panic!(\"cannot move after `index` itself\");\n    }\n    if previous_index == Some(target.index) {\n        // Already in the right place\n        return;\n    }\n    self.update_link(previous_index, next_index);\n    self.update_link(Some(index.index), Some(target.index));\n    self.update_link(target_next_index, Some(index.index));\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    let (previous_index, next_index) = match &self.entries[index.index()] {\n      Entry::Occupied(entry) if entry.generation == index.generation => {\n        (entry.previous, entry.next)\n      }\n      _ => panic!(\"expected occupied entry with correct generation at `index`\"),\n    };\n    let target_next_index = match &self.entries[target.index()] {\n      Entry::Occupied(entry) if entry.generation == target.generation => entry.next,\n      _ => panic!(\"expected occupied entry with correct generation at `target`\"),\n    };\n    if target.index == index.index {\n      panic!(\"cannot move after `index` itself\");\n    }\n    if previous_index == Some(target.index) {\n      // Already in the right place\n      return;\n    }\n    self.update_link(previous_index, next_index);\n    self.update_link(Some(index.index), Some(target.index));\n    self.update_link(target_next_index, Some(index.index));\n  }",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    let (previous_index, next_index) = match &self.entries[index.index()] {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            (entry.previous, entry.next)\n        }\n        _ => panic!(\"expected occupied entry with correct generation at `index`\"),\n    };\n    let target_next_index = match &self.entries[target.index()] {\n        Entry::Occupied(entry) if entry.generation == target.generation => entry.next,\n        _ => panic!(\"expected occupied entry with correct generation at `target`\"),\n    };\n    if target.index == index.index {\n        panic!(\"cannot move after `index` itself\");\n    }\n    if previous_index == Some(target.index) {\n        // Already in the right place\n        return;\n    }\n    self.update_link(previous_index, next_index);\n    self.update_link(Some(index.index), Some(target.index));\n    self.update_link(target_next_index, Some(index.index));\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    let (previous_index, next_index) = match &self.entries[index.index()] {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            (entry.previous, entry.next)\n        }\n        _ => panic!(\"expected occupied entry with correct generation at `index`\"),\n    };\n    let target_next_index = match &self.entries[target.index()] {\n        Entry::Occupied(entry) if entry.generation == target.generation => entry.next,\n        _ => panic!(\"expected occupied entry with correct generation at `target`\"),\n    };\n    if target.index == index.index {\n        panic!(\"cannot move after `index` itself\");\n    }\n    if previous_index == Some(target.index) {\n        // Already in the right place\n        return;\n    }\n    self.update_link(previous_index, next_index);\n    self.update_link(Some(index.index), Some(target.index));\n    self.update_link(target_next_index, Some(index.index));\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    let (previous_index, next_index) = match &self.entries[index.index()] {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            (entry.previous, entry.next)\n        }\n        _ => panic!(\"expected occupied entry with correct generation at `index`\"),\n    };\n    let target_next_index = match &self.entries[target.index()] {\n        Entry::Occupied(entry) if entry.generation == target.generation => entry.next,\n        _ => panic!(\"expected occupied entry with correct generation at `target`\"),\n    };\n    if target.index == index.index {\n        panic!(\"cannot move after `index` itself\");\n    }\n    if previous_index == Some(target.index) {\n        // Already in the right place\n        return;\n    }\n    self.update_link(previous_index, next_index);\n    self.update_link(Some(index.index), target_next_index);\n    self.update_link(target.next, Some(index.index));\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    let (previous_index, next_index) = match &self.entries[index.index()] {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            (entry.previous, entry.next)\n        }\n        _ => panic!(\"expected occupied entry with correct generation at `index`\"),\n    };\n    let target_next_index = match &self.entries[target.index()] {\n        Entry::Occupied(entry) if entry.generation == target.generation => entry.next,\n        _ => panic!(\"expected occupied entry with correct generation at `target`\"),\n    };\n    if target.index == index.index {\n        panic!(\"cannot move after `index` itself\");\n    }\n    if previous_index == Some(target.index) {\n        // Already in the right place\n        return;\n    }\n    self.update_link(previous_index, next_index);\n    self.update_link(Some(index.index), Some(target.index));\n    self.update_link(target_next_index, Some(index.index));\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    let (previous_index, next_index) = match &self.entries[index.index()] {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            (entry.previous, entry.next)\n        }\n        _ => panic!(\"expected occupied entry with correct generation at `index`\"),\n    };\n    let target_next_index = match &self.entries[target.index()] {\n        Entry::Occupied(entry) if entry.generation == target.generation => entry.next,\n        _ => panic!(\"expected occupied entry with correct generation at `target`\"),\n    };\n    if target.index == index.index {\n        panic!(\"cannot move after `index` itself\");\n    }\n    if previous_index == Some(target.index) {\n        // Already in the right place\n        return;\n    }\n    self.update_link(previous_index, next_index);\n    self.update_link(Some(index.index), target_next_index);\n    self.update_link(target.next, Some(index.index));\n}"
    ],
    [
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let previous_index = match self.entries.get(index.index()) {\n        Some(Entry::Occupied(entry)) if entry.generation == index.generation => entry.previous,\n        _ => panic!(\"expected occupied entry with correct generation\"),\n    };\n    let new_index = self.insert_new(value, previous_index, Some(index.index()));\n    let entry = self.entries[index.index()].occupied_mut();\n    entry.previous = Some(new_index);\n    if let Some(previous_index) = previous_index {\n        self.entries[previous_index.get()].occupied_mut().next = Some(new_index);\n    }\n    Index::new(new_index, self.generation)\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let next_index = match &mut self.entries[index.index()] {\n        Entry::Occupied(entry) if entry.generation == index.generation => entry.next,\n        _ => panic!(\"expected occupied entry with correct generation\"),\n    };\n    let new_index = self.insert_new(value, Some(index.index()), next_index);\n    let entry = self.entries[index.index()].occupied_mut();\n    entry.next = Some(new_index);\n    Index::new(new_index, self.generation)\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let previous_index = match self.entries.get(index.index()) {\n        Some(Entry::Occupied(entry)) if entry.generation == index.generation => entry.previous,\n        _ => panic!(\"expected occupied entry with correct generation\"),\n    };\n    let new_index = self.insert_new(value, previous_index, Some(index.index()));\n    let entry = self.entries[index.index()].occupied_mut();\n    entry.previous = Some(new_index);\n    if let Some(previous_index) = previous_index {\n        self.entries[previous_index.get()].occupied_mut().next = Some(new_index);\n    } else {\n        self.head = Some(new_index);\n    }\n    Index::new(new_index, self.generation)\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let entry = self.entries[index.index()].occupied_mut();\n    let new_index = self.insert_new(value, Some(index.index()), Some(entry.next));\n    entry.next = Some(new_index);\n    if let Some(next_index) = entry.next {\n        self.entries[next_index.get()].occupied_mut().previous = Some(new_index);\n    } else {\n        self.tail = Some(new_index);\n    }\n    Index::new(new_index, self.generation)\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    if let Some(previous_index) = self.get_previous_index(index) {\n        let next_index = match &mut self.entries[index.index()] {\n            Entry::Occupied(entry) if entry.generation == index.generation => entry.next,\n            _ => panic!(\"expected occupied entry with correct generation\"),\n        };\n        let new_index = self.insert_new(value, Some(previous_index), next_index);\n        let entry = self.entries[index.index()].occupied_mut();\n        entry.previous = Some(new_index);\n        new_index\n    } else {\n        panic!(\"index not in list anymore or invalidated\")\n    }\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let previous_index = match self.entries.get(index.index()) {\n        Some(Entry::Occupied(entry)) if entry.generation == index.generation => {\n            Some(entry.previous)\n        }\n        _ => panic!(\"expected occupied entry with correct generation\"),\n    };\n    let new_index = self.insert_new(value, previous_index, Some(index.index()));\n    let entry = self.entries[index.index()].occupied_mut();\n    entry.previous = Some(new_index);\n    Index::new(new_index, self.generation)\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let index = index.index();\n    let generation = index.generation();\n    let previous_index = match &mut self.entries[index] {\n        Entry::Occupied(entry) if entry.generation == generation => entry.previous,\n        _ => panic!(\"expected occupied entry with correct generation\"),\n    };\n    let new_index = self.insert_new(value, previous_index, Some(index));\n    let entry = self.entries[index].occupied_mut();\n    entry.previous = Some(new_index);\n    Index::new(new_index, self.generation)\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let previous_index = match self.entries.get(index.index()) {\n        Some(Entry::Occupied(entry)) if entry.generation == index.generation => {\n            entry.previous\n        }\n        _ => panic!(\"expected occupied entry with correct generation\"),\n    };\n    let new_index = self.insert_new(value, previous_index, Some(index.index()));\n    let entry = self.entries[index.index()].occupied_mut();\n    entry.previous = Some(new_index);\n    Index::new(new_index, self.generation)\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let previous_index = match self.entries.get(index.index()) {\n        Some(Entry::Occupied(entry)) if entry.generation == index.generation => entry.previous,\n        _ => panic!(\"expected occupied entry with correct generation\"),\n    };\n    let new_index = self.insert_new(value, previous_index, Some(index.index()));\n    let entry = self.entries[index.index()].occupied_mut();\n    entry.previous = Some(new_index);\n    Index::new(new_index, self.generation)\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    if let Some(index) = index {\n      let entry = self.entries[index.get()].occupied_ref();\n      let generation = entry.generation;\n      let index = self.insert_new(value, Some(index), entry.next);\n      self.entries[index.get()].occupied_mut().previous = Some(index);\n      if let Some(next_index) = entry.next {\n        self.entries[next_index.get()].occupied_mut().previous = Some(index);\n      } else {\n        self.tail = Some(index);\n      }\n      Index::new(index, generation)\n    } else {\n      panic!(\"index not in list anymore\");\n    }\n  }"
    ],
    [
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n  if minimum_capacity < self.length {\n    panic!(\"minimum capacity must be greater than or equal to the current length\");\n  }\n\n  let mut count = NonMaxUsize::zero();\n  let mut entries = Vec::with_capacity(minimum_capacity);\n  let generation = create_initial_generation();\n  let length = self.length;\n  let mut map = HashMap::with_capacity(length);\n  let mut next_index = self.head;\n\n  while let Some(index) = next_index {\n    let mut entry = self.remove_entry(index).expect(\"expected occupied entry\");\n    next_index = entry.next;\n\n    let _ = map.insert(\n      Index::new(index, entry.generation),\n      Index::new(count, generation),\n    );\n\n    entry.generation = generation;\n    entry.previous = if count > 0 {\n      Some(count.checked_sub(1).unwrap())\n    } else {\n      None\n    };\n    entry.next = if count < length - 1 {\n      Some(count.checked_add(1).expect(\"overflow\"))\n    } else {\n      None\n    };\n\n    entries.push(Entry::Occupied(entry));\n    count = count.checked_add(1).expect(\"overflow\");\n  }\n\n  self.entries = entries;\n  self.generation = generation;\n  self.head = Some(count.checked_sub(length).unwrap());\n  self.length = length;\n  self.tail = Some(count.checked_sub(1).unwrap());\n  self.vacant_head = None;\n\n  map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n  if minimum_capacity < self.length {\n    panic!(\"the given minimum capacity is less than the current length of the list\");\n  }\n\n  let mut count = NonMaxUsize::zero();\n  let mut entries = Vec::with_capacity(minimum_capacity);\n  let generation = create_initial_generation();\n  let length = self.length;\n  let mut map = HashMap::with_capacity(length);\n  let mut next_index = self.head;\n\n  while let Some(index) = next_index {\n    let mut entry = self.remove_entry(index).expect(\"expected occupied entry\");\n    next_index = entry.next;\n\n    let _ = map.insert(\n      Index::new(index, entry.generation),\n      Index::new(count, generation),\n    );\n\n    entry.generation = generation;\n    entry.previous = if count > 0 {\n      Some(count.checked_sub(1).unwrap())\n    } else {\n      None\n    };\n    entry.next = if count < length - 1 {\n      Some(count.checked_add(1).expect(\"overflow\"))\n    } else {\n      None\n    };\n\n    entries.push(Entry::Occupied(entry));\n    count = count.checked_add(1).expect(\"overflow\");\n  }\n\n  self.entries = entries;\n  self.generation = generation;\n  self.head = Some(NonMaxUsize::zero());\n  self.length = length;\n  self.tail = Some(count.checked_sub(1).unwrap());\n  self.vacant_head = None;\n\n  map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    if minimum_capacity < self.length {\n      panic!(\"the minimum capacity must be greater than or equal to the current length of the list\");\n    }\n\n    let mut count = NonMaxUsize::zero();\n    let mut entries = Vec::with_capacity(minimum_capacity);\n    let generation = create_initial_generation();\n    let length = self.length;\n    let mut map = HashMap::with_capacity(length);\n    let mut next_index = self.head;\n\n    while let Some(index) = next_index {\n      let mut entry = self.remove_entry(index).expect(\"expected occupied entry\");\n      next_index = entry.next;\n\n      let _ = map.insert(\n        Index::new(index, entry.generation),\n        Index::new(count, generation),\n      );\n\n      entry.generation = generation;\n      entry.previous = if count > 0 {\n        Some(count.checked_sub(1).unwrap())\n      } else {\n        None\n      };\n      entry.next = if count < length - 1 {\n        Some(count.checked_add(1).expect(\"overflow\"))\n      } else {\n        None\n      };\n\n      entries.push(Entry::Occupied(entry));\n      count = count.checked_add(1).expect(\"overflow\");\n    }\n\n    self.entries = entries;\n    self.generation = generation;\n    self.length = length;\n    self.vacant_head = None;\n\n    map\n  }",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n  if minimum_capacity < self.length {\n    panic!(\"the given minimum capacity is less than the current length of the list\");\n  }\n\n  let mut count = NonMaxUsize::zero();\n  let mut entries = Vec::with_capacity(minimum_capacity);\n  let generation = create_initial_generation();\n  let length = self.length;\n  let mut map = HashMap::with_capacity(length);\n  let mut next_index = self.head;\n\n  while let Some(index) = next_index {\n    let mut entry = self.remove_entry(index).expect(\"expected occupied entry\");\n    next_index = entry.next;\n\n    let _ = map.insert(\n      Index::new(index, entry.generation),\n      Index::new(count, generation),\n    );\n\n    entry.generation = generation;\n    entry.previous = if count > 0 {\n      Some(count.checked_sub(1).unwrap())\n    } else {\n      None\n    };\n    entry.next = if count < length - 1 {\n      Some(count.checked_add(1).expect(\"overflow\"))\n    } else {\n      None\n    };\n\n    entries.push(Entry::Occupied(entry));\n    count = count.checked_add(1).expect(\"overflow\");\n  }\n\n  self.entries = entries;\n  self.generation = generation;\n  self.head = Some(NonMaxUsize::zero());\n  self.length = length;\n  self.tail = Some(count.checked_sub(1).unwrap());\n  self.vacant_head = None;\n\n  map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    if minimum_capacity < self.length {\n      panic!(\"cannot pack to a capacity smaller than the current length\");\n    }\n\n    let mut count = NonMaxUsize::zero();\n    let mut entries = Vec::with_capacity(minimum_capacity);\n    let generation = create_initial_generation();\n    let length = self.length;\n    let mut map = HashMap::with_capacity(length);\n    let mut next_index = self.head;\n\n    while let Some(index) = next_index {\n      let mut entry = self.remove_entry(index).expect(\"expected occupied entry\");\n      next_index = entry.next;\n\n      let _ = map.insert(\n        Index::new(index, entry.generation),\n        Index::new(count, generation),\n      );\n\n      entry.generation = generation;\n      entry.previous = if count > 0 {\n        Some(count.checked_sub(1).unwrap())\n      } else {\n        None\n      };\n      entry.next = if count < length - 1 {\n        Some(count.checked_add(1).expect(\"overflow\"))\n      } else {\n        None\n      };\n\n      entries.push(Entry::Occupied(entry));\n      count = count.checked_add(1).expect(\"overflow\");\n    }\n\n    self.entries = entries;\n    self.generation = generation;\n    self.head = self.tail = None;\n    self.length = 0;\n    self.vacant_head = None;\n\n    map\n  }",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n  if minimum_capacity < self.length {\n    panic!(\"the given minimum capacity is less than the current length of the list\");\n  }\n\n  let mut count = NonMaxUsize::zero();\n  let mut entries = Vec::with_capacity(minimum_capacity);\n  let generation = create_initial_generation();\n  let length = self.length;\n  let mut map = HashMap::with_capacity(length);\n  let mut next_index = self.head;\n\n  while let Some(index) = next_index {\n    let mut entry = self.remove_entry(index).expect(\"expected occupied entry\");\n    next_index = entry.next;\n\n    let _ = map.insert(\n      Index::new(index, entry.generation),\n      Index::new(count, generation),\n    );\n\n    entry.generation = generation;\n    entry.previous = if count > 0 {\n      Some(count.checked_sub(1).unwrap())\n    } else {\n      None\n    };\n    entry.next = if count < length - 1 {\n      Some(count.checked_add(1).expect(\"overflow\"))\n    } else {\n      None\n    };\n\n    entries.push(Entry::Occupied(entry));\n    count = count.checked_add(1).expect(\"overflow\");\n  }\n\n  self.entries = entries;\n  self.generation = generation;\n  self.head = self.tail = None;\n  self.length = length;\n  self.vacant_head = None;\n\n  map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n  if minimum_capacity < self.length {\n    panic!(\"minimum capacity must be greater than or equal to the current length\");\n  }\n\n  let mut count = NonMaxUsize::zero();\n  let mut entries = Vec::with_capacity(minimum_capacity);\n  let generation = create_initial_generation();\n  let length = self.length;\n  let mut map = HashMap::with_capacity(length);\n  let mut next_index = self.head;\n\n  while let Some(index) = next_index {\n    let mut entry = self.remove_entry(index).expect(\"expected occupied entry\");\n    next_index = entry.next;\n\n    let _ = map.insert(\n      Index::new(index, entry.generation),\n      Index::new(count, generation),\n    );\n\n    entry.generation = generation;\n    entry.previous = if count > 0 {\n      Some(count.checked_sub(1).unwrap())\n    } else {\n      None\n    };\n    entry.next = if count < length - 1 {\n      Some(count.checked_add(1).expect(\"overflow\"))\n    } else {\n      None\n    };\n\n    entries.push(Entry::Occupied(entry));\n    count = count.checked_add(1).expect(\"overflow\");\n  }\n\n  self.entries = entries;\n  self.generation = generation;\n  self.head = Some(count.checked_sub(length).unwrap());\n  self.length = length;\n  self.tail = Some(count.checked_sub(1).unwrap());\n  self.vacant_head = None;\n\n  map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    if minimum_capacity < self.length {\n      panic!(\"the minimum capacity must be greater than or equal to the length of the list\");\n    }\n\n    let mut count = NonMaxUsize::zero();\n    let mut entries = Vec::with_capacity(minimum_capacity);\n    let generation = create_initial_generation();\n    let length = self.length;\n    let mut map = HashMap::with_capacity(length);\n    let mut next_index = self.head;\n\n    while let Some(index) = next_index {\n      let mut entry = self.remove_entry(index).expect(\"expected occupied entry\");\n      next_index = entry.next;\n\n      let _ = map.insert(\n        Index::new(index, entry.generation),\n        Index::new(count, generation),\n      );\n\n      entry.generation = generation;\n      entry.previous = if count > 0 {\n        Some(count.checked_sub(1).unwrap())\n      } else {\n        None\n      };\n      entry.next = if count < length - 1 {\n        Some(count.checked_add(1).expect(\"overflow\"))\n      } else {\n        None\n      };\n\n      entries.push(Entry::Occupied(entry));\n      count = count.checked_add(1).expect(\"overflow\");\n    }\n\n    self.entries = entries;\n    self.generation = generation;\n    self.head = Some(NonMaxUsize::zero());\n    self.length = length;\n    self.tail = Some(count.checked_sub(1).unwrap());\n    self.vacant_head = None;\n\n    map\n  }",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    if minimum_capacity < self.length {\n      panic!(\"cannot pack to a capacity smaller than the current length\");\n    }\n\n    let mut count = NonMaxUsize::zero();\n    let mut entries = Vec::with_capacity(minimum_capacity);\n    let generation = create_initial_generation();\n    let length = self.length;\n    let mut map = HashMap::with_capacity(length);\n    let mut next_index = self.head;\n\n    while let Some(index) = next_index {\n      let mut entry = self.remove_entry(index).expect(\"expected occupied entry\");\n      next_index = entry.next;\n\n      let _ = map.insert(\n        Index::new(index, entry.generation),\n        Index::new(count, generation),\n      );\n\n      entry.generation = generation;\n      entry.previous = if count > 0 {\n        Some(count.checked_sub(1).unwrap())\n      } else {\n        None\n      };\n      entry.next = if count < length - 1 {\n        Some(count.checked_add(1).expect(\"overflow\"))\n      } else {\n        None\n      };\n\n      entries.push(Entry::Occupied(entry));\n      count = count.checked_add(1).expect(\"overflow\");\n    }\n\n    self.entries = entries;\n    self.generation = generation;\n    self.head = self.entries.first().map(|entry| entry.occupied_ref().index);\n    self.tail = self.entries.last().map(|entry| entry.occupied_ref().index);\n    self.length = length;\n    self.vacant_head = None;\n\n    map\n  }",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n  if minimum_capacity < self.length {\n    panic!(\"cannot pack to a capacity less than the current length\");\n  }\n\n  let mut count = NonMaxUsize::zero();\n  let mut entries = Vec::with_capacity(minimum_capacity);\n  let generation = create_initial_generation();\n  let length = self.length;\n  let mut map = HashMap::with_capacity(length);\n  let mut next_index = self.head;\n\n  while let Some(index) = next_index {\n    let mut entry = self.remove_entry(index).expect(\"expected occupied entry\");\n    next_index = entry.next;\n\n    let _ = map.insert(\n      Index::new(index, entry.generation),\n      Index::new(count, generation),\n    );\n\n    entry.generation = generation;\n    entry.previous = if count > 0 {\n      Some(count.checked_sub(1).unwrap())\n    } else {\n      None\n    };\n    entry.next = if count < length - 1 {\n      Some(count.checked_add(1).expect(\"overflow\"))\n    } else {\n      None\n    };\n\n    entries.push(Entry::Occupied(entry));\n    count = count.checked_add(1).expect(\"overflow\");\n  }\n\n  self.entries = entries;\n  self.generation = generation;\n  self.head = Some(count);\n  self.length = length;\n  self.tail = Some(count.checked_sub(1).unwrap());\n  self.vacant_head = None;\n\n  map\n}"
    ],
    [
      "pub fn pop_back (&mut self) -> Option<T> {\n    self.remove_entry(self.tail?).map(|entry| entry.value)\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    self.remove_entry(self.tail?).map(|entry| entry.value)\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    self.remove_entry(self.tail?).map(|entry| entry.value)\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    self.remove_entry(self.tail?).map(|entry| entry.value)\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    self.remove_entry(self.tail?).map(|entry| entry.value)\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    self.remove_entry(self.tail?).map(|entry| entry.value)\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    self.remove_entry(self.tail?).map(|entry| entry.value)\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    self.remove_entry(self.tail?).map(|entry| entry.value)\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    self.remove_entry(self.tail?).map(|entry| entry.value)\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    self.remove_entry(self.tail?).map(|entry| entry.value)\n}"
    ],
    [
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let tail_index = match self.tail {\n        Some(index) => index,\n        None => return self.insert_empty(value),\n    };\n    let index = self.insert_new(value, Some(tail_index), None);\n    self.entries[tail_index.get()].occupied_mut().next = Some(index);\n    self.tail = Some(index);\n    Index::new(index, self.generation)\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let tail_index = match self.tail {\n        Some(index) => index,\n        None => return self.insert_empty(value),\n    };\n    let index = self.insert_new(value, Some(tail_index), None);\n    self.entries[tail_index.get()].occupied_mut().next = Some(index);\n    self.tail = Some(index);\n    Index::new(index, self.generation)\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let tail_index = match self.tail {\n        Some(index) => index,\n        None => return self.insert_empty(value),\n    };\n    let index = self.insert_new(value, Some(tail_index), None);\n    self.entries[tail_index.get()].occupied_mut().next = Some(index);\n    self.tail = Some(index);\n    Index::new(index, self.generation)\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let tail_index = match self.tail {\n        Some(index) => index,\n        None => return self.insert_empty(value),\n    };\n    let index = self.insert_new(value, Some(tail_index), None);\n    self.entries[tail_index.get()].occupied_mut().next = Some(index);\n    self.tail = Some(index);\n    Index::new(index, self.generation)\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let tail_index = match self.tail {\n        Some(index) => index,\n        None => return self.insert_empty(value),\n    };\n    let index = self.insert_new(value, Some(tail_index), None);\n    self.entries[tail_index.get()].occupied_mut().next = Some(index);\n    self.tail = Some(index);\n    Index::new(index, self.generation)\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let tail_index = match self.tail {\n        Some(index) => index,\n        None => return self.insert_empty(value),\n    };\n    let index = self.insert_new(value, Some(tail_index), None);\n    self.entries[tail_index.get()].occupied_mut().next = Some(index);\n    self.tail = Some(index);\n    Index::new(index, self.generation)\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let tail_index = match self.tail {\n        Some(index) => index,\n        None => return self.insert_empty(value),\n    };\n    let index = self.insert_new(value, Some(tail_index), None);\n    self.entries[tail_index.get()].occupied_mut().next = Some(index);\n    self.tail = Some(index);\n    Index::new(index, self.generation)\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let tail_index = match self.tail {\n        Some(index) => index,\n        None => return self.insert_empty(value),\n    };\n    let index = self.insert_new(value, Some(tail_index), None);\n    self.entries[tail_index.get()].occupied_mut().next = Some(index);\n    self.tail = Some(index);\n    Index::new(index, self.generation)\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let tail_index = match self.tail {\n        Some(index) => index,\n        None => return self.insert_empty(value),\n    };\n    let index = self.insert_new(value, Some(tail_index), None);\n    self.entries[tail_index.get()].occupied_mut().next = Some(index);\n    self.tail = Some(index);\n    Index::new(index, self.generation)\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let tail_index = match self.tail {\n        Some(index) => index,\n        None => return self.insert_empty(value),\n    };\n    let index = self.insert_new(value, Some(tail_index), None);\n    self.entries[tail_index.get()].occupied_mut().next = Some(index);\n    self.tail = Some(index);\n    Index::new(index, self.generation)\n}"
    ],
    [
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n  let mut index = self.head;\n  while let Some(index) = index {\n    let mut entry = self.remove_entry(index).expect(\"expected occupied entry\");\n    let value = entry.value.as_mut();\n    if predicate(value) {\n      entry.generation = self.generation;\n      entry.previous = self.tail;\n      entry.next = None;\n      self.entries[index.get()] = Entry::Occupied(entry);\n      self.tail = Some(index);\n      index = entry.next;\n    } else {\n      index = entry.next;\n    }\n  }\n  self.head = self.tail;\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut next_index = self.head;\n    while let Some(index) = next_index {\n        let mut entry = self.remove_entry(index).expect(\"expected occupied entry\");\n        next_index = entry.next;\n        if predicate(&mut entry.value) {\n            self.insert_entry(entry);\n        }\n    }\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n  let mut next_index = self.head;\n  while let Some(index) = next_index {\n    let mut entry = self.remove_entry(index).expect(\"expected occupied entry\");\n    next_index = entry.next;\n    if predicate(&mut entry.value) {\n      self.insert_entry(entry);\n    }\n  }\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut next_index = self.head;\n    while let Some(index) = next_index {\n        let mut entry = self.remove_entry(index).expect(\"expected occupied entry\");\n        next_index = entry.next;\n\n        if predicate(&mut entry.value) {\n            self.insert_new(entry.value, entry.previous, entry.next);\n        }\n    }\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut index = self.head;\n    while let Some(index) = index {\n        let entry = self.entries[index.get()].occupied_mut();\n        if predicate(&mut entry.value) {\n            index = entry.next;\n        } else {\n            index = self.remove_entry(index).expect(\"expected occupied entry\").next;\n        }\n    }\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut index = self.head;\n    while let Some(index) = index {\n        let entry = self.remove_entry(index).expect(\"expected occupied entry\");\n        let mut value = entry.value;\n        if predicate(&mut value) {\n            self.insert_new(value, entry.previous, entry.next);\n        }\n        index = entry.next;\n    }\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n  let mut index = self.head;\n  while let Some(index) = index {\n    let entry = self.remove_entry(index).expect(\"expected occupied entry\");\n    index = entry.next;\n    if predicate(&mut entry.value) {\n      self.insert_new(entry.value, entry.previous, entry.next);\n    }\n  }\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut head = self.head;\n    let mut tail = self.tail;\n    let mut next_index = head;\n\n    while let Some(index) = next_index {\n        let mut entry = self.remove_entry(index).expect(\"expected occupied entry\");\n        next_index = entry.next;\n\n        if predicate(&mut entry.value) {\n            if let Some(previous_index) = entry.previous {\n                self.entries[previous_index.get()].occupied_mut().next = Some(index);\n            } else {\n                head = Some(index);\n            }\n\n            if let Some(next_index) = entry.next {\n                self.entries[next_index.get()].occupied_mut().previous = Some(index);\n            } else {\n                tail = Some(index);\n            }\n\n            self.entries[index.get()] = Entry::Occupied(entry);\n        }\n    }\n\n    self.head = head;\n    self.tail = tail;\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut head = self.head;\n    let mut tail = self.tail;\n    let mut next_index = head;\n    let mut previous_index = None;\n    let mut count = 0;\n\n    while let Some(index) = next_index {\n        let mut entry = self.remove_entry(index).expect(\"expected occupied entry\");\n        next_index = entry.next;\n\n        if predicate(&mut entry.value) {\n            if let Some(previous_index) = previous_index {\n                self.entries[previous_index.get()].occupied_mut().next = Some(index);\n            } else {\n                head = Some(index);\n            }\n\n            if let Some(next_index) = next_index {\n                self.entries[next_index.get()].occupied_mut().previous = Some(index);\n            } else {\n                tail = Some(index);\n            }\n\n            previous_index = Some(index);\n            count += 1;\n        }\n    }\n\n    self.head = head;\n    self.tail = tail;\n    self.length = count;\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n  let mut head = self.head;\n  let mut tail = self.tail;\n  let mut count = self.length;\n  let mut generation = self.generation;\n  let mut next_index = self.head;\n  let mut entries = Vec::with_capacity(count);\n  let mut map = HashMap::with_capacity(count);\n\n  while let Some(index) = next_index {\n    let mut entry = self.remove_entry(index).expect(\"expected occupied entry\");\n    next_index = entry.next;\n\n    if predicate(&mut entry.value) {\n      let _ = map.insert(\n        Index::new(index, entry.generation),\n        Index::new(count, generation),\n      );\n\n      entry.generation = generation;\n      entry.previous = if count > 0 {\n        Some(count.checked_sub(1).unwrap())\n      } else {\n        None\n      };\n      entry.next = if count < count - 1 {\n        Some(count.checked_add(1).expect(\"overflow\"))\n      } else {\n        None\n      };\n\n      entries.push(Entry::Occupied(entry));\n      count = count.checked_add(1).expect(\"overflow\");\n    }\n  }\n\n  self.head = head;\n  self.tail = tail;\n  self.length = count;\n  self.generation = generation;\n  self.entries = entries;\n  self.map = map;\n}"
    ],
    [
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut last_free_lba = self.header.first_usable_lba;\n    for i in 1..self.header.number_of_partition_entries {\n        let p = &self[i];\n        if p.is_used() {\n            if last_free_lba < p.starting_lba {\n                free_sectors.push((last_free_lba, p.starting_lba - last_free_lba));\n            }\n            last_free_lba = p.ending_lba + 1;\n        }\n    }\n    if last_free_lba < self.header.last_usable_lba {\n        free_sectors.push((last_free_lba, self.header.last_usable_lba - last_free_lba + 1));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut current_start = self.header.first_usable_lba;\n    let mut current_size = 0;\n    for x in &self.partitions {\n        if x.starting_lba > current_start {\n            free_sectors.push((current_start, current_size));\n        }\n        current_start = x.ending_lba + 1;\n        current_size = 0;\n    }\n    free_sectors.push((current_start, current_size));\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut last_free_lba = self.header.first_usable_lba;\n    let mut last_free_sectors = 0;\n    for i in 1..self.header.number_of_partition_entries + 1 {\n        let p = &self[i];\n        if p.is_used() {\n            if last_free_sectors > 0 {\n                free_sectors.push((last_free_lba, last_free_sectors));\n            }\n            last_free_lba = p.ending_lba + 1;\n            last_free_sectors = 0;\n        } else {\n            last_free_sectors += p.size().unwrap();\n        }\n    }\n    if last_free_sectors > 0 {\n        free_sectors.push((last_free_lba, last_free_sectors));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut start = self.header.first_usable_lba;\n    let mut end = self.header.last_usable_lba;\n    let align = self.align;\n\n    for p in &self.partitions {\n        if p.starting_lba > start {\n            free_sectors.push((start, (p.starting_lba - start) / align * align));\n        }\n        start = p.ending_lba + 1;\n    }\n    if start < end {\n        free_sectors.push((start, (end - start) / align * align));\n    }\n\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut last_lba = self.header.first_usable_lba;\n    for partition in self.iter() {\n        if partition.starting_lba > last_lba {\n            free_sectors.push((last_lba, partition.starting_lba - last_lba));\n        }\n        last_lba = partition.ending_lba + 1;\n    }\n    if last_lba < self.header.last_usable_lba {\n        free_sectors.push((last_lba, self.header.last_usable_lba - last_lba));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut start = self.header.first_usable_lba;\n    let mut end = self.header.last_usable_lba;\n    for partition in &self.partitions {\n        if partition.starting_lba >= end {\n            break;\n        }\n        if start < partition.starting_lba {\n            free_sectors.push((start, partition.starting_lba - start));\n        }\n        start = partition.ending_lba + 1;\n        if start > end {\n            break;\n        }\n    }\n    if start < end {\n        free_sectors.push((start, end - start));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut current_start = self.header.first_usable_lba;\n    let mut current_size = 0;\n    for i in 1..=self.header.number_of_partition_entries {\n        let p = &self[i];\n        if p.is_used() {\n            if current_size > 0 {\n                free_sectors.push((current_start, current_size));\n            }\n            current_start = p.ending_lba + 1;\n            current_size = 0;\n        } else {\n            current_size += 1;\n        }\n    }\n    if current_size > 0 {\n        free_sectors.push((current_start, current_size));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut current_start = self.header.first_usable_lba;\n    let mut current_size = 0;\n    for i in 1..=self.header.number_of_partition_entries {\n        let p = &self[i];\n        if p.is_used() {\n            if current_size != 0 {\n                free_sectors.push((current_start, current_size));\n                current_size = 0;\n            }\n            current_start = p.ending_lba + 1;\n        } else {\n            current_size += 1;\n        }\n    }\n    if current_size != 0 {\n        free_sectors.push((current_start, current_size));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut current_free_start = self.header.first_usable_lba;\n    let mut current_free_size = 0;\n    for i in 1..self.header.number_of_partition_entries {\n        let partition = &self[i];\n        let partition_start = partition.starting_lba;\n        let partition_end = partition.ending_lba;\n        let partition_size = partition_end - partition_start + 1;\n        if partition_start > current_free_start {\n            if current_free_size > 0 {\n                free_sectors.push((current_free_start, current_free_size));\n            }\n            current_free_start = partition_end + 1;\n            current_free_size = 0;\n        }\n        current_free_size += partition_size;\n    }\n    if current_free_size > 0 {\n        free_sectors.push((current_free_start, current_free_size));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut last_free_sector = self.header.first_usable_lba;\n    let mut current_free_sector = last_free_sector;\n    let mut current_free_size = 0;\n\n    for i in 1..self.header.number_of_partition_entries + 1 {\n        let partition = &self[i];\n        let start = partition.starting_lba;\n        let end = partition.ending_lba;\n\n        if start > last_free_sector {\n            // we have a free spot\n            free_sectors.push((last_free_sector, current_free_size));\n            current_free_size = 0;\n        }\n\n        if start > current_free_sector {\n            // we have a free spot\n            free_sectors.push((current_free_sector, current_free_size));\n            current_free_size = 0;\n        }\n\n        current_free_sector = end + 1;\n        current_free_size += 1;\n        last_free_sector = end + 1;\n    }\n\n    if current_free_size > 0 {\n        free_sectors.push((current_free_sector, current_free_size));\n    }\n\n    free_sectors\n}"
    ],
    [
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    self.find_free_sectors()\n        .iter()\n        .filter(|(_, l)| *l >= size)\n        .min_by_key(|(_, l)| *l)\n        .map(|(i, l)| (i + l - size) / self.align * self.align)\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    self.find_free_sectors()\n        .iter()\n        .filter(|(_, l)| *l >= size)\n        .last()\n        .map(|(i, l)| (i + l - size) / self.align * self.align)\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    self.find_free_sectors()\n        .iter()\n        .filter(|(_, l)| *l >= size)\n        .min_by_key(|(_, l)| *l)\n        .map(|(i, l)| (i + l - size) / self.align * self.align)\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    self.find_free_sectors()\n        .iter()\n        .filter(|(_, l)| *l >= size)\n        .min_by_key(|(_, l)| *l)\n        .map(|(i, l)| (i + l - size) / self.align * self.align)\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    self.find_free_sectors()\n        .iter()\n        .filter(|(_, l)| *l >= size)\n        .min_by_key(|(_, l)| *l)\n        .map(|(i, l)| (i + l - size) / self.align * self.align)\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    self.find_free_sectors()\n        .iter()\n        .filter(|(_, l)| *l >= size)\n        .last()\n        .map(|(i, l)| (i + l - size) / self.align * self.align)\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    self.find_free_sectors()\n        .iter()\n        .filter(|(_, l)| *l >= size)\n        .min_by_key(|(_, l)| *l)\n        .map(|(i, l)| (i + l - size) / self.align * self.align)\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    let mut optimal_place = None;\n    let mut optimal_size = 0;\n    for (start, length) in self.find_free_sectors() {\n        let end = start + length;\n        let free_space = end - start;\n        if free_space >= size && free_space < optimal_size {\n            optimal_place = Some(start);\n            optimal_size = free_space;\n        }\n    }\n    optimal_place\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    self.find_free_sectors()\n        .iter()\n        .filter(|(_, l)| *l >= size)\n        .min_by_key(|(_, l)| *l)\n        .map(|(i, l)| (i + l - size) / self.align * self.align)\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    let mut optimal_place = None;\n    let mut optimal_size = None;\n    for (i, l) in self.find_free_sectors() {\n        if l >= size {\n            if optimal_size.is_none() || l < optimal_size.unwrap() {\n                optimal_place = Some(i);\n                optimal_size = Some(l);\n            }\n        }\n    }\n    optimal_place.map(|i| i + optimal_size.unwrap() - size)\n}"
    ],
    [
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    if self.align > 0 {\n        Ok((self.header.last_usable_lba + 1 - self.header.first_usable_lba) / self.align * self.align)\n    } else {\n        Err(Error::new(\"align must be greater than 0\"))\n    }\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let align = self.align;\n    let free_sectors = self.find_free_sectors();\n    let max_size = free_sectors\n        .iter()\n        .skip_while(|(m, _)| *m < self.header.first_usable_lba)\n        .take(1)\n        .find(|(m, _)| *m == ((self.header.last_usable_lba + 1) / align) * align)\n        .map(|(_, n)| n)\n        .unwrap_or(&0);\n    Ok(max_size)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    if self.align == 0 {\n        return Err(Error::new(\"align must be greater than 0\"));\n    }\n    let free_sectors = self.find_free_sectors();\n    let max_size = free_sectors\n        .iter()\n        .skip_while(|(m, _)| *m < self.header.first_usable_lba)\n        .take(1)\n        .find(|(m, _)| *m == ((self.header.last_usable_lba + 1) / self.align) * self.align)\n        .map(|(_, n)| n)\n        .unwrap_or(&0);\n    Ok(*max_size)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let free_sectors = self.find_free_sectors();\n    let max_size = free_sectors.iter().map(|(_, n)| *n).max().unwrap_or(0);\n    Ok(max_size)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let free_sectors = self.find_free_sectors();\n    let max_size = free_sectors.iter().map(|(m, n)| m + n).max().unwrap_or(0);\n    Ok(max_size)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let align = self.align;\n    let first_usable_lba = self.header.first_usable_lba;\n    let last_usable_lba = self.header.last_usable_lba;\n    let free_sectors = self.find_free_sectors();\n    let mut max_size = 0;\n    for (starting_lba, size) in free_sectors {\n        if starting_lba >= first_usable_lba && starting_lba + size <= last_usable_lba {\n            let aligned_starting_lba = (starting_lba + align - 1) / align * align;\n            let aligned_ending_lba = aligned_starting_lba + size - 1;\n            if aligned_ending_lba <= last_usable_lba {\n                max_size = max_size.max(aligned_ending_lba - aligned_starting_lba + 1);\n            }\n        }\n    }\n    Ok(max_size)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    if self.align == 0 {\n        return Err(Error::new(\"align must be greater than 0\"));\n    }\n    let mut positions = vec![self.header.first_usable_lba - 1];\n    for partition in self.partitions.iter().filter(|x| x.is_used()) {\n        positions.push(partition.starting_lba);\n        positions.push(partition.ending_lba);\n    }\n    positions.push(self.header.last_usable_lba + 1);\n    positions.sort_unstable();\n    let mut free_sectors = 0;\n    for i in 1..positions.len() {\n        if positions[i] - positions[i - 1] > 1 {\n            free_sectors += positions[i] - positions[i - 1] - 1;\n        }\n    }\n    Ok(free_sectors)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let free_sectors = self.find_free_sectors();\n    let max_size = free_sectors.iter().map(|(_, n)| n).max().unwrap_or(0);\n    Ok(max_size)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let free_sectors = self.find_free_sectors();\n    let align = self.align;\n    Ok(free_sectors\n        .iter()\n        .skip_while(|(m, _)| *m < self.header.first_usable_lba)\n        .take(1)\n        .find(|(m, _)| *m == ((self.header.last_usable_lba + 1) / align) * align)\n        .map(|(_, n)| n)\n        .unwrap_or(&0))\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let free_sectors = self.find_free_sectors();\n    let max_size = free_sectors\n        .iter()\n        .skip_while(|(m, _)| *m < self.header.first_usable_lba)\n        .take(1)\n        .find(|(m, _)| *m == ((self.header.last_usable_lba + 1) / self.align) * self.align)\n        .map(|(_, n)| n)\n        .unwrap_or(&0);\n    Ok(max_size)\n}"
    ],
    [
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let partition = self.get_partition(partition_number)?;\n    let start = partition.starting_lba as u64 * self.sector_size;\n    let end = partition.ending_lba as u64 * self.sector_size;\n    if start > end {\n        return Err(Error::InvalidPartition(partition_number));\n    }\n    Ok(start..=end)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let partition = self.get_partition(partition_number)?;\n    let start = partition.starting_lba * self.header.sector_size;\n    let end = partition.ending_lba * self.header.sector_size;\n    Ok(start..=end)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let partition = self.get_partition(partition_number)?;\n    let starting_lba = partition.starting_lba;\n    let ending_lba = partition.ending_lba;\n    if starting_lba > ending_lba {\n        return Err(Error::InvalidPartition {\n            number: partition_number,\n            message: \"partition's `ending_lba` is less than its `starting_lba`\".into(),\n        });\n    }\n    Ok(starting_lba * self.sector_size..=ending_lba * self.sector_size)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let partition = self.get_partition(partition_number)?;\n    let start = partition.starting_lba * self.sector_size;\n    let end = partition.ending_lba * self.sector_size;\n    if end < start {\n        return Err(Error::InvalidPartitionRange);\n    }\n    Ok(start..=end)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let partition = self.get_partition(partition_number)?;\n    let start = partition.starting_lba * self.sector_size;\n    let end = partition.ending_lba * self.sector_size;\n    Ok(start..=end)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let partition = self.get_partition(partition_number)?;\n    let start = partition.starting_lba * self.header.sector_size;\n    let end = partition.ending_lba * self.header.sector_size;\n    if start > end {\n        return Err(Error::InvalidPartitionRange {\n            start,\n            end,\n            partition_number,\n        });\n    }\n    Ok(start..=end)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let partition = self.get_partition(partition_number)?;\n    let start = partition.starting_lba * self.sector_size;\n    let end = partition.ending_lba * self.sector_size;\n    if end < start {\n        return Err(Error::PartitionEndBeforeStart);\n    }\n    Ok(start..=end)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let partition = self.get_partition(partition_number)?;\n    let start = partition.starting_lba * self.sector_size;\n    let end = partition.ending_lba * self.sector_size;\n    Ok(start..=end)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let partition = self.get_partition(partition_number)?;\n    let start = partition.starting_lba * self.header.sector_size;\n    let end = partition.ending_lba * self.header.sector_size;\n    Ok(start..=end)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let partition = self.get_partition(partition_number)?;\n    let start = u64::from(partition.starting_lba) * self.header.sector_size;\n    let end = u64::from(partition.ending_lba) * self.header.sector_size;\n    if end < start {\n        return Err(Error::InvalidPartition(partition_number));\n    }\n    Ok(start..=end)\n}"
    ],
    [
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}"
    ],
    [
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\n    debug_assert_eq!(self.m, self.n);\n\n    let mut tr: T = T::zero();\n\n    for i in 0..self.m {\n        tr += self[[i, i]];\n    }\n\n    tr\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\n    let (m, n): (usize, usize) = self.dim();\n    debug_assert_eq!(m, n);\n\n    let mut tr: T = T::zero();\n    for i in 0..m {\n        tr += self[[i, i]];\n    }\n\n    tr\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\n    debug_assert_eq!(self.m, self.n);\n    let mut sum: T = T::zero();\n    for i in 0..self.m {\n        sum += self[[i, i]];\n    }\n    sum\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\ndebug_assert_eq!(self.m, self.n);\n\nlet mut tr: T = T::zero();\n\nfor i in 0..self.m\n{\ntr += self[[i, i]];\n}\n\ntr\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\n    let (m, n): (usize, usize) = self.dim();\n    debug_assert_eq!(m, n);\n    let mut sum: T = T::zero();\n    for i in 0..m {\n        sum += self[[i, i]];\n    }\n    sum\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\ndebug_assert_eq!(self.m, self.n);\nlet mut sum: T = T::zero();\nfor i in 0..self.m\n{\nsum += self[[i, i]];\n}\nsum\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\n    let (m, n): (usize, usize) = self.dim();\n    assert_eq!(m, n);\n\n    let mut tr: T = T::zero();\n\n    for i in 0..m {\n        tr += self[[i, i]];\n    }\n\n    tr\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\ndebug_assert_eq!(self.m, self.n);\n\nlet mut tr: T = T::zero();\nfor i in 0..self.m\n{\ntr += self[[i, i]];\n}\ntr\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\ndebug_assert_eq!(self.m, self.n);\nlet mut sum: T = T::zero();\nfor i in 0..self.m {\nsum += self[[i, i]];\n}\nsum\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\ndebug_assert_eq!(self.m, self.n);\nlet mut sum: T = T::zero();\nfor i in 0..self.m\n{\nsum += self[[i, i]];\n}\nsum\n}"
    ],
    [
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\nlet (m, n): (usize, usize) = self.dim();\ndebug_assert!(row_s < m);\ndebug_assert!(row_e < m);\ndebug_assert!(column_s < n);\ndebug_assert!(column_e <= n);\nlet mut slice: General<T> = General::zero(row_e - row_s + 1, column_e - column_s + 1);\n\nfor r in row_s..=(row_e) {\nfor c in column_s..=(column_e) {\nslice[[r - row_s, c - column_s]] = self[[r, c]];\n}\n}\nslice\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\n    let mut slice: General<T> = General::zero(row_e - row_s + 1, column_e - column_s + 1);\n\n    for r in row_s..(row_e + 1) {\n        for c in column_s..(column_e + 1) {\n            slice[[r - row_s, c - column_s]] = self[[r, c]];\n        }\n    }\n    slice\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\nlet mut slice: General<T> = General::zero(row_e - row_s + 1, column_e - column_s + 1);\n\n        for r in row_s..=(row_e) {\n            for c in column_s..=(column_e) {\n                slice[[r - row_s, c - column_s]] = self[[r, c]];\n            }\n        }\n        slice\n    }\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\nlet mut slice: General<T> = General::zero(row_e - row_s + 1, column_e - column_s + 1);\n\n        for r in row_s..=(row_e) {\n            for c in column_s..=(column_e) {\n                slice[[r - row_s, c - column_s]] = self[[r, c]];\n            }\n        }\n        slice\n    }\n}\n\nimpl<T> General<T>\nwhere\n    T: Scalar + Clone + Copy,",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\n    let (m, n): (usize, usize) = self.dim();\n    assert!(row_s < m && row_e < m && column_s < n && column_e <= n);\n\n    let mut slice: General<T> = General::zero(row_e - row_s + 1, column_e - column_s + 1);\n\n    for r in row_s..(row_e + 1) {\n        for c in column_s..(column_e + 1) {\n            slice[[r - row_s, c - column_s]] = self[[r, c]];\n        }\n    }\n    slice\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\n    let mut slice: General<T> = General::zero(row_e - row_s + 1, column_e - column_s + 1);\n\n    for r in row_s..(row_e + 1) {\n        for c in column_s..(column_e + 1) {\n            slice[[r - row_s, c - column_s]] = self[[r, c]];\n        }\n    }\n    slice\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\nlet (m, n): (usize, usize) = self.dim();\ndebug_assert!(row_s < m);\ndebug_assert!(row_e < m);\ndebug_assert!(column_s < n);\ndebug_assert!(column_e < n);\n\nlet mut slice: General<T> = General::zero(row_e - row_s + 1, column_e - column_s + 1);\n\nfor r in row_s..(row_e + 1) {\nfor c in column_s..(column_e + 1) {\nslice[[r - row_s, c - column_s]] = self[[r, c]];\n}\n}\nslice\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\n    let mut slice: General<T> = General::zero(row_e - row_s + 1, column_e - column_s + 1);\n\n    for r in row_s..=(row_e) {\n        for c in column_s..=(column_e) {\n            slice[[r - row_s, c - column_s]] = self[[r, c]];\n        }\n    }\n    slice\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\n    let (m, n): (usize, usize) = self.dim();\n    assert!(row_s < m && row_e < m && column_s < n && column_e <= n);\n    let mut slice: General<T> = General::zero(row_e - row_s + 1, column_e - column_s + 1);\n\n    for r in row_s..(row_e + 1) {\n        for c in column_s..(column_e + 1) {\n            slice[[r - row_s, c - column_s]] = self[[r, c]];\n        }\n    }\n    slice\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\nlet mut slice: General<T> = General::zero(row_e - row_s + 1, column_e - column_s + 1);\n\n        for r in row_s..=(row_e) {\n            for c in column_s..=(column_e) {\n                slice[[r - row_s, c - column_s]] = self[[r, c]];\n            }\n        }\n        slice\n    }\n}"
    ],
    [
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    let (rows, cols) = slice.dim();\n    for r in 0..rows\n    {\n        for c in 0..cols\n        {\n            self[[row + r, column + c]] = slice[[r, c]];\n        }\n    }\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    let (rows, cols): (usize, usize) = slice.dim();\n    for r in 0..rows\n    {\n        for c in 0..cols\n        {\n            self[[row + r, column + c]] = slice[[r, c]];\n        }\n    }\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    let (row_e, column_e): (usize, usize) = slice.dim();\n\n    for r in row..(row_e + 1)\n    {\n        for c in column..(column_e + 1)\n        {\n            self[[r, c]] = slice[[r - row, c - column]];\n        }\n    }\n\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    let (rows, cols): (usize, usize) = slice.dim();\n\n    for r in 0..rows\n    {\n        for c in 0..cols\n        {\n            self[[row + r, column + c]] = slice[[r, c]];\n        }\n    }\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    let (row_e, column_e): (usize, usize) = slice.dim();\n    let (m, n): (usize, usize) = self.dim();\n    assert!(row + row_e < m && column + column_e < n);\n\n    for r in 0..row_e {\n        for c in 0..column_e {\n            self[[row + r, column + c]] = slice[[r, c]];\n        }\n    }\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    let (row_e, column_e): (usize, usize) = slice.dim();\n\n    for r in row..(row_e + 1)\n    {\n        for c in column..(column_e + 1)\n        {\n            self[[r, c]] = slice[[r - row, c - column]];\n        }\n    }\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    let (row_e, column_e): (usize, usize) = slice.dim();\n    let (rows, columns): (usize, usize) = self.dim();\n\n    assert!(row_e + row <= rows && column_e + column <= columns, \"Slice out of bounds\");\n\n    for r in 0..row_e\n    {\n        for c in 0..column_e\n        {\n            self[[row + r, column + c]] = slice[[r, c]];\n        }\n    }\n\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    let (rows, cols): (usize, usize) = slice.dim();\n    for r in 0..rows\n    {\n        for c in 0..cols\n        {\n            self[[row + r, column + c]] = slice[[r, c]];\n        }\n    }\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    let (rows, cols): (usize, usize) = slice.dim();\n    let (m, n): (usize, usize) = self.dim();\n    debug_assert!(row + rows <= m && column + cols <= n);\n\n    for r in 0..rows\n    {\n        for c in 0..cols\n        {\n            self[[row + r, column + c]] = slice[[r, c]];\n        }\n    }\n\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    let (row_e, column_e): (usize, usize) = slice.dim();\n\n    for r in row..(row_e + 1)\n    {\n        for c in column..(column_e + 1)\n        {\n            self[[r, c]] = slice[[r - row, c - column]];\n        }\n    }\n\n    self\n}"
    ],
    [
      "pub fn dotp (&self, rhs: &Self) -> T {\n    let (m, n): (usize, usize) = self.dim();\n    let (m2, n2): (usize, usize) = rhs.dim();\n\n    if m != m2 || n != n2 {\n        panic!(\"Vector dimensions do not match\");\n    }\n\n    let mut sum: T = T::zero();\n\n    for i in 0..m {\n        sum += self[i] * rhs[i];\n    }\n\n    sum\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    let (m, n): (usize, usize) = self.dim();\n    let (rhs_m, rhs_n): (usize, usize) = rhs.dim();\n\n    if m != rhs_m || n != rhs_n {\n        panic!(\"Vector dimensions do not match\");\n    }\n\n    let mut sum: T = T::zero();\n\n    for i in 0..(m * n) {\n        sum += self[i] * rhs[i];\n    }\n\n    sum\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    let (m, n): (usize, usize) = self.dim();\n    let (m_rhs, n_rhs): (usize, usize) = rhs.dim();\n    if m != m_rhs || n != n_rhs\n    {\n        panic!(\"Dimension mismatch\");\n    }\n    let mut sum: T = T::zero();\n    for i in 0..m\n    {\n        sum += self[i] * rhs[i];\n    }\n    sum\n}",
      "pub fn dotp (&self, rhs: &Self) -> T where\n    T: Field + Scalar,\n{\n    let (m, n): (usize, usize) = self.dim();\n    let (m1, n1): (usize, usize) = rhs.dim();\n    if m != m1 || n != n1 {\n        panic!(\"Vector dimensions do not match\");\n    }\n\n    let mut sum: T = T::zero();\n    for i in 0..(m * n) {\n        sum += self[i] * rhs[i];\n    }\n\n    sum\n}",
      "pub fn dotp (&self, rhs: &Self) -> T where\n    T: Field + Scalar + Power + AbsDiffEq<Epsilon = T>,\n{\n    let (m, n): (usize, usize) = self.dim();\n    let (m2, n2): (usize, usize) = rhs.dim();\n    if m != m2 || n != n2 {\n        panic!(\"Dimension mismatch\");\n    }\n\n    let mut sum: T = T::zero();\n    for i in 0..m {\n        sum += self[i] * rhs[i];\n    }\n\n    sum\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    let (m, n): (usize, usize) = self.dim();\n    let (m1, n1): (usize, usize) = rhs.dim();\n    if m != m1 || n != n1\n    {\n        panic!(\"Vector dimensions do not match\");\n    }\n    let mut sum: T = T::zero();\n    for i in 0..(m * n)\n    {\n        sum += self[i] * rhs[i];\n    }\n    sum\n}",
      "pub fn dotp (&self, rhs: &Self) -> T where\n    T: Field + Scalar + Power,\n{\n    let (m, n): (usize, usize) = self.dim();\n    let (m1, n1): (usize, usize) = rhs.dim();\n\n    if m != m1 || n != n1 {\n        panic!(\"Dimensions do not match\");\n    }\n\n    let mut sum: T = T::zero();\n\n    for i in 0..m {\n        sum += self[i] * rhs[i];\n    }\n\n    sum\n}",
      "pub fn dotp (&self, rhs: &Self) -> T where\n    T: Field + Scalar,\n{\n    let (m, n): (usize, usize) = self.dim();\n    let (m1, n1): (usize, usize) = rhs.dim();\n\n    if m != m1 || n != n1 {\n        panic!(\"Dimensions do not match\");\n    }\n\n    let mut sum: T = T::zero();\n    for i in 0..m {\n        sum += self[i] * rhs[i];\n    }\n\n    sum\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    let (m, n): (usize, usize) = self.dim();\n    let (m_rhs, n_rhs): (usize, usize) = rhs.dim();\n\n    if m != m_rhs || n != n_rhs {\n        panic!(\"Vector dimensions do not match\");\n    }\n\n    let mut sum: T = T::zero();\n\n    for i in 0..m {\n        sum += self[i] * rhs[i];\n    }\n\n    sum\n}",
      "pub fn dotp (&self, rhs: &Self) -> T where\n    T: Field + Scalar,\n{\n    let (m, n): (usize, usize) = self.dim();\n    let (m_rhs, n_rhs): (usize, usize) = rhs.dim();\n\n    if m != m_rhs || n != n_rhs {\n        panic!(\"Dimension mismatch\");\n    }\n\n    let mut sum: T = T::zero();\n    for i in 0..m {\n        sum += self[i] * rhs[i];\n    }\n\n    sum\n}"
    ],
    [
      "pub fn argmax (&self) -> usize {\n    let (m, n) = self.dim();\n    let mut max_index: usize = 0;\n    let mut max: T = self[max_index];\n    let limit: usize = m.max(n);\n    debug_assert_ne!(limit, 0);\n    for idx in 0..limit {\n        let element: T = self[idx];\n        if element > max {\n            max_index = idx;\n            max = element;\n        }\n    }\n    max_index\n}",
      "pub fn argmax (&self) -> usize {\n    let (m, n) = self.dim();\n    let mut max_index: usize = 0;\n    let mut max: T = self[max_index];\n    let limit: usize = m.max(n);\n    debug_assert_ne!(limit, 0);\n    for idx in 0..limit\n    {\n        let element: T = self[idx];\n        if element > max\n        {\n            max_index = idx;\n            max = element;\n        }\n    }\n    max_index\n}",
      "pub fn argmax (&self) -> usize {\n    let (m, n) = self.dim();\n    let mut max_index: usize = 0;\n    let mut max: T = self[max_index];\n    let limit: usize = m.max(n);\n    debug_assert_ne!(limit, 0);\n    for idx in 0..limit\n    {\n        let element: T = self[idx];\n        if element > max\n        {\n            max_index = idx;\n            max = element;\n        }\n    }\n    max_index\n}",
      "pub fn argmax (&self) -> usize {\n    let (m, n) = self.dim();\n    let mut max_index: usize = 0;\n    let mut max: T = self[max_index];\n\n    let limit: usize = m.max(n);\n\n    debug_assert_ne!(limit, 0);\n\n    for idx in 0..limit {\n        let element: T = self[idx];\n        if element > max {\n            max_index = idx;\n            max = element;\n        }\n    }\n\n    max_index\n}",
      "pub fn argmax (&self) -> usize {\n    let (m, n) = self.dim();\n    let mut max_index: usize = 0;\n    let mut max: T = self[max_index];\n\n    let limit: usize = m.max(n);\n\n    debug_assert_ne!(limit, 0);\n\n    for idx in 0..limit {\n        let element: T = self[idx];\n        if element > max {\n            max_index = idx;\n            max = element;\n        }\n    }\n\n    max_index\n}",
      "pub fn argmax (&self) -> usize {\n    let (m, n) = self.dim();\n    let mut max_index: usize = 0;\n    let mut max: T = self[max_index];\n    let limit: usize = m.max(n);\n    debug_assert_ne!(limit, 0);\n    for idx in 0..limit\n    {\n        let element: T = self[idx];\n        if element > max\n        {\n            max_index = idx;\n            max = element;\n        }\n    }\n    max_index\n}",
      "pub fn argmax (&self) -> usize {\n    let (m, n) = self.dim();\n    let mut max_index: usize = 0;\n    let mut max: T = self[max_index];\n\n    let limit: usize = m.max(n);\n\n    debug_assert_ne!(limit, 0);\n\n    for idx in 0..limit\n    {\n        let element: T = self[idx];\n        if element > max\n        {\n            max_index = idx;\n            max = element;\n        }\n    }\n\n    max_index\n}",
      "pub fn argmax (&self) -> usize {\n    let (m, n) = self.dim();\n    let mut max_index: usize = 0;\n    let mut max: T = self[max_index];\n    let limit: usize = m.max(n);\n    debug_assert_ne!(limit, 0);\n    for idx in 0..limit {\n        let element: T = self[idx];\n        if element > max {\n            max_index = idx;\n            max = element;\n        }\n    }\n    max_index\n}",
      "pub fn argmax (&self) -> usize {\n    let (m, n) = self.dim();\n    let mut max_index: usize = 0;\n    let mut max: T = self[max_index];\n    let limit: usize = m.max(n);\n    debug_assert_ne!(limit, 0);\n    for idx in 0..limit\n    {\n        let element: T = self[idx];\n        if element > max\n        {\n            max_index = idx;\n            max = element;\n        }\n    }\n    max_index\n}",
      "pub fn argmax (&self) -> usize {\n    let (m, n) = self.dim();\n    let mut max_index: usize = 0;\n    let mut max: T = self[max_index];\n    let limit: usize = m.max(n);\n    debug_assert_ne!(limit, 0);\n    for idx in 0..limit\n    {\n        let element: T = self[idx];\n        if element > max\n        {\n            max_index = idx;\n            max = element;\n        }\n    }\n    max_index\n}"
    ],
    [
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    let (m, _n): (usize, usize) = self.dim();\n    debug_assert!(s < m);\n    debug_assert!(e < m);\n    debug_assert!(s <= e);\n\n    let mut v: Vector<T> = Vector::zero(e - s + 1);\n    v = v.transpose();\n\n    for k in s..(e + 1) {\n        v[k - s] = self[k];\n    }\n\n    v\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    let (m, _n): (usize, usize) = self.dim();\n    debug_assert!(s <= e && e < m);\n\n    let mut v: Vector<T> = Vector::zero(e - s + 1);\n\n    for r in s..(e + 1) {\n        v[r - s] = self[r];\n    }\n\n    v\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    let (m, _n): (usize, usize) = self.dim();\n    debug_assert!(s < m);\n    debug_assert!(e < m);\n\n    let mut v: Vector<T> = Vector::zero(e - s + 1);\n\n    for r in s..=(e) {\n        v[r - s] = self[r];\n    }\n    v\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    let (m, _n): (usize, usize) = self.dim();\n    debug_assert!(s <= e && e < m);\n\n    let mut v: Vector<T> = Vector::zero(e - s + 1);\n    for r in s..(e + 1) {\n        v[r - s] = self[r];\n    }\n    v\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    let (m, _n): (usize, usize) = self.dim();\n    debug_assert!(s < m && e < m);\n\n    let mut v: Vector<T> = Vector::zero(e - s + 1);\n    v = v.transpose();\n\n    for k in s..=(e) {\n        v[k] = self[k];\n    }\n\n    v\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    let (m, _n): (usize, usize) = self.dim();\n    debug_assert!(s < m);\n    debug_assert!(e < m);\n\n    let mut v: Vector<T> = Vector::zero(e - s + 1);\n\n    for r in s..=(e) {\n        v[r - s] = self[r];\n    }\n    v\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    let (m, _n): (usize, usize) = self.dim();\n    debug_assert!(s < m && e < m && s <= e);\n\n    let mut v: Vector<T> = Vector::zero(e - s + 1);\n\n    for r in s..=(e) {\n        v[r - s] = self[r];\n    }\n\n    v\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    let (m, _n): (usize, usize) = self.dim();\n    debug_assert!(s < m && e < m);\n\n    let mut v: Vector<T> = Vector::zero(e - s + 1);\n\n    for k in s..(e + 1) {\n        v[k - s] = self[k];\n    }\n\n    v\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    let (m, _n): (usize, usize) = self.dim();\n    debug_assert!(s <= e && e < m);\n\n    let mut v: Vector<T> = Vector::zero(e - s + 1);\n    for r in s..(e + 1) {\n        v[r - s] = self[r];\n    }\n    v\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    let (m, _n): (usize, usize) = self.dim();\n    debug_assert!(s <= e);\n    debug_assert!(e < m);\n\n    let mut v: Vector<T> = Vector::zero(e - s + 1);\n    v = v.transpose();\n\n    for k in s..=(e) {\n        v[k - s] = self[k];\n    }\n\n    v\n}"
    ],
    [
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (rhs_m, _): (usize, usize) = rhs.dim();\n    let (m, _): (usize, usize) = self.dim();\n    debug_assert!(s < m);\n    debug_assert!(rhs_m + s <= m);\n    for i in 0..rhs_m {\n        self.data[s + i] = rhs.data[i];\n    }\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (rhs_m, _): (usize, usize) = rhs.dim();\n    let (m, n): (usize, usize) = self.dim();\n    if m == 1 {\n        debug_assert!(s < n);\n    } else {\n        debug_assert!(s < m);\n    }\n    debug_assert!(rhs_m + s <= m);\n    for i in 0..rhs_m {\n        self.data[s + i] = rhs.data[i];\n    }\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, n): (usize, usize) = self.dim();\n    let (rhs_m, rhs_n): (usize, usize) = rhs.dim();\n    if m == 1 {\n        debug_assert!(s < n);\n        debug_assert!(rhs_m == n - s);\n    } else {\n        debug_assert!(s < m);\n        debug_assert!(rhs_m == m - s);\n    }\n    for i in 0..rhs_m {\n        self.data[s + i] = rhs.data[i];\n    }\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, n): (usize, usize) = self.dim();\n    let (rhs_m, _): (usize, usize) = rhs.dim();\n    debug_assert!(s < m);\n    debug_assert!(rhs_m + s <= m);\n    for i in 0..rhs_m\n    {\n        self.data[s + i] = rhs.data[i];\n    }\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, n): (usize, usize) = rhs.dim();\n    debug_assert!(s < m);\n    for i in 0..n {\n        self[s + i] = rhs[i];\n    }\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (rhs_m, _): (usize, usize) = rhs.dim();\n    let (m, _): (usize, usize) = self.dim();\n\n    debug_assert!(s < m);\n    debug_assert!(rhs_m + s <= m);\n\n    for i in 0..rhs_m {\n        self[s + i] = rhs[i];\n    }\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (rhs_m, _): (usize, usize) = rhs.dim();\n    let (m, _): (usize, usize) = self.dim();\n    if s + rhs_m > m {\n        panic!(\"Index out of bounds\");\n    }\n    for i in 0..rhs_m {\n        self[s + i] = rhs[i];\n    }\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (rhs_m, _): (usize, usize) = rhs.dim();\n    let (m, _): (usize, usize) = self.dim();\n    debug_assert!(s + rhs_m <= m);\n    self.data.set_slice(rhs.data.clone(), s);\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (rhs_m, _): (usize, usize) = rhs.dim();\n    let (_m, n): (usize, usize) = self.dim();\n    if n != rhs_m {\n        panic!(\"Vector and matrix dimensions do not match\");\n    }\n    for i in 0..rhs_m {\n        self[s + i] = rhs[i];\n    }\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, n): (usize, usize) = rhs.dim();\n    let (_m, n): (usize, usize) = self.dim();\n    debug_assert!(n == m);\n    debug_assert!(s < n);\n\n    for k in 0..m {\n        self[k + s] = rhs[k];\n    }\n}"
    ],
    [
      "fn abs (&self) -> Self {\n    let re: T = self.re.abs();\n    let im: T = self.im.abs();\n    let max: T = re.max(im);\n    let min: T = re.min(im);\n    let r: T = max * (T::one() + min / max);\n    Complex {\n        re: r,\n        im: T::zero(),\n    }\n}",
      "fn abs (&self) -> Self {\n    let re: T = self.re.abs();\n    let im: T = self.im.abs();\n    let max: T = re.max(im);\n    let min: T = re.min(im);\n    let ratio: T = min / max;\n    let result: T = max * (T::one() + ratio).sqrt();\n    Complex::new(result, T::zero())\n}",
      "fn abs (&self) -> Self {\n    Complex {\n        re: self.re.abs(),\n        im: self.im.abs(),\n    }\n}",
      "fn abs (&self) -> Self {\n    let re: T = self.re.abs();\n    let im: T = self.im.abs();\n    let max: T = if re > im { re } else { im };\n    let min: T = if re > im { im } else { re };\n    let sign: Sign = if self.re < T::zero() { Sign::Negative } else { Sign::Positive };\n    let abs: T = if min == T::zero() { max } else { max * (min / max).sqrt() };\n    Complex { re: abs, im: T::zero() }\n}",
      "fn abs (&self) -> Self {\n    let re: T = self.re.abs();\n    let im: T = self.im.abs();\n    let max: T = re.max(im);\n    let min: T = re.min(im);\n    let value: T = max * (T::one() + (min / max).sqrt());\n    Complex::new(value, T::zero())\n}",
      "fn abs (&self) -> Self {\n    Complex {\n        re: self.re.abs(),\n        im: self.im.abs(),\n    }\n}",
      "fn abs (&self) -> Self {\n    let re: T = self.re.abs();\n    let im: T = self.im.abs();\n\n    let abs: T = (re * re + im * im).sqrt();\n\n    Complex::new(abs, T::zero())\n}",
      "fn abs (&self) -> Self {\n    let re: T = self.re.abs();\n    let im: T = self.im.abs();\n    let abs: T = (re * re + im * im).sqrt();\n    Complex::new(abs, T::zero())\n}",
      "fn abs (&self) -> Self {\n    let re: T = self.re.abs();\n    let im: T = self.im.abs();\n    let max: T = re.max(im);\n    let min: T = re.min(im);\n    let ratio: T = min / max;\n    let abs: T = max * ratio.sqrt();\n    Complex {\n        re: abs,\n        im: T::zero(),\n    }\n}",
      "fn abs (&self) -> Self {\n    let re: T = self.re.abs();\n    let im: T = self.im.abs();\n    let max: T = re.max(im);\n    let min: T = re.min(im);\n    let result: T = max * (min / max).sqrt();\n    Complex::new(result, T::zero())\n}"
    ],
    [
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty() {\n        panic!()\n    }\n    let n: usize = root.len();\n    let mut coef: Vec<T> = Vec::with_capacity(n + 1);\n    coef.push(T::one());\n    for i in 0..n {\n        let mut c: T = T::one();\n        for j in 0..i {\n            c *= root[i] - root[j];\n        }\n        coef.push(-c);\n    }\n    Polynomial::from_coef(coef)\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty() {\n        panic!()\n    }\n\n    let n = root.len();\n    let mut coef: Vec<T> = vec![T::one(); n + 1];\n\n    for i in 0..n {\n        for j in 0..n {\n            if i != j {\n                coef[i] -= root[j] * coef[n - i];\n            }\n        }\n    }\n\n    Polynomial { coef }\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty() {\n        panic!()\n    }\n\n    let n = root.len();\n\n    let mut coef: Vec<T> = Vec::with_capacity(n + 1);\n\n    coef.push(T::one());\n\n    for i in 0..n {\n        let mut term: T = T::one();\n\n        for j in 0..n {\n            if i != j {\n                term *= -root[j];\n            }\n        }\n\n        coef.push(term);\n    }\n\n    Polynomial { coef }\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty()\n    {\n        panic!()\n    }\n    let n = root.len();\n    let mut coef: Vec<T> = vec![T::one(); n + 1];\n    for i in 0..n\n    {\n        for j in 0..n\n        {\n            if i != j\n            {\n                coef[n - i] = coef[n - i] - root[j] * coef[n - i - 1];\n            }\n        }\n    }\n    Polynomial { coef }\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty()\n    {\n        panic!()\n    }\n\n    let mut coef: Vec<T> = vec![T::one(); root.len() + 1];\n\n    for i in 0..root.len()\n    {\n        for j in 0..root.len()\n        {\n            if i != j\n            {\n                coef[i] = coef[i] * (T::one() - root[j]);\n            }\n        }\n    }\n\n    Polynomial::from_coef(coef)\n}\n\nimpl<T> Polynomial<T>\nwhere\n    T: Field + Scalar,",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty()\n    {\n        panic!()\n    }\n\n    let n: usize = root.len();\n    let mut coef: Vec<T> = vec![T::one(); n + 1];\n\n    for i in 0..n\n    {\n        for j in 0..n\n        {\n            if i != j\n            {\n                coef[i] = coef[i] - root[j] * coef[n - i - 1];\n            }\n        }\n    }\n\n    Polynomial { coef }\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty() {\n        panic!()\n    }\n\n    let mut coef: Vec<T> = Vec::with_capacity(root.len() + 1);\n\n    coef.push(T::one());\n\n    for i in 0..root.len() {\n        let mut factor: T = T::one();\n\n        for j in 0..root.len() {\n            if i != j {\n                factor *= root[j] - root[i];\n            }\n        }\n\n        coef.push(factor);\n    }\n\n    Polynomial::from_coef(coef)\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty() {\n        panic!()\n    }\n\n    let mut coef: Vec<T> = Vec::with_capacity(root.len() + 1);\n    coef.push(T::one());\n\n    for i in 0..root.len() {\n        let mut temp: T = T::zero();\n        for j in 0..root.len() {\n            if i == j {\n                continue;\n            }\n            temp = temp - root[j] * coef[i - j];\n        }\n        coef.push(temp);\n    }\n\n    Polynomial { coef }\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty() {\n        panic!()\n    }\n    let mut coef: Vec<T> = vec![T::one(); root.len() + 1];\n    for i in 0..root.len() {\n        for j in 0..root.len() {\n            if i != j {\n                coef[i + 1] -= root[j] * coef[i]\n            }\n        }\n    }\n    Polynomial { coef }\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty()\n    {\n        panic!()\n    }\n    let mut coef: Vec<T> = vec![T::one(); root.len() + 1];\n    for i in 0..root.len()\n    {\n        coef[0] = -root[i];\n        for j in 1..root.len() + 1\n        {\n            coef[j] = coef[j] - root[i] * coef[j - 1];\n        }\n    }\n    Polynomial::from_coef(coef)\n}"
    ],
    [
      "pub fn eval (&self, x: T) -> T {\n    let mut res: T = T::zero();\n    for (i, v) in self.coef.iter().enumerate()\n    {\n        res += *v * x.pow(i as u32);\n    }\n    res\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut res: T = T::zero();\n    for (i, v) in self.coef.iter().enumerate()\n    {\n        res += v * x.pow(i as u32);\n    }\n    res\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut res: T = T::zero();\n    for (i, v_i) in self.coef.iter().enumerate()\n    {\n        res += *v_i * x.pow(i as u32);\n    }\n    res\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut res: T = T::zero();\n    for (i, v_i) in self.coef.iter().enumerate()\n    {\n        res += *v_i * x.pow(i as u32);\n    }\n    res\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut res: T = T::zero();\n    for (i, c) in self.coef.iter().enumerate()\n    {\n        res += *c * x.pow(i as u32);\n    }\n    res\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut result: T = T::zero();\n    for (i, c) in self.coef.iter().enumerate()\n    {\n        result += *c * x.pow(i as u32);\n    }\n    result\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut result: T = T::zero();\n    for (i, coef) in self.coef.iter().enumerate()\n    {\n        result += coef * x.pow(i as u32);\n    }\n    result\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut res: T = T::zero();\n    for (i, v_i) in self.coef.iter().enumerate()\n    {\n        res += *v_i * x.pow(i as u32);\n    }\n    res\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut res: T = T::zero();\n    for (i, v) in self.coef.iter().enumerate()\n    {\n        res += *v * x.pow(i as u32);\n    }\n    res\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut res: T = T::zero();\n    for (i, v_i) in self.coef.iter().enumerate()\n    {\n        res += *v_i * x.pow(i as u32);\n    }\n    res\n}"
    ],
    [
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut diff: Vec<T> = Vec::with_capacity(self.coef.len() - 1);\n\n    for i in 1..self.coef.len()\n    {\n        diff.push(self.coef[i] * T::from_f64(i as f64));\n    }\n\n    Polynomial { coef: diff }\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut diff: Vec<T> = Vec::with_capacity(self.degree());\n\n    for (i, a_i) in self.coef.iter().enumerate() {\n        if i == 0 {\n            diff.push(*a_i);\n        } else {\n            diff.push(*a_i * T::from_f64((i + 1) as f64));\n        }\n    }\n\n    Polynomial { coef: diff }\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut diff: Vec<T> = Vec::new();\n\n    for (i, a_i) in self.coef.iter().enumerate() {\n        diff.push(*a_i * T::from_f64((i + 1) as f64));\n    }\n\n    Polynomial { coef: diff }\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut diff: Vec<T> = Vec::new();\n\n    for (i, a_i) in self.coef.iter().enumerate() {\n        diff.push(*a_i * T::from_f64((i + 1) as f64));\n    }\n\n    Polynomial { coef: diff }\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut diff: Vec<T> = Vec::with_capacity(self.coef.len() - 1);\n\n    for (i, a_i) in self.coef.iter().enumerate() {\n        if i == 0 {\n            continue;\n        }\n\n        diff.push(*a_i * T::from_f64((i as f64) as f64));\n    }\n\n    Polynomial { coef: diff }\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut diff: Vec<T> = Vec::with_capacity(self.degree());\n\n    for (i, a_i) in self.coef.iter().enumerate() {\n        if i == 0 {\n            diff.push(T::zero());\n        } else {\n            diff.push(*a_i * T::from_f64((i as f64) as f64));\n        }\n    }\n\n    Polynomial { coef: diff }\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut diff: Vec<T> = Vec::with_capacity(self.degree());\n    for (i, a_i) in self.coef.iter().enumerate()\n    {\n        diff.push(*a_i * T::from_f64((i + 1) as f64));\n    }\n\n    Polynomial { coef: diff }\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut diff: Vec<T> = Vec::new();\n    for (i, a_i) in self.coef.iter().enumerate() {\n        diff.push(*a_i * T::from_f64((i + 1) as f64));\n    }\n\n    Polynomial {\n        coef: Polynomial::reduce_coef(diff),\n    }\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut diff: Vec<T> = Vec::new();\n    for i in 0..self.coef.len()\n    {\n        diff.push(self.coef[i] * T::from_f64((i + 1) as f64));\n    }\n\n    Polynomial { coef: diff }\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut diff: Vec<T> = Vec::with_capacity(self.degree());\n    for i in 0..self.degree()\n    {\n        diff.push(self.coef[i] * (self.degree() - i) as f64);\n    }\n\n    Polynomial { coef: diff }\n}"
    ],
    [
      "pub fn integrate (&self) -> Polynomial<T> {\n    let mut coef: Vec<T> = Vec::with_capacity(self.degree() + 1);\n    for i in 0..(self.degree() + 1) {\n        coef.push(self.coef[i] * (i as f64 + 1.0).into());\n    }\n    Polynomial { coef }\n}",
      "pub fn integrate (&self) -> Polynomial<T> {\n    let mut coef: Vec<T> = Vec::new();\n    for (i, v_i) in self.coef.iter().enumerate() {\n        coef.push(*v_i / (i as f64 + 1.0));\n    }\n    Polynomial { coef }\n}",
      "pub fn integrate (&self) -> Polynomial<T> {\n    let mut coef: Vec<T> = Vec::new();\n    for i in 0..self.coef.len() {\n        coef.push(self.coef[i].integrate());\n    }\n    Polynomial { coef }\n}",
      "pub fn integrate (&self) -> Polynomial<T> where\n    T: MagmaMul + MonoidAdd + Scalar,\n{\n    let mut res: Vec<T> = Vec::new();\n    for (i, v_i) in self.coef.iter().enumerate() {\n        res.push(*v_i * T::from_f64(i as f64 + 1.0));\n    }\n    Polynomial { coef: res }\n}",
      "pub fn integrate (&self) -> Polynomial<T> {\n    let mut coef_diff: Vec<T> = Vec::new();\n    for i in 0..self.degree() {\n        coef_diff.push(self.coef[i] * (i as f64 + 1.0));\n    }\n    Polynomial { coef: coef_diff }\n}",
      "pub fn integrate (&self) -> Polynomial<T> {\n    let mut coef_diff: Vec<T> = Vec::new();\n    for i in 0..self.degree() {\n        coef_diff.push(self.coef[i]);\n    }\n    Polynomial { coef: coef_diff }\n}",
      "pub fn integrate (&self) -> Polynomial<T> where\n        T: Field + Scalar + AbsDiffEq<Epsilon = T>,\n{\n    let mut coef_diff: Vec<T> = vec![T::zero(); self.degree() + 1];\n\n    for i in 0..self.degree() + 1 {\n        coef_diff[i] = self.coef[i] * (T::from_u32(i + 1).unwrap());\n    }\n\n    Polynomial { coef: coef_diff }\n}",
      "pub fn integrate (&self) -> Polynomial<T> {\n    let mut res: Vec<T> = Vec::new();\n    for (i, v_i) in self.coef.iter().enumerate() {\n        res.push(v_i * (i as T + T::one()));\n    }\n    Polynomial { coef: res }\n}",
      "pub fn integrate (&self) -> Polynomial<T> {\n    let mut coef: Vec<T> = Vec::new();\n    let mut degree = self.degree();\n    for i in 0..(degree + 1) {\n        coef.push(self.coef[i] * (degree - i as u32 + 1) as T);\n    }\n    Polynomial { coef }\n}",
      "pub fn integrate (&self) -> Polynomial<T> where\n    T: Field + Scalar + AbsDiffEq<Epsilon = T>,\n{\n    let mut coef: Vec<T> = Vec::new();\n    for i in 0..self.degree() + 1 {\n        coef.push(self.coef[i] * (i as f64 + 1.0).recip());\n    }\n\n    Polynomial { coef }\n}"
    ],
    [
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    match self.elem_counts.entry(val) {\n        Entry::Vacant(entry) => {\n            entry.insert(n);\n            self.size += n;\n        }\n        Entry::Occupied(mut entry) => {\n            let count = entry.get_mut();\n            *count += n;\n            self.size += n;\n        }\n    }\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    match self.elem_counts.entry(val) {\n        Entry::Vacant(entry) => {\n            entry.insert(n);\n            self.size += n;\n        },\n        Entry::Occupied(mut entry) => {\n            let count = entry.get_mut();\n            *count += n;\n            self.size += n;\n        }\n    }\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    let entry = self.elem_counts.entry(val);\n    match entry {\n        hash_map::Entry::Vacant(vacant) => {\n            vacant.insert(n);\n            self.size += n;\n        }\n        hash_map::Entry::Occupied(occupied) => {\n            let count = occupied.into_mut();\n            *count += n;\n            self.size += n;\n        }\n    }\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    match self.elem_counts.entry(val) {\n        Entry::Vacant(entry) => {\n            entry.insert(n);\n            self.size += n;\n        }\n        Entry::Occupied(mut entry) => {\n            let count = entry.get_mut();\n            *count += n;\n            self.size += n;\n        }\n    }\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    match self.elem_counts.entry(val) {\n        Entry::Vacant(entry) => {\n            entry.insert(n);\n            self.size += n;\n        }\n        Entry::Occupied(mut entry) => {\n            let count = entry.get_mut();\n            *count += n;\n            self.size += n;\n        }\n    }\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    match self.elem_counts.entry(val) {\n        Entry::Vacant(entry) => {\n            entry.insert(n);\n            self.size += n;\n        }\n        Entry::Occupied(mut entry) => {\n            let count = entry.get_mut();\n            *count += n;\n            self.size += n;\n        }\n    }\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    match self.elem_counts.entry(val) {\n        Entry::Vacant(entry) => {\n            entry.insert(n);\n            self.size += n;\n        },\n        Entry::Occupied(mut entry) => {\n            let count = entry.get_mut();\n            *count += n;\n            self.size += n;\n        },\n    }\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    let entry = self.elem_counts.entry(val);\n    match entry {\n        Entry::Occupied(mut entry) => {\n            let count = entry.get_mut();\n            *count += n;\n        }\n        Entry::Vacant(entry) => {\n            entry.insert(n);\n        }\n    }\n    self.size += n;\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    match self.elem_counts.entry(val) {\n        Entry::Vacant(entry) => {\n            entry.insert(n);\n            self.size += n;\n        }\n        Entry::Occupied(mut entry) => {\n            let count = entry.get_mut();\n            *count += n;\n            self.size += n;\n        }\n    }\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    let entry = self.elem_counts.entry(val);\n    match entry {\n        Entry::Vacant(v) => {\n            v.insert(n);\n            self.size += n;\n        }\n        Entry::Occupied(mut o) => {\n            let count = o.get_mut();\n            *count += n;\n            self.size += n;\n        }\n    }\n}"
    ],
    [
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    let mut removed = 0;\n    if let Some(count) = self.elem_counts.get_mut(val) {\n        if *count >= times {\n            *count -= times;\n            removed = times;\n        } else {\n            removed = *count;\n            self.remove(val);\n        }\n    }\n    self.size -= removed;\n    removed\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    match self.elem_counts.entry(val.clone()) {\n        Entry::Vacant(_) => 0,\n        Entry::Occupied(mut view) => {\n            let count = view.get_mut();\n            if count > &times {\n                *count -= times;\n                times\n            } else {\n                let result = *count;\n                view.remove();\n                result\n            }\n        }\n    }\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    match self.elem_counts.entry(val.clone()) {\n        Entry::Vacant(_) => 0,\n        Entry::Occupied(mut view) => {\n            let count = view.get_mut();\n            if *count >= times {\n                *count -= times;\n                self.size -= times;\n                times\n            } else {\n                self.size -= *count;\n                *count = 0;\n                *count\n            }\n        }\n    }\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    match self.elem_counts.entry(val.clone()) {\n        Entry::Vacant(_) => 0,\n        Entry::Occupied(mut view) => {\n            let count = view.get_mut();\n            let removed = count.min(times);\n            *count -= removed;\n            self.size -= removed;\n            if *count == 0 {\n                view.remove_entry();\n            }\n            removed\n        }\n    }\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    match self.elem_counts.entry(val.clone()) {\n        Entry::Vacant(_) => 0,\n        Entry::Occupied(mut view) => {\n            let count = view.get_mut();\n            let to_remove = if times < *count {\n                *count -= times;\n                times\n            } else {\n                let result = *count;\n                *count = 0;\n                result\n            };\n            self.size -= to_remove;\n            to_remove\n        }\n    }\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    match self.elem_counts.entry(val.clone()) {\n        Entry::Vacant(_) => 0,\n        Entry::Occupied(mut view) => {\n            let count = view.get_mut();\n            if *count >= times {\n                *count -= times;\n                self.size -= times;\n                times\n            } else {\n                self.size -= *count;\n                *count = 0;\n                view.remove();\n                *count\n            }\n        }\n    }\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    let mut removed = 0;\n    match self.elem_counts.entry(val.clone()) {\n        Entry::Vacant(_) => {\n            return removed;\n        }\n        Entry::Occupied(mut view) => {\n            let count = view.get_mut();\n            if *count >= times {\n                *count -= times;\n                removed = times;\n            } else {\n                removed = *count;\n                *count = 0;\n            }\n            if *count == 0 {\n                view.remove();\n            }\n        }\n    }\n    self.size -= removed;\n    removed\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    match self.elem_counts.entry(val.clone()) {\n        Entry::Vacant(_) => 0,\n        Entry::Occupied(mut view) => {\n            let count = view.get_mut();\n            let ret = *count;\n            *count -= times;\n            if *count == 0 {\n                view.remove();\n            }\n            ret\n        }\n    }\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    match self.elem_counts.entry(val.clone()) {\n        Entry::Vacant(_) => 0,\n        Entry::Occupied(mut view) => {\n            let count = view.get_mut();\n            let removed = if times < *count {\n                *count -= times;\n                times\n            } else {\n                *count = 0;\n                *count\n            };\n            self.size -= removed;\n            removed\n        }\n    }\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    match self.elem_counts.entry(val.clone()) {\n        Entry::Vacant(_) => 0,\n        Entry::Occupied(mut view) => {\n            let count = view.get_mut();\n            let removed = count.min(times);\n            *count -= removed;\n            if *count == 0 {\n                view.remove();\n            }\n            removed\n        }\n    }\n}"
    ],
    [
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret = self.clone();\n    for val in rhs.distinct_elements() {\n        ret.insert_times(val, rhs.count_of(val));\n    }\n    ret\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret = self.clone();\n    for val in rhs.distinct_elements() {\n        ret.insert_times(val, rhs.count_of(val));\n    }\n    ret\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret = self.clone();\n    for val in rhs.distinct_elements() {\n        ret.insert_times(val, rhs.count_of(val));\n    }\n    ret\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret = self.clone();\n    for val in rhs.distinct_elements() {\n        ret.insert_times(val, rhs.count_of(val));\n    }\n    ret\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret = self.clone();\n    for val in rhs.distinct_elements() {\n        let count = rhs.count_of(val);\n        ret.insert_times(val, count);\n    }\n    ret\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret = self.clone();\n    for val in rhs.distinct_elements() {\n        ret.insert_times(val, rhs.count_of(val));\n    }\n    ret\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret = self.clone();\n    for val in rhs.distinct_elements() {\n        let count = rhs.count_of(val);\n        ret.insert_times(val, count);\n    }\n    ret\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret = self.clone();\n    for val in rhs.distinct_elements() {\n        ret.insert_times(val, rhs.count_of(val));\n    }\n    ret\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret = self.clone();\n    for val in rhs.distinct_elements() {\n        let count = rhs.count_of(val);\n        ret.insert_times(val, count);\n    }\n    ret\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret = self.clone();\n    for val in rhs.distinct_elements() {\n        ret.insert_times(val, rhs.count_of(val));\n    }\n    ret\n}"
    ],
    [
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        let times = count.min(rhs.count_of(val));\n        if times > 0 {\n            ret.insert_times((*val).clone(), times);\n        }\n    }\n    ret\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        let times = rhs.count_of(val);\n        if times < count {\n            ret.insert_times((*val).clone(), count - times);\n        }\n    }\n    ret\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        if count > rhs.count_of(val) {\n            ret.insert_times((*val).clone(), count - rhs.count_of(val));\n        }\n    }\n    ret\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        if count > rhs.count_of(val) {\n            ret.insert_times((*val).clone(), count - rhs.count_of(val));\n        }\n    }\n    ret\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        if rhs.contains(val) {\n            let rhs_count = rhs.count_of(val);\n            if rhs_count < count {\n                ret.insert_times((*val).clone(), count - rhs_count);\n            }\n        } else {\n            ret.insert_times((*val).clone(), count);\n        }\n    }\n    ret\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        let rhs_count = rhs.count_of(val);\n        if count > rhs_count {\n            ret.insert_times((*val).clone(), count - rhs_count);\n        }\n    }\n    ret\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        if count > rhs.count_of(val) {\n            ret.insert_times((*val).clone(), count - rhs.count_of(val));\n        }\n    }\n    ret\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        let rhs_count = rhs.count_of(val);\n        if count > rhs_count {\n            ret.insert_times((*val).clone(), count - rhs_count);\n        }\n    }\n    ret\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        if rhs.contains(val) {\n            let rhs_count = rhs.count_of(val);\n            if count > rhs_count {\n                ret.insert_times((*val).clone(), count - rhs_count);\n            }\n        } else {\n            ret.insert_times((*val).clone(), count);\n        }\n    }\n    ret\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        let rhs_count = rhs.count_of(val);\n        if count > rhs_count {\n            ret.insert_times((*val).clone(), count - rhs_count);\n        }\n    }\n    ret\n}"
    ],
    [
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(b) => Cow::Borrowed(RawStr::new(b)),\n        Cow::Owned(b) => Cow::Owned(RawStr::new(b))\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(b) => Cow::Borrowed(RawStr::new(b)),\n        Cow::Owned(b) => Cow::Owned(RawStr::new(b))\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(b) => Cow::Borrowed(RawStr::new(b)),\n        Cow::Owned(b) => Cow::Owned(RawStr::new(b))\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(b) => Cow::Borrowed(RawStr::new(b)),\n        Cow::Owned(b) => Cow::Owned(RawStr::new(b).into_owned())\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(b) => Cow::Borrowed(RawStr::new(b)),\n        Cow::Owned(b) => Cow::Owned(RawStr::new(b).into_owned())\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(b) => Cow::Borrowed(RawStr::new(b)),\n        Cow::Owned(b) => Cow::Owned(RawStr::new(b).into_owned())\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(b) => Cow::Borrowed(RawStr::new(b)),\n        Cow::Owned(b) => Cow::Owned(RawStr::new(b))\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(b) => Cow::Borrowed(RawStr::new(b)),\n        Cow::Owned(b) => Cow::Owned(RawStr::new(b))\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(b) => Cow::Borrowed(RawStr::new(b)),\n        Cow::Owned(b) => Cow::Owned(RawStr::new(b))\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(b) => Cow::Borrowed(RawStr::new(b)),\n        Cow::Owned(b) => Cow::Owned(RawStr::new(b))\n    }\n}"
    ],
    [
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let string = self.as_str();\n    let mut allocated = String::new(); // this is allocation free\n    for i in memchr::memchr_iter(b'&', string.as_bytes()) {\n        if allocated.is_empty() {\n            allocated = string.into();\n        }\n\n        unsafe { allocated.as_bytes_mut()[i] = b'&'; }\n    }\n\n    match allocated.is_empty() {\n        true => Cow::Borrowed(string),\n        false => Cow::Owned(allocated)\n    }\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let string = self.as_str();\n    let mut allocated = String::new(); // this is allocation free\n    for i in memchr::memchr_iter(b'&', string.as_bytes()) {\n        if allocated.is_empty() {\n            allocated = string.into();\n        }\n\n        unsafe { allocated.as_bytes_mut()[i] = b'&'; }\n    }\n\n    match allocated.is_empty() {\n        true => Cow::Borrowed(string),\n        false => Cow::Owned(allocated)\n    }\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let string = self.as_str();\n    let mut allocated = String::new(); // this is allocation free\n    for i in memchr::memchr_iter(b'&', string.as_bytes()) {\n        if allocated.is_empty() {\n            allocated = string.into();\n        }\n\n        unsafe { allocated.as_bytes_mut()[i] = b'&'; }\n    }\n\n    match allocated.is_empty() {\n        true => Cow::Borrowed(string),\n        false => Cow::Owned(allocated)\n    }\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let string = self.as_str();\n    let mut allocated = String::new(); // this is allocation free\n    for i in memchr::memchr_iter(b'&', string.as_bytes()) {\n        if allocated.is_empty() {\n            allocated = string.into();\n        }\n\n        unsafe { allocated.as_bytes_mut()[i] = b'&'; }\n    }\n\n    match allocated.is_empty() {\n        true => Cow::Borrowed(string),\n        false => Cow::Owned(allocated)\n    }\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let string = self.as_str();\n    let mut allocated = String::new(); // this is allocation free\n    for i in memchr::memchr_iter(b'&', string.as_bytes()) {\n        if allocated.is_empty() {\n            allocated = string.into();\n        }\n\n        unsafe { allocated.as_bytes_mut()[i] = b'&'; }\n    }\n\n    match allocated.is_empty() {\n        true => Cow::Borrowed(string),\n        false => Cow::Owned(allocated)\n    }\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let string = self.as_str();\n    let mut allocated = String::new(); // this is allocation free\n    for i in memchr::memchr_iter(b'&', string.as_bytes()) {\n        if allocated.is_empty() {\n            allocated = string.into();\n        }\n\n        unsafe { allocated.as_bytes_mut()[i] = b'&'; }\n    }\n\n    match allocated.is_empty() {\n        true => Cow::Borrowed(string),\n        false => Cow::Owned(allocated)\n    }\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let string = self.as_str();\n    let mut allocated = String::new(); // this is allocation free\n    for i in memchr::memchr_iter(b'&', string.as_bytes()) {\n        if allocated.is_empty() {\n            allocated = string.into();\n        }\n\n        unsafe { allocated.as_bytes_mut()[i] = b'&'; }\n    }\n\n    match allocated.is_empty() {\n        true => Cow::Borrowed(string),\n        false => Cow::Owned(allocated)\n    }\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let string = self.as_str();\n    let mut allocated = String::new(); // this is allocation free\n    for i in memchr::memchr_iter(b'&', string.as_bytes()) {\n        if allocated.is_empty() {\n            allocated = string.into();\n        }\n\n        unsafe { allocated.as_bytes_mut()[i] = b'&'; }\n    }\n\n    match allocated.is_empty() {\n        true => Cow::Borrowed(string),\n        false => Cow::Owned(allocated)\n    }\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let string = self.as_str();\n    let mut allocated = String::new(); // this is allocation free\n    for i in memchr::memchr_iter(b'&', string.as_bytes()) {\n        if allocated.is_empty() {\n            allocated = string.into();\n        }\n\n        unsafe { allocated.as_bytes_mut()[i] = b'&'; }\n    }\n\n    match allocated.is_empty() {\n        true => Cow::Borrowed(string),\n        false => Cow::Owned(allocated)\n    }\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let string = self.as_str();\n    let mut allocated = String::new(); // this is allocation free\n    for i in memchr::memchr_iter(b'&', string.as_bytes()) {\n        if allocated.is_empty() {\n            allocated = string.into();\n        }\n\n        unsafe { allocated.as_bytes_mut()[i] = b'&'; }\n    }\n\n    match allocated.is_empty() {\n        true => Cow::Borrowed(string),\n        false => Cow::Owned(allocated)\n    }\n}"
    ],
    [
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let mut i = 0;\n    let bytes = self.as_bytes();\n    while i < bytes.len() {\n        if bytes[i] == b {\n            return (self.slice(0, i), self.slice(i + 1, self.len()));\n        }\n\n        i += 1;\n    }\n\n    (self, RawStr::new(\"\"))\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    if b < 0x80 {\n        let bytes = self.as_bytes();\n        match memchr::memchr(b, bytes) {\n            Some(i) => (&self[..i], &self[i + 1..]),\n            None => (self, &self[..0])\n        }\n    } else {\n        (self, &self[..0])\n    }\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let mut i = 0;\n    let bytes = self.as_bytes();\n    while i < bytes.len() {\n        if bytes[i] == b {\n            return (self.slice(0, i), self.slice(i + 1, self.len()));\n        }\n\n        i += 1;\n    }\n\n    (self, RawStr::new(\"\"))\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    if b < 0x80 {\n        let mut i = 0;\n        let bytes = self.as_bytes();\n        while i < bytes.len() {\n            if bytes[i] == b {\n                return (self.slice(0, i), self.slice(i + 1, self.len()));\n            }\n\n            i += 1;\n        }\n    }\n\n    (self, RawStr::new(\"\"))\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let bytes = self.as_bytes();\n    let mut i = 0;\n    while i < bytes.len() {\n        if bytes[i] == b {\n            return (self.slice(0, i), self.slice(i + 1, self.len()));\n        }\n\n        i += 1;\n    }\n\n    (self, RawStr::new(\"\"))\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let mut i = 0;\n    let bytes = self.as_bytes();\n    while i < bytes.len() {\n        if bytes[i] == b {\n            return (self.slice(0, i), self.slice(i + 1, self.len()));\n        }\n\n        i += 1;\n    }\n\n    (self, RawStr::new(\"\"))\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let bytes = self.as_bytes();\n    let mut i = 0;\n    while i < bytes.len() {\n        if bytes[i] == b {\n            break;\n        }\n\n        i += 1;\n    }\n\n    let before = &self[..i];\n    let after = &self[i..];\n    (before, after)\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    if b < 0x80 {\n        let mut i = 0;\n        let bytes = self.as_bytes();\n        while i < bytes.len() {\n            if bytes[i] == b {\n                return (self.slice(0, i), self.slice(i + 1, self.len()));\n            }\n\n            i += 1;\n        }\n    }\n\n    (self, RawStr::new(\"\"))\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let bytes = self.as_bytes();\n    let mut i = 0;\n    while i < bytes.len() {\n        if bytes[i] == b {\n            break;\n        }\n\n        i += 1;\n    }\n\n    let before = RawStr::new(&bytes[..i]);\n    let after = RawStr::new(&bytes[i..]);\n    (before, after)\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    if b < 0x80 {\n        let bytes = self.as_bytes();\n        match bytes.iter().position(|&c| c == b) {\n            Some(i) => (&self[..i], &self[i + 1..]),\n            None => (self, &self[..0])\n        }\n    } else {\n        (self, &self[..0])\n    }\n}"
    ],
    [
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Get | Method::Head | Method::Connect | Method::Trace | Method::Options => false,\n        _ => true,\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Get | Method::Head | Method::Connect | Method::Trace | Method::Options => false,\n        Method::Put | Method::Post | Method::Delete | Method::Patch => true\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Put | Method::Post | Method::Delete | Method::Patch => true,\n        _ => false,\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Get | Method::Head | Method::Connect | Method::Trace | Method::Options => false,\n        _ => true\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Put | Method::Post | Method::Delete | Method::Patch => true,\n        _ => false\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Get | Method::Head | Method::Connect | Method::Trace | Method::Options => false,\n        Method::Put | Method::Post | Method::Delete | Method::Patch => true,\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Put | Method::Post | Method::Delete | Method::Patch => true,\n        _ => false\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Put | Method::Post | Method::Delete | Method::Patch => true,\n        _ => false\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Get | Method::Head | Method::Connect | Method::Trace | Method::Options => false,\n        _ => true\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Get | Method::Head | Method::Connect | Method::Trace | Method::Options => false,\n        _ => true\n    }\n}"
    ],
    [
      "pub const fn is_valid_name (name: &str) -> bool {\n    if name.is_empty() {\n        return false;\n    }\n\n    let mut iter = name.chars();\n    let first = iter.next().unwrap();\n    if !is_valid_start(&first) {\n        return false;\n    }\n\n    for c in iter {\n        if !is_valid_continue(&c) {\n            return false;\n        }\n    }\n\n    true\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    name.chars().all(is_valid_token)\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    name.bytes().all(|b| b.is_ascii_alphanumeric() || b\"!#$%&'*+-.^_`|~\".contains(&b))\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    !name.is_empty() && name.bytes().all(|b| is_valid_token(&b as &char))\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    !name.is_empty()\n        && name.chars().all(|c| c.is_ascii_alphanumeric() || \"!#$%&'*+-.^_`|~\".contains(c))\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    if name.is_empty() { return false; }\n    for c in name.chars() {\n        if !is_valid_token(&c) { return false; }\n    }\n    true\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    if name.is_empty() {\n        return false;\n    }\n\n    for (i, byte) in name.as_bytes().iter().enumerate() {\n        if i == 0 {\n            if !is_valid_start(byte) {\n                return false;\n            }\n        } else {\n            if !is_valid_continue(byte) {\n                return false;\n            }\n        }\n    }\n\n    true\n}\n\n#[inline(always)]\nfn is_valid_start(byte: &u8) -> bool {\n    matches!(byte, b'!'..=b'~' | b'A'..=b'Z' | b'a'..=b'z')\n}\n\n#[inline(always)]\nfn is_valid_continue(byte: &u8) -> bool {\n    is_valid_start(byte) || matches!(byte, b'0'..=b'9' | b' ' | b'\\t')\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    !name.is_empty() && name.bytes().all(is_valid_token)\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    name.bytes().all(|b| b.is_ascii_alphanumeric() || matches!(b, b'!' | b'#' | b'$' | b'%' | b'&' | b'\\'' | b'*' | b'+' | b'-' | b'.' | b'^' | b'_' | b'`' | b'|' | b'~'))\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    name.chars().all(|c| {\n        matches!(c, '!' | '#' | '$' | '%' | '&' | '\\'' | '*'\n            | '+' | '-' | '.' | '^' | '_' | '`' | '|' | '~'\n            | '0'..='9' | 'A'..='Z' | 'a'..='z')\n    })\n}"
    ],
    [
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    self.headers.entry(Uncased::new(name)).or_insert_with(Vec::new).append(values);\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    self.headers.entry(Uncased::new(name)).or_insert_with(Vec::new).append(values);\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    self.headers.entry(Uncased::new(name)).or_insert_with(Vec::new).append(values);\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    self.headers.entry(Uncased::new(name)).or_insert_with(Vec::new).append(values);\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n        self.headers.entry(Uncased::new(name))\n            .or_insert_with(Vec::new)\n            .append(values);\n        values.clear();\n    }",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n        self.headers.entry(Uncased::new(name)).or_insert_with(Vec::new).append(values);\n        values.clear();\n    }",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    self.headers.entry(Uncased::new(name)).or_insert_with(Vec::new).append(values);\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    self.headers.entry(Uncased::new(name)).or_insert_with(Vec::new).append(values);\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    self.headers.entry(Uncased::new(name)).or_insert_with(Vec::new).append(values);\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n        self.headers.entry(Uncased::new(name))\n            .or_insert_with(Vec::new)\n            .append(values);\n}"
    ],
    [
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}"
    ],
    [
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}"
    ],
    [
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}"
    ],
    [
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    let mut i = 0;\n    for (k, v) in self.iter() {\n        if i == n {\n            return Some((k, v));\n        }\n\n        i += 1;\n    }\n\n    None\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    let mut i = 0;\n    for (key, val) in self.segments() {\n        if i == n {\n            return Some((key, val));\n        }\n\n        i += 1;\n    }\n\n    None\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    let mut i = 0;\n    for (k, v) in self.iter() {\n        if i == n {\n            return Some((k, v));\n        }\n\n        i += 1;\n    }\n\n    None\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    if n >= self.len() {\n        return None;\n    }\n\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    let mut found = false;\n    let mut found_value = false;\n    let mut value_start = 0;\n    let mut value_end = 0;\n    let mut key = \"\";\n    let mut value = \"\";\n    let bytes = self.as_bytes();\n    while i < bytes.len() {\n        if j == n {\n            found = true;\n        }\n\n        if !found {\n            if bytes[i] == b'&' {\n                j += 1;\n            }\n        } else {\n            if bytes[i] == b'=' {\n                found_value = true;\n                value_start = i + 1;\n            }\n        }\n\n        if found_value {\n            if bytes[i] == b'&' {\n                value_end = i;\n                break;\n            }\n        }\n\n        i += 1;\n    }\n\n    if found {\n        if found_value {\n            key = unsafe { std::str::from_utf8_unchecked(&bytes[k..j]) };\n            value = unsafe { std::str::from_utf8_unchecked(&bytes[value_start..value_end]) };\n        } else {\n            key = unsafe { std::str::from_utf8_unchecked(&bytes[k..j]) };\n            value = \"\";\n        }\n\n        return Some((key, value));\n    }\n\n    None\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    let mut i = 0;\n    for (key, value) in self.iter() {\n        if i == n {\n            return Some((key, value));\n        }\n\n        i += 1;\n    }\n\n    None\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    if n >= self.len() {\n        return None;\n    }\n\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    let mut key = None;\n    let mut value = None;\n\n    while i < self.len() {\n        if j == n {\n            key = Some(self.get_unchecked(k..i));\n            k = i + 1;\n        }\n\n        if j == n + 1 {\n            value = Some(self.get_unchecked(k..i));\n            break;\n        }\n\n        if self.as_bytes()[i] == b'&' {\n            j += 1;\n        }\n\n        i += 1;\n    }\n\n    if let Some(key) = key {\n        if let Some(value) = value {\n            return Some((key, value));\n        }\n\n        return Some((key, \"\"));\n    }\n\n    None\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    let mut i = 0;\n    for (k, v) in self.iter() {\n        if i == n {\n            return Some((k, v));\n        }\n\n        i += 1;\n    }\n\n    None\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    if n >= self.len() {\n        return None;\n    }\n\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    let mut l = 0;\n    let mut m = 0;\n    let mut n = 0;\n    let mut o = 0;\n    let mut p = 0;\n    let mut q = 0;\n    let mut r = 0;\n    let mut s = 0;\n    let mut t = 0;\n    let mut u = 0;\n    let mut v = 0;\n    let mut w = 0;\n    let mut x = 0;\n    let mut y = 0;\n    let mut z = 0;\n\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    let mut l = 0;\n    let mut m = 0;\n    let mut n = 0;\n    let mut o = 0;\n    let mut p = 0;\n    let mut q = 0;\n    let mut r = 0;\n    let mut s = 0;\n    let mut t = 0;\n    let mut u = 0;\n    let mut v = 0;\n    let mut w = 0;\n    let mut x = 0;\n    let mut y = 0;\n    let mut z = 0;\n\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    let mut l = 0;\n    let mut m = 0;\n    let mut n = 0;\n    let mut o = 0;\n    let mut p = 0;\n    let mut q = 0;\n    let mut r = 0;\n    let mut s = 0;\n    let mut t = 0;\n    let mut u = 0;\n    let mut v = 0;\n    let mut w = 0;\n    let mut x = 0;\n    let mut y = 0;\n    let mut z = 0;\n\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    let mut i = 0;\n    for (key, value) in self.segments() {\n        if i == n {\n            return Some((key, value));\n        }\n\n        i += 1;\n    }\n\n    None\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    let mut i = 0;\n    let mut start = 0;\n    let mut end = 0;\n    let mut key = 0;\n    let mut value = 0;\n    let mut decoded_key = 0;\n    let mut decoded_value = 0;\n    let mut decoded_key_start = 0;\n    let mut decoded_value_start = 0;\n    let mut decoded_key_end = 0;\n    let mut decoded_value_end = 0;\n    let mut key_start = 0;\n    let mut value_start = 0;\n    let mut key_end = 0;\n    let mut value_end = 0;\n    let mut key_len = 0;\n    let mut value_len = 0;\n    let mut decoded_key_len = 0;\n    let mut decoded_value_len = 0;\n    let mut decoded_key_str = \"\";\n    let mut decoded_value_str = \"\";\n    let mut decoded_key_cow = \"\";\n    let mut decoded_value_cow = \"\";\n    let mut decoded_key_cow_str = \"\";\n    let mut decoded_value_cow_str = \"\";\n    let mut decoded_key_cow_cow = \"\";\n    let mut decoded_value_cow_cow = \"\";\n    let mut decoded_key_cow_cow_str = \"\";\n    let mut decoded_value_cow_cow_str = \"\";\n    let mut decoded_key_cow_cow_cow = \"\";\n    let mut decoded_value_cow_cow_cow = \"\";\n    let mut decoded_key_cow_cow_cow_str = \"\";\n    let mut decoded_value_cow_cow_cow_str = \"\";\n    let mut decoded_key_cow_cow_cow_cow = \"\";\n    let mut decoded_value_cow_cow_cow_cow = \"\";\n    let mut decoded_key_cow_cow_cow_cow_str = \"\";\n    let mut decoded_value_cow_cow_cow_cow_str = \"\";\n}"
    ],
    [
      "pub fn is_normalized (&self) -> bool {\n    self.path().is_normalized(true) && self.query().map_or(true, |q| q.is_normalized())\n}",
      "pub fn is_normalized (&self) -> bool {\n    self.path().is_normalized(true) && self.query().map_or(true, |q| q.is_normalized())\n}",
      "pub fn is_normalized (&self) -> bool {\n    self.path().is_normalized(true) && self.query().map_or(true, |q| q.is_normalized())\n}",
      "pub fn is_normalized (&self) -> bool {\n    self.path().is_normalized(true) && self.query().map_or(true, |q| q.is_normalized())\n}",
      "pub fn is_normalized (&self) -> bool {\n    // TODO: implement\n    true\n}",
      "pub fn is_normalized (&self) -> bool {\n    match self {\n        Absolute::Asterisk => true,\n        Absolute::Authority(ref authority) => authority.is_normalized(),\n        Absolute::Origin(ref origin) => origin.is_normalized(),\n    }\n}",
      "pub fn is_normalized (&self) -> bool {\n    match self {\n        Absolute::Generic(uri) => uri.is_normalized(),\n        Absolute::Asterisk => true,\n        Absolute::Authority(uri) => uri.is_normalized(),\n    }\n}",
      "pub fn is_normalized (&self) -> bool {\n    self.path().is_normalized(true) && self.query().map_or(true, |q| q.is_normalized())\n}",
      "pub fn is_normalized (&self) -> bool {\n    self.path().is_normalized(true) && self.query().map_or(true, |q| q.is_normalized())\n}",
      "pub fn is_normalized (&self) -> bool {\n    // The scheme is normalized if it is ASCII and lowercase.\n    self.scheme().is_ascii() && self.scheme().to_ascii_lowercase() == self.scheme()\n\n    // The authority is normalized if it is a valid authority and\n    // the user info, host, and port are all normalized.\n    self.authority().map_or(true, |a| a.is_normalized())\n\n    // The path is normalized if it is normalized and does not start\n    // with a double slash.\n    self.path().is_normalized(true)\n\n    // The query is normalized if it is normalized.\n    self.query().map_or(true, |q| q.is_normalized())\n\n    // The fragment is normalized if it is normalized.\n    self.fragment().map_or(true, |f| f.is_normalized())\n}"
    ],
    [
      "pub fn top_left (&self) -> Point {\n    Point::new(self.left(), self.top())\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.left(), self.top())\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.left(), self.top())\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.left(), self.top())\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.left(), self.top())\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.left(), self.top())\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.left(), self.top())\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.left(), self.top())\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.left(), self.top())\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.left(), self.top())\n}"
    ],
    [
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}"
    ],
    [
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nx >= self.left() && x < self.right() && y >= self.top() && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\n    let (x, y) = point.into();\n    x >= self.left() && x < self.right() && y >= self.top() && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nx >= self.left() && x < self.right() && y >= self.top() && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nx >= self.left() && x < self.right() && y >= self.top() && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nx >= self.left() && x < self.right() && y >= self.top() && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\n    let (x, y) = point.into();\n    x >= self.left() && x < self.right() && y >= self.top() && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nx >= self.left() && x < self.right() && y >= self.top() && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\n    let (x, y) = point.into();\n    x >= self.left() && x < self.right() && y >= self.top() && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\n    let (x, y) = point.into();\n    x >= self.left() && x < self.right() && y >= self.top() && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\n    let (x, y) = point.into();\n    x >= self.left() && x < self.right() && y >= self.top() && y < self.bottom()\n}"
    ],
    [
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    let inside_x = other.left() >= self.left() && other.right() < self.right();\n    let inside_y = other.top() >= self.top() && other.bottom() < self.bottom();\n    inside_x && inside_y\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    let left = self.left();\n    let right = self.right();\n    let top = self.top();\n    let bottom = self.bottom();\n\n    let other_left = other.left();\n    let other_right = other.right();\n    let other_top = other.top();\n    let other_bottom = other.bottom();\n\n    left <= other_left && right >= other_right && top <= other_top && bottom >= other_bottom\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    let inside_x = other.left() >= self.left() && other.right() <= self.right();\n    let inside_y = other.top() >= self.top() && other.bottom() <= self.bottom();\n    inside_x && inside_y\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    let left = self.left();\n    let right = self.right();\n    let top = self.top();\n    let bottom = self.bottom();\n    let other_left = other.left();\n    let other_right = other.right();\n    let other_top = other.top();\n    let other_bottom = other.bottom();\n    left <= other_left && right >= other_right && top <= other_top && bottom >= other_bottom\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    self.left() <= other.left() && self.right() >= other.right() && self.top() <= other.top() && self.bottom() >= other.bottom()\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    self.left() <= other.left() && self.right() >= other.right() &&\n    self.top() <= other.top() && self.bottom() >= other.bottom()\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    self.left() <= other.left() && self.top() <= other.top() &&\n    self.right() >= other.right() && self.bottom() >= other.bottom()\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    self.left() <= other.left() &&\n    self.right() >= other.right() &&\n    self.top() <= other.top() &&\n    self.bottom() >= other.bottom()\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    self.left() <= other.left() && self.right() >= other.right() &&\n    self.top() <= other.top() && self.bottom() >= other.bottom()\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    self.left() <= other.left() && self.right() >= other.right() && self.top() <= other.top() && self.bottom() >= other.bottom()\n}"
    ],
    [
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\n    self.tree.get(value)\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\n    self.tree.get(value)\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.get(value)\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\n    self.tree.get(value)\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.get(value)\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\n    self.tree.get(value)\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\n    self.tree.get(value)\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.get(value)\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\n    self.tree.get(value)\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.get(value)\n}"
    ],
    [
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.get_leftmost().map(|(v, _)| v)\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.get_lftmost().map(|(v, _)| v)\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.get_leftmost().map(|(v, _)| v)\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.get_leftmost().map(|(v, _)| v)\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.get_lftmost().map(|(v, _)| v)\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.get_lftmost().map(|(v, _)| v)\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.get_leftmost().map(|(v, _)| v)\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.get_leftmost().map(|(v, _)| v)\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.get_leftmost().map(|(v, _)| v)\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.get_leftmost().map(|(v, _)| v)\n}"
    ],
    [
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(v, _)| v)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(v, _)| v)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(v, _)| v)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(v, _)| v)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(v, _)| v)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(v, _)| v)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(v, _)| v)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(v, _)| v)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(v, _)| v)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(v, _)| v)\n}"
    ],
    [
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}"
    ],
    [
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\n    self.tree.remove(value)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.remove(value)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.remove(value)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\n    self.tree.remove(value)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\n    self.tree.remove(value)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\n    self.tree.remove(value)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.remove(value)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\n    self.tree.remove(value)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.remove(value)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.remove(value)\n}"
    ],
    [
      "pub fn push (&mut self, item: T) {\n    self.tree.push(item);\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.insert(item, ());\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.push(item);\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.push(item);\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.push(item);\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.insert(item, ());\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.push(item);\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.push(item);\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.push(item);\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.insert(item, ());\n}"
    ],
    [
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let size = self.read_u32()?;\n    let mut bytes = vec![0; size as usize];\n    self.read_exact(&mut bytes)?;\n    Ok(bytes)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let size = self.read_u32()?;\n    let mut buf = vec![0; size as usize];\n    self.inner.read_exact(&mut buf)?;\n    Ok(buf)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let size = self.read_u32()?;\n    let mut buf = vec![0; size as usize];\n    self.read_exact(&mut buf)?;\n    Ok(buf)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let len = self.read_u32()?;\n    let mut buf = vec![0; len as usize];\n    self.read_exact(&mut buf)?;\n    Ok(buf)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let size = self.read_u32()?;\n    let mut buf = vec![0; size as usize];\n    self.read_exact(&mut buf)?;\n    Ok(buf)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let size = self.read_u32()?;\n    let mut bytes = vec![0; size as usize];\n    self.inner.read_exact(&mut bytes)?;\n    Ok(bytes)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let size = self.read_u32()?;\n    let mut bytes = vec![0; size as usize];\n    self.read_exact(&mut bytes)?;\n    Ok(bytes)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let size = self.read_u32()?;\n    let bytes = self.read_bytes_exact(size as usize)?;\n    Ok(bytes)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let size = self.read_u32()?;\n    let bytes = self.read_bytes_with_size(size as usize)?;\n    Ok(bytes)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let size = self.read_u32()?;\n    let mut buf = vec![0; size as usize];\n    self.read_exact(&mut buf)?;\n    Ok(buf)\n}"
    ],
    [
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let bytes = self.read_bytes()?;\n\n    // If most significant bit is set then drop the leading zero byte.\n    if bytes.get(0).unwrap_or(&0) & 0x80 != 0 {\n        Ok(bytes[1..].to_vec())\n    } else {\n        Ok(bytes)\n    }\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let bytes = self.read_bytes()?;\n    let mut result = Vec::new();\n\n    // If most significant bit is set then prepend a zero byte to\n    // avoid interpretation as a negative number.\n    if bytes.get(0).unwrap_or(&0) & 0x80 != 0 {\n        result.push(0);\n    }\n\n    result.extend_from_slice(&bytes);\n\n    Ok(result)\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let bytes = self.read_bytes()?;\n\n    // If the most significant bit of the first byte is set then the number is negative,\n    // otherwise it is positive.\n    // Positive numbers must be preceeded by a leading zero byte according to RFC 4251, section 5.\n    if bytes.get(0).unwrap_or(&0) & 0x80 != 0 {\n        Ok(bytes)\n    } else {\n        // Remove leading zero byte.\n        Ok(bytes[1..].to_vec())\n    }\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let bytes = self.read_bytes()?;\n\n    // If the first byte is zero then drop it.\n    if bytes.get(0).unwrap_or(&0) == &0 {\n        let mut result = bytes[1..].to_vec();\n        result.insert(0, 0);\n        Ok(result)\n    } else {\n        Ok(bytes)\n    }\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let bytes = self.read_bytes()?;\n    let mut result = Vec::new();\n\n    // If most significant bit is set then drop the leading zero byte.\n    if bytes.get(0).unwrap_or(&0) & 0x80 != 0 {\n        result.extend_from_slice(&bytes[1..]);\n    } else {\n        result.extend_from_slice(&bytes);\n    }\n\n    Ok(result)\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let bytes = self.read_bytes()?;\n    if bytes.get(0).unwrap_or(&0) & 0x80 != 0 {\n        Ok(bytes)\n    } else {\n        Ok(bytes[1..].to_vec())\n    }\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let bytes = self.read_bytes()?;\n    if bytes.get(0).unwrap_or(&0) & 0x80 != 0 {\n        Ok(bytes)\n    } else {\n        Ok(bytes[1..].to_vec())\n    }\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let bytes = self.read_bytes()?;\n    if bytes.len() > 0 && bytes[0] == 0 {\n        Ok(bytes[1..].to_vec())\n    } else {\n        Ok(bytes)\n    }\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let bytes = self.read_bytes()?;\n    let mut result = bytes.to_vec();\n\n    // If the first byte is zero, drop it.\n    if result.get(0).unwrap_or(&0) == &0 {\n        result.remove(0);\n    }\n\n    Ok(result)\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let bytes = self.read_bytes()?;\n\n    // If most significant bit is set then drop the leading zero byte\n    // to avoid interpretation as a negative number.\n    if bytes.get(0).unwrap_or(&0) & 0x80 != 0 {\n        Ok(bytes[1..].to_vec())\n    } else {\n        Ok(bytes)\n    }\n}"
    ],
    [
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    String::from_utf8(bytes).map_err(|_| Error::with_kind(ErrorKind::InvalidFormat))\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    String::from_utf8(bytes).map_err(|_| Error::with_kind(ErrorKind::InvalidFormat))\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    String::from_utf8(bytes).map_err(|_| Error::with_kind(ErrorKind::InvalidFormat))\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    String::from_utf8(bytes).map_err(|_| Error::with_kind(ErrorKind::InvalidFormat))\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    String::from_utf8(bytes).map_err(|_| Error::with_kind(ErrorKind::InvalidFormat))\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    String::from_utf8(bytes).map_err(|_| Error::with_kind(ErrorKind::InvalidFormat))\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    let result = String::from_utf8(bytes)?;\n    Ok(result)\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    String::from_utf8(bytes).map_err(|_| Error::with_kind(ErrorKind::InvalidFormat))\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    let result = String::from_utf8(bytes)?;\n    Ok(result)\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    String::from_utf8(bytes).map_err(|_| Error::with_kind(ErrorKind::InvalidFormat))\n}"
    ],
    [
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 4;\n    let value = BigEndian::read_u32(&slice[..4]);\n\n    Ok(value)\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 4;\n    let value = BigEndian::read_u32(&slice[..4]);\n\n    Ok(value)\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 4;\n    let value = BigEndian::read_u32(&slice[..4]);\n\n    Ok(value)\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 4;\n    let value = BigEndian::read_u32(&slice[..4]);\n\n    Ok(value)\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 4;\n    let value = BigEndian::read_u32(&slice[..4]);\n\n    Ok(value)\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 4;\n    let value = BigEndian::read_u32(&slice[..4]);\n\n    Ok(value)\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 4;\n    let value = BigEndian::read_u32(&slice[..4]);\n\n    Ok(value)\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 4;\n    let value = BigEndian::read_u32(&slice[..4]);\n\n    Ok(value)\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 4;\n    let value = BigEndian::read_u32(&slice[..4]);\n\n    Ok(value)\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 4;\n    let value = BigEndian::read_u32(&slice[..4]);\n\n    Ok(value)\n}"
    ],
    [
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}"
    ],
    [
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    self.inner.extend_from_slice(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    self.inner.extend_from_slice(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    self.inner.extend_from_slice(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    self.inner.extend_from_slice(&val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    self.inner.extend_from_slice(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    self.inner.extend_from_slice(&(val.len() as u32).to_be_bytes());\n    self.inner.extend_from_slice(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    self.inner.extend_from_slice(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    self.inner.extend_from_slice(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    let size = val.len() as u32;\n    self.inner.extend_from_slice(&size.to_be_bytes());\n    self.inner.extend_from_slice(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    let mut bytes = val.to_vec();\n\n    // If most significant bit is set then prepend a zero byte to\n    // avoid interpretation as a negative number.\n    if val.get(0).unwrap_or(&0) & 0x80 != 0 {\n        bytes.insert(0, 0);\n    }\n\n    self.inner.extend_from_slice(&bytes);\n}"
    ],
    [
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => UnixStr::new(b\"/\"),\n        Component::CurDir => UnixStr::new(b\".\"),\n        Component::ParentDir => UnixStr::new(b\"..\"),\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => UnixStr::new_unchecked(\"/\"),\n        Component::CurDir => UnixStr::new_unchecked(\".\"),\n        Component::ParentDir => UnixStr::new_unchecked(\"..\"),\n        Component::Normal(s) => s,\n    }\n}\n\nimpl<'a> AsRef<UnixStr> for Component<'a> {\n    fn as_ref(&self) -> &UnixStr {\n        self.as_unix_str()\n    }\n}\n\nimpl<'a> AsRef<str> for Component<'a> {\n    fn as_ref(&self) -> &str {\n        self.as_unix_str().as_str()\n    }\n}\n\nimpl<'a> AsRef<Path> for Component<'a> {\n    fn as_ref(&self) -> &Path {\n        Path::new(self.as_ref())\n    }\n}\n\nimpl<'a> From<Component<'a>> for &'a UnixStr {\n    fn from(comp: Component<'a>) -> Self {\n        comp.as_unix_str()\n    }\n}\n\nimpl<'a> From<Component<'a>> for &'a str {\n    fn from(comp: Component<'a>) -> Self {\n        comp.as_ref()\n    }\n}\n\nimpl<'a> From<Component<'a>> for &'a Path {\n    fn from(comp: Component<'a>) -> Self {\n        comp.as_ref()\n    }\n}\n\nimpl<'a> From<&'a Component<'a>> for &'a UnixStr {\n    fn from(comp: &'a Component<'a>) -> Self {\n        comp.as_unix_str()\n    }\n}\n\nimpl<'a> From<&'a Component<'a>> for &'a str {\n    fn from(comp: &'a Component<'a>) -> Self {\n        comp.as_ref()\n    }\n}\n\nimpl<'a> From<&'a Component<'a>> for &'a Path {\n    fn from(comp: &'a Component<'a>) -> Self {\n        comp.as_ref()\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => UnixStr::new(b\"\"),\n        Component::CurDir => UnixStr::new(b\".\"),\n        Component::ParentDir => UnixStr::new(b\"..\"),\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => UnixStr::from_str(\"/\"),\n        Component::CurDir => UnixStr::from_str(\".\"),\n        Component::ParentDir => UnixStr::from_str(\"..\"),\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => UNIX_ROOT_DIR,\n        Component::CurDir => UNIX_CUR_DIR,\n        Component::ParentDir => UNIX_PARENT_DIR,\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => UnixStr::new(\"\"),\n        Component::CurDir => UnixStr::new(\".\"),\n        Component::ParentDir => UnixStr::new(\"..\"),\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => UnixStr::new(b\"/\"),\n        Component::CurDir => UnixStr::new(b\".\"),\n        Component::ParentDir => UnixStr::new(b\"..\"),\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => UnixStr::from_str(\"/\"),\n        Component::CurDir => UnixStr::from_str(\".\"),\n        Component::ParentDir => UnixStr::from_str(\"..\"),\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => UnixStr::new_unchecked(\"\"),\n        Component::CurDir => UnixStr::new_unchecked(\".\"),\n        Component::ParentDir => UnixStr::new_unchecked(\"..\"),\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => UnixStr::new_unchecked(\"\"),\n        Component::CurDir => UnixStr::new_unchecked(\".\"),\n        Component::ParentDir => UnixStr::new_unchecked(\"..\"),\n        Component::Normal(s) => s,\n    }\n}"
    ],
    [
      "pub fn as_path (&self) -> &'a Path {\n    unsafe { &*(self as *const _ as *const Path) }\n}",
      "pub fn as_path (&self) -> &'a Path {\n    unsafe { &*(self.source as *const [u8] as *const Path) }\n}\n\nimpl<'a> Iterator for Utf8LossyChunksIter<'a> {\n    type Item = Utf8LossyChunk<'a>;\n    fn next(&mut self) -> Option<Utf8LossyChunk<'a>> {\n        if self.source.is_empty() {\n            return None;\n        }\n        let mut valid_len = 0;\n        let mut broken = None;\n        while valid_len < self.source.len() {\n            let width = utf8_char_width(self.source[valid_len]);\n            if width == 0 {\n                broken = Some(&self.source[valid_len..]);\n                break;\n            }\n            valid_len += width;\n        }\n        let (valid, rest) = self.source.split_at(valid_len);\n        self.source = rest;\n        Some(Utf8LossyChunk {\n            valid: unsafe { core::str::from_utf8_unchecked(valid) },\n            broken: broken.unwrap_or_else(|| &[]),\n        })\n    }\n}\n\nimpl AsRef<str> for Utf8Lossy {\n    fn as_ref(&self) -> &str {\n        unsafe { core::str::from_utf8_unchecked(&self.bytes) }\n    }\n}\n\nimpl AsRef<Path> for Utf8Lossy {\n    fn as_ref(&self) -> &Path {\n        Path::new(self)\n    }\n}\n\nimpl AsRef<Path> for Utf8LossyChunk<'_> {\n    fn as_ref(&self) -> &Path {\n        Path::new(self)\n    }\n}\n\nimpl<'a> AsRef<Path> for Utf8LossyChunksIter<'a> {\n    fn as_ref(&self) -> &Path {\n        Path::new(self)\n    }\n}\n\nimpl cmp::PartialEq for Utf8Lossy {\n}",
      "pub fn as_path (&self) -> &'a Path {\n    let rw = self.as_ref() as *const UnixStr;\n    unsafe { &*(rw as *const Path) }\n}",
      "pub fn as_path (&self) -> &'a Path {\n    self\n}",
      "pub fn as_path (&self) -> &'a Path {\n    unsafe { &*(self as *const _ as *const Path) }\n}",
      "pub fn as_path (&self) -> &'a Path {\n    let rw = self.source as *const [u8] as *const UnixStr;\n    let inner = unsafe { &*(rw) };\n    Path::new(inner)\n}",
      "pub fn as_path (&self) -> &'a Path {\n    // SAFETY: Both use the same memory layout, and UTF-8 correctness isn't required.\n    unsafe { mem::transmute(self.source) }\n}",
      "pub fn as_path (&self) -> &'a Path {\n    let start = self.source.as_ptr() as usize;\n    let end = self.source.as_ptr() as usize + self.valid.len();\n    unsafe { &*(start as *const Path) }\n}",
      "pub fn as_path (&self) -> &'a Path {\n    unsafe { &*(self as *const _ as *const Path) }\n}",
      "pub fn as_path (&self) -> &'a Path {\n    unsafe { &*(self.source as *const [u8] as *const Path) }\n}\n\nimpl<'a> Iterator for Utf8LossyChunksIter<'a> {\n    type Item = Utf8LossyChunk<'a>;\n\n    fn next(&mut self) -> Option<Utf8LossyChunk<'a>> {\n        if self.source.is_empty() {\n            return None;\n        }\n\n        let mut valid_len = 0;\n        let mut broken_start = 0;\n        let mut broken_end = 0;\n        let mut broken_len = 0;\n\n        for (i, byte) in self.source.iter().enumerate() {\n            if utf8_char_width(*byte) == 1 {\n                valid_len += 1;\n            } else {\n                broken_start = i;\n                broken_len = 1;\n                break;\n            }\n        }\n\n        for (i, byte) in self.source[valid_len..].iter().enumerate() {\n            if utf8_char_width(*byte) == 1 {\n                valid_len += 1;\n            } else {\n                broken_end = i + valid_len;\n                broken_len += 1;\n            }\n        }\n\n        let (valid, rest) = self.source.split_at(valid_len);\n        self.source = rest;\n\n        Some(Utf8LossyChunk {\n            valid: unsafe { str::from_utf8_unchecked(valid) },\n            broken: &self.source[broken_start..broken_end],\n        })\n    }\n}"
    ],
    [
      "pub fn pop (&mut self) -> bool {\n    if let Some(parent) = self.parent() {\n        *self = parent;\n        true\n    } else {\n        false\n    }\n}",
      "pub fn pop (&mut self) -> bool {\n    if let Some(p) = self.parent() {\n        *self = p;\n        true\n    } else {\n        false\n    }\n}",
      "pub fn pop (&mut self) -> bool {\n    self.as_mut_vec().pop();\n}",
      "pub fn pop (&mut self) -> bool {\n    if let Some(p) = self.parent() {\n        *self = p;\n        true\n    } else {\n        false\n    }\n}",
      "pub fn pop (&mut self) -> bool {\n    if let Some(p) = self.parent() {\n        self.path = p.as_unix_str();\n        true\n    } else {\n        false\n    }\n}",
      "pub fn pop (&mut self) -> bool {\n    if let Some(parent) = self.parent() {\n        *self = parent;\n        true\n    } else {\n        false\n    }\n}",
      "pub fn pop (&mut self) -> bool {\n    self.parent().map(|parent| *self = parent.to_path_buf())\n}",
      "pub fn pop (&mut self) -> bool {\n    if let Some(parent) = self.parent() {\n        *self = parent;\n        true\n    } else {\n        false\n    }\n}",
      "pub fn pop (&mut self) -> bool {\n    if let Some(parent) = self.parent() {\n        *self = parent;\n        true\n    } else {\n        false\n    }\n}",
      "pub fn pop (&mut self) -> bool {\n    if let Some(parent) = self.parent() {\n        self.path = parent.as_unix_str().to_owned();\n        true\n    } else {\n        false\n    }\n}"
    ],
    [
      "pub fn parent (&self) -> Option<&Path> {\n    let mut comps = self.components();\n    let comp = comps.next_back();\n    comp.and_then(|c| match c {\n        Component::RootDir => Some(self),\n        Component::ParentDir => comps.as_path().parent(),\n        _ => Some(comps.as_path()),\n    })\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    if self.is_root() {\n        return None;\n    }\n\n    let mut components = self.components();\n    components.next_back();\n    Some(components.as_path())\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    if self.is_empty() {\n        return None;\n    }\n    let mut comps = self.components();\n    comps.next_back();\n    Some(comps.as_path())\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    let mut comps = self.components();\n    let comp = comps.next_back();\n    comp.and_then(|c| match c {\n        Component::RootDir => Some(self),\n        Component::ParentDir => comps.as_path().parent(),\n        _ => Some(comps.as_path()),\n    })\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    let mut comps = self.components();\n    comps.next_back();\n    if comps.has_root() {\n        None\n    } else {\n        Some(comps.as_path())\n    }\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    let mut comps = self.components();\n    let comp = comps.next_back();\n    comp.and_then(|p| match p {\n        Component::RootDir => Some(self),\n        Component::Prefix(..) => Some(self),\n        Component::Normal(..) => {\n            comps.next_back();\n            Some(Path::new(comps.as_path()))\n        }\n        _ => None,\n    })\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    let mut comps = self.components();\n    comps.next_back();\n    if let Some(Component::Prefix(..)) = comps.next_back() {\n        return None;\n    }\n    Some(comps.as_path())\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    let mut components = self.components();\n    components.next_back();\n    if components.next_back().is_some() {\n        Some(Path::new(components.as_path()))\n    } else {\n        None\n    }\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    let mut components = self.components();\n    components.next_back();\n    components.as_path().as_ref().ok()\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    let mut comps = self.components();\n    let comp = comps.next_back();\n    let mut new_path = match comp {\n        Some(Component::Normal(_)) | Some(Component::CurDir) => {\n            comps.as_path()\n        }\n        _ => return None,\n    };\n    if let Some(root) = self.root() {\n        new_path = root.join(new_path);\n    }\n    Some(new_path)\n}"
    ],
    [
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    self.file_name().map(|c| c.as_unix_str())\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    let mut comps = self.components();\n    let comp = comps.next_back();\n    comp.and_then(|p| match p {\n        Component::Normal(_) | Component::CurDir | Component::ParentDir => {\n            Some(comps.as_path())\n        }\n        _ => None,\n    })\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    self.file_name_components().next_back()\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    self.file_name_as_components().next()\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    let mut comps = self.components();\n    let comp = comps.next_back();\n    comp.and_then(|p| match p {\n        Component::Normal(_) | Component::CurDir | Component::ParentDir => {\n            Some(p.as_unix_str())\n        }\n        _ => None,\n    })\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    let mut comps = self.components();\n    let comp = comps.next_back();\n    comp.and_then(|p| match p {\n        Component::Normal(_) | Component::CurDir | Component::ParentDir => {\n            Some(comps.as_path())\n        }\n        _ => None,\n    })\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    self.file_name().map(|c| c.as_unix_str())\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    self.file_name_component().map(|comp| comp.as_unix_str())\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    let mut comps = self.components();\n    comps.next_back();\n    comps.next()\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    self.file_name().map(|s| s.as_unix_str())\n}"
    ],
    [
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    let cur_len = self.v.len();\n    if len >= cur_len {\n        self.v.reserve_exact(len - cur_len);\n    }\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    self.v.reserve_exact(len);\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    let cur_len = self.v.len();\n    if len >= cur_len {\n        self.v.reserve_exact(len - cur_len);\n    }\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    let cur_len = self.v.len();\n    if len >= cur_len {\n        self.v.reserve_exact(len - cur_len);\n    }\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    let cur_len = self.v.len();\n    if len >= cur_len {\n        self.v.reserve_exact(len - cur_len);\n    }\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    let cur_len = self.v.len();\n    if len >= cur_len {\n        self.v.reserve_exact(len - cur_len);\n    }\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    let cur_len = self.v.len();\n    if len >= cur_len {\n        self.v.reserve_exact(len - cur_len);\n    }\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    self.v.reserve_exact(len - self.v.len());\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    let cur_len = self.v.len();\n    if len >= cur_len {\n        self.v.reserve_exact(len - cur_len);\n    }\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    let cur_len = self.v.len();\n    if len >= cur_len {\n        self.v.reserve_exact(len - cur_len);\n    }\n}"
    ],
    [
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}"
    ],
    [
      "pub fn append (&mut self, other: &mut Self) {\n    for (key, value) in other.drain() {\n        self.insert(key, value);\n    }\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    for (key, value) in other.drain() {\n        self.insert(key, value);\n    }\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    for (k, v) in other.drain() {\n        self.insert(k, v);\n    }\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    for (k, v) in other.iter() {\n        self.insert(k, v);\n    }\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    for (k, v) in other.iter_mut() {\n        self.insert(k, v);\n    }\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    for (key, value) in other.drain() {\n        self.insert(key, value);\n    }\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    for (key, value) in other.drain() {\n        self.insert(key, value);\n    }\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    for (k, v) in other.drain() {\n        self.insert(k, v);\n    }\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    for (k, v) in other.iter() {\n        self.insert(k, v);\n    }\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    for (k, v) in other.iter_mut() {\n        self.insert(k, v);\n    }\n}"
    ],
    [
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::new();\n    other.v.resize(at, None);\n    other\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::new();\n    other.v.extend(self.v[at..].iter_mut().map(|el| el.take()));\n    other.n = other.v.iter().filter(|el| el.is_some()).count();\n    self.n -= other.n;\n    other\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::new();\n    other.v.extend(self.v[at..].iter_mut().map(|el| el.take()));\n    other.n = other.v.iter().filter(|el| el.is_some()).count();\n    self.n -= other.n;\n    other\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::new();\n    other.v = self.v[at..].to_vec();\n    other.n = self.n - at;\n    self.n = at;\n    other\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::new();\n    other.v = self.v.split_off(at);\n    other.n = other.v.iter().filter(|e| e.is_some()).count();\n    self.n -= other.n;\n    other\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::new();\n    other.v.extend(self.v[at..].iter_mut().map(|el| el.take()));\n    other.n = other.v.iter().filter(|el| el.is_some()).count();\n    self.n -= other.n;\n    other\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::new();\n    other.v = self.v[at..].to_vec();\n    other.n = other.v.iter().filter(|x| x.is_some()).count();\n    self.v.truncate(at);\n    self.n = self.v.iter().filter(|x| x.is_some()).count();\n    other\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::new();\n    other.v.extend(self.v[at..].iter_mut().map(|el| el.take()));\n    other.n = other.v.iter().filter(|el| el.is_some()).count();\n    self.n -= other.n;\n    other\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::new();\n    other.v = self.v[at..].to_vec();\n    other.n = other.v.iter().filter(|e| e.is_some()).count();\n    self.n -= other.n;\n    other\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::new();\n    other.v = self.v.split_off(at);\n    other.n = other.v.iter().filter(|x| x.is_some()).count();\n    self.n -= other.n;\n    other\n}"
    ],
    [
      "pub fn get (&self, key: usize) -> Option<&V> {\n    if key >= self.v.len() {\n        return None;\n    }\n    self.v[key].as_ref()\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    if key >= self.v.len() {\n        return None;\n    }\n    match &self.v[key] {\n        Some(value) => Some(value),\n        None => None\n    }\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    if key >= self.v.len() {\n        return None;\n    }\n    match &self.v[key] {\n        Some(value) => Some(value),\n        None => None,\n    }\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    if key >= self.v.len() {\n        return None;\n    }\n    match &self.v[key] {\n        Some(value) => Some(value),\n        None => None,\n    }\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    if key >= self.v.len() {\n        return None;\n    }\n    let result = &self.v[key];\n    result.as_ref()\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    if key >= self.v.len() {\n        return None;\n    }\n    self.v[key].as_ref()\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    if key >= self.v.len() {\n        return None;\n    }\n    self.v[key].as_ref()\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    if key >= self.v.len() {\n        return None;\n    }\n    match &self.v[key] {\n        Some(value) => Some(value),\n        None => None\n    }\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    if key >= self.v.len() {\n        return None;\n    }\n    self.v[key].as_ref()\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    if key >= self.v.len() {\n        return None;\n    }\n    let result = &self.v[key];\n    if result.is_some() {\n        return Some(&result.as_ref().unwrap());\n    }\n    None\n}"
    ],
    [
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key >= self.v.len() {\n        self.v.resize(key + 1, None);\n    }\n    let result = &mut self.v[key];\n    let was = result.take();\n    if was.is_none() {\n        self.n += 1;\n    }\n    *result = Some(value);\n    was\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key >= self.v.len() {\n        self.v.resize(key + 1, None);\n    }\n    let result = &mut self.v[key];\n    let was = result.replace(value);\n    if was.is_none() {\n        self.n += 1;\n    }\n    was\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key >= self.v.len() {\n        self.v.resize(key + 1, None);\n    }\n    let result = &mut self.v[key];\n    let was = result.replace(value);\n    if was.is_none() {\n        self.n += 1;\n    }\n    was\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key >= self.v.len() {\n        self.v.resize(key + 1, None);\n    }\n    let result = &mut self.v[key];\n    let was = result.take();\n    if was.is_none() {\n        self.n += 1;\n    }\n    *result = Some(value);\n    was\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key >= self.v.len() {\n        self.v.resize(key + 1, None);\n    }\n    let result = &mut self.v[key];\n    let was = result.replace(value);\n    if was.is_none() {\n        self.n += 1;\n    }\n    was\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key >= self.v.len() {\n        self.v.resize(key + 1, None);\n    }\n    let result = &mut self.v[key];\n    let was = result.take();\n    *result = Some(value);\n    if was.is_none() {\n        self.n += 1;\n    }\n    was\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key >= self.v.len() {\n        self.v.resize(key + 1, None);\n    }\n    let result = &mut self.v[key];\n    let was = result.replace(value);\n    if was.is_none() {\n        self.n += 1;\n    }\n    was\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key >= self.v.len() {\n        self.v.resize(key + 1, None);\n    }\n    let result = &mut self.v[key];\n    let was = result.take();\n    *result = Some(value);\n    if was.is_none() {\n        self.n += 1;\n    }\n    was\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key >= self.v.len() {\n        self.v.resize(key + 1, None);\n    }\n    let result = &mut self.v[key];\n    let was = result.replace(value);\n    if was.is_none() {\n        self.n += 1;\n    }\n    was\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key >= self.v.len() {\n        self.v.resize(key + 1, None);\n    }\n    let result = &mut self.v[key];\n    let was = result.take();\n    *result = Some(value);\n    if was.is_none() {\n        self.n += 1;\n    }\n    was\n}"
    ],
    [
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    if key < self.v.len() {\n        let was = replace(&mut self.v[key], None);\n        if was.is_some() {\n            self.n -= 1;\n        }\n        was\n    } else {\n        None\n    }\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    if key < self.v.len() {\n        let was = replace(&mut self.v[key], None);\n        if was.is_some() {\n            self.n -= 1;\n        }\n        was\n    } else {\n        None\n    }\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    if key < self.v.len() {\n        let was = replace(&mut self.v[key], None);\n        if was.is_some() {\n            self.n -= 1;\n        }\n        was\n    } else {\n        None\n    }\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    if key < self.v.len() {\n        let was = replace(&mut self.v[key], None);\n        if was.is_some() {\n            self.n -= 1;\n        }\n        was\n    } else {\n        None\n    }\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    if key < self.v.len() {\n        let was = replace(&mut self.v[key], None);\n        if was.is_some() {\n            self.n -= 1;\n        }\n        was\n    } else {\n        None\n    }\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    if key < self.v.len() {\n        let was = replace(&mut self.v[key], None);\n        if was.is_some() {\n            self.n -= 1;\n        }\n        was\n    } else {\n        None\n    }\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    if key < self.v.len() {\n        let was = replace(&mut self.v[key], None);\n        if was.is_some() {\n            self.n -= 1;\n        }\n        was\n    } else {\n        None\n    }\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    if key < self.v.len() {\n        let was = replace(&mut self.v[key], None);\n        if was.is_some() {\n            self.n -= 1;\n        }\n        was\n    } else {\n        None\n    }\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    if key < self.v.len() {\n        let was = replace(&mut self.v[key], None);\n        if was.is_some() {\n            self.n -= 1;\n        }\n        was\n    } else {\n        None\n    }\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    if key < self.v.len() {\n        let was = replace(&mut self.v[key], None);\n        if was.is_some() {\n            self.n -= 1;\n        }\n        was\n    } else {\n        None\n    }\n}"
    ],
    [
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    for i in 0..self.v.len() {\n        if let Some(value) = self.v[i].as_mut() {\n            if !f(i, value) {\n                self.v[i].take();\n                self.n -= 1;\n            }\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    for (k, v) in self.iter_mut() {\n        if !f(k, v) {\n            self.remove(k);\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    let mut i = 0;\n    while i < self.v.len() {\n        if let Some(ref mut v) = self.v[i] {\n            if f(i, v) {\n                i += 1;\n            } else {\n                self.remove(i);\n            }\n        } else {\n            i += 1;\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    let mut i = 0;\n    while i < self.v.len() {\n        if let Some(value) = self.v[i].as_mut() {\n            if f(i, value) {\n                i += 1;\n            } else {\n                self.v.swap_remove(i);\n                self.n -= 1;\n            }\n        } else {\n            i += 1;\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    let mut i = 0;\n    while i < self.v.len() {\n        if let Some(ref mut value) = self.v[i] {\n            if !f(i, value) {\n                self.remove(i);\n            }\n        }\n        i += 1;\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    for i in 0..self.v.len() {\n        let mut val = self.v[i].take();\n        if !f(i, &mut val) {\n            self.n -= 1;\n        } else {\n            self.v[i] = val;\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    for i in 0..self.v.len() {\n        if let Some(v) = &mut self.v[i] {\n            if !f(i, v) {\n                self.remove(i);\n            }\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    for i in 0..self.v.len() {\n        if let Some(v) = &mut self.v[i] {\n            if !f(i, v) {\n                self.remove(i);\n            }\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    let mut i = 0;\n    while i < self.v.len() {\n        if let Some(v) = self.v[i].as_mut() {\n            if !f(i, v) {\n                self.remove(i);\n            } else {\n                i += 1;\n            }\n        } else {\n            i += 1;\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    let mut i = 0;\n    while i < self.v.len() {\n        if !f(i, &mut self.v[i]) {\n            self.remove(i);\n        } else {\n            i += 1;\n        }\n    }\n}"
    ],
    [
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    let (mut all, tail) = self.head_tail_mut();\n    if tail.len() == 0 {\n        return Err(val);\n    }\n    let ptr = tail.as_mut_ptr();\n    unsafe {\n        // SAFETY:\n        // * can only create instances where layout of `T` 'fits'\n        // * valid for lifetime `'a` (as per `UninitView`).\n        // * unaliased for lifetime `'a` (as per own invariant from unsafe constructor). No\n        //   other method duplicates the pointer or allows a second `Uninit` without borrowing\n        //   the first.\n        ptr::write(ptr, val);\n        // SAFETY:\n        // * Just initialized one more element past the end. By the way, this can not\n        //   overflow since the result is at most `self.capacity()`.\n        self.set_len(self.len() + 1);\n    }\n    Ok(())\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    let (mut all, tail) = self.head_tail_mut();\n    let (head, tail) = all.split_at_byte(mem::size_of::<T>()).unwrap();\n    unsafe {\n        // SAFETY:\n        // * the source is valid for reads for its own layout\n        // * the memory is valid for the same layout as val, so aligned and large enough\n        // * both are aligned, uninit due to allocator requirements\n        core::ptr::copy(val as *const _ as *const u8, head.as_ptr() as *mut u8, mem::size_of::<T>());\n    }\n    self.length += 1;\n    Ok(())\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    // SAFETY:\n    // * unaliased as we had a mutable reference\n    // * can write uninitialized bytes as much as we want\n    let uninit = Uninit::from_maybe_uninit(self.uninit.as_mut_ptr());\n    let uninit = uninit.split_at_byte(self.length).unwrap();\n    let uninit = uninit.cast::<T>().unwrap();\n    let uninit = uninit.init(val);\n    self.length += 1;\n    Ok(())\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    // Get the mutable slice of the vector.\n    let mut slice = self.as_mut_slice();\n    // If the vector is full, return the value.\n    if slice.is_empty() {\n        return Err(val)\n    }\n    // Write the value to the last element of the slice.\n    slice[0] = val;\n    // Shrink the slice to only contain the written value.\n    slice = &mut slice[1..];\n    // Set the length of the vector to the new slice length.\n    self.set_len(slice.len());\n    // Return Ok.\n    Ok(())\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    let (mut all, tail) = self.head_tail_mut();\n    if tail.capacity() == 0 {\n        return Err(val)\n    }\n    let tail = tail.split_at_byte(mem::size_of::<T>()).unwrap();\n    unsafe {\n        // SAFETY:\n        // * `tail` is the tail of `all`, so the memory is valid for `T`.\n        // * `all` is a slice of `MaybeUninit<T>` so it is valid for `T`.\n        // * `all` is a slice of `MaybeUninit<T>` so it is valid for `MaybeUninit<T>`.\n        // * `all` is a slice of `MaybeUninit<T>` so it is valid for `MaybeUninit<()>`.\n        // * `tail` is the tail of `all`, so the memory is valid for `MaybeUninit<()>`.\n        // * `all` is a slice of `MaybeUninit<T>` so it is valid for `MaybeUninit<T>`.\n        // * `all` is a slice of `MaybeUninit<T>` so it is valid for `MaybeUninit<()>`.\n        // * `all` is a slice of `MaybeUninit<T>` so it is valid for `MaybeUninit<T>`.\n        // * `all` is a slice of `MaybeUninit<T>` so it is valid for `MaybeUninit<()>`.\n        // * `all` is a slice of `MaybeUninit<T>` so it is valid for `MaybeUninit<T>`.\n        // * `all` is a slice of `MaybeUninit<T>` so it is valid for `MaybeUninit<()>`.\n        // * `all` is a slice of `MaybeUninit<T>` so it is valid for `MaybeUninit<T>`.\n        // * `all` is a slice of `MaybeUninit<T>` so it is valid for `MaybeUninit<()>`.\n        // * `all` is a slice of `MaybeUninit<T>` so it is valid for `MaybeUninit<T>`.\n}\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    let (all, tail) = self.head_tail_mut();\n    if tail.len() == 0 {\n        return Err(val)\n    }\n    unsafe {\n        // SAFETY:\n        // * `tail` is non-empty\n        // * `tail` is behind `all`\n        // * `all` is unaliased\n        // * `all` is valid for the layout of `T`\n        // * `val` is valid for the layout of `T`\n        // * `val` is unaliased\n        // * `val` is not behind `all`\n        // * `all` is behind `self.uninit`\n        // * `self.uninit` is unaliased\n        // * `self.uninit` is valid for the layout of `T`\n        // * `self.uninit` is not behind `all`\n        // * `self.uninit` is not behind `val`\n        // * `self.uninit` is not behind `tail`\n        // * `tail` is not behind `all`\n        // * `all` is not behind `self.uninit`\n        // * `self.uninit` is not behind `tail`\n        // * `tail` is not behind `val`\n        // * `all` is not behind `val`\n        // * `all` is not behind `tail`\n        // * `val` is not behind `all`\n        // * `val` is not behind `tail`\n        // * `val` is not behind `self.uninit`\n        // * `tail` is not behind `self.uninit`\n        // * `all` is not behind `self.uninit`\n        // * `self.uninit` is not behind `self.uninit`\n        // * `tail` is not behind `self.uninit`\n        // * `val` is not behind `self.uninit`\n        // * `all` is not behind `val`\n        // * `tail` is not behind `val`\n        // * `self.uninit` is not behind `val`\n        // * `all` is not behind `tail`\n}\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    let (mut all, tail) = self.head_tail_mut();\n    if tail.len() == 0 {\n        return Err(val);\n    }\n    let ptr = tail.as_begin_ptr();\n    unsafe {\n        // SAFETY:\n        // * `tail` is not empty\n        // * `all` is not empty\n        // * `all` is behind `tail`\n        // * `all` is not empty\n        // * `all` is behind `tail`\n        // * `all` is unaliased\n        // * `tail` is unaliased\n        // * `all` is behind `tail`\n        // * `all` is not empty\n        // * `all` is behind `tail`\n        // * `all` is unaliased\n        // * `tail` is unaliased\n        // * `all` is behind `tail`\n        // * `all` is not empty\n        // * `all` is behind `tail`\n        // * `all` is unaliased\n        // * `tail` is unaliased\n        // * `all` is behind `tail`\n        // * `all` is not empty\n        // * `all` is behind `tail`\n        // * `all` is unaliased\n        // * `tail` is unaliased\n        // * `all` is behind `tail`\n        // * `all` is not empty\n        // * `all` is behind `tail`\n        // * `all` is unaliased\n        // * `tail` is unaliased\n        // * `all` is behind `tail`\n        // * `all` is not empty\n        // * `all` is behind `tail`\n        // * `all` is unaliased\n        // * `tail` is unaliased\n        // * `all` is behind `tail`\n        // * `all` is not empty\n        // * `all` is behind `tail`\n        // * `all` is unaliased\n        // * `tail` is unaliased\n        // * `all` is behind `tail`\n        // * `all` is not empty\n}\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    let (all, tail) = self.head_tail_mut();\n    if tail.capacity() == 0 {\n        return Err(val);\n    }\n    let ptr = tail.as_begin_ptr();\n    unsafe {\n        // SAFETY:\n        // * can only create instances where layout of `T` 'fits'\n        // * valid for lifetime `'a` (as per `UninitView`).\n        // * unaliased for lifetime `'a` (as per own invariant from unsafe constructor). No\n        //   other method duplicates the pointer or allows a second `Uninit` without borrowing\n        //   the first.\n        ptr::write(ptr, val);\n    }\n    self.length += 1;\n    Ok(())\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    let (all, tail) = self.head_tail_mut();\n    let (uninit, _) = tail.split_at_byte(mem::size_of::<T>()).unwrap();\n    uninit.init(val);\n    self.length += 1;\n    Ok(())\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    let (all, tail) = self.head_tail_mut();\n    if tail.len() == 0 {\n        return Err(val);\n    }\n    let mut tail = tail.split_at_byte(mem::size_of::<T>()).unwrap();\n    unsafe {\n        // SAFETY:\n        // * the source is valid for reads for its own layout\n        // * the memory is valid for the same layout as val, so aligned and large enough\n        // * both are aligned, uninit due to allocator requirements\n        core::ptr::copy(val as *const _ as *const u8, tail.as_ptr() as *mut u8, mem::size_of_val(&val));\n    }\n    self.length += 1;\n    Ok(())\n}"
    ],
    [
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity(), \"`at` out of bounds\");\n    // `self.length` is always smaller than `split_at`.\n    let new_uninit = self.uninit.split_at(at).unwrap();\n    // The first `at` elements stay in this vec.\n    let new_len = self.length.saturating_sub(at);\n    self.length -= new_len;\n    FixedVec {\n        uninit: new_uninit,\n        length: new_len,\n    }\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity(), \"`at` out of bounds\");\n    // `self.length` is always smaller than `split_at`.\n    let new_uninit = self.uninit.split_at(at).unwrap();\n    // The first `at` elements stay in this vec.\n    let new_len = self.length.saturating_sub(at);\n    self.length -= new_len;\n    FixedVec {\n        uninit: new_uninit,\n        length: new_len,\n    }\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity(), \"`at` out of bounds\");\n    let new_uninit = self.uninit.split_at(at).unwrap();\n    let new_len = self.length.saturating_sub(at);\n    self.length -= new_len;\n    FixedVec {\n        uninit: new_uninit,\n        length: new_len,\n    }\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity(), \"`at` out of bounds\");\n    // `self.length` is always smaller than `split_at`.\n    let new_uninit = self.uninit.split_at(at).unwrap();\n    // The first `at` elements stay in this vec.\n    let new_len = self.length.saturating_sub(at);\n    self.length -= new_len;\n    FixedVec {\n        uninit: new_uninit,\n        length: new_len,\n    }\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity(), \"`at` out of bounds\");\n    let new_uninit = self.uninit.split_at(at).unwrap();\n    let new_len = self.length.saturating_sub(at);\n    self.length -= new_len;\n    FixedVec {\n        uninit: new_uninit,\n        length: new_len,\n    }\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity(), \"`at` out of bounds\");\n    // `self.length` is always smaller than `split_at`.\n    let new_uninit = self.uninit.split_at(at).unwrap();\n    // The first `at` elements stay in this vec.\n    let new_len = self.length.saturating_sub(at);\n    self.length -= new_len;\n    FixedVec {\n        uninit: new_uninit,\n        length: new_len,\n    }\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity(), \"`at` out of bounds\");\n    // `self.length` is always smaller than `split_at`.\n    let new_uninit = self.uninit.split_at(at).unwrap();\n    // The first `at` elements stay in this vec.\n    let new_len = self.length.saturating_sub(at);\n    self.length -= new_len;\n    FixedVec {\n        uninit: new_uninit,\n        length: new_len,\n    }\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity(), \"`at` out of bounds\");\n    let new_uninit = self.uninit.split_at(at).unwrap();\n    let new_len = self.length.saturating_sub(at);\n    self.length -= new_len;\n    FixedVec {\n        uninit: new_uninit,\n        length: new_len,\n    }\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity(), \"`at` out of bounds\");\n    let new_uninit = self.uninit.split_at(at).unwrap();\n    let new_len = self.length.saturating_sub(at);\n    self.length -= new_len;\n    FixedVec {\n        uninit: new_uninit,\n        length: new_len,\n    }\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity(), \"`at` out of bounds\");\n    // `self.length` is always smaller than `split_at`.\n    let new_uninit = self.uninit.split_at(at).unwrap();\n    // The first `at` elements stay in this vec.\n    let new_len = self.length.saturating_sub(at);\n    self.length -= new_len;\n    FixedVec {\n        uninit: new_uninit,\n        length: new_len,\n    }\n}"
    ],
    [
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    let inner = self.inner();\n    let strong = inner.strong.get();\n    if strong == 0 {\n        return None;\n    }\n    let new_strong = strong + 1;\n    if inner.strong.compare_exchange(strong, new_strong).is_err() {\n        return None;\n    }\n    Some(Rc {\n        inner: self.inner,\n        lifetime: PhantomData,\n    })\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.strong.get() != 0 {\n        Some(Rc {\n            inner: self.inner,\n            strong: self.strong,\n            weak: self.weak,\n        })\n    } else {\n        None\n    }\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    let inner = self.inner();\n    if inner.strong.get() == 0 {\n        return None;\n    }\n    inner.strong.increment();\n    Some(Rc {\n        inner: self.inner(),\n        lifetime: PhantomData,\n        typed: PhantomData,\n    })\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    let inner = self.inner();\n    if inner.strong.get() == 0 {\n        return None;\n    }\n    inner.strong.increment();\n    Some(Rc {\n        inner: self.inner,\n        phantom: PhantomData,\n    })\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.strong.get() != 0 {\n        Some(Rc {\n            inner: self.inner,\n            strong: self.strong,\n            weak: self.weak,\n            phantom: PhantomData,\n        })\n    } else {\n        None\n    }\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.strong_count() == 0 {\n        None\n    } else {\n        Some(Rc {\n            inner: self.inner,\n            phantom: PhantomData,\n        })\n    }\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.strong.get() == 0 {\n        None\n    } else {\n        Some(Rc {\n            inner: self.inner,\n            strong: self.strong,\n            weak: self.weak,\n        })\n    }\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.strong_count() != 0 {\n        Some(Rc {\n            inner: self.inner.clone(),\n            lifetime: PhantomData,\n        })\n    } else {\n        None\n    }\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    let inner = self.inner();\n    if inner.strong.get() == 0 {\n        None\n    } else {\n        Some(Rc {\n            inner: self.inner,\n            lifetime: PhantomData,\n            typed: PhantomData,\n        })\n    }\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    let inner = self.inner();\n    if inner.strong.get() == 0 {\n        None\n    } else {\n        Some(Rc {\n            inner: self.inner(),\n            lifetime: PhantomData,\n        })\n    }\n}"
    ]
  ]
}