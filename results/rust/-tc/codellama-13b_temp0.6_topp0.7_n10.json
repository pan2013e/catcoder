{
  "benchmark": "rusteval-tc",
  "lastest_eval": {
    "compile@1": 0.5955555555555555,
    "pass@1": 0.49888888888888877,
    "compile@3": 0.7010185185185185,
    "pass@3": 0.5961111111111113,
    "compile@5": 0.73831569664903,
    "pass@5": 0.6379629629629631
  },
  "n": 10,
  "k": [
    1,
    3,
    5
  ],
  "fn_codes": [
    [
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut bit_vec = BitVec::with_capacity(nbits);\n    for _ in 0..nbits {\n        bit_vec.push(bit);\n    }\n    bit_vec\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut bit_vec = BitVec::with_capacity(nbits);\n    for _ in 0..nbits {\n        bit_vec.push(bit);\n    }\n    bit_vec\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut bit_vec = BitVec::with_capacity(nbits);\n    for _ in 0..nbits {\n        bit_vec.push(bit);\n    }\n    bit_vec\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut bit_vec = BitVec::with_capacity(nbits);\n    for _ in 0..nbits {\n        bit_vec.push(bit);\n    }\n    bit_vec\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut bit_vec = BitVec::with_capacity(nbits);\n    for _ in 0..nbits {\n        bit_vec.push(bit);\n    }\n    bit_vec\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut bv = BitVec::with_capacity(nbits);\n    bv.set_all(bit);\n    bv\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut bit_vec = BitVec::with_capacity(nbits);\n    for _ in 0..nbits {\n        bit_vec.push(bit);\n    }\n    bit_vec\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut bit_vec = BitVec::with_capacity(nbits);\n    for _ in 0..nbits {\n        bit_vec.push(bit);\n    }\n    bit_vec\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut bv = BitVec::with_capacity(nbits);\n    bv.storage.resize(blocks_for_bits::<B>(nbits), B::zero());\n    bv.nbits = nbits;\n    if bit {\n        bv.storage.iter_mut().for_each(|x| *x = !B::zero());\n    }\n    bv\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut bit_vec = BitVec::with_capacity(nbits);\n    for _ in 0..nbits {\n        bit_vec.push(bit);\n    }\n    bit_vec\n}"
    ],
    [
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bit_vec = BitVec::with_capacity(len);\n    for i in 0..len {\n        bit_vec.push(f(i));\n    }\n    bit_vec\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bit_vec = BitVec::with_capacity(len);\n    for i in 0..len {\n        bit_vec.push(f(i));\n    }\n    bit_vec\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bit_vec = BitVec::with_capacity(len);\n    for i in 0..len {\n        bit_vec.push(f(i));\n    }\n    bit_vec\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bit_vec = BitVec::with_capacity(len);\n    for i in 0..len {\n        bit_vec.push(f(i));\n    }\n    bit_vec\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bit_vec = BitVec::with_capacity(len);\n    for i in 0..len {\n        bit_vec.push(f(i));\n    }\n    bit_vec\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bit_vec = BitVec::with_capacity(len);\n    for i in 0..len {\n        bit_vec.push(f(i));\n    }\n    bit_vec\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bit_vec = BitVec::with_capacity(len);\n    for i in 0..len {\n        bit_vec.push(f(i));\n    }\n    bit_vec\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bit_vec = BitVec::with_capacity(len);\n    for i in 0..len {\n        bit_vec.push(f(i));\n    }\n    bit_vec\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bit_vec = BitVec::with_capacity(len);\n    for i in 0..len {\n        bit_vec.push(f(i));\n    }\n    bit_vec\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bit_vec = BitVec::with_capacity(len);\n    for i in 0..len {\n        bit_vec.push(f(i));\n    }\n    bit_vec\n}"
    ],
    [
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i >= self.nbits {\n        return None;\n    }\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let flag = B::one() << b;\n    Some(self.storage[w] & flag != B::zero())\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i >= self.nbits {\n        return None;\n    }\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let flag = B::one() << b;\n    let val = self.storage[w] & flag;\n    Some(val != B::zero())\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i >= self.nbits {\n        None\n    } else {\n        let w = i / B::bits();\n        let b = i % B::bits();\n        let flag = B::one() << b;\n        Some((self.storage[w] & flag) != B::zero())\n    }\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i < self.nbits {\n        let w = i / B::bits();\n        let b = i % B::bits();\n        let flag = B::one() << b;\n        Some((self.storage[w] & flag) != B::zero())\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i < self.nbits {\n        let w = i / B::bits();\n        let b = i % B::bits();\n        let flag = B::one() << b;\n        Some((self.storage[w] & flag) != B::zero())\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i >= self.nbits {\n        return None;\n    }\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let flag = B::one() << b;\n    let val = self.storage[w] & flag;\n    Some(val != B::zero())\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i < self.nbits {\n        let w = i / B::bits();\n        let b = i % B::bits();\n        let flag = B::one() << b;\n        let val = self.storage[w] & flag;\n        Some(val != B::zero())\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i < self.nbits {\n        let w = i / B::bits();\n        let b = i % B::bits();\n        let flag = B::one() << b;\n        Some(self.storage[w] & flag != B::zero())\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i < self.nbits {\n        let w = i / B::bits();\n        let b = i % B::bits();\n        let flag = B::one() << b;\n        Some((self.storage[w] & flag) != B::zero())\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i < self.nbits {\n        let w = i / B::bits();\n        let b = i % B::bits();\n        let flag = B::one() << b;\n        let val = self.storage[w] & flag;\n        Some(val != B::zero())\n    } else {\n        None\n    }\n}"
    ],
    [
      "pub fn set (&mut self, i: usize, x: bool) {\n    self.ensure_invariant();\n    assert!(i < self.nbits, \"`i` out of bounds\");\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let mask = B::one() << b;\n    if x {\n        self.storage[w] = self.storage[w] | mask;\n    } else {\n        self.storage[w] = self.storage[w] & !mask;\n    }\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    self.ensure_invariant();\n    if i >= self.nbits {\n        panic!(\"index out of bounds\");\n    }\n    let w = i / B::bits();\n    let b = i % B::bits();\n    self.storage.get_mut(w).map(|block| {\n        if x {\n            *block = *block | (B::one() << b);\n        } else {\n            *block = *block & !(B::one() << b);\n        }\n    });\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    self.ensure_invariant();\n    if i >= self.nbits {\n        panic!(\"index out of bounds\");\n    }\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let flag = B::one() << b;\n    let val = if x { self.storage[w] | flag } else { self.storage[w] & !flag };\n    self.storage[w] = val;\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    self.ensure_invariant();\n    assert!(i < self.nbits, \"index out of bounds\");\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let mask = B::one() << b;\n    if x {\n        self.storage[w] |= mask;\n    } else {\n        self.storage[w] &= !mask;\n    }\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    self.ensure_invariant();\n    assert!(i < self.nbits, \"index out of bounds\");\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let flag = B::one() << b;\n    if x {\n        self.storage[w] |= flag;\n    } else {\n        self.storage[w] &= !flag;\n    }\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    self.ensure_invariant();\n    assert!(i < self.nbits, \"`i` out of bounds\");\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let flag = B::one() << b;\n    let val = if x { self.storage[w] | flag } else { self.storage[w] & !flag };\n    self.storage[w] = val;\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    self.ensure_invariant();\n    assert!(i < self.nbits, \"index out of bounds\");\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let mask = B::one() << b;\n    if x {\n        self.storage[w] |= mask;\n    } else {\n        self.storage[w] &= !mask;\n    }\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    self.ensure_invariant();\n    if i >= self.nbits {\n        panic!(\"index out of bounds\");\n    }\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let mask = B::one() << b;\n    let flag = if x { mask } else { B::zero() };\n    self.storage[w] = self.storage[w].wrapping_add(flag.wrapping_sub(self.storage[w] & mask));\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    self.ensure_invariant();\n    if i >= self.nbits {\n        panic!(\"index out of bounds\");\n    }\n    let w = i / B::bits();\n    let b = i % B::bits();\n    self.storage[w] = self.storage[w].set(b, x);\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    self.ensure_invariant();\n    if i >= self.nbits {\n        panic!(\"index out of bounds\");\n    }\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let flag = B::one() << b;\n    if x {\n        self.storage[w] |= flag;\n    } else {\n        self.storage[w] &= !flag;\n    }\n}"
    ],
    [
      "pub fn negate (&mut self) {\n    self.ensure_invariant();\n    for w in &mut self.storage { *w = !*w; }\n    self.fix_last_block();\n}",
      "pub fn negate (&mut self) {\n    self.ensure_invariant();\n    for w in &mut self.storage { *w = !*w; }\n    self.fix_last_block();\n}",
      "pub fn negate (&mut self) {\n    for w in &mut self.storage {\n        *w = !*w;\n    }\n    self.fix_last_block_with_ones();\n}",
      "pub fn negate (&mut self) {\n    self.ensure_invariant();\n    for w in &mut self.storage { *w = !*w; }\n    self.fix_last_block();\n}",
      "pub fn negate (&mut self) {\n    self.ensure_invariant();\n    for w in &mut self.storage { *w = !*w; }\n    self.fix_last_block_with_ones();\n}",
      "pub fn negate (&mut self) {\n    self.ensure_invariant();\n    for w in &mut self.storage { *w = !*w; }\n    self.fix_last_block();\n}",
      "pub fn negate (&mut self) {\n    self.ensure_invariant();\n    for w in &mut self.storage { *w = !*w; }\n    self.fix_last_block();\n}",
      "pub fn negate (&mut self) {\n    for w in &mut self.storage { *w = !*w; }\n    self.fix_last_block();\n}",
      "pub fn negate (&mut self) {\n    for w in &mut self.storage {\n        *w = !*w;\n    }\n    self.fix_last_block();\n}",
      "pub fn negate (&mut self) {\n    self.ensure_invariant();\n    for w in &mut self.storage { *w = !*w; }\n    self.fix_last_block();\n}"
    ],
    [
      "pub fn all (&self) -> bool {\n    self.blocks().all(|w| w == !B::zero())\n}",
      "pub fn all (&self) -> bool {\n    self.blocks().all(|w| w == !B::zero())\n}",
      "pub fn all (&self) -> bool {\n    self.blocks().all(|w| w == !B::zero())\n}",
      "pub fn all (&self) -> bool {\n    self.blocks().all(|w| w == !B::zero())\n}",
      "pub fn all (&self) -> bool {\n    self.blocks().all(|w| w == !B::zero())\n}",
      "pub fn all (&self) -> bool {\n    self.blocks().all(|w| w == !B::zero())\n}",
      "pub fn all (&self) -> bool {\n    self.blocks().all(|w| w == !B::zero())\n}",
      "pub fn all (&self) -> bool {\n    self.blocks().all(|w| w == !B::zero())\n}",
      "pub fn all (&self) -> bool {\n    self.blocks().all(|w| w == !B::zero())\n}",
      "pub fn all (&self) -> bool {\n    self.blocks().all(|w| w == !B::zero())\n}"
    ],
    [
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::with_capacity(self.nbits / 8);\n    let mut byte = 0;\n    let mut bit = 0;\n    for i in 0..self.nbits {\n        if self.get(i).unwrap() {\n            byte |= 1 << (7 - bit);\n        }\n        bit += 1;\n        if bit == 8 {\n            bytes.push(byte);\n            byte = 0;\n            bit = 0;\n        }\n    }\n    if bit != 0 {\n        bytes.push(byte);\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::new();\n    let mut word_index = 0;\n    let mut bit_index = 0;\n    while bit_index < self.nbits {\n        let word = self.storage[word_index];\n        let mut byte = 0;\n        for i in 0..8 {\n            if bit_index < self.nbits && self.get(bit_index) {\n                byte |= 1 << (7 - i);\n            }\n            bit_index += 1;\n        }\n        bytes.push(byte);\n        word_index += 1;\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::with_capacity(self.nbits / 8);\n    let mut i = 0;\n    while i < self.nbits {\n        let mut byte = 0;\n        for j in 0..8 {\n            if i < self.nbits && self.get(i) {\n                byte |= 1 << (7 - j);\n            }\n            i += 1;\n        }\n        bytes.push(byte);\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::new();\n    let mut word_index = 0;\n    let mut byte_index = 0;\n    let mut bit_index = 0;\n    let mut word = self.storage[word_index];\n    while bit_index < self.nbits {\n        if byte_index == 0 {\n            word = self.storage[word_index];\n            word_index += 1;\n        }\n        let bit = word & (1 << (B::bits() - 1 - byte_index));\n        if bit != 0 {\n            bytes.push(1 << (7 - byte_index));\n        } else {\n            bytes.push(0);\n        }\n        byte_index += 1;\n        if byte_index == 8 {\n            byte_index = 0;\n        }\n        bit_index += 1;\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::with_capacity(self.nbits / 8);\n    let mut byte = 0;\n    let mut bit = 0;\n    for &b in self.storage.iter() {\n        for _ in 0..B::bits() {\n            byte |= (b & (1 << bit)) >> bit;\n            bit += 1;\n            if bit == 8 {\n                bytes.push(byte);\n                byte = 0;\n                bit = 0;\n            }\n        }\n    }\n    if bit != 0 {\n        bytes.push(byte);\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::new();\n    let mut byte = 0;\n    let mut bits_read = 0;\n    let mut bits_written = 0;\n    for bit in self.iter() {\n        if bit {\n            byte |= 1 << (7 - bits_written % 8);\n        }\n        bits_read += 1;\n        bits_written += 1;\n        if bits_written % 8 == 0 {\n            bytes.push(byte);\n            byte = 0;\n        }\n    }\n    if bits_written % 8 != 0 {\n        bytes.push(byte);\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::new();\n    let mut word_index = 0;\n    let mut bit_index = 0;\n    let mut word = self.storage[word_index];\n    while bit_index < self.nbits {\n        if bit_index % 8 == 0 {\n            bytes.push((word >> (B::bits() - 8)) as u8);\n            word <<= 8;\n        } else {\n            bytes[bytes.len() - 1] |= (word & (B::one() << (B::bits() - 1))) as u8;\n            word <<= 1;\n        }\n        bit_index += 1;\n        if bit_index % B::bits() == 0 {\n            word_index += 1;\n            word = self.storage[word_index];\n        }\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::with_capacity(self.nbits / 8);\n    let mut byte = 0u8;\n    let mut bit = 0u8;\n    for (i, &b) in self.storage.iter().enumerate() {\n        for j in 0..B::bits() {\n            if b & (B::one() << j) != B::zero() {\n                byte |= 1 << (7 - bit);\n            }\n            bit += 1;\n            if bit == 8 {\n                bytes.push(byte);\n                byte = 0;\n                bit = 0;\n            }\n        }\n    }\n    if bit != 0 {\n        bytes.push(byte);\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::new();\n    let mut word = 0;\n    let mut i = 0;\n    let mut byte = 0;\n    let mut bit = 0;\n    let mut byte_index = 0;\n    let mut bit_index = 0;\n    let mut word_index = 0;\n    while i < self.nbits {\n        if bit == 0 {\n            word = self.storage[word_index];\n            word_index += 1;\n        }\n        let bit_val = (word & (1 << bit)) != 0;\n        if bit_val {\n            byte |= 1 << byte_index;\n        }\n        bit += 1;\n        i += 1;\n        if bit == B::bits() {\n            bit = 0;\n            bytes.push(byte);\n            byte = 0;\n            byte_index = 0;\n        } else {\n            byte_index += 1;\n        }\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::with_capacity(self.nbits / 8);\n    let mut byte = 0;\n    let mut bit = 0;\n    for &bit in self.storage.iter() {\n        byte |= (bit << bit) as u8;\n        bit += 1;\n        if bit == 8 {\n            bytes.push(byte);\n            byte = 0;\n            bit = 0;\n        }\n    }\n    if bit != 0 {\n        bytes.push(byte);\n    }\n    bytes\n}"
    ],
    [
      "pub fn grow (&mut self, n: usize, value: bool) {\n    let new_nbits = self.nbits + n;\n    let new_nblocks = blocks_for_bits::<B>(new_nbits);\n    self.storage.grow(new_nblocks, if value { !B::zero() } else { B::zero() });\n    self.nbits = new_nbits;\n    self.fix_last_block();\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    self.reserve(n);\n    for _ in 0..n {\n        self.push(value);\n    }\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    self.reserve(n);\n    for _ in 0..n {\n        self.push(value);\n    }\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    self.reserve(n);\n    let nblocks = n / B::bits();\n    let last_block = n % B::bits();\n    let mut last_block_val = if value { !B::zero() } else { B::zero() };\n    if last_block > 0 {\n        last_block_val &= B::max_value() >> (B::bits() - last_block);\n    }\n    for _ in 0..nblocks {\n        self.storage.push(if value { !B::zero() } else { B::zero() });\n    }\n    if last_block > 0 {\n        self.storage.push(last_block_val);\n    }\n    self.nbits += n;\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    let old_len = self.len();\n    self.reserve(n);\n    for _ in 0..n {\n        self.set(old_len, value);\n    }\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    self.reserve(n);\n    let mut i = 0;\n    while i < n {\n        self.push(value);\n        i += 1;\n    }\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    self.reserve(n);\n    for _ in 0..n {\n        self.push(value);\n    }\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    let new_len = self.len() + n;\n    if new_len > self.capacity() {\n        self.reserve(new_len - self.len());\n    }\n    let mut i = self.len();\n    while i < new_len {\n        self.set(i, value);\n        i += 1;\n    }\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    self.reserve(n);\n    let mut i = 0;\n    while i < n {\n        self.push(value);\n        i += 1;\n    }\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    self.reserve(n);\n    for _ in 0..n {\n        self.push(value);\n    }\n}"
    ],
    [
      "pub fn pop (&mut self) -> Option<bool> {\n    let len = self.len();\n    if len == 0 {\n        None\n    } else {\n        let bit = self.get(len - 1).unwrap();\n        self.set(len - 1, false);\n        self.nbits -= 1;\n        Some(bit)\n    }\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.is_empty() {\n        None\n    } else {\n        let new_nbits = self.nbits - 1;\n        let new_nblocks = self.nblocks(new_nbits);\n        let last_block = self.storage[new_nblocks - 1];\n        let bit = last_block.get_bit(new_nbits % B::bits());\n        self.nbits = new_nbits;\n        self.fix_last_block();\n        Some(bit)\n    }\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.len() == 0 {\n        None\n    } else {\n        let bit = self.get(self.len() - 1).unwrap();\n        self.set(self.len() - 1, false);\n        Some(bit)\n    }\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.is_empty() {\n        return None;\n    }\n    let idx = self.nbits - 1;\n    let bit = self.get(idx).unwrap();\n    self.set(idx, false);\n    self.nbits -= 1;\n    Some(bit)\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.is_empty() {\n        return None;\n    }\n\n    let nbits = self.nbits;\n    let new_nbits = nbits - 1;\n    let bit_idx = nbits - 1;\n    let block_idx = bit_idx / B::bits();\n    let bit_idx_in_block = bit_idx % B::bits();\n    let block = &mut self.storage[block_idx];\n    let bit = block.get(bit_idx_in_block);\n    *block = block.clear_bit(bit_idx_in_block);\n    self.nbits = new_nbits;\n    self.fix_last_block();\n    bit\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.is_empty() {\n        return None;\n    }\n    let bit = self.get(self.len() - 1).unwrap();\n    self.set(self.len() - 1, false);\n    self.nbits -= 1;\n    self.fix_last_block();\n    Some(bit)\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.is_empty() {\n        None\n    } else {\n        let bit = self.get(self.len() - 1).unwrap();\n        self.set(self.len() - 1, false);\n        self.nbits -= 1;\n        self.fix_last_block();\n        Some(bit)\n    }\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.len() == 0 {\n        return None;\n    }\n\n    let bit = self.get(self.len() - 1).unwrap();\n    self.set(self.len() - 1, false);\n    self.nbits -= 1;\n\n    self.fix_last_block();\n\n    Some(bit)\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.len() == 0 {\n        return None;\n    }\n    let last_idx = self.len() - 1;\n    let last_bit = self.get(last_idx).unwrap();\n    self.set(last_idx, false);\n    self.nbits -= 1;\n    Some(last_bit)\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.len() == 0 {\n        return None;\n    }\n    let bit_index = self.len() - 1;\n    let bit = self.get(bit_index).unwrap();\n    self.set(bit_index, false);\n    Some(bit)\n}"
    ],
    [
      "pub fn push (&mut self, elem: bool) {\n    let old_len = self.len();\n    self.nbits += 1;\n    if old_len == self.capacity() {\n        self.storage.push(if elem { !B::zero() } else { B::zero() });\n    } else {\n        let new_len = self.len();\n        let new_block = self.storage[new_len / B::bits() - 1];\n        let old_block = self.storage[new_len / B::bits()];\n        self.storage[new_len / B::bits() - 1] = if elem {\n            new_block | (B::one() << (new_len % B::bits()))\n        } else {\n            new_block & !(B::one() << (new_len % B::bits()))\n        };\n        self.storage[new_len / B::bits()] = old_block;\n    }\n}",
      "pub fn push (&mut self, elem: bool) {\n    let nbits = self.len();\n    if nbits % B::bits() == 0 {\n        self.storage.push(B::zero());\n    }\n    self.set(nbits, elem);\n}",
      "pub fn push (&mut self, elem: bool) {\n    self.ensure_invariant();\n    if self.nbits % B::bits() == 0 {\n        self.storage.push(B::zero());\n    }\n    self.set(self.nbits, elem);\n    self.nbits += 1;\n}",
      "pub fn push (&mut self, elem: bool) {\n    self.nbits += 1;\n    let old_len = self.storage.len();\n    self.storage.push(if elem { !B::zero() } else { B::zero() });\n    if self.nbits % B::bits() == 0 {\n        self.storage.push(B::zero());\n    }\n    debug_assert_eq!(self.storage.len(), old_len + 1);\n}",
      "pub fn push (&mut self, elem: bool) {\n    let old_len = self.len();\n    if old_len == self.capacity() {\n        self.reserve(1);\n    }\n    self.set(old_len, elem);\n    self.nbits += 1;\n}",
      "pub fn push (&mut self, elem: bool) {\n    self.ensure_invariant();\n    let w = self.nbits / B::bits();\n    let b = self.nbits % B::bits();\n    if b == 0 {\n        self.storage.push(if elem { !B::zero() } else { B::zero() });\n    } else {\n        let flag = B::one() << b;\n        let val = if elem { self.storage[w] | flag }\n                  else { self.storage[w] & !flag };\n        self.storage[w] = val;\n    }\n    self.nbits += 1;\n}",
      "pub fn push (&mut self, elem: bool) {\n    self.ensure_invariant();\n    if self.nbits % B::bits() == 0 {\n        self.storage.push(B::zero());\n    }\n    self.set(self.nbits, elem);\n    self.nbits += 1;\n}",
      "pub fn push (&mut self, elem: bool) {\n    let old_len = self.len();\n    self.nbits += 1;\n    if old_len == self.capacity() {\n        self.storage.push(if elem { !B::zero() } else { B::zero() });\n    } else {\n        self.set(old_len, elem);\n    }\n}",
      "pub fn push (&mut self, elem: bool) {\n    self.ensure_invariant();\n    let n = self.nbits;\n    if n % B::bits() == 0 {\n        self.storage.push(B::zero());\n    }\n    self.set(n, elem);\n    self.nbits = n + 1;\n}",
      "pub fn push (&mut self, elem: bool) {\n    self.ensure_invariant();\n    let len = self.len();\n    self.nbits = len + 1;\n    let w = len / B::bits();\n    let b = len % B::bits();\n    let flag = B::one() << b;\n    if elem {\n        self.storage[w] |= flag;\n    } else {\n        self.storage[w] &= !flag;\n    }\n    if self.nbits % B::bits() == 0 {\n        self.storage.push(B::zero());\n    }\n}"
    ],
    [
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let mut coefficients = Vec::with_capacity(degree.as_finite().unwrap() as usize);\n    for _ in 0..degree.as_finite().unwrap() {\n        coefficients.push(Scalar::random());\n    }\n    Self {\n        degree,\n        coefficients,\n    }\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let mut coefficients = vec![];\n    for _ in 0..=degree {\n        coefficients.push(Scalar::random());\n    }\n    Self { coefficients }\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let mut coeffs = vec![];\n    for _ in 0..degree.as_u16() + 1 {\n        coeffs.push(Scalar::random());\n    }\n    Self { coeffs }\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let mut rng = rand::thread_rng();\n    let mut coefficients = Vec::with_capacity(degree.into());\n    match degree {\n        PolynomialDegree::Infinity => return Self::zero(),\n        PolynomialDegree::Finite(degree) => {\n            for _ in 0..degree {\n                coefficients.push(Scalar::random(&mut rng));\n            }\n        }\n    }\n    Self::from_coefficients(coefficients)\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let mut coefficients = vec![];\n    let mut rng = rand::thread_rng();\n    for _ in 0..degree.as_usize() {\n        coefficients.push(Scalar::random(&mut rng));\n    }\n    Self { coefficients }\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let coefficients = match degree {\n        PolynomialDegree::Infinity => vec![],\n        PolynomialDegree::Finite(degree) => (0..degree).map(|_| Scalar::random()).collect(),\n    };\n    Self { coefficients }\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let mut coeffs = Vec::new();\n    let max_degree = degree.max_degree();\n    for i in 0..max_degree {\n        coeffs.push(Scalar::random());\n    }\n    Self {\n        degree,\n        coeffs,\n    }\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let mut coefficients = Vec::with_capacity(degree.as_finite().unwrap_or(0) as usize + 1);\n    for _ in 0..=degree {\n        coefficients.push(Scalar::random());\n    }\n    Self {\n        degree,\n        coefficients,\n    }\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let n = match degree {\n        PolynomialDegree::Infinity => 0,\n        PolynomialDegree::Finite(n) => n,\n    };\n    let mut coefficients = Vec::with_capacity(n as usize + 1);\n    for _ in 0..=n {\n        coefficients.push(Scalar::random());\n    }\n    Self { coefficients }\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let degree = match degree {\n        PolynomialDegree::Finite(degree) => degree,\n        PolynomialDegree::Infinity => return Self::zero(),\n    };\n    let mut coefficients = Vec::with_capacity(degree as usize + 1);\n    coefficients.push(Scalar::random());\n    for _ in 1..=degree {\n        coefficients.push(Scalar::random());\n    }\n    Self { coefficients }\n}"
    ],
    [
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = vec![const_term];\n    coefficients.extend(iter::repeat_with(Scalar::random).take(usize::from(n)));\n    Self::from_coefficients(coefficients)\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefs = vec![Scalar::zero(); usize::from(n) + 1];\n    coefs[0] = const_term;\n    for i in 1..usize::from(n) + 1 {\n        coefs[i] = Scalar::random();\n    }\n    Self::from_coefficients(coefs)\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = vec![const_term];\n    for _ in 0..n {\n        coefficients.push(Scalar::random());\n    }\n    Self::from_coefficients(coefficients)\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefs = vec![Scalar::zero(); usize::from(n) + 1];\n    coefs[0] = const_term;\n    for i in 1..=n {\n        coefs[usize::from(i)] = Scalar::random();\n    }\n    Self::from_coefficients(coefs)\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let coefficients = iter::repeat_with(Scalar::random)\n        .take(usize::from(n) + 1)\n        .collect::<Vec<_>>();\n    Self::from_coefficients(coefficients).with_fixed_const_term(const_term)\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = vec![const_term];\n    coefficients.extend(iter::repeat_with(Scalar::random).take(usize::from(n)));\n    Self::from_coefficients(coefficients)\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = vec![Scalar::zero(); usize::from(n) + 1];\n    coefficients[0] = const_term;\n    for i in 1..usize::from(n) + 1 {\n        coefficients[i] = Scalar::random();\n    }\n    Self::from_coefficients(coefficients)\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = iter::repeat_with(Scalar::random)\n        .take(usize::from(n) + 1)\n        .collect::<Vec<_>>();\n    coefficients[0] = const_term;\n    Self::from_coefficients(coefficients)\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = vec![Scalar::zero(); usize::from(n) + 1];\n    coefficients[0] = const_term;\n    for i in 1..usize::from(n) + 1 {\n        coefficients[i] = Scalar::random();\n    }\n    Self::from_coefficients(coefficients)\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefs = iter::repeat_with(Scalar::random)\n        .take(usize::from(n) + 1)\n        .collect::<Vec<_>>();\n    coefs[0] = const_term;\n    Self::from_coefficients(coefs)\n}"
    ],
    [
      "pub fn degree (&self) -> PolynomialDegree {\n    match self.coefficients.iter().rposition(|&x| x != Scalar::zero()) {\n        Some(degree) => degree.into(),\n        None => PolynomialDegree::Infinity,\n    }\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    self.coefficients.iter().rposition(|coef| *coef != Scalar::zero()).map_or(PolynomialDegree::Infinity, |deg| (deg as u16).into())\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    if self.coefficients.iter().any(|coefficient| !coefficient.is_zero()) {\n        self.coefficients.len().try_into().unwrap()\n    } else {\n        PolynomialDegree::Infinity\n    }\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    self.coefficients.iter().rposition(|coefficient| !coefficient.is_zero()).map_or(PolynomialDegree::Infinity, |degree| degree.into())\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    self.coefficients.iter().rposition(|coefficient| *coefficient != Scalar::zero()).map_or(PolynomialDegree::Infinity, |index| index.into())\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    match self.coefficients.iter().rposition(|&x| x != Scalar::zero()) {\n        Some(i) => i.into(),\n        None => PolynomialDegree::Infinity,\n    }\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    match self.coefficients.iter().rposition(|&c| c != Scalar::zero()) {\n        Some(degree) => PolynomialDegree::Finite(degree.try_into().unwrap()),\n        None => PolynomialDegree::Infinity,\n    }\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    match self.coefficients.iter().rposition(|x| *x != Scalar::zero()) {\n        Some(i) => PolynomialDegree::Finite(i.try_into().unwrap()),\n        None => PolynomialDegree::Infinity,\n    }\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    self.coefficients.iter().rposition(|c| c != &Scalar::zero()).map_or(PolynomialDegree::Infinity, |i| i.into())\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    match self.coefficients.iter().rposition(|c| c != &Scalar::zero()) {\n        Some(degree) => PolynomialDegree::Finite(degree.try_into().unwrap()),\n        None => PolynomialDegree::Infinity,\n    }\n}"
    ],
    [
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = Scalar::zero();\n    for (i, coefficient) in self.coefficients().iter().enumerate() {\n        let mut term = *coefficient;\n        for _ in 0..i {\n            term *= point_x;\n        }\n        result += term;\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = Scalar::zero();\n    for (i, coeff) in self.coefficients().iter().enumerate() {\n        let mut term = coeff.clone();\n        for j in 0..i {\n            term *= point_x.clone();\n        }\n        result += term;\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = Scalar::zero();\n    let mut point_x_power = point_x.clone();\n    for i in 0..self.coefficients.len() {\n        result = result + &self.coefficients[i] * &point_x_power;\n        point_x_power = point_x_power * point_x;\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = Scalar::zero();\n    let mut x = point_x.clone();\n    for i in 0..self.coefficients.len() {\n        result = result + &self.coefficients[i] * &x;\n        x = x * point_x;\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = Scalar::zero();\n    for (i, coeff) in self.coefficients.iter().rev().enumerate() {\n        let mut term = coeff.clone();\n        for _ in 0..i {\n            term *= point_x;\n        }\n        result += term;\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = Scalar::zero();\n    for (i, coeff) in self.coefficients.iter().enumerate() {\n        let mut tmp = coeff.clone();\n        for _ in 0..i {\n            tmp *= point_x;\n        }\n        result += tmp;\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = Scalar::zero();\n    let mut x = point_x.clone();\n    for (i, c) in self.coefficients.iter().enumerate() {\n        result += c * &x;\n        x *= point_x;\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = Scalar::zero();\n    for (i, coeff) in self.coefficients.iter().enumerate() {\n        let mut term = coeff.clone();\n        for _ in 0..i {\n            term = &term * point_x;\n        }\n        result = &result + &term;\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = Scalar::zero();\n    let mut x = point_x.clone();\n    for i in 0..self.coefficients.len() {\n        result += &self.coefficients[i] * &x;\n        x *= point_x;\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut y = self.coefficients[0].clone();\n    let mut x = point_x.clone();\n    for i in 1..self.coefficients.len() {\n        y = y + &self.coefficients[i] * &x;\n        x = x * point_x;\n    }\n    y\n}"
    ],
    [
      "pub fn back (&self) -> Option<&T> {\n    let index = self.tail?.get();\n    match &self.entries[index] {\n        Entry::Occupied(entry) => Some(&entry.value),\n        _ => None,\n    }\n}",
      "pub fn back (&self) -> Option<&T> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    Some(self.get_unchecked(index))\n}",
      "pub fn back (&self) -> Option<&T> {\n    let index = self.tail?.get();\n\n    match &self.entries[index] {\n      Entry::Occupied(entry) => Some(&entry.value),\n      _ => None,\n    }\n}",
      "pub fn back (&self) -> Option<&T> {\n    let index = self.tail?.get();\n    match &self.entries[index] {\n        Entry::Occupied(entry) => Some(&entry.value),\n        _ => None,\n    }\n}",
      "pub fn back (&self) -> Option<&T> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    Some(self.get_unchecked(index))\n}",
      "pub fn back (&self) -> Option<&T> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    Some(&self.get_unchecked(index))\n}",
      "pub fn back (&self) -> Option<&T> {\n    let index = self.tail?.get();\n\n    match &self.entries[index] {\n      Entry::Occupied(entry) => Some(&entry.value),\n      _ => None,\n    }\n}",
      "pub fn back (&self) -> Option<&T> {\n    let index = self.tail?.get();\n    match &self.entries[index] {\n        Entry::Occupied(entry) => Some(&entry.value),\n        _ => None,\n    }\n}",
      "pub fn back (&self) -> Option<&T> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    self.get(index)\n}",
      "pub fn back (&self) -> Option<&T> {\n    let index = self.tail?.get();\n\n    match &self.entries[index] {\n      Entry::Occupied(entry) => Some(&entry.value),\n      _ => None,\n    }\n  }"
    ],
    [
      "pub fn back_index (&self) -> Option<Index<T>> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    Some(index)\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    Some(index)\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    Some(index)\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    Some(index)\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    Some(index)\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    Some(index)\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    Some(index)\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    Some(index)\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    Some(index)\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    Some(index)\n}"
    ],
    [
      "pub fn clear (&mut self) {\n    self.entries.clear();\n    self.head = None;\n    self.tail = None;\n    self.length = 0;\n}",
      "pub fn clear (&mut self) {\n    self.head = None;\n    self.tail = None;\n    self.length = 0;\n    self.entries.clear();\n}",
      "pub fn clear (&mut self) {\n    let mut next_index = self.head;\n    while let Some(index) = next_index {\n        let entry = self.entries[index.get()].occupied_mut();\n        next_index = entry.next;\n        self.remove_entry(index);\n    }\n}",
      "pub fn clear (&mut self) {\n    self.entries.clear();\n    self.head = None;\n    self.tail = None;\n    self.length = 0;\n}",
      "pub fn clear (&mut self) {\n    self.entries.clear();\n    self.head = None;\n    self.tail = None;\n    self.length = 0;\n}",
      "pub fn clear (&mut self) {\n    self.head = None;\n    self.tail = None;\n    self.length = 0;\n    self.entries.clear();\n}",
      "pub fn clear (&mut self) {\n    self.entries.clear();\n    self.head = None;\n    self.tail = None;\n    self.length = 0;\n}",
      "pub fn clear (&mut self) {\n    self.head = None;\n    self.tail = None;\n    self.length = 0;\n    self.entries.clear();\n}",
      "pub fn clear (&mut self) {\n    self.head = None;\n    self.tail = None;\n    self.length = 0;\n    self.entries.clear();\n}",
      "pub fn clear (&mut self) {\n    self.head = None;\n    self.tail = None;\n    self.length = 0;\n    self.entries.clear();\n}"
    ],
    [
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?;\n    let entry = self.entries[index.get()].occupied_mut();\n    Some(&mut entry.value)\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?;\n    let entry = self.entries[index.get()].occupied_mut();\n    Some(&mut entry.value)\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    Some(self.get_mut(index).unwrap())\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    Some(self.get_mut(index).unwrap())\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?;\n    let entry = self.entries[index.get()].occupied_mut();\n    Some(&mut entry.value)\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    self.get_mut(index)\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    self.get_mut(index)\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?;\n    let entry = self.entries[index.get()].occupied_mut();\n    Some(&mut entry.value)\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    self.get_mut(index)\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    Some(&mut self.entries[index.index()].occupied_mut().value)\n}"
    ],
    [
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let index = index.index();\n    match &self.entries[index] {\n        Entry::Occupied(entry) if entry.generation == index.generation => Some(&entry.value),\n        _ => None,\n    }\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let index = index.index();\n    let entry = &self.entries[index];\n    match entry {\n        Entry::Occupied(entry) if entry.generation == index.generation => Some(&entry.value),\n        _ => None,\n    }\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let index = index.index();\n    let entry = &self.entries[index];\n    match entry {\n        Entry::Occupied(entry) if entry.generation == index.generation => Some(&entry.value),\n        _ => None,\n    }\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let index = index.index();\n    let entry = &self.entries[index];\n    match entry {\n        Entry::Occupied(entry) if entry.generation == index.generation => Some(&entry.value),\n        _ => None,\n    }\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let index = index.index();\n    let entry = &self.entries[index];\n    match entry {\n        Entry::Occupied(entry) if entry.generation == index.generation() => Some(&entry.value),\n        _ => None,\n    }\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let index = index.index();\n    let entry = &self.entries[index];\n    match entry {\n        Entry::Occupied(entry) if entry.generation == index.generation() => Some(&entry.value),\n        _ => None,\n    }\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let index = index.index();\n    let generation = index.generation();\n    match &self.entries[index] {\n        Entry::Occupied(entry) if entry.generation == generation => Some(&entry.value),\n        _ => None,\n    }\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let index = index.index();\n    let entry = &self.entries[index];\n    match entry {\n        Entry::Occupied(entry) if entry.generation == index.generation => Some(&entry.value),\n        _ => None,\n    }\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let index = index.index();\n    match &self.entries[index] {\n        Entry::Occupied(entry) if entry.generation == index.generation => Some(&entry.value),\n        _ => None,\n    }\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let index = index.index();\n    let entry = &self.entries[index];\n    match entry {\n        Entry::Occupied(entry) if entry.generation == index.generation() => Some(&entry.value),\n        _ => None,\n    }\n}"
    ],
    [
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    match self.entries.get(index.index())? {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            let next_index = entry.next?;\n            let next_entry = self.entries[next_index.get()].occupied_ref();\n            Some(Index::new(next_index, next_entry.generation))\n        }\n        _ => None,\n    }\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    match self.entries.get(index.index())? {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            let next_index = entry.next?;\n            let next_entry = self.entries[next_index.get()].occupied_ref();\n            Some(Index::new(next_index, next_entry.generation))\n        }\n        _ => None,\n    }\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    match self.entries.get(index.index())? {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            let next_index = entry.next?;\n            let next_entry = self.entries[next_index.get()].occupied_ref();\n            Some(Index::new(next_index, next_entry.generation))\n        }\n        _ => None,\n    }\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    match self.entries.get(index.index())? {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            let next_index = entry.next?;\n            let next_entry = self.entries[next_index.get()].occupied_ref();\n            Some(Index::new(next_index, next_entry.generation))\n        }\n        _ => None,\n    }\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    match self.entries.get(index.index())? {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            let next_index = entry.next?;\n            let next_entry = self.entries[next_index.get()].occupied_ref();\n            Some(Index::new(next_index, next_entry.generation))\n        }\n        _ => None,\n    }\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    match self.entries.get(index.index())? {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            let next_index = entry.next?;\n            let next_entry = self.entries[next_index.get()].occupied_ref();\n            Some(Index::new(next_index, next_entry.generation))\n        }\n        _ => None,\n    }\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    match self.entries.get(index.index())? {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            let next_index = entry.next?;\n            let next_entry = self.entries[next_index.get()].occupied_ref();\n            Some(Index::new(next_index, next_entry.generation))\n        }\n        _ => None,\n    }\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    match self.entries.get(index.index())? {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            let next_index = entry.next?;\n            let next_entry = self.entries[next_index.get()].occupied_ref();\n            Some(Index::new(next_index, next_entry.generation))\n        }\n        _ => None,\n    }\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    match self.entries.get(index.index())? {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            let next_index = entry.next?;\n            let next_entry = self.entries[next_index.get()].occupied_ref();\n            Some(Index::new(next_index, next_entry.generation))\n        }\n        _ => None,\n    }\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    match self.entries.get(index.index())? {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            let next_index = entry.next?;\n            let next_entry = self.entries[next_index.get()].occupied_ref();\n            Some(Index::new(next_index, next_entry.generation))\n        }\n        _ => None,\n    }\n}"
    ],
    [
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n  let (previous_index, next_index) = match &self.entries[index.index()] {\n    Entry::Occupied(entry) if entry.generation == index.generation() => {\n      (entry.previous(), entry.next())\n    }\n    _ => panic!(\"invalid index\"),\n  };\n  let (target_previous_index, target_next_index) = match &self.entries[target.index()] {\n    Entry::Occupied(entry) if entry.generation == target.generation() => {\n      (entry.previous(), entry.next())\n    }\n    _ => panic!(\"invalid target\"),\n  };\n  if index == target {\n    panic!(\"cannot move to self\");\n  }\n  self.update_link(previous_index, Some(target_next_index));\n  self.update_link(target_next_index, Some(index));\n  self.update_link(target_previous_index, Some(index));\n  self.update_link(Some(index), next_index);\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n  let (previous_index, next_index) = match &self.entries[index.index()] {\n    Entry::Occupied(entry) if entry.generation == index.generation() => {\n      (entry.previous, entry.next)\n    }\n    _ => panic!(\"invalid index\"),\n  };\n  let (target_previous_index, target_next_index) = match &self.entries[target.index()] {\n    Entry::Occupied(entry) if entry.generation == target.generation() => {\n      (entry.previous, entry.next)\n    }\n    _ => panic!(\"invalid target\"),\n  };\n  if previous_index == Some(target) {\n    panic!(\"index cannot be moved after itself\");\n  }\n  self.update_link(previous_index, Some(target));\n  self.update_link(Some(index), target_next_index);\n  self.update_link(target_previous_index, Some(index));\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n  let (previous_index, next_index) = match &self.entries[index.index()] {\n    Entry::Occupied(entry) if entry.generation == index.generation() => {\n      (entry.previous(), entry.next())\n    }\n    _ => panic!(\"invalid index\"),\n  };\n  let (previous_target, next_target) = match &self.entries[target.index()] {\n    Entry::Occupied(entry) if entry.generation == target.generation() => {\n      (entry.previous(), entry.next())\n    }\n    _ => panic!(\"invalid target\"),\n  };\n  if previous_index == Some(target) {\n    panic!(\"index cannot be moved to the same index\");\n  }\n  self.update_link(previous_index, Some(target));\n  self.update_link(Some(index), next_target);\n  self.update_link(previous_target, Some(index));\n  self.update_link(next_target, next_index);\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    let (previous_index, next_index) = match &self.entries[index.index()] {\n        Entry::Occupied(entry) if entry.generation == index.generation() => {\n            (entry.previous(), entry.next())\n        }\n}\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n  let (previous_index, next_index) = match &self.entries[index.index()] {\n    Entry::Occupied(entry) if entry.generation == index.generation() => {\n      (entry.previous, entry.next)\n    }\n}\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    let (previous_index, next_index) = match &self.entries[index.index()] {\n        Entry::Occupied(entry) if entry.generation == index.generation() => {\n            (entry.previous, entry.next)\n        }\n        _ => panic!(\"invalid index\"),\n    };\n    let (previous_target, next_target) = match &self.entries[target.index()] {\n        Entry::Occupied(entry) if entry.generation == target.generation() => {\n            (entry.previous, entry.next)\n        }\n        _ => panic!(\"invalid target\"),\n    };\n    if previous_index == Some(target) || next_index == Some(target) {\n        panic!(\"index and target are the same\");\n    }\n    self.update_link(previous_index, Some(target));\n    self.update_link(Some(index), next_target);\n    self.update_link(previous_target, next_index);\n    self.update_link(next_target, Some(index));\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    let (previous_index, next_index) = match &self.entries[index.index()] {\n        Entry::Occupied(entry) if entry.generation == index.generation() => {\n            (entry.previous, entry.next)\n        }\n}\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    let (previous_index, next_index) = match &self.entries[index.index()] {\n        Entry::Occupied(entry) if entry.generation == index.generation() => (entry.previous, entry.next),\n        _ => panic!(\"expected valid index\"),\n    };\n    self.update_link(previous_index, Some(target));\n    self.update_link(next_index, Some(target));\n    self.update_link(Some(target), next_index);\n    self.update_link(Some(index), None);\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n  let (previous_index, next_index) = match &self.entries[index.index()] {\n    Entry::Occupied(entry) if entry.generation == index.generation() => {\n      (entry.previous(), entry.next())\n    }\n}\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n  let (previous_index, next_index) = match &self.entries[index.index()] {\n    Entry::Occupied(entry) if entry.generation == index.generation() => {\n      (entry.previous, entry.next)\n    }\n    _ => panic!(\"invalid index\"),\n  };\n  let (target_previous_index, target_next_index) = match &self.entries[target.index()] {\n    Entry::Occupied(entry) if entry.generation == target.generation() => {\n      (entry.previous, entry.next)\n    }\n    _ => panic!(\"invalid target\"),\n  };\n  if index == target {\n    panic!(\"index and target cannot be the same\");\n  }\n  self.update_link(previous_index, Some(target_next_index));\n  self.update_link(Some(index), target_next_index);\n  self.update_link(target_previous_index, Some(index));\n  self.update_link(target_next_index, next_index);\n}"
    ],
    [
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let previous_index = self.get_previous_index(index);\n    let new_index = self.insert_new(value, previous_index, Some(index));\n    if let Some(previous_index) = previous_index {\n        self.entries[previous_index.get()].occupied_mut().next = Some(new_index);\n    }\n    if Some(index.index) == self.head {\n        self.head = Some(new_index);\n    }\n    Index::new(new_index, self.generation)\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    match self.entries.get(index.index())? {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            let previous_index = entry.previous?;\n            let previous_entry = self.entries[previous_index.get()].occupied_ref();\n            let new_index = self.insert_new(value, Some(previous_index), Some(index.index()));\n            self.entries[index.index()].occupied_mut().previous = Some(new_index);\n            self.entries[previous_index.get()].occupied_mut().next = Some(new_index);\n            Index::new(new_index, self.generation)\n        }\n        _ => None\n    }\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n  let previous_index = self.get_previous_index(index);\n  let new_index = self.insert_new(value, previous_index, Some(index));\n  if let Some(previous_index) = previous_index {\n    self.entries[previous_index.get()].occupied_mut().next = Some(new_index);\n  }\n  if Some(index.index) == self.head {\n    self.head = Some(new_index);\n  }\n  Index::new(new_index, self.generation)\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n  match self.entries.get(index.index())? {\n    Entry::Occupied(entry) if entry.generation == index.generation => {\n      let previous_index = entry.previous?;\n      let previous_entry = self.entries[previous_index.get()].occupied_ref();\n      let new_index = self.insert_new(value, Some(previous_index), Some(index.index()));\n      self.entries[index.index()].occupied_mut().previous = Some(new_index);\n      self.entries[previous_index.get()].occupied_mut().next = Some(new_index);\n      Index::new(new_index, self.generation)\n    }\n    _ => None\n  }\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n  match self.entries.get(index.index())? {\n    Entry::Occupied(entry) if entry.generation == index.generation => {\n      let previous_index = entry.previous?;\n      let previous_entry = self.entries[previous_index.get()].occupied_ref();\n      let new_index = self.insert_new(value, Some(previous_index), Some(index.index()));\n      self.entries[previous_index.get()].occupied_mut().next = Some(new_index);\n      self.entries[index.index()].occupied_mut().previous = Some(new_index);\n      Index::new(new_index, self.generation)\n    }\n    _ => None\n  }\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    match self.entries.get(index.index()) {\n        Some(Entry::Occupied(entry)) if entry.generation == index.generation => {\n            let previous_index = entry.previous;\n            let new_index = self.insert_new(value, previous_index, Some(index.index()));\n            self.entries[index.index()].occupied_mut().previous = Some(new_index);\n            if let Some(previous_index) = previous_index {\n                self.entries[previous_index.get()].occupied_mut().next = Some(new_index);\n            }\n            Index::new(new_index, self.generation)\n        }\n        _ => panic!(\"invalid index\"),\n    }\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    match self.entries.get(index.index())? {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            let previous_index = entry.previous?;\n            let previous_entry = self.entries[previous_index.get()].occupied_ref();\n            let new_index = self.insert_new(value, Some(previous_index), Some(index.index()));\n            self.entries[previous_index.get()].occupied_mut().next = Some(new_index);\n            self.entries[index.index()].occupied_mut().previous = Some(new_index);\n            Index::new(new_index, self.generation)\n        }\n        _ => None,\n    }\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let previous_index = self.get_previous_index(index);\n    let new_index = self.insert_new(value, previous_index, Some(index));\n    if let Some(previous_index) = previous_index {\n        self.entries[previous_index.get()].occupied_mut().next = Some(new_index);\n    }\n    if Some(index.index) == self.head {\n        self.head = Some(new_index);\n    }\n    Index::new(new_index, self.generation)\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let new_index = self.insert_new(value, index.previous, Some(index.index));\n    if let Some(previous_index) = index.previous {\n        self.entries[previous_index.get()].occupied_mut().next = Some(new_index);\n    }\n    if Some(index.index) == self.head {\n        self.head = Some(new_index);\n    }\n    Index::new(new_index, self.generation)\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let previous_index = self.get_previous_index(index);\n    let new_index = self.insert_new(value, previous_index, Some(index));\n    if let Some(previous_index) = previous_index {\n        self.entries[previous_index.get()].occupied_mut().next = Some(new_index);\n    }\n    if Some(index.index) == self.head {\n        self.head = Some(new_index);\n    }\n    Index::new(new_index, self.generation)\n}"
    ],
    [
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n  if minimum_capacity < self.len() {\n    panic!(\"minimum capacity must be greater than or equal to the current length\");\n  }\n\n  let mut map = HashMap::new();\n\n  let mut index = self.head;\n  while let Some(non_max_index) = index {\n    let index = non_max_index.get();\n    let entry = self.entries[index].occupied_mut();\n    let next = entry.next;\n    entry.next = None;\n    map.insert(Index::new(index), Index::new(index));\n    index = next;\n  }\n\n  self.head = None;\n  self.length = 0;\n  self.vacant_head = None;\n\n  for (index, value) in map.iter_mut() {\n    let next = self.insert_new(value.get().clone(), None, None);\n    *value = Index::new(next.get());\n  }\n\n  map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    if self.length == 0 {\n        self.entries.clear();\n        self.generation = 0;\n        self.vacant_head = None;\n        return HashMap::new();\n    }\n\n    let mut map = HashMap::new();\n    let mut previous = None;\n    let mut next = self.head;\n\n    while let Some(index) = next {\n        let entry = self.entries[index.get()].occupied_mut();\n        entry.previous = previous;\n        entry.next = None;\n        previous = Some(index);\n        next = entry.next;\n        map.insert(Index::new(index, self.generation), index.into());\n    }\n\n    self.head = previous;\n    self.vacant_head = None;\n    self.length = self.entries.len();\n\n    if self.length < minimum_capacity {\n        self.reserve(minimum_capacity - self.length);\n    }\n\n    map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n  if self.length == 0 {\n    self.entries.clear();\n    return HashMap::new();\n  }\n\n  if self.capacity() >= minimum_capacity {\n    return HashMap::new();\n  }\n\n  let mut map = HashMap::new();\n  let mut new_index = 0;\n  let mut index = self.head;\n  while let Some(current_index) = index {\n    let current_entry = &mut self.entries[current_index.get()];\n    if let Entry::Occupied(entry) = current_entry {\n      entry.index = NonMaxUsize::new(new_index).unwrap();\n      map.insert(Index::new(current_index, entry.generation), Index::new(new_index, entry.generation));\n      new_index += 1;\n    }\n    index = current_entry.vacant_ref().next;\n  }\n\n  self.entries.truncate(new_index);\n  self.vacant_head = None;\n  self.head = Some(NonMaxUsize::new(0).unwrap());\n  self.length = new_index;\n\n  map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    if self.length == 0 {\n        self.entries.clear();\n        self.vacant_head = None;\n        self.generation = 0;\n        self.head = None;\n        return HashMap::new();\n    }\n\n    let mut map = HashMap::new();\n    let mut previous = None;\n    let mut next = self.head;\n    while let Some(index) = next {\n        let entry = self.entries[index.get()].occupied_mut();\n        if let Some(previous_index) = previous {\n            map.insert(index, previous_index);\n            entry.previous = Some(previous_index);\n        } else {\n            map.insert(index, index);\n            entry.previous = None;\n        }\n        previous = Some(index);\n        next = entry.next;\n    }\n\n    self.entries.truncate(self.length);\n    self.vacant_head = None;\n    self.generation += 1;\n    self.head = previous;\n\n    map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n  if self.length == 0 {\n    self.entries.clear();\n    return HashMap::new();\n  }\n\n  if self.capacity() >= minimum_capacity {\n    return HashMap::new();\n  }\n\n  let mut map = HashMap::new();\n  let mut new_head = None;\n  let mut new_tail = None;\n  let mut previous = None;\n  let mut next = None;\n\n  for index in self.entries.iter().map(|entry| entry.occupied_ref().index) {\n    let entry = self.entries.remove(index.get()).unwrap();\n    let value = entry.occupied().value;\n\n    if entry.previous.is_some() {\n      let previous_index = entry.previous.unwrap();\n      let previous_entry = self.entries.get_mut(previous_index.get()).unwrap();\n      previous_entry.next = next;\n    } else {\n      new_head = next;\n    }\n\n    if entry.next.is_some() {\n      let next_index = entry.next.unwrap();\n      let next_entry = self.entries.get_mut(next_index.get()).unwrap();\n      next_entry.previous = previous;\n    } else {\n      new_tail = previous;\n    }\n\n    let new_index = self.insert_new(value, previous, next);\n    map.insert(index, new_index);\n    previous = Some(new_index);\n    next = Some(new_index);\n  }\n\n  self.head = new_head;\n  self.tail = new_tail;\n  map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n  if minimum_capacity < self.len() {\n    panic!(\"minimum capacity must be greater than or equal to the current length\");\n  }\n\n  if self.capacity() == minimum_capacity {\n    return HashMap::new();\n  }\n\n  let mut map = HashMap::new();\n\n  let mut previous = None;\n  let mut current = self.head;\n\n  while let Some(index) = current {\n    let entry = self.entries[index.get()].occupied_mut();\n    entry.previous = previous;\n    entry.next = None;\n\n    map.insert(Index::new(index.get(), self.generation), index.into());\n\n    previous = Some(index);\n    current = entry.next;\n  }\n\n  self.head = previous;\n  self.vacant_head = None;\n\n  for index in self.entries.iter_mut().map(|entry| entry.occupied_mut().next) {\n    if let Some(index) = index {\n      self.entries[index.get()].occupied_mut().previous = previous;\n    }\n  }\n\n  self.entries.truncate(self.len());\n\n  map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    if minimum_capacity < self.len() {\n        panic!(\"cannot pack to a capacity less than the current length\");\n    }\n\n    let mut map = HashMap::new();\n    let mut index = self.head;\n\n    while let Some(current_index) = index {\n        let current_entry = self.entries[current_index.get()].occupied_mut();\n        let next_index = current_entry.next;\n\n        if let Some(next_index) = next_index {\n            let next_entry = self.entries[next_index.get()].occupied_ref();\n            let next_previous = next_entry.previous;\n\n            if next_previous == Some(current_index) {\n                let new_index = self.insert_new(\n                    current_entry.value.clone(),\n                    Some(current_index),\n                    next_index,\n                );\n\n                map.insert(current_index, new_index);\n                index = next_index;\n                continue;\n            }\n        }\n\n        index = next_index;\n    }\n\n    self.shrink_to_fit(minimum_capacity);\n    map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n  if self.length == 0 {\n    self.entries.clear();\n    return HashMap::new();\n  }\n\n  if minimum_capacity < self.length {\n    panic!(\"minimum capacity must be at least the current length\");\n  }\n\n  let mut map = HashMap::new();\n  let mut new_head = None;\n  let mut new_tail = None;\n  let mut new_index = 0;\n\n  let mut previous = None;\n  let mut next = self.head;\n\n  while let Some(index) = next {\n    let entry = self.entries[index.get()].occupied_mut();\n\n    if entry.previous.is_some() {\n      if let Some(previous_index) = previous {\n        let previous_entry = self.entries[previous_index.get()].occupied_mut();\n        previous_entry.next = Some(index);\n      } else {\n        new_head = Some(index);\n      }\n\n      entry.previous = Some(NonMaxUsize::new(new_index).unwrap());\n      new_index += 1;\n    }\n\n    if entry.next.is_some() {\n      entry.next = Some(NonMaxUsize::new(new_index).unwrap());\n      new_index += 1;\n    }\n\n    map.insert(Index::new(index.get(), self.generation), Index::new(new_index, self.generation));\n\n    previous = Some(index);\n    next = entry.next;\n  }\n\n  if let Some(previous_index) = previous {\n    let previous_entry = self.entries[previous_index.get()].occupied_mut();\n    previous_entry.next = None;\n  }\n\n  self.head = new_head;\n  self.entries.truncate(minimum_capacity);\n  self.vacant_head = None;\n\n  map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    let mut map = HashMap::new();\n    let mut previous = None;\n    let mut next = None;\n    let mut iter = self.entries.iter_mut();\n    while let Some(entry) = iter.next() {\n        match entry {\n            Entry::Occupied(occupied) => {\n                if let Some(previous) = previous {\n                    occupied.previous = Some(previous);\n                }\n                if let Some(next) = next {\n                    occupied.next = Some(next);\n                }\n                previous = Some(occupied.index);\n                next = None;\n            }\n            Entry::Vacant(vacant) => {\n                vacant.previous = previous;\n                vacant.next = next;\n                previous = None;\n                next = Some(vacant.index);\n            }\n        }\n    }\n    if let Some(previous) = previous {\n        self.head = Some(previous);\n    }\n    if let Some(next) = next {\n        self.tail = Some(next);\n    }\n    for (index, entry) in self.entries.iter_mut().enumerate() {\n        match entry {\n            Entry::Occupied(occupied) => {\n                occupied.index = NonMaxUsize::new(index).unwrap();\n                map.insert(occupied.index, occupied.index);\n            }\n            Entry::Vacant(vacant) => {\n                vacant.index = NonMaxUsize::new(index).unwrap();\n            }\n        }\n    }\n    self.vacant_head = None;\n    self.vacant_tail = None;\n    self.length = self.entries.len();\n    map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n  if minimum_capacity < self.len() {\n    panic!(\"minimum capacity is less than the current length\");\n  }\n\n  let mut map = HashMap::new();\n\n  if self.len() == 0 {\n    self.entries.clear();\n    self.head = None;\n    self.vacant_head = None;\n    self.length = 0;\n    self.generation = 0;\n    return map;\n  }\n\n  let mut current_index = self.head.unwrap();\n  let mut current_generation = self.generation;\n  let mut previous_index = None;\n\n  while let Some(index) = current_index {\n    let entry = self.entries[index.get()].occupied_mut();\n    let next_index = entry.next;\n\n    if entry.generation == current_generation {\n      if let Some(previous_index) = previous_index {\n        self.entries[previous_index.get()].occupied_mut().next = next_index;\n      } else {\n        self.head = next_index;\n      }\n\n      if let Some(next_index) = next_index {\n        self.entries[next_index.get()].occupied_mut().previous = previous_index;\n      }\n\n      self.vacant_head = Some(index);\n      self.length -= 1;\n      map.insert(Index::new(index.get(), current_generation), Index::new(index.get(), current_generation));\n    } else {\n      previous_index = Some(index);\n    }\n\n    current_index = next_index;\n    current_generation += 1;\n  }\n\n  self.generation = current_generation;\n\n  if self.length == 0 {\n    self.head = None;\n    self.vacant_head = None;\n  }\n\n  map\n}"
    ],
    [
      "pub fn pop_back (&mut self) -> Option<T> {\n    self.remove_entry(self.tail?).map(|entry| entry.value)\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    self.remove_entry(self.tail?).map(|entry| entry.value)\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    self.remove_entry(self.tail?).map(|entry| entry.value)\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    self.remove_entry(self.tail?).map(|entry| entry.value)\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    self.remove_entry(self.tail?).map(|entry| entry.value)\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    self.remove_entry(self.tail?).map(|entry| entry.value)\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    self.remove_entry(self.tail?).map(|entry| entry.value)\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    self.remove_entry(self.tail?).map(|entry| entry.value)\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    self.remove_entry(self.tail?).map(|entry| entry.value)\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    self.remove_entry(self.tail?).map(|entry| entry.value)\n}"
    ],
    [
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let tail_index = match self.tail {\n        Some(index) => index,\n        None => return self.insert_empty(value),\n    };\n    let index = self.insert_new(value, Some(tail_index), None);\n    self.entries[tail_index.get()].occupied_mut().next = Some(index);\n    self.tail = Some(index);\n    Index::new(index, self.generation)\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let tail_index = match self.tail {\n        Some(index) => index,\n        None => return self.insert_empty(value),\n    };\n    let index = self.insert_new(value, Some(tail_index), None);\n    self.entries[tail_index.get()].occupied_mut().next = Some(index);\n    self.tail = Some(index);\n    Index::new(index, self.generation)\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let tail_index = match self.tail {\n        Some(index) => index,\n        None => return self.insert_empty(value),\n    };\n    let index = self.insert_new(value, Some(tail_index), None);\n    self.entries[tail_index.get()].occupied_mut().next = Some(index);\n    self.tail = Some(index);\n    Index::new(index, self.generation)\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let tail_index = match self.tail {\n        Some(index) => index,\n        None => return self.insert_empty(value),\n    };\n    let index = self.insert_new(value, Some(tail_index), None);\n    self.entries[tail_index.get()].occupied_mut().next = Some(index);\n    self.tail = Some(index);\n    Index::new(index, self.generation)\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let tail_index = match self.tail {\n        Some(index) => index,\n        None => return self.insert_empty(value),\n    };\n    let index = self.insert_new(value, Some(tail_index), None);\n    self.entries[tail_index.get()].occupied_mut().next = Some(index);\n    self.tail = Some(index);\n    Index::new(index, self.generation)\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let tail_index = match self.tail {\n        Some(index) => index,\n        None => return self.insert_empty(value),\n    };\n    let index = self.insert_new(value, Some(tail_index), None);\n    self.entries[tail_index.get()].occupied_mut().next = Some(index);\n    self.tail = Some(index);\n    Index::new(index, self.generation)\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let tail_index = match self.tail {\n        Some(index) => index,\n        None => return self.insert_empty(value),\n    };\n    let index = self.insert_new(value, Some(tail_index), None);\n    self.entries[tail_index.get()].occupied_mut().next = Some(index);\n    self.tail = Some(index);\n    Index::new(index, self.generation)\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n  let tail_index = match self.tail {\n    Some(index) => index,\n    None => return self.insert_empty(value),\n  };\n  let index = self.insert_new(value, Some(tail_index), None);\n  self.entries[tail_index.get()].occupied_mut().next = Some(index);\n  self.tail = Some(index);\n  Index::new(index, self.generation)\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let tail_index = match self.tail {\n        Some(index) => index,\n        None => return self.insert_empty(value),\n    };\n    let index = self.insert_new(value, Some(tail_index), None);\n    self.entries[tail_index.get()].occupied_mut().next = Some(index);\n    self.tail = Some(index);\n    Index::new(index, self.generation)\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let tail_index = match self.tail {\n        Some(index) => index,\n        None => return self.insert_empty(value),\n    };\n    let index = self.insert_new(value, Some(tail_index), None);\n    self.entries[tail_index.get()].occupied_mut().next = Some(index);\n    self.tail = Some(index);\n    Index::new(index, self.generation)\n}"
    ],
    [
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut previous_index = None;\n    let mut index = self.head;\n    while let Some(current_index) = index {\n        let current_entry = &mut self.entries[current_index.get()];\n        if predicate(&mut current_entry.value) {\n            previous_index = Some(current_index);\n            index = current_entry.next;\n        } else {\n            let next_index = current_entry.next;\n            self.remove_helper(previous_index, current_index, next_index);\n            index = next_index;\n        }\n    }\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut index = self.head;\n    while let Some(index) = index {\n        let entry = &mut self.entries[index.get()];\n        if !predicate(&mut entry.value) {\n            self.remove_entry(index);\n        }\n        index = entry.next;\n    }\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut previous_index = self.head;\n    let mut current_index = self.get_next_index(previous_index);\n    while let Some(index) = current_index {\n        let next_index = self.get_next_index(index);\n        if !predicate(&mut self.entries[index.get()].value) {\n            self.remove_helper(previous_index, index, next_index);\n        } else {\n            previous_index = Some(index);\n        }\n        current_index = next_index;\n    }\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n  let mut previous_index = None;\n  let mut index = self.head;\n  while let Some(index) = index {\n    let entry = &mut self.entries[index.get()];\n    let next_index = entry.next;\n    if predicate(&mut entry.value) {\n      if let Some(previous_index) = previous_index {\n        self.entries[previous_index.get()].next = index;\n      } else {\n        self.head = Some(index);\n      }\n      previous_index = Some(index);\n    } else {\n      self.remove_entry(index);\n    }\n    index = next_index;\n  }\n  if let Some(previous_index) = previous_index {\n    self.tail = Some(previous_index);\n  } else {\n    self.tail = None;\n  }\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut index = self.head;\n    while let Some(index) = index {\n        let entry = &mut self.entries[index.get()];\n        if !predicate(&mut entry.value) {\n            self.remove_entry(index);\n        }\n        index = entry.next;\n    }\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut index = self.head;\n    while let Some(entry_index) = index {\n        let entry = &mut self.entries[entry_index.get()];\n        if let Entry::Occupied(entry) = entry {\n            if predicate(&mut entry.value) {\n                index = entry.next;\n            } else {\n                let next_index = entry.next;\n                self.remove_helper(entry.previous, entry_index, next_index);\n                index = next_index;\n            }\n        } else {\n            unreachable!();\n        }\n    }\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut index = self.head;\n    while let Some(index) = index {\n        let entry = &mut self.entries[index.get()];\n        if !predicate(&mut entry.value) {\n            self.remove_entry(index);\n        } else {\n            index = entry.next;\n        }\n    }\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut index = self.head;\n    while let Some(index) = index {\n        let entry = &mut self.entries[index.get()];\n        if let Entry::Occupied(entry) = entry {\n            if predicate(&mut entry.value) {\n                index = entry.next;\n            } else {\n                self.remove_entry(index);\n            }\n        } else {\n            index = None;\n        }\n    }\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut index = self.head;\n    while let Some(entry_index) = index {\n        let entry = &mut self.entries[entry_index.get()];\n        if !predicate(&mut entry.value) {\n            let next_index = entry.next;\n            self.remove_entry(entry_index);\n            index = next_index;\n        } else {\n            index = entry.next;\n        }\n    }\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut previous_index = None;\n    let mut index = self.head;\n    while let Some(index) = index {\n        let index = index.get();\n        let entry = &mut self.entries[index];\n        if predicate(&mut entry.value) {\n            previous_index = Some(index);\n            index = entry.next;\n        } else {\n            self.remove_helper(previous_index, index, entry.next);\n        }\n    }\n}"
    ],
    [
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut current_free_start = 0;\n    let mut current_free_end = 0;\n    for partition in &self.partitions {\n        let start = partition.starting_lba;\n        let end = partition.ending_lba;\n        if current_free_start == 0 {\n            current_free_start = start;\n        }\n        if current_free_end < start {\n            current_free_end = start;\n        }\n        if current_free_end < end {\n            current_free_end = end;\n        }\n    }\n    if current_free_start > 0 {\n        free_sectors.push((current_free_start, current_free_end - current_free_start));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut last_lba = self.header.first_usable_lba;\n    for partition in &self.partitions {\n        if last_lba < partition.starting_lba {\n            free_sectors.push((last_lba, partition.starting_lba - last_lba));\n        }\n        last_lba = partition.ending_lba + 1;\n    }\n    if last_lba < self.header.last_usable_lba {\n        free_sectors.push((last_lba, self.header.last_usable_lba - last_lba + 1));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut current_free_start = self.header.first_usable_lba;\n    let mut current_free_end = self.header.first_usable_lba;\n    for partition in &self.partitions {\n        if current_free_end < partition.starting_lba {\n            current_free_end = partition.starting_lba;\n        }\n        if current_free_end < partition.ending_lba {\n            current_free_end = partition.ending_lba;\n        }\n        if current_free_start != current_free_end {\n            free_sectors.push((current_free_start, current_free_end - current_free_start));\n        }\n        current_free_start = partition.ending_lba + 1;\n        current_free_end = partition.ending_lba + 1;\n    }\n    if current_free_start != self.header.last_usable_lba {\n        free_sectors.push((current_free_start, self.header.last_usable_lba - current_free_start + 1));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut current_free_start = 0;\n    let mut current_free_end = 0;\n    for (i, partition) in self.partitions.iter().enumerate() {\n        if i == 0 {\n            current_free_start = self.header.first_usable_lba;\n        } else {\n            current_free_start = self.partitions[i - 1].ending_lba + 1;\n        }\n        current_free_end = partition.starting_lba - 1;\n        if current_free_end >= current_free_start {\n            free_sectors.push((current_free_start, current_free_end - current_free_start + 1));\n        }\n    }\n    current_free_start = self.partitions[self.partitions.len() - 1].ending_lba + 1;\n    current_free_end = self.header.last_usable_lba;\n    if current_free_end >= current_free_start {\n        free_sectors.push((current_free_start, current_free_end - current_free_start + 1));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut last_lba = self.header.first_usable_lba;\n    for partition in &self.partitions {\n        let first_lba = partition.starting_lba;\n        let size = partition.ending_lba - first_lba + 1;\n        if first_lba > last_lba {\n            free_sectors.push((last_lba, first_lba - last_lba));\n        }\n        last_lba = first_lba + size;\n    }\n    if last_lba < self.header.last_usable_lba {\n        free_sectors.push((last_lba, self.header.last_usable_lba - last_lba + 1));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut last_free_sector = self.header.first_usable_lba;\n    let mut last_used_sector = self.header.first_usable_lba;\n    for partition in &self.partitions {\n        if partition.starting_lba > last_used_sector {\n            free_sectors.push((last_free_sector, partition.starting_lba - last_free_sector));\n        }\n        last_free_sector = partition.ending_lba + 1;\n        last_used_sector = partition.ending_lba;\n    }\n    if last_used_sector < self.header.last_usable_lba {\n        free_sectors.push((last_free_sector, self.header.last_usable_lba - last_free_sector));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut current_free_start = self.header.first_usable_lba;\n    let mut current_free_end = self.header.first_usable_lba;\n\n    for partition in &self.partitions {\n        if partition.starting_lba > current_free_end {\n            free_sectors.push((current_free_start, current_free_end - current_free_start));\n        }\n        current_free_start = partition.ending_lba + 1;\n        current_free_end = partition.ending_lba + 1;\n    }\n\n    if current_free_end < self.header.last_usable_lba {\n        free_sectors.push((current_free_start, self.header.last_usable_lba - current_free_start));\n    }\n\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut last_lba = self.header.first_usable_lba;\n    for partition in &self.partitions {\n        let start = partition.ending_lba + 1;\n        let end = last_lba;\n        if start <= end {\n            free_sectors.push((start, end - start + 1));\n        }\n        last_lba = partition.starting_lba;\n    }\n    let start = self.header.last_usable_lba + 1;\n    let end = last_lba;\n    if start <= end {\n        free_sectors.push((start, end - start + 1));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut current_lba = self.header.first_usable_lba;\n    let mut current_size = 0;\n    for partition in &self.partitions {\n        if current_lba == partition.starting_lba {\n            current_lba = partition.ending_lba + 1;\n        } else {\n            let size = current_lba - partition.starting_lba;\n            if size > current_size {\n                free_sectors.push((partition.starting_lba, size));\n                current_size = size;\n            }\n            current_lba = partition.ending_lba + 1;\n        }\n    }\n    if current_lba < self.header.last_usable_lba {\n        free_sectors.push((current_lba, self.header.last_usable_lba - current_lba + 1));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut current_free_sectors = 0;\n    let mut current_free_starting_lba = 0;\n    for partition in &self.partitions {\n        if current_free_sectors > 0 {\n            if partition.starting_lba - current_free_starting_lba < self.align {\n                current_free_sectors += partition.starting_lba - current_free_starting_lba;\n                current_free_starting_lba = partition.ending_lba + 1;\n            } else {\n                free_sectors.push((current_free_starting_lba, current_free_sectors));\n                current_free_sectors = 0;\n            }\n        }\n        if partition.ending_lba + 1 - partition.starting_lba < self.align {\n            current_free_sectors += partition.ending_lba + 1 - partition.starting_lba;\n            current_free_starting_lba = partition.starting_lba;\n        }\n    }\n    if current_free_sectors > 0 {\n        free_sectors.push((current_free_starting_lba, current_free_sectors));\n    }\n    free_sectors\n}"
    ],
    [
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    self.find_free_sectors()\n        .into_iter()\n        .filter(|(start, end)| end - start >= size)\n        .min_by_key(|(start, end)| end - start)\n        .map(|(start, _)| start)\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    let mut optimal_place = None;\n    let mut optimal_size = None;\n    for (start, size) in self.find_free_sectors() {\n        if size >= size {\n            if optimal_size.is_none() || size < optimal_size.unwrap() {\n                optimal_place = Some(start);\n                optimal_size = Some(size);\n            }\n        }\n    }\n    optimal_place\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    self.find_free_sectors()\n        .into_iter()\n        .filter(|(start, end)| end - start >= size)\n        .min_by_key(|(start, end)| end - start)\n        .map(|(start, end)| start)\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    let mut free_sectors = self.find_free_sectors();\n    free_sectors.sort_by(|a, b| a.1.cmp(&b.1));\n    free_sectors.into_iter().find(|x| x.1 >= size).map(|x| x.0)\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    let mut optimal_place = None;\n    let mut optimal_size = None;\n    for (start, len) in self.find_free_sectors() {\n        if len < size {\n            continue;\n        }\n        if optimal_size.is_none() || len < optimal_size.unwrap() {\n            optimal_place = Some(start);\n            optimal_size = Some(len);\n        }\n    }\n    optimal_place\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    self.find_free_sectors()\n        .into_iter()\n        .filter(|(_, s)| *s >= size)\n        .min_by_key(|(_, s)| *s)\n        .map(|(l, _)| l)\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    self.find_free_sectors()\n        .into_iter()\n        .filter(|(_, size)| *size >= size)\n        .min_by_key(|(_, size)| *size)\n        .map(|(lba, _)| lba)\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    let mut free_sectors = self.find_free_sectors();\n    free_sectors.sort_by_key(|&(start, _)| start);\n    free_sectors.into_iter().find(|&(_, size)| size >= size).map(|(start, _)| start)\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    let mut optimal_place: Option<u64> = None;\n    let mut optimal_size: u64 = 0;\n    for (start, size) in self.find_free_sectors() {\n        if size >= size && size < optimal_size {\n            optimal_place = Some(start);\n            optimal_size = size;\n        }\n    }\n    optimal_place\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    self.find_free_sectors()\n        .into_iter()\n        .filter(|(start, _)| *start % self.align == 0)\n        .min_by_key(|(_, size)| *size)\n        .map(|(start, _)| start)\n}"
    ],
    [
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let mut last_lba = self.header.last_usable_lba;\n    let mut align = self.align;\n    if align == 0 {\n        return Err(Error::new(ErrorKind::DivisionByZero, \"align cannot be 0\"));\n    }\n    if last_lba % align != 0 {\n        last_lba = (last_lba / align + 1) * align;\n    }\n    Ok(last_lba - self.header.first_usable_lba)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let mut last_lba = self.header.first_usable_lba;\n    let mut last_size = 0;\n    for (lba, size) in self.find_free_sectors()? {\n        if size > last_size {\n            last_lba = lba;\n            last_size = size;\n        }\n    }\n    Ok(last_lba - self.header.first_usable_lba)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let first_usable_lba = self.header.first_usable_lba;\n    let last_usable_lba = self.header.last_usable_lba;\n    let align = self.align;\n\n    let first_usable_lba = first_usable_lba + align - 1;\n    let last_usable_lba = last_usable_lba - align + 1;\n\n    if first_usable_lba > last_usable_lba {\n        return Err(Error::NoFreeSpace);\n    }\n\n    Ok(last_usable_lba - first_usable_lba + 1)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let mut size = self.header.last_usable_lba - self.header.first_usable_lba;\n    size -= self.header.partition_entry_lba;\n    size -= self.header.number_of_partition_entries as u64;\n    size -= 2; // the primary and backup header\n    size -= 1; // the protective MBR\n    size /= self.align;\n    size *= self.align;\n    Ok(size)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let mut last_usable_lba = self.header.last_usable_lba;\n    if last_usable_lba % self.align != 0 {\n        last_usable_lba = last_usable_lba - (last_usable_lba % self.align);\n    }\n    Ok(last_usable_lba - self.header.first_usable_lba)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let mut max_size = self.header.last_usable_lba - self.header.first_usable_lba;\n    if max_size % self.align != 0 {\n        max_size -= max_size % self.align;\n    }\n    Ok(max_size)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let mut size = self.header.last_usable_lba - self.header.first_usable_lba;\n    size -= self.header.first_usable_lba;\n    size -= self.header.last_usable_lba;\n    size -= self.header.partition_entry_lba;\n    size -= self.header.number_of_partition_entries as u64;\n    size -= self.header.size_of_partition_entry as u64;\n    size -= self.header.partition_entry_array_crc32 as u64;\n    size -= self.header.primary_lba;\n    size -= self.header.backup_lba;\n    size -= self.header.first_usable_lba;\n    size -= self.header.last_usable_lba;\n    size -= self.header.disk_guid.len() as u64;\n    size -= self.header.signature.len() as u64;\n    size -= self.header.revision.len() as u64;\n    size -= self.header.header_size as u64;\n    size -= self.header.crc32_checksum as u64;\n    size -= self.header.reserved.len() as u64;\n    size -= self.sector_size;\n    size -= self.align;\n    Ok(size)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let mut max_size = self.header.last_usable_lba - self.header.first_usable_lba;\n    if self.align > 0 {\n        max_size -= max_size % self.align;\n    }\n    Ok(max_size)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let first_usable_lba = self.header.first_usable_lba;\n    let last_usable_lba = self.header.last_usable_lba;\n    let align = self.align;\n\n    if first_usable_lba > last_usable_lba {\n        return Err(Error::InvalidLBARange);\n    }\n\n    let mut size = last_usable_lba - first_usable_lba;\n    if size % align != 0 {\n        size -= size % align;\n    }\n\n    Ok(size)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let mut size = self.header.last_usable_lba + 1 - self.header.first_usable_lba;\n    if size % self.align != 0 {\n        size -= size % self.align;\n    }\n    Ok(size)\n}"
    ],
    [
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let partition_entry = &self[partition_number];\n    let start_byte = self.header.lba_to_byte(partition_entry.starting_lba)?;\n    let end_byte = self.header.lba_to_byte(partition_entry.ending_lba)?;\n    Ok(start_byte..=end_byte)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let partition = self.partitions[partition_number as usize - 1];\n    let starting_byte = partition.starting_lba * self.header.logical_block_size;\n    let ending_byte = partition.ending_lba * self.header.logical_block_size;\n    Ok(starting_byte..=ending_byte)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let partition = self[partition_number];\n    let starting_byte = partition.starting_lba * self.header.logical_block_size;\n    let ending_byte = partition.ending_lba * self.header.logical_block_size;\n    Ok(starting_byte..=ending_byte)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let partition = &self[partition_number];\n    let starting_byte = partition.starting_lba * self.header.logical_block_size;\n    let ending_byte = partition.ending_lba * self.header.logical_block_size;\n    Ok(starting_byte..=ending_byte)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let partition = self.get_partition(partition_number)?;\n    let start = partition.starting_lba * self.header.sector_size;\n    let end = partition.ending_lba * self.header.sector_size;\n    Ok(start..=end)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let partition = &self[partition_number];\n    let starting_lba = partition.starting_lba;\n    let ending_lba = partition.ending_lba;\n    let sector_size = self.header.sector_size;\n    let starting_byte = starting_lba * sector_size;\n    let ending_byte = ending_lba * sector_size;\n    Ok(starting_byte..=ending_byte)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let partition_entry = self.get_partition_entry(partition_number)?;\n    let start = partition_entry.starting_lba * self.header.logical_block_size;\n    let end = partition_entry.ending_lba * self.header.logical_block_size;\n    Ok(start..=end)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let partition_entry = self.get_partition_entry(partition_number)?;\n    let start_byte = partition_entry.starting_lba * self.header.logical_block_size;\n    let end_byte = partition_entry.ending_lba * self.header.logical_block_size;\n    Ok(start_byte..=end_byte)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let partition = &self[partition_number];\n    let start = partition.starting_lba * self.header.sector_size;\n    let end = partition.ending_lba * self.header.sector_size;\n    Ok(start..=end)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let partition_entry = self.get_partition_entry(partition_number)?;\n    let range = partition_entry.range()?;\n    Ok(range.start * self.header.sector_size..=range.end * self.header.sector_size)\n}"
    ],
    [
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}"
    ],
    [
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\ndebug_assert_eq!(self.m, self.n, \"Unable to calculate the trace of a non-square matrix\");\nlet mut tr: T = T::zero();\nfor i in 0..self.m {\ntr += self.data[i * self.m + i];\n}\ntr\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\n    let (m, n): (usize, usize) = self.dim();\n    debug_assert_eq!(m, n, \"Unable to calculate the trace of a non-square matrix\");\n    let mut tr: T = T::zero();\n    for i in 0..m\n    {\n        tr += self[[i, i]];\n    }\n    tr\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\n    let (m, n): (usize, usize) = self.dim();\n    debug_assert_eq!(\n        m, n,\n        \"Unable to compute the trace of a non-square matrix\"\n    );\n    debug_assert_ne!(\n        m, 0,\n        \"Unable to compute the trace of an empty matrix.\"\n    );\n    let mut tr: T = T::zero();\n    for i in 0..m {\n        tr += self[[i, i]];\n    }\n    tr\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\ndebug_assert_eq!(self.m, self.n, \"Unable to calculate the trace of a non-square matrix\");\nlet mut tr: T = T::zero();\nfor i in 0..self.n {\ntr += self[[i, i]];\n}\ntr\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\ndebug_assert_eq!(self.m, self.n, \"Unable to calculate the trace of a non-square matrix\");\nlet mut tr: T = T::zero();\nfor i in 0..self.n {\ntr += self[[i, i]];\n}\ntr\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\ndebug_assert_eq!(self.m, self.n, \"Unable to calculate the trace of a non-square matrix\");\ndebug_assert_ne!(self.m, 0, \"Unable to calculate the trace of an empty matrix\");\nlet mut tr: T = T::zero();\nfor i in 0..self.m {\ntr += self.data[i * self.m + i];\n}\ntr\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\ndebug_assert_eq!(self.m, self.n, \"Unable to calculate the trace of a non-square matrix\");\nlet mut tr: T = T::zero();\nfor i in 0..self.m\n{\ntr += self[[i, i]];\n}\ntr\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\n    let (m, n): (usize, usize) = self.dim();\n    debug_assert_eq!(m, n, \"Unable to calculate the trace of a non-square matrix\");\n    debug_assert_ne!(m, 0, \"Unable to calculate the trace of an empty matrix.\");\n\n    let mut tr: T = T::zero();\n    for i in 0..m {\n        tr += self[[i, i]];\n    }\n\n    tr\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\n    let (m, n): (usize, usize) = self.dim();\n    debug_assert_eq!(\n        m, n,\n        \"Unable to calculate the trace of a non-square matrix\"\n    );\n    debug_assert_ne!(\n        m, 0,\n        \"Unable to calculate the trace of an empty matrix.\"\n    );\n    let mut tr: T = T::zero();\n    for i in 0..m {\n        tr += self[[i, i]];\n    }\n    tr\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\n    let (m, n): (usize, usize) = self.dim();\n    debug_assert_eq!(\n        m, n,\n        \"Unable to calculate the trace of a non-square matrix\"\n    );\n    debug_assert_ne!(\n        m, 0,\n        \"Unable to calculate the trace of an empty matrix.\"\n    );\n    let mut tr: T = T::zero();\n    for i in 0..m {\n        tr += self[[i, i]];\n    }\n    tr\n}"
    ],
    [
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\nlet mut slice: General<T> = General::zero(row_e - row_s + 1, column_e - column_s + 1);\n\nfor r in row_s..(row_e + 1) {\nfor c in column_s..(column_e + 1) {\nslice[[r - row_s, c - column_s]] = self[[r, c]];\n}\n}\nslice\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\n    let mut slice: General<T> = General::zero(row_e - row_s + 1, column_e - column_s + 1);\n\n    for r in row_s..(row_e + 1) {\n        for c in column_s..(column_e + 1) {\n            slice[[r - row_s, c - column_s]] = self[[r, c]];\n        }\n    }\n    slice\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\nlet mut slice: General<T> = General::zero(row_e - row_s + 1, column_e - column_s + 1);\n\nfor r in row_s..(row_e + 1) {\nfor c in column_s..(column_e + 1) {\nslice[[r - row_s, c - column_s]] = self[[r, c]];\n}\n}\nslice\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\nlet mut slice: General<T> = General::zero(row_e - row_s + 1, column_e - column_s + 1);\n\nfor r in row_s..(row_e + 1) {\nfor c in column_s..(column_e + 1) {\nslice[[r - row_s, c - column_s]] = self[[r, c]];\n}\n}\nslice\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\n    let mut slice: General<T> = General::zero(row_e - row_s + 1, column_e - column_s + 1);\n\n    for r in row_s..(row_e + 1) {\n        for c in column_s..(column_e + 1) {\n            slice[[r - row_s, c - column_s]] = self[[r, c]];\n        }\n    }\n    slice\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\nlet mut slice: General<T> = General::zero(row_e - row_s + 1, column_e - column_s + 1);\n\nfor r in row_s..(row_e + 1) {\nfor c in column_s..(column_e + 1) {\nslice[[r - row_s, c - column_s]] = self[[r, c]];\n}\n}\nslice\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\n    let mut slice: General<T> = General::zero(row_e - row_s + 1, column_e - column_s + 1);\n\n    for r in row_s..(row_e + 1) {\n        for c in column_s..(column_e + 1) {\n            slice[[r - row_s, c - column_s]] = self[[r, c]];\n        }\n    }\n    slice\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\nlet mut slice: General<T> = General::zero(row_e - row_s + 1, column_e - column_s + 1);\n\nfor r in row_s..(row_e + 1) {\nfor c in column_s..(column_e + 1) {\nslice[[r - row_s, c - column_s]] = self[[r, c]];\n}\n}\nslice\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\nlet mut slice: General<T> = General::zero(row_e - row_s + 1, column_e - column_s + 1);\n\nfor r in row_s..(row_e + 1) {\nfor c in column_s..(column_e + 1) {\nslice[[r - row_s, c - column_s]] = self[[r, c]];\n}\n}\nslice\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\n    let mut slice: General<T> = General::zero(row_e - row_s + 1, column_e - column_s + 1);\n\n    for r in row_s..(row_e + 1) {\n        for c in column_s..(column_e + 1) {\n            slice[[r - row_s, c - column_s]] = self[[r, c]];\n        }\n    }\n    slice\n}"
    ],
    [
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    debug_assert!(row < self.m);\n    debug_assert!(column < self.n);\n\n    let (m, n): (usize, usize) = slice.dim();\n    for r in 0..m {\n        for c in 0..n {\n            self[[row + r, column + c]] = slice[[r, c]];\n        }\n    }\n\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    let (m, n): (usize, usize) = self.dim();\n    let (row_s, row_e, column_s, column_e): (usize, usize, usize, usize) = (0, m - 1, 0, n - 1);\n\n    for r in row_s..(row_e + 1) {\n        for c in column_s..(column_e + 1) {\n            self[[r, c]] = slice[[r - row_s, c - column_s]];\n        }\n    }\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    let (m, n): (usize, usize) = self.dim();\n    let (slice_m, slice_n): (usize, usize) = slice.dim();\n\n    debug_assert!(row + slice_m <= m);\n    debug_assert!(column + slice_n <= n);\n\n    for r in 0..slice_m {\n        for c in 0..slice_n {\n            self[[row + r, column + c]] = slice[[r, c]];\n        }\n    }\n\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    let (m, n): (usize, usize) = self.dim();\n    let (slice_m, slice_n): (usize, usize) = slice.dim();\n\n    if m == 1 {\n        debug_assert!(row + slice_m <= n);\n    } else {\n        debug_assert!(row + slice_m <= m);\n    }\n\n    if n == 1 {\n        debug_assert!(column + slice_n <= m);\n    } else {\n        debug_assert!(column + slice_n <= n);\n    }\n\n    for r in 0..slice_m {\n        for c in 0..slice_n {\n            self[[row + r, column + c]] = slice[[r, c]];\n        }\n    }\n\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    debug_assert!(row < self.m);\n    debug_assert!(column < self.n);\n\n    for r in 0..slice.m {\n        for c in 0..slice.n {\n            self[[row + r, column + c]] = slice[[r, c]];\n        }\n    }\n\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    let (m, n): (usize, usize) = self.dim();\n    let (m_slice, n_slice): (usize, usize) = slice.dim();\n    debug_assert!(row + m_slice <= m);\n    debug_assert!(column + n_slice <= n);\n\n    for i in 0..m_slice {\n        for j in 0..n_slice {\n            self[[row + i, column + j]] = slice[[i, j]];\n        }\n    }\n\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    let (m, n): (usize, usize) = self.dim();\n    let (m_slice, n_slice): (usize, usize) = slice.dim();\n\n    if m == 1 {\n        debug_assert!(row < n);\n        debug_assert!(column < n);\n    } else {\n        debug_assert!(row < m);\n        debug_assert!(column < m);\n    }\n\n    for i in 0..m_slice {\n        for j in 0..n_slice {\n            self[[row + i, column + j]] = slice[[i, j]];\n        }\n    }\n\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    let (m, n): (usize, usize) = self.dim();\n    debug_assert!(row < m);\n    debug_assert!(column < n);\n\n    let (slice_m, slice_n): (usize, usize) = slice.dim();\n    debug_assert!(slice_m <= m - row);\n    debug_assert!(slice_n <= n - column);\n\n    for r in 0..slice_m {\n        for c in 0..slice_n {\n            self[[row + r, column + c]] = slice[[r, c]];\n        }\n    }\n\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    debug_assert!(row < self.m);\n    debug_assert!(column < self.n);\n\n    for r in 0..slice.m {\n        for c in 0..slice.n {\n            self[[row + r, column + c]] = slice[[r, c]];\n        }\n    }\n\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    let (m, n): (usize, usize) = self.dim();\n    let (slice_m, slice_n): (usize, usize) = slice.dim();\n    debug_assert!(row + slice_m <= m);\n    debug_assert!(column + slice_n <= n);\n\n    for i in 0..slice_m {\n        for j in 0..slice_n {\n            self[[row + i, column + j]] = slice[[i, j]];\n        }\n    }\n\n    self\n}"
    ],
    [
      "pub fn dotp (&self, rhs: &Self) -> T {\n    let (m, n): (usize, usize) = self.dim();\n    let mut sum: T = T::zero();\n    for i in 0..m\n    {\n        sum = sum + self[i] * rhs[i];\n    }\n    sum\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    let (m, n): (usize, usize) = self.dim();\n    debug_assert_eq!(m, n);\n    debug_assert_eq!(m, rhs.dim().0);\n\n    let mut dotp: T = T::zero();\n\n    for idx in 0..m {\n        dotp += self[idx] * rhs[idx];\n    }\n\n    dotp\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    let (m, n): (usize, usize) = self.dim();\n    debug_assert_eq!(m, n);\n    debug_assert_eq!(m, rhs.dim().0);\n\n    let mut dotp: T = T::zero();\n    for idx in 0..m\n    {\n        dotp += self[idx] * rhs[idx];\n    }\n\n    dotp\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    let (m, n): (usize, usize) = self.dim();\n    debug_assert_eq!(m, rhs.dim().0);\n    debug_assert_eq!(n, rhs.dim().1);\n\n    let mut sum: T = T::zero();\n    for i in 0..m\n    {\n        sum = sum + self[i] * rhs[i];\n    }\n    sum\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    let (m, n): (usize, usize) = self.dim();\n    debug_assert_eq!(m, n);\n    debug_assert_eq!(m, rhs.dim().0);\n\n    let mut dotp: T = T::zero();\n\n    for idx in 0..m {\n        dotp += self[idx] * rhs[idx];\n    }\n\n    dotp\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    let (m, n): (usize, usize) = self.dim();\n    let mut sum: T = T::zero();\n    for i in 0..m {\n        sum += self[i] * rhs[i];\n    }\n    sum\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    let (m, n): (usize, usize) = self.dim();\n    let mut dotp: T = T::zero();\n    for i in 0..m\n    {\n        dotp += self[i] * rhs[i];\n    }\n    dotp\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    let (m, n): (usize, usize) = self.dim();\n    debug_assert_eq!(m, n);\n    debug_assert_eq!(m, rhs.dim().0);\n\n    let mut dotp: T = T::zero();\n    for i in 0..m {\n        dotp += self[i] * rhs[i];\n    }\n\n    dotp\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    let (m, n): (usize, usize) = self.dim();\n    let mut dotp: T = T::zero();\n    for idx in 0..m {\n        dotp += self[idx] * rhs[idx];\n    }\n    dotp\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    let (m, n) = self.dim();\n    debug_assert_eq!(m, rhs.dim().0);\n    let mut dotp: T = T::zero();\n    for i in 0..m {\n        dotp += self[i] * rhs[i];\n    }\n    dotp\n}"
    ],
    [
      "pub fn argmax (&self) -> usize {\n    let (m, n) = self.dim();\n    let mut max_index: usize = 0;\n    let mut max: T = self[max_index];\n\n    let limit: usize = m.max(n);\n\n    debug_assert_ne!(limit, 0);\n\n    for idx in 0..limit\n    {\n        let element: T = self[idx];\n        if element > max\n        {\n            max_index = idx;\n            max = element;\n        }\n    }\n\n    max_index\n}",
      "pub fn argmax (&self) -> usize {\n    let (m, n) = self.dim();\n    let mut max_index: usize = 0;\n    let mut max: T = self[max_index];\n\n    let limit: usize = m.max(n);\n\n    debug_assert_ne!(limit, 0);\n\n    for idx in 0..limit {\n        let element: T = self[idx];\n        if element > max {\n            max_index = idx;\n            max = element;\n        }\n    }\n\n    max_index\n}",
      "pub fn argmax (&self) -> usize {\n    let (m, n) = self.dim();\n\n    let mut max_index: usize = 0;\n    let mut max: T = self[max_index];\n\n    let limit: usize = m.max(n);\n\n    debug_assert_ne!(limit, 0);\n\n    for idx in 0..limit {\n        let element: T = self[idx];\n        if element > max {\n            max_index = idx;\n            max = element;\n        }\n    }\n\n    max_index\n}",
      "pub fn argmax (&self) -> usize {\n    let (m, n) = self.dim();\n    let mut max_index: usize = 0;\n    let mut max: T = self[max_index];\n\n    let limit: usize = m.max(n);\n\n    debug_assert_ne!(limit, 0);\n\n    for idx in 0..limit {\n        let element: T = self[idx];\n        if element > max {\n            max_index = idx;\n            max = element;\n        }\n    }\n\n    max_index\n}",
      "pub fn argmax (&self) -> usize {\n    let (m, n) = self.dim();\n    let mut max_index: usize = 0;\n    let mut max: T = self[max_index];\n    let limit: usize = m.max(n);\n    debug_assert_ne!(limit, 0);\n    for idx in 0..limit {\n        let element: T = self[idx];\n        if element > max {\n            max_index = idx;\n            max = element;\n        }\n    }\n    max_index\n}",
      "pub fn argmax (&self) -> usize {\n    let (m, n) = self.dim();\n    let mut max_index: usize = 0;\n    let mut max: T = self[max_index];\n    let limit: usize = m.max(n);\n    debug_assert_ne!(limit, 0);\n    for idx in 0..limit {\n        let element: T = self[idx];\n        if element > max {\n            max_index = idx;\n            max = element;\n        }\n    }\n    max_index\n}",
      "pub fn argmax (&self) -> usize {\n    let (m, n) = self.dim();\n\n    let mut max_index: usize = 0;\n    let mut max: T = self[max_index];\n\n    let limit: usize = m.max(n);\n\n    debug_assert_ne!(limit, 0);\n\n    for idx in 0..limit {\n        let element: T = self[idx];\n        if element > max {\n            max_index = idx;\n            max = element;\n        }\n    }\n\n    max_index\n}",
      "pub fn argmax (&self) -> usize {\n    let (m, n) = self.dim();\n    let mut max_index: usize = 0;\n    let mut max: T = self[max_index];\n\n    let limit: usize = m.max(n);\n\n    debug_assert_ne!(limit, 0);\n\n    for idx in 0..limit {\n        let element: T = self[idx];\n        if element > max {\n            max_index = idx;\n            max = element;\n        }\n    }\n\n    max_index\n}",
      "pub fn argmax (&self) -> usize {\n    let (m, n) = self.dim();\n    let mut max_index: usize = 0;\n    let mut max: T = self[max_index];\n    let limit: usize = m.max(n);\n    debug_assert_ne!(limit, 0);\n    for idx in 0..limit {\n        let element: T = self[idx];\n        if element > max {\n            max_index = idx;\n            max = element;\n        }\n    }\n    max_index\n}",
      "pub fn argmax (&self) -> usize {\n    let (m, n) = self.dim();\n\n    let mut max_index: usize = 0;\n    let mut max: T = self[max_index];\n\n    let limit: usize = m.max(n);\n\n    debug_assert_ne!(limit, 0);\n\n    for idx in 0..limit {\n        let element: T = self[idx];\n        if element > max {\n            max_index = idx;\n            max = element;\n        }\n    }\n\n    max_index\n}"
    ],
    [
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    let (m, _n): (usize, usize) = self.dim();\n    debug_assert!(s < m);\n    debug_assert!(e < m);\n    debug_assert!(s <= e);\n\n    let mut slice: Vector<T> = Vector::new_column(m - s);\n\n    for r in s..=(e) {\n        slice[r - s] = self[r];\n    }\n    slice\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    let (m, _n): (usize, usize) = self.dim();\n    debug_assert!(s < m);\n    debug_assert!(e < m);\n    debug_assert!(s <= e);\n    let mut slice: Vector<T> = Vector::new_column(m - s);\n    for r in s..(e + 1)\n    {\n        slice[r - s] = self[r];\n    }\n    slice\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    let (m, _n): (usize, usize) = self.dim();\n    debug_assert!(s < m);\n    debug_assert!(e < m);\n    debug_assert!(s <= e);\n    let mut slice: Vector<T> = Vector::new_column(m - s);\n    for r in s..(e + 1)\n    {\n        slice[r - s] = self[r];\n    }\n    slice\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    let (m, _n): (usize, usize) = self.dim();\n    debug_assert!(s < m);\n    debug_assert!(e < m);\n    debug_assert!(s <= e);\n\n    let mut slice: Vector<T> = Vector::new_column(e - s + 1);\n\n    for r in s..=(e) {\n        slice[r - s] = self[r];\n    }\n    slice\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    let (m, _n): (usize, usize) = self.dim();\n    debug_assert!(s < m);\n    debug_assert!(e < m);\n    debug_assert!(s <= e);\n\n    let mut slice: Vector<T> = Vector::new_column(m - s);\n\n    for r in s..(e + 1)\n    {\n        slice[r - s] = self[r];\n    }\n    slice\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    let (m, _n): (usize, usize) = self.dim();\n    debug_assert!(s < m);\n    debug_assert!(e < m);\n    debug_assert!(s <= e);\n\n    let mut slice: Vector<T> = Vector::new_column(m - s);\n\n    for r in s..=(e) {\n        slice[r - s] = self[r];\n    }\n    slice\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    let (m, _n): (usize, usize) = self.dim();\n    debug_assert!(s < m);\n    debug_assert!(e < m);\n    debug_assert!(s <= e);\n\n    let mut slice: Vector<T> = Vector::new_column(m - s);\n\n    for r in s..(e + 1) {\n        slice[r - s] = self[r];\n    }\n    slice\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    let (m, _n): (usize, usize) = self.dim();\n    debug_assert!(s <= e);\n    debug_assert!(e < m);\n    let mut slice: Vector<T> = Vector::new_column(vec![T::zero(); e - s + 1]);\n    for r in s..=(e) {\n        slice[r - s] = self[r];\n    }\n    slice\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    let (m, _n): (usize, usize) = self.dim();\n    debug_assert!(s < m);\n    debug_assert!(e < m);\n    debug_assert!(s <= e);\n    let mut slice: Vector<T> = Vector::zero(e - s + 1);\n    for r in s..=(e)\n    {\n        slice[r - s] = self[r];\n    }\n    slice\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    let (m, _n): (usize, usize) = self.dim();\n    debug_assert!(s < m);\n    debug_assert!(e < m);\n    debug_assert!(s <= e);\n\n    let mut slice: Vector<T> = Vector::zero(e - s + 1);\n\n    for r in s..=(e)\n    {\n        slice[r - s] = self[r];\n    }\n    slice\n}"
    ],
    [
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (rhs_m, rhs_n): (usize, usize) = rhs.dim();\n    let (m, n): (usize, usize) = self.dim();\n    if m == 1 {\n        debug_assert!(s < n);\n        debug_assert!(rhs_n + s <= n);\n    } else {\n        debug_assert!(s < m);\n        debug_assert!(rhs_m + s <= m);\n    }\n\n    for r in s..(rhs_m + s) {\n        self[r] = rhs[r - s];\n    }\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, n): (usize, usize) = self.dim();\n    let (rhs_m, rhs_n): (usize, usize) = rhs.dim();\n\n    if m == 1 {\n        debug_assert!(s < n);\n        debug_assert!(s + rhs_n <= n);\n    } else {\n        debug_assert!(s < m);\n        debug_assert!(s + rhs_m <= m);\n    }\n\n    let mut slice: Vector<T> = rhs.get_slice(0, rhs_m - 1);\n    self.set_slice(&slice, s);\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, n): (usize, usize) = self.dim();\n    if m == 1 {\n        debug_assert!(s < n);\n    } else {\n        debug_assert!(s < m);\n    }\n\n    let mut rhs_data: Vec<T> = rhs.convert_to_vec();\n    for r in s..(s + rhs_data.len()) {\n        self[r] = rhs_data[r - s];\n    }\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (rhs_m, _rhs_n): (usize, usize) = rhs.dim();\n    let (m, _n): (usize, usize) = self.dim();\n\n    debug_assert!(s < m);\n    debug_assert!(rhs_m == m - s);\n\n    for r in s..(m) {\n        self[r] = rhs[r - s];\n    }\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, n): (usize, usize) = self.dim();\n    let (rhs_m, rhs_n): (usize, usize) = rhs.dim();\n\n    if m == 1 {\n        debug_assert!(s < n);\n        debug_assert!(s + rhs_n <= n);\n    } else {\n        debug_assert!(s < m);\n        debug_assert!(s + rhs_m <= m);\n    }\n\n    for r in s..(s + rhs_m) {\n        for c in 0..rhs_n {\n            self[r][c] = rhs[r - s][c];\n        }\n    }\n}\n\nimpl<T> Display for Vector<T>\nwhere\n    T: Display,\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let (m, n): (usize, usize) = self.dim();\n\n        if m == 1 {\n            write!(f, \"[\")?;\n            for i in 0..n {\n                write!(f, \"{}\", self[i])?;\n                if i != n - 1 {\n                    write!(f, \", \")?;\n                }\n            }\n            write!(f, \"]\")?;\n        } else {\n            write!(f, \"[\\n\")?;\n            for i in 0..m {\n                write!(f, \"  \")?;\n                for j in 0..n {\n                    write!(f, \"{}\", self[i][j])?;\n                    if j != n - 1 {\n                        write!(f, \", \")?;\n                    }\n                }\n                if i != m - 1 {\n                    write!(f, \";\\n\")?;\n                }\n            }\n            write!(f, \"]\")?;\n        }\n        Ok(())\n    }\n}\n\nimpl<T> PartialEq<Self> for Vector<T>\nwhere\n    T: Scalar,",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, n): (usize, usize) = self.dim();\n    let (rhs_m, rhs_n): (usize, usize) = rhs.dim();\n    debug_assert!(s < m);\n    debug_assert!(rhs_m == rhs_n);\n    debug_assert!(rhs_n == n);\n\n    for r in s..(s + rhs_m)\n    {\n        self[r] = rhs[r - s];\n    }\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (rhs_m, rhs_n): (usize, usize) = rhs.dim();\n    let (m, n): (usize, usize) = self.dim();\n    if m == 1 {\n        debug_assert!(s < n);\n        debug_assert!(rhs_n <= n);\n    } else {\n        debug_assert!(s < m);\n        debug_assert!(rhs_m <= m);\n    }\n\n    for r in s..(s + rhs_m) {\n        self[r] = rhs[r - s];\n    }\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, n): (usize, usize) = self.dim();\n    if m == 1 {\n        debug_assert!(s < n);\n    } else {\n        debug_assert!(s < m);\n    }\n\n    let mut slice: Vector<T> = Vector::zero(rhs.dim().1);\n    for r in s..(rhs.dim().1 + s) {\n        slice[r - s] = rhs[r]\n    }\n\n    self.data[s..(rhs.dim().1 + s)] = slice.data;\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, n): (usize, usize) = self.dim();\n    let (rhs_m, rhs_n): (usize, usize) = rhs.dim();\n    debug_assert!(s < m);\n    debug_assert!(rhs_m <= m - s);\n    debug_assert!(rhs_n == n);\n\n    for r in s..(s + rhs_m) {\n        self[r] = rhs[r - s];\n    }\n}\n\nimpl<T> PartialEq<Self> for Vector<T>\nwhere\n    T: Scalar,",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, n): (usize, usize) = self.dim();\n    if m == 1 {\n        debug_assert!(s < n);\n    } else {\n        debug_assert!(s < m);\n    }\n\n    let mut rhs_data: Vec<T> = rhs.convert_to_vec();\n\n    for r in s..(m) {\n        self[r] = rhs_data[r - s];\n    }\n}"
    ],
    [
      "fn abs (&self) -> Self {\n    let re: T = self.re.abs();\n    let im: T = self.im.abs();\n    let max: T = re.max(im);\n    let min: T = re.min(im);\n    let abs: T = max * (min / max);\n    Complex { re: abs, im: T::zero() }\n}",
      "fn abs (&self) -> Self {\n    let abs: Self = self.re.powi(2) + self.im.powi(2);\n    abs.sqrt()\n}",
      "fn abs (&self) -> Self {\n    let re: Self = self.re.abs();\n    let im: Self = self.im.abs();\n    let value: Self = (re * re + im * im).sqrt();\n    value\n}",
      "fn abs (&self) -> Self {\n    let mut a: Self = self.clone();\n    a.re = a.re.abs();\n    a.im = a.im.abs();\n    a\n}",
      "fn abs (&self) -> Self {\n    let re_abs: Self = self.re.abs();\n    let im_abs: Self = self.im.abs();\n\n    let max_abs: Self = re_abs.max(im_abs);\n    let min_abs: Self = re_abs.min(im_abs);\n\n    let mut value: Self = max_abs;\n\n    if min_abs != 0.0\n    {\n        value = max_abs * (min_abs / (max_abs + min_abs));\n    }\n\n    Complex {\n        re: value,\n        im: T::zero(),\n    }\n}",
      "fn abs (&self) -> Self {\n    let re: Self = self.re.powi(2);\n    let im: Self = self.im.powi(2);\n    let sum: Self = re + im;\n    sum.sqrt()\n}",
      "fn abs (&self) -> Self {\n    self.re.powi(2) + self.im.powi(2)\n}",
      "fn abs (&self) -> Self {\n    self.re.hypot(self.im)\n}",
      "fn abs (&self) -> Self {\n    let re_abs: T = self.re.abs();\n    let im_abs: T = self.im.abs();\n\n    let abs_square: T = re_abs * re_abs + im_abs * im_abs;\n\n    Complex {\n        re: abs_square.sqrt(),\n        im: T::zero(),\n    }\n}",
      "fn abs (&self) -> Self {\n    let x: Self = self.re.powi(2);\n    let y: Self = self.im.powi(2);\n    let z: Self = x + y;\n    let w: Self = z.sqrt();\n    return w;\n}"
    ],
    [
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty() {\n        panic!(\"Root is an empty vector\");\n    }\n    let mut coef: Vec<T> = vec![T::zero(); root.len() + 1];\n    coef[0] = T::one();\n    for i in 0..root.len() {\n        for j in 0..root.len() - i {\n            coef[j] = coef[j] - root[i] * coef[j + 1];\n        }\n    }\n    Polynomial { coef }\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty() {\n        panic!(\"Root is an empty vector\");\n    }\n\n    let n: usize = root.len() - 1;\n    let mut coef: Vec<T> = vec![T::zero(); n + 1];\n\n    coef[n] = T::one();\n\n    for i in 0..n {\n        let a: T = root[i];\n        let b: T = root[n - i];\n\n        coef[i] = a - b;\n        coef[n - i] = a + b;\n    }\n\n    Polynomial { coef }\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty() {\n        panic!(\"Root is an empty vector\");\n    }\n\n    let mut coef: Vec<T> = Vec::new();\n\n    for i in 0..root.len() {\n        let mut coef_i: T = T::zero();\n\n        for j in 0..root.len() {\n            if i == j {\n                coef_i = coef_i - root[j];\n            } else {\n                coef_i = coef_i - root[j] * T::from_f64(1.0 / (root[i] - root[j])).unwrap();\n            }\n        }\n\n        coef.push(coef_i);\n    }\n\n    Polynomial { coef }\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\nif root.is_empty() {\npanic!()\n}\nlet n: usize = root.len();\nlet mut coef: Vec<T> = Vec::with_capacity(n);\ncoef.push(T::one());\n\nfor i in 0..n {\nfor j in 0..n {\nif i == j {\ncontinue;\n}\nlet a: T = T::one() / (root[i] - root[j]);\ncoef.push(a);\n}\n}\n\nPolynomial { coef }\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty() {\n        panic!(\"The root is an empty vector\");\n    }\n    let mut coef: Vec<T> = vec![T::zero(); root.len() + 1];\n    coef[0] = T::one();\n    for i in 0..root.len() {\n        let mut c: T = T::one();\n        for j in 0..root.len() {\n            if i != j {\n                c = c * (root[i] - root[j]);\n            }\n        }\n        coef[i + 1] = -c;\n    }\n    Polynomial { coef }\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty() {\n        panic!()\n    }\n    let mut coef: Vec<T> = Vec::with_capacity(root.len() + 1);\n    let n: usize = root.len();\n    coef.push(T::one());\n    for i in 0..n {\n        let mut c: T = T::zero();\n        for j in 0..n {\n            if i == j {\n                continue;\n            }\n            c = c - root[j] * coef[i - j];\n        }\n        coef.push(c);\n    }\n    coef.reverse();\n    Polynomial { coef }\n}\n\nimpl<T> Polynomial<T>\nwhere\n    T: Field + Scalar + AbsDiffEq<Epsilon = T>,",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\nif root.is_empty() {\npanic!()\n}\n\nlet n = root.len() - 1;\nlet mut coef: Vec<T> = Vec::with_capacity(n + 1);\n\nfor i in 0..n {\ncoef.push(T::one() - root[i] * root[n]);\n}\ncoef.push(T::one());\n\nPolynomial { coef }\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty() {\n        panic!()\n    }\n    let mut coef: Vec<T> = Vec::new();\n    let n: usize = root.len();\n    for i in 0..n {\n        let mut coef_i: T = T::zero();\n        for j in 0..n {\n            if i == j {\n                continue;\n            }\n            coef_i = coef_i - root[j] * T::from_f64(1.0).unwrap();\n        }\n        coef.push(coef_i);\n    }\n    coef.reverse();\n    Polynomial { coef }\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty() {\n        panic!(\"Root is an empty vector\")\n    }\n    let n: usize = root.len();\n    let mut coef: Vec<T> = vec![T::zero(); n + 1];\n    coef[n] = T::one();\n    for i in 0..n {\n        let mut factor: T = T::one();\n        for j in 0..n {\n            if i != j {\n                factor *= T::from_f64(-1.0) * root[i] * root[j];\n            }\n        }\n        coef[i] = factor;\n    }\n    Polynomial { coef }\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty() {\n        panic!()\n    }\n\n    let n: usize = root.len() - 1;\n\n    let mut coef: Vec<T> = Vec::with_capacity(n + 1);\n\n    coef.push(T::one());\n\n    for i in 0..n {\n        let mut sum: T = T::zero();\n\n        for j in 0..i + 1 {\n            sum = sum + root[j] * coef[i - j];\n        }\n\n        coef.push(-sum / T::from_f64((i + 1) as f64));\n    }\n\n    coef.push(-coef[0]);\n\n    Polynomial { coef }\n}"
    ],
    [
      "pub fn eval (&self, x: T) -> T {\n    let mut res: T = T::zero();\n    for i in 0..self.coef.len() {\n        res = res * x + self.coef[i];\n    }\n    res\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut result: T = T::zero();\n    for i in 0..self.coef.len()\n    {\n        result += self.coef[i] * x.powi(i as i32);\n    }\n    result\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut res: T = T::zero();\n    for i in 0..self.coef.len()\n    {\n        res += self.coef[i] * x.powi(i as i32);\n    }\n    res\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut result: T = T::zero();\n    for (i, c) in self.coef.iter().enumerate()\n    {\n        result += c * x.pow(i as u32);\n    }\n    result\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut result: T = T::zero();\n    for i in 0..self.coef.len()\n    {\n        result += self.coef[i] * x.pow(i as u32);\n    }\n    result\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut res: T = T::zero();\n    for i in 0..self.coef.len() {\n        res = res * x + self.coef[i];\n    }\n    res\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut result: T = T::zero();\n    for (i, coef) in self.coef.iter().enumerate() {\n        result += coef * x.powi(i as i32);\n    }\n    result\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut result: T = T::zero();\n    for (i, coef) in self.coef.iter().enumerate() {\n        result = result * x + coef;\n    }\n    result\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut result: T = T::zero();\n    for (i, c) in self.coef.iter().enumerate()\n    {\n        result += c * x.powi(i as i32);\n    }\n    result\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut res: T = T::zero();\n    for (i, coef) in self.coef.iter().enumerate() {\n        res += coef * x.powi(i as i32);\n    }\n    res\n}"
    ],
    [
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut coef_diff = Vec::with_capacity(self.degree());\n    for i in 0..self.degree() {\n        coef_diff.push(self.coef[i] * (self.degree() - i as f64));\n    }\n    Polynomial { coef: coef_diff }\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut coef_diff = Vec::with_capacity(self.degree());\n    for i in 1..self.degree() + 1 {\n        let c: T = self.coef[i];\n        let r: T = T::from_f64(i as f64);\n        coef_diff.push(c * r);\n    }\n    Polynomial { coef: coef_diff }\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut coef_diff = Vec::with_capacity(self.degree());\n    for i in 1..self.degree() + 1 {\n        coef_diff.push(self.coef[i] * T::from_f64(i as f64).unwrap());\n    }\n    Polynomial { coef: coef_diff }\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut coef = Vec::with_capacity(self.degree());\n    for i in 0..self.degree() {\n        coef.push(self.coef[i + 1] * (i + 1) as T);\n    }\n    Polynomial { coef }\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut coef_diff = Vec::with_capacity(self.degree());\n    for i in 1..self.degree() + 1 {\n        let c: T = self.coef[i];\n        let r: T = T::from_f64(i as f64);\n        coef_diff.push(c * r);\n    }\n    Polynomial { coef: coef_diff }\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut coef_diff = Vec::with_capacity(self.degree());\n    for i in 0..self.degree() {\n        coef_diff.push(self.coef[i + 1] * (i as f64 + 1.0));\n    }\n    Polynomial { coef: coef_diff }\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut coef = Vec::with_capacity(self.degree());\n    for i in 0..self.degree() {\n        coef.push(self.coef[i+1] * (i+1) as T);\n    }\n    Polynomial { coef }\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut coef_diff = Vec::with_capacity(self.degree());\n    for i in 0..self.degree() {\n        coef_diff.push(self.coef[i] * (self.degree() - i) as f64);\n    }\n    Polynomial { coef: coef_diff }\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut coef_diff = Vec::with_capacity(self.degree());\n    for i in 0..self.degree() {\n        coef_diff.push(self.coef[i] * (i as f64 + 1.0));\n    }\n    Polynomial { coef: coef_diff }\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut coef_diff = Vec::with_capacity(self.degree());\n    for i in 1..self.degree() + 1 {\n        coef_diff.push(self.coef[i] * (i as f64));\n    }\n    Polynomial { coef: coef_diff }\n}"
    ],
    [
      "pub fn integrate (&self) -> Polynomial<T> {\n    Polynomial {\n        coef: self.coef.clone().into_iter().enumerate().map(|(i, x)| x * (i as f64 + 1.0)).collect::<Vec<T>>(),\n    }\n}",
      "pub fn integrate (&self) -> Polynomial<T> {\n    let mut coef: Vec<T> = Vec::with_capacity(self.coef.len() + 1);\n    coef.push(T::zero());\n    for i in 0..self.coef.len() {\n        coef.push(self.coef[i] / (i as f64 + 1.0));\n    }\n    Polynomial { coef }\n}",
      "pub fn integrate (&self) -> Polynomial<T> {\n    Polynomial {\n        coef: self.coef.clone().into_iter().enumerate().map(|(i, x)| {\n            if i == 0 {\n                x\n            } else {\n                x * (i as f64 + 1.0)\n            }\n        }).collect::<Vec<T>>()\n    }\n}",
      "pub fn integrate (&self) -> Polynomial<T> {\n    let mut coef: Vec<T> = Vec::with_capacity(self.coef.len() + 1);\n    for i in 0..self.coef.len()\n    {\n        coef.push(self.coef[i] * (i as f64 + 1.0));\n    }\n    coef.reverse();\n    Polynomial { coef }\n}",
      "pub fn integrate (&self) -> Polynomial<T> where\n    T: Field + Scalar + AbsDiffEq<Epsilon = T>,\n{\n    let mut coef: Vec<T> = Vec::new();\n    for i in 0..self.coef.len() {\n        coef.push(self.coef[i] / (i as T + 1.0));\n    }\n    Polynomial { coef }\n}",
      "pub fn integrate (&self) -> Polynomial<T> {\n    let mut coef: Vec<T> = Vec::new();\n\n    for i in 0..self.coef.len() {\n        coef.push(self.coef[i] / (i as T + 1));\n    }\n\n    Polynomial { coef }\n}",
      "pub fn integrate (&self) -> Polynomial<T> where\n    T: Field + Scalar + AbsDiffEq<Epsilon = T>,\n{\n    let n: usize = self.degree() + 1;\n    let mut coef: Vec<T> = vec![T::zero(); n];\n\n    for i in 0..n {\n        coef[i] = self.coef[i] / (i as T + T::one());\n    }\n\n    Polynomial { coef }\n}",
      "pub fn integrate (&self) -> Polynomial<T> {\n    let mut coef: Vec<T> = Vec::new();\n\n    for i in 0..self.coef.len() {\n        coef.push(self.coef[i] * (i as f64 + 1.0));\n    }\n\n    Polynomial { coef }\n}",
      "pub fn integrate (&self) -> Polynomial<T> where\n    T: Field + Scalar + AbsDiffEq<Epsilon = T>,\n{\n    let mut coef: Vec<T> = vec![T::zero(); self.coef.len() + 1];\n\n    for i in 0..self.coef.len() {\n        coef[i] = self.coef[i] / (i as f64 + 1.0);\n    }\n\n    Polynomial { coef }\n}",
      "pub fn integrate (&self) -> Polynomial<T> {\n    Polynomial {\n        coef: self.coef.iter().enumerate().map(|(i, c)| c * T::from_f64(i as f64 + 1.0)).collect::<Vec<T>>()\n    }\n}\n"
    ],
    [
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    match self.elem_counts.entry(val) {\n        Entry::Occupied(mut entry) => {\n            let count = entry.get_mut();\n            *count += n;\n        }\n        Entry::Vacant(entry) => {\n            entry.insert(n);\n        }\n    }\n    self.size += n;\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    match self.elem_counts.entry(val) {\n        Entry::Occupied(mut entry) => {\n            let count = entry.get_mut();\n            *count += n;\n        }\n        Entry::Vacant(entry) => {\n            entry.insert(n);\n        }\n    }\n    self.size += n;\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    match self.elem_counts.entry(val) {\n        Entry::Vacant(entry) => {\n            entry.insert(n);\n            self.size += n;\n        },\n        Entry::Occupied(mut entry) => {\n            let count = entry.get_mut();\n            *count += n;\n            self.size += n;\n        }\n    }\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    match self.elem_counts.entry(val) {\n        Entry::Vacant(entry) => {\n            entry.insert(n);\n            self.size += n;\n        }\n        Entry::Occupied(mut entry) => {\n            let count = entry.get_mut();\n            *count += n;\n            self.size += n;\n        }\n    }\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    match self.elem_counts.entry(val) {\n        Entry::Occupied(mut entry) => {\n            let count = entry.get_mut();\n            *count += n;\n        }\n        Entry::Vacant(entry) => {\n            entry.insert(n);\n        }\n    }\n    self.size += n;\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    match self.elem_counts.entry(val) {\n        Entry::Occupied(mut entry) => {\n            let count = entry.get_mut();\n            *count += n;\n        }\n        Entry::Vacant(entry) => {\n            entry.insert(n);\n        }\n    }\n    self.size += n;\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    let count = self.elem_counts.entry(val).or_insert(0);\n    *count += n;\n    self.size += n;\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    match self.elem_counts.entry(val) {\n        Entry::Occupied(mut entry) => {\n            let count = entry.get_mut();\n            *count += n;\n        }\n        Entry::Vacant(entry) => {\n            entry.insert(n);\n        }\n    }\n    self.size += n;\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    match self.elem_counts.entry(val) {\n        Entry::Occupied(mut entry) => {\n            let count = entry.get_mut();\n            *count += n;\n        }\n        Entry::Vacant(entry) => {\n            entry.insert(n);\n        }\n    }\n    self.size += n;\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    match self.elem_counts.entry(val) {\n        Entry::Occupied(mut entry) => {\n            let count = entry.get_mut();\n            *count += n;\n        }\n        Entry::Vacant(entry) => {\n            entry.insert(n);\n        }\n    }\n    self.size += n;\n}"
    ],
    [
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    let mut removed = 0;\n    if let Some(count) = self.elem_counts.get_mut(val) {\n        if *count >= times {\n            *count -= times;\n            removed = times;\n        } else {\n            removed = *count;\n            self.elem_counts.remove(val);\n        }\n        self.size -= removed;\n    }\n    removed\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    let count = self.count_of(val);\n    if count == 0 {\n        return 0;\n    }\n    if count < times {\n        self.remove_all(val);\n        return count;\n    }\n    self.elem_counts.insert(val, count - times);\n    self.size -= times;\n    times\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    match self.elem_counts.entry(val) {\n        Entry::Vacant(_) => 0,\n        Entry::Occupied(mut view) => {\n            let v = view.get_mut();\n            let count = *v;\n            *v -= times;\n            if *v == 0 {\n                view.remove();\n            }\n            count\n        }\n    }\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    let mut removed = 0;\n    if let Some(count) = self.elem_counts.get_mut(val) {\n        if *count >= times {\n            *count -= times;\n            removed = times;\n        } else {\n            removed = *count;\n            self.elem_counts.remove(val);\n        }\n        self.size -= removed;\n    }\n    removed\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    let mut count = 0;\n    match self.elem_counts.entry(val.clone()) {\n        Entry::Vacant(_) => {},\n        Entry::Occupied(mut view) => {\n            let v = view.get_mut();\n            if *v >= times {\n                *v -= times;\n                count = times;\n            } else {\n                count = *v;\n                *v = 0;\n            }\n        }\n    }\n    self.size -= count;\n    count\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    let count = self.elem_counts.get(val).unwrap_or(&0);\n    let removed = if count >= &times {\n        self.size -= times;\n        self.elem_counts.insert(val.clone(), count - times);\n        times\n    } else {\n        self.size -= count;\n        self.elem_counts.remove(val);\n        *count\n    };\n    removed\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    match self.elem_counts.entry(val.clone()) {\n        Entry::Vacant(_) => 0,\n        Entry::Occupied(mut view) => {\n            let count = view.get_mut();\n            let to_remove = if times > *count {\n                *count\n            } else {\n                times\n            };\n            *count -= to_remove;\n            if *count == 0 {\n                self.size -= to_remove;\n            }\n            to_remove\n        }\n    }\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    match self.elem_counts.entry(val.clone()) {\n        Entry::Vacant(_) => 0,\n        Entry::Occupied(mut view) => {\n            let count = view.get_mut();\n            let removed = if *count >= times {\n                *count -= times;\n                times\n            } else {\n                let removed = *count;\n                *count = 0;\n                removed\n            };\n            self.size -= removed;\n            removed\n        }\n    }\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    match self.elem_counts.entry(val) {\n        Entry::Vacant(_) => 0,\n        Entry::Occupied(mut view) => {\n            let count = view.get_mut();\n            let removed = count.min(times);\n            *count -= removed;\n            self.size -= removed;\n            if *count == 0 {\n                view.remove();\n            }\n            removed\n        }\n    }\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    match self.elem_counts.entry(val) {\n        Entry::Vacant(_) => 0,\n        Entry::Occupied(mut view) => {\n            let count = *view.get();\n            if count > times {\n                *view.get_mut() -= times;\n                self.size -= times;\n                times\n            } else {\n                self.size -= count;\n                view.remove();\n                count\n            }\n        }\n    }\n}"
    ],
    [
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret = self.clone();\n    for val in rhs.distinct_elements() {\n        let count = rhs.count_of(val);\n        ret.insert_times(val, count);\n    }\n    ret\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret = self.clone();\n    for val in rhs.distinct_elements() {\n        let count = rhs.count_of(val);\n        ret.insert_times(val, count);\n    }\n    ret\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret = self.clone();\n    for val in rhs.distinct_elements() {\n        let count = rhs.count_of(val);\n        ret.insert_times(val, count);\n    }\n    ret\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret = self.clone();\n    for val in rhs.distinct_elements() {\n        let count = rhs.count_of(val);\n        ret.insert_times(val, count);\n    }\n    ret\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret = self.clone();\n    for val in rhs.distinct_elements() {\n        let count = rhs.count_of(val);\n        ret.insert_times(val, count);\n    }\n    ret\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret = self.clone();\n    for val in rhs.distinct_elements() {\n        let count = rhs.count_of(val);\n        ret.insert_times(val, count);\n    }\n    ret\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret = self.clone();\n    for val in rhs.distinct_elements() {\n        let count = rhs.count_of(val);\n        ret.insert_times(val, count);\n    }\n    ret\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret = self.clone();\n    for val in rhs.distinct_elements() {\n        let count = rhs.count_of(val);\n        ret.insert_times(val, count);\n    }\n    ret\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret = self.clone();\n    for val in rhs.distinct_elements() {\n        let count = rhs.count_of(val);\n        ret.insert_times(val, count);\n    }\n    ret\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret = self.clone();\n    for val in rhs.distinct_elements() {\n        let count = rhs.count_of(val);\n        ret.insert_times(val, count);\n    }\n    ret\n}"
    ],
    [
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        let mut remove_count = rhs.count_of(val);\n        if remove_count > count {\n            remove_count = count;\n        }\n        ret.insert_times((*val).clone(), count - remove_count);\n    }\n    ret\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        let mut remove_count = rhs.count_of(val);\n        if remove_count > count {\n            remove_count = count;\n        }\n        ret.insert_times((*val).clone(), count - remove_count);\n    }\n    ret\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        let rhs_count = rhs.count_of(val);\n        if count > rhs_count {\n            ret.insert_times((*val).clone(), count - rhs_count);\n        }\n    }\n    ret\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        let rhs_count = rhs.count_of(val);\n        if count > rhs_count {\n            ret.insert_times((*val).clone(), count - rhs_count);\n        }\n    }\n    ret\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        let rhs_count = rhs.count_of(val);\n        if count > rhs_count {\n            ret.insert_times((*val).clone(), count - rhs_count);\n        }\n    }\n    ret\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        if count > rhs.count_of(val) {\n            ret.insert_times((*val).clone(), count - rhs.count_of(val));\n        }\n    }\n    ret\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        if count > rhs.count_of(val) {\n            ret.insert_times((*val).clone(), count - rhs.count_of(val));\n        }\n    }\n    ret\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        let remove = rhs.count_of(val);\n        if count > remove {\n            ret.insert_times((*val).clone(), count - remove);\n        }\n    }\n    ret\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        let mut remove = count;\n        if let Some(rhs_count) = rhs.count_of(val) {\n            remove = remove.min(rhs_count);\n        }\n        if remove > 0 {\n            ret.insert_times((*val).clone(), count - remove);\n        }\n    }\n    ret\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        if count > rhs.count_of(val) {\n            ret.insert_times((*val).clone(), count - rhs.count_of(val));\n        }\n    }\n    ret\n}"
    ],
    [
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(b) => Cow::Borrowed(RawStr::new(b)),\n        Cow::Owned(b) => Cow::Owned(RawStr::new(b).into_owned()),\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(b) => Cow::Borrowed(RawStr::new(b)),\n        Cow::Owned(b) => Cow::Owned(RawStr::new(b)),\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(b) => Cow::Borrowed(RawStr::new(b)),\n        Cow::Owned(b) => Cow::Owned(RawStr::new(b)),\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(b) => Cow::Borrowed(RawStr::new(b)),\n        Cow::Owned(b) => Cow::Owned(RawStr::new(b)),\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(b) => Cow::Borrowed(RawStr::new(b)),\n        Cow::Owned(b) => Cow::Owned(RawStr::new(b)),\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(b) => Cow::Borrowed(RawStr::new(b)),\n        Cow::Owned(b) => Cow::Owned(RawStr::new(b)),\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(b) => Cow::Borrowed(RawStr::new(b)),\n        Cow::Owned(b) => Cow::Owned(RawStr::new(b)),\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(b) => Cow::Borrowed(RawStr::new(b)),\n        Cow::Owned(b) => Cow::Owned(RawStr::new(b)),\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(b) => Cow::Borrowed(RawStr::new(b)),\n        Cow::Owned(b) => Cow::Owned(RawStr::new(b)),\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(b) => Cow::Borrowed(RawStr::new(b)),\n        Cow::Owned(b) => Cow::Owned(RawStr::new(b).into_owned()),\n    }\n}"
    ],
    [
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let mut escaped = String::new();\n    for c in self.chars() {\n        match c {\n            '<' => escaped.push_str(\"&lt;\"),\n            '>' => escaped.push_str(\"&gt;\"),\n            '&' => escaped.push_str(\"&amp;\"),\n            '\"' => escaped.push_str(\"&quot;\"),\n            '\\'' => escaped.push_str(\"&#x27;\"),\n            '/' => escaped.push_str(\"&#x2F;\"),\n            '`' => escaped.push_str(\"&#x60;\"),\n            _ => escaped.push(c),\n        }\n    }\n    Cow::Owned(escaped)\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let string = self._replace_plus();\n    match percent_encoding::percent_decode(string.as_bytes()).decode_utf8()? {\n        Cow::Owned(s) => Ok(Cow::Owned(s)),\n        Cow::Borrowed(_) => Ok(string)\n    }\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let string = self._replace_plus();\n    match percent_encoding::percent_decode(string.as_bytes()).decode_utf8() {\n        Ok(s) => Cow::Owned(s.to_string()),\n        Err(e) => {\n            let s = e.into_owned();\n            Cow::Owned(s.into_iter().map(|b| match b {\n                b'&' => \"&amp;\".to_string(),\n                b'<' => \"&lt;\".to_string(),\n                b'>' => \"&gt;\".to_string(),\n                b'\"' => \"&quot;\".to_string(),\n                b'\\'' => \"&#x27;\".to_string(),\n                b'/' => \"&#x2F;\".to_string(),\n                b'`' => \"&#x60;\".to_string(),\n                b => b.to_string(),\n            }).collect::<String>())\n        }\n    }\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let string = self._replace_plus();\n    match percent_encoding::percent_decode(string.as_bytes()).decode_utf8()? {\n        Cow::Owned(s) => Ok(Cow::Owned(s)),\n        Cow::Borrowed(_) => Ok(string)\n    }\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let mut escaped = String::new();\n    for c in self.chars() {\n        match c {\n            '<' => escaped.push_str(\"&lt;\"),\n            '>' => escaped.push_str(\"&gt;\"),\n            '&' => escaped.push_str(\"&amp;\"),\n            '\"' => escaped.push_str(\"&quot;\"),\n            '\\'' => escaped.push_str(\"&#x27;\"),\n            '/' => escaped.push_str(\"&#x2F;\"),\n            '`' => escaped.push_str(\"&#x60;\"),\n            c => escaped.push(c),\n        }\n    }\n    escaped.into()\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let string = self.as_str();\n    let mut escaped = String::with_capacity(string.len());\n    for c in string.chars() {\n        match c {\n            '<' => escaped.push_str(\"&lt;\"),\n            '>' => escaped.push_str(\"&gt;\"),\n            '\"' => escaped.push_str(\"&quot;\"),\n            '\\'' => escaped.push_str(\"&#x27;\"),\n            '/' => escaped.push_str(\"&#x2F;\"),\n            '`' => escaped.push_str(\"&#x60;\"),\n            '&' => escaped.push_str(\"&amp;\"),\n            _ => escaped.push(c),\n        }\n    }\n    escaped.into()\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let string = self._replace_plus();\n    match percent_encoding::percent_decode(string.as_bytes()).decode_utf8() {\n        Ok(decoded) => {\n            let mut escaped = String::with_capacity(decoded.len());\n            for c in decoded.chars() {\n                match c {\n                    '&' => escaped.push_str(\"&amp;\"),\n                    '<' => escaped.push_str(\"&lt;\"),\n                    '>' => escaped.push_str(\"&gt;\"),\n                    '\"' => escaped.push_str(\"&quot;\"),\n                    '\\'' => escaped.push_str(\"&#x27;\"),\n                    '/' => escaped.push_str(\"&#x2F;\"),\n                    '`' => escaped.push_str(\"&#x60;\"),\n                    _ => escaped.push(c),\n                }\n            }\n            Cow::Owned(escaped)\n        },\n        Err(_) => string\n    }\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let mut output = String::new();\n    for c in self.chars() {\n        match c {\n            '<' => output.push_str(\"&lt;\"),\n            '>' => output.push_str(\"&gt;\"),\n            '\"' => output.push_str(\"&quot;\"),\n            '\\'' => output.push_str(\"&#x27;\"),\n            '&' => output.push_str(\"&amp;\"),\n            '/' => output.push_str(\"&#x2F;\"),\n            '`' => output.push_str(\"&#x60;\"),\n            _ => output.push(c),\n        }\n    }\n    output.into()\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let string = self.as_str();\n    let mut escaped = String::with_capacity(string.len());\n    for c in string.chars() {\n        match c {\n            '<' => escaped.push_str(\"&lt;\"),\n            '>' => escaped.push_str(\"&gt;\"),\n            '\"' => escaped.push_str(\"&quot;\"),\n            '\\'' => escaped.push_str(\"&#x27;\"),\n            '/' => escaped.push_str(\"&#x2F;\"),\n            '`' => escaped.push_str(\"&#x60;\"),\n            '&' => escaped.push_str(\"&amp;\"),\n            c => escaped.push(c),\n        }\n    }\n    escaped.into()\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let string = self.as_str();\n    let mut result = String::with_capacity(string.len());\n    for c in string.chars() {\n        match c {\n            '<' => result.push_str(\"&lt;\"),\n            '>' => result.push_str(\"&gt;\"),\n            '\"' => result.push_str(\"&quot;\"),\n            '\\'' => result.push_str(\"&#x27;\"),\n            '/' => result.push_str(\"&#x2F;\"),\n            '`' => result.push_str(\"&#x60;\"),\n            '&' => result.push_str(\"&amp;\"),\n            c => result.push(c),\n        }\n    }\n    result.into()\n}"
    ],
    [
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let bytes = self.as_bytes();\n    let mut i = 0;\n    while i < bytes.len() {\n        if bytes[i] == b {\n            return (self.slice(0, i), self.slice(i + 1, self.len()));\n        }\n        i += 1;\n    }\n    (self, RawStr::new(\"\"))\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let bytes = self.as_bytes();\n    let mut i = 0;\n    while i < bytes.len() && bytes[i] != b {\n        i += 1;\n    }\n    (&self[..i], &self[i..])\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let mut iter = self.as_str().bytes();\n    let mut before = \"\";\n    let mut after = \"\";\n    while let Some(c) = iter.next() {\n        if c == b {\n            after = iter.as_str();\n            break;\n        }\n        before = iter.as_str();\n    }\n    (RawStr::new(before), RawStr::new(after))\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let bytes = self.as_bytes();\n    let mut i = 0;\n    while i < bytes.len() {\n        if bytes[i] == b {\n            break;\n        }\n        i += 1;\n    }\n    (self.slice(0, i), self.slice(i + 1, self.len()))\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let mut iter = self.as_str().bytes();\n    let mut before = RawStr::new(\"\");\n    let mut after = RawStr::new(\"\");\n    loop {\n        match iter.next() {\n            Some(c) => {\n                if c == b {\n                    after = RawStr::new(iter.as_str());\n                    break;\n                }\n                before.push(c as char);\n            }\n            None => break,\n        }\n    }\n    (&before, &after)\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let mut i = 0;\n    while i < self.len() {\n        if self.as_bytes()[i] == b {\n            return (&self[..i], &self[i + 1..]);\n        }\n        i += 1;\n    }\n    (self, RawStr::new(\"\"))\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let mut i = 0;\n    let mut j = 0;\n    for (k, c) in self.as_str().char_indices() {\n        if c as u8 == b {\n            i = k;\n            break;\n        }\n\n        j = k;\n    }\n\n    (RawStr::new(&self.as_str()[..i]), RawStr::new(&self.as_str()[j..]))\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    if self.is_empty() {\n        return (self, self);\n    }\n\n    let mut i = 0;\n    let mut found = false;\n    let mut before = 0;\n    let mut after = 0;\n    while i < self.len() {\n        if self.as_bytes()[i] == b {\n            found = true;\n            break;\n        }\n\n        i += 1;\n    }\n\n    if found {\n        before = i;\n        after = i + 1;\n    } else {\n        before = self.len();\n        after = 0;\n    }\n\n    (&self[..before], &self[after..])\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let bytes = self.as_bytes();\n    let mut i = 0;\n    while i < bytes.len() {\n        if bytes[i] == b {\n            return (&self[..i], &self[i + 1..]);\n        }\n        i += 1;\n    }\n    (self, &self[bytes.len()..])\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let mut iter = self.as_str().bytes();\n    let mut before = \"\";\n    let mut after = \"\";\n    let mut found = false;\n    while let Some(c) = iter.next() {\n        if c == b {\n            found = true;\n            break;\n        }\n        before = before.push(c as char);\n    }\n    while let Some(c) = iter.next() {\n        after = after.push(c as char);\n    }\n    if found {\n        (RawStr::new(before), RawStr::new(after))\n    } else {\n        (self, RawStr::new(\"\"))\n    }\n}"
    ],
    [
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Get | Method::Head | Method::Connect | Method::Trace | Method::Options => false,\n        _ => true\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Get | Method::Head | Method::Connect | Method::Trace | Method::Options => false,\n        _ => true,\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Get | Method::Head | Method::Connect | Method::Trace | Method::Options => false,\n        _ => true\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Get | Method::Head | Method::Connect | Method::Trace | Method::Options => false,\n        _ => true\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Get | Method::Head | Method::Connect | Method::Trace | Method::Options => false,\n        Method::Put | Method::Post | Method::Delete | Method::Patch => true\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Get | Method::Head | Method::Connect | Method::Trace | Method::Options => false,\n        _ => true\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Get | Method::Head | Method::Connect | Method::Trace | Method::Options => false,\n        Method::Put | Method::Post | Method::Delete | Method::Patch => true,\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Get | Method::Head | Method::Connect | Method::Trace | Method::Options => false,\n        _ => true\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Get | Method::Head | Method::Connect | Method::Trace | Method::Options => false,\n        _ => true\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Get | Method::Head | Method::Connect | Method::Trace | Method::Options => false,\n        _ => true\n    }\n}"
    ],
    [
      "pub const fn is_valid_name (name: &str) -> bool {\n    name.chars().all(|c| c.is_ascii_alphanumeric() || c == '!' || c == '#' || c == '$' || c == '%' || c == '&' || c == '\\'' || c == '*' || c == '+' || c == '-' || c == '.' || c == '^' || c == '_' || c == '`' || c == '|' || c == '~')\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    if name.is_empty() {\n        return false;\n    }\n\n    for (i, c) in name.chars().enumerate() {\n        if i == 0 {\n            if !c.is_ascii_alphanumeric() {\n                return false;\n            }\n        } else {\n            if !c.is_ascii_alphanumeric() && !c.is_ascii_punctuation() {\n                return false;\n            }\n        }\n    }\n\n    true\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    if name.is_empty() {\n        return false;\n    }\n\n    for c in name.chars() {\n        if c.is_ascii_alphanumeric() || c == '!' || c == '#' || c == '$' || c == '%' || c == '&' || c == '\\'' || c == '*' || c == '+' || c == '-' || c == '.' || c == '^' || c == '_' || c == '`' || c == '|' || c == '~' {\n            continue;\n        }\n\n        return false;\n    }\n\n    true\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    if name.is_empty() {\n        return false;\n    }\n\n    let mut iter = name.chars();\n    let first = iter.next().unwrap();\n    if !(first.is_alphanumeric() || first == '!' || first == '#' || first == '$' || first == '%' || first == '&' || first == '\\'' || first == '*' || first == '+' || first == '-' || first == '.' || first == '^' || first == '_' || first == '`' || first == '|' || first == '~') {\n        return false;\n    }\n\n    for c in iter {\n        if !(c.is_alphanumeric() || c == '!' || c == '#' || c == '$' || c == '%' || c == '&' || c == '\\'' || c == '*' || c == '+' || c == '-' || c == '.' || c == '^' || c == '_' || c == '`' || c == '|' || c == '~') {\n            return false;\n        }\n    }\n\n    true\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    let mut iter = name.chars();\n    if let Some(c) = iter.next() {\n        if !c.is_ascii_alphanumeric() && !c.is_ascii_punctuation() {\n            return false;\n        }\n    }\n    for c in iter {\n        if !c.is_ascii_alphanumeric() && !c.is_ascii_punctuation() && !c.is_ascii_whitespace() {\n            return false;\n        }\n    }\n    true\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    name.chars().all(|c| {\n        match c {\n            '!' | '#' | '$' | '%' | '&' | '\\'' | '*' | '+' | '-' | '.' | '^' | '_' | '`' | '|' | '~' | '0'..='9' | 'a'..='z' | 'A'..='Z' => true,\n            _ => false\n        }\n    })\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    let mut iter = name.chars();\n    match iter.next() {\n        Some(c) => {\n            c.is_ascii_alphanumeric() || c == '!' || c == '#' || c == '$' || c == '%' || c == '&' || c == '\\'' || c == '*' || c == '+' || c == '-' || c == '.' || c == '^' || c == '_' || c == '`' || c == '|' || c == '~'\n        },\n        None => false\n    } && iter.all(|c| c.is_ascii_alphanumeric() || c == '!' || c == '#' || c == '$' || c == '%' || c == '&' || c == '\\'' || c == '*' || c == '+' || c == '-' || c == '.' || c == '^' || c == '_' || c == '`' || c == '|' || c == '~' || c == ' ' || c == '\\t')\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    let mut iter = name.chars();\n    if let Some(c) = iter.next() {\n        if c.is_digit(10) || c.is_alphabetic() {\n            for c in iter {\n                if c.is_digit(10) || c.is_alphabetic() || c == '-' || c == '_' || c == '~' {\n                    continue;\n                }\n                return false;\n            }\n            return true;\n        }\n    }\n    false\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    name.chars().all(|c| c.is_ascii_alphanumeric() || c == '!' || c == '#' || c == '$' || c == '%' || c == '&' || c == '\\'' || c == '*' || c == '+' || c == '-' || c == '.' || c == '^' || c == '_' || c == '`' || c == '|' || c == '~')\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    let mut chars = name.chars();\n    match chars.next() {\n        Some(c) => {\n            if !c.is_ascii_alphanumeric() && !c.is_ascii_punctuation() {\n                return false;\n            }\n            for c in chars {\n                if !c.is_ascii_alphanumeric() && !c.is_ascii_punctuation() && !c.is_ascii_whitespace() {\n                    return false;\n                }\n            }\n            true\n        },\n        None => false\n    }\n}"
    ],
    [
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    self.headers.entry(Uncased::new(name)).or_insert(vec![]).append(values);\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    self.headers.entry(Uncased::new(name)).or_insert(vec![]).append(values);\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    self.headers.entry(Uncased::new(name)).or_insert(vec![]).append(values);\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    self.headers.entry(Uncased::new(name)).or_insert(vec![]).append(values);\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    self.headers.entry(Uncased::new(name)).or_insert(vec![]).append(values);\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    self.headers.entry(Uncased::new(name)).or_insert(vec![]).append(values);\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    self.headers.entry(Uncased::new(name)).or_insert(vec![]).append(values);\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    self.headers.entry(Uncased::new(name)).or_insert(vec![]).append(values);\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    self.headers.entry(Uncased::new(name)).or_insert(vec![]).append(values);\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    self.headers.entry(Uncased::new(name)).or_insert(vec![]).append(values);\n}"
    ],
    [
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}"
    ],
    [
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}"
    ],
    [
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}"
    ],
    [
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    let n = self.pos + n;\n    if n >= self.segments.len() {\n        return None;\n    }\n\n    let mut i = 0;\n    let mut start = 0;\n    let mut end = 0;\n    for (i, &b) in self.segments.iter().enumerate() {\n        if b == b'=' {\n            end = i;\n            break;\n        }\n    }\n\n    let mut start = start;\n    let mut end = end;\n    if end == 0 {\n        end = i;\n    }\n\n    let mut start = start;\n    let mut end = end;\n    if end == 0 {\n        end = i;\n    }\n\n    Some((&self.segments[start..end], &self.segments[end+1..]))\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    let n = n + self.pos;\n    if n >= self.segments.len() {\n        return None;\n    }\n\n    let mut iter = self.segments[n].splitn(2, '=');\n    let key = iter.next().unwrap();\n    let value = iter.next().unwrap_or(\"\");\n    Some((key, value))\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    let mut i = 0;\n    for (key, value) in self.segments.iter() {\n        if i == n {\n            return Some((key, value));\n        }\n        i += 1;\n    }\n    None\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    if n >= self.len() {\n        return None;\n    }\n\n    let mut pos = self.pos;\n    let mut iter = self.segments.iter();\n\n    while pos > 0 {\n        iter.next();\n        pos -= 1;\n    }\n\n    let mut key = None;\n    let mut value = None;\n\n    for (i, segment) in iter.enumerate() {\n        if i % 2 == 0 {\n            key = Some(segment);\n        } else {\n            value = Some(segment);\n            break;\n        }\n    }\n\n    self.pos += 1;\n    Some((key.unwrap(), value.unwrap()))\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    if n < self.len() {\n        let pos = self.pos + n;\n        let mut iter = self.segments.iter();\n        for _ in 0..pos {\n            iter.next();\n        }\n        let (key, value) = iter.next().unwrap();\n        Some((key, value))\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    if n < self.len() {\n        let mut pos = self.pos;\n        let mut i = 0;\n        while i < n {\n            pos += 1;\n            if self.segments[pos] == '&' {\n                i += 1;\n            }\n        }\n\n        let mut key = pos;\n        let mut val = pos;\n        while self.segments[val] != '=' && self.segments[val] != '&' {\n            val += 1;\n        }\n\n        if self.segments[val] == '=' {\n            val += 1;\n            while self.segments[val] != '&' {\n                val += 1;\n            }\n        }\n\n        let key_slice = &self.segments[key..val];\n        let val_slice = &self.segments[val..];\n        return Some((key_slice, val_slice));\n    }\n\n    None\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    let mut pos = self.pos;\n    let mut i = 0;\n    for (key, value) in self.segments.iter() {\n        if i == n {\n            self.pos = pos;\n            return Some((key, value));\n        }\n        pos += 1;\n        i += 1;\n    }\n    self.pos = pos;\n    None\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    if n >= self.segments.len() {\n        return None;\n    }\n\n    let segment = &self.segments[n];\n    let (key, value) = segment.split_at(segment.find('=').unwrap_or(segment.len()));\n\n    Some((key, value))\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    if n < self.len() {\n        let start = self.pos + n;\n        let end = self.segments.len();\n        let mut i = start;\n        while i < end && self.segments[i] == '&' {\n            i += 1;\n        }\n        if i < end {\n            let mut j = i;\n            while j < end && self.segments[j] != '=' {\n                j += 1;\n            }\n            if j < end {\n                let key = &self.segments[start..i];\n                let mut value = &self.segments[j+1..end];\n                while j < end && self.segments[j] == '&' {\n                    j += 1;\n                }\n                if j < end {\n                    value = &self.segments[j..end];\n                }\n                return Some((key, value));\n            }\n        }\n    }\n    None\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    if n >= self.segments.len() {\n        return None;\n    }\n\n    let segment = &self.segments[n];\n    let mut pos = 0;\n    while pos < segment.len() && segment[pos] != '=' {\n        pos += 1;\n    }\n\n    if pos == segment.len() {\n        return Some((segment, \"\"));\n    }\n\n    let key = &segment[..pos];\n    let value = &segment[pos + 1..];\n    Some((key, value))\n}"
    ],
    [
      "pub fn is_normalized (&self) -> bool {\n    self.path().is_normalized() && self.query().map_or(true, |q| q.is_normalized())\n}",
      "pub fn is_normalized (&self) -> bool {\n    self.path().is_normalized()\n}",
      "pub fn is_normalized (&self) -> bool {\n    self.path().is_normalized()\n}",
      "pub fn is_normalized (&self) -> bool {\n    self.path().is_normalized() && self.query().is_none()\n}",
      "pub fn is_normalized (&self) -> bool {\n    self.path().is_normalized() && self.query().is_none()\n}",
      "pub fn is_normalized (&self) -> bool {\n    self.path().is_normalized()\n}",
      "pub fn is_normalized (&self) -> bool {\n    self.path().is_normalized()\n}",
      "pub fn is_normalized (&self) -> bool {\n    self.path().is_normalized()\n}",
      "pub fn is_normalized (&self) -> bool {\n    self.path().is_normalized()\n}",
      "pub fn is_normalized (&self) -> bool {\n    self.path().is_normalized()\n}"
    ],
    [
      "pub fn top_left (&self) -> Point {\n    Point::new(self.left(), self.top())\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.left(), self.top())\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.left(), self.top())\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.left(), self.top())\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.left(), self.top())\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.left(), self.top())\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.left(), self.top())\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.left(), self.top())\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.left(), self.top())\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.left(), self.top())\n}"
    ],
    [
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}"
    ],
    [
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nx >= self.left() && x < self.right() && y >= self.top() && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nx >= self.left() && x < self.right() && y >= self.top() && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nx >= self.left() && x < self.right() && y >= self.top() && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nx >= self.left() && x < self.right() && y >= self.top() && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nx >= self.left() && x < self.right() && y >= self.top() && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nx >= self.raw.x && x < self.raw.x + self.raw.w && y >= self.raw.y && y < self.raw.y + self.raw.h\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nx >= self.raw.x && x < self.raw.x + self.raw.w &&\ny >= self.raw.y && y < self.raw.y + self.raw.h\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nx >= self.raw.x && x < self.raw.x + self.raw.w &&\ny >= self.raw.y && y < self.raw.y + self.raw.h\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nx >= self.left() && x < self.right() && y >= self.top() && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nx >= self.left() && x < self.right() && y >= self.top() && y < self.bottom()\n}"
    ],
    [
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    self.x() <= other.x() && self.y() <= other.y() &&\n    self.x() + self.width() >= other.x() + other.width() &&\n    self.y() + self.height() >= other.y() + other.height()\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    self.x() <= other.x() && self.y() <= other.y() &&\n    self.x() + self.width() >= other.x() + other.width() &&\n    self.y() + self.height() >= other.y() + other.height()\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    self.x() <= other.x() &&\n    self.y() <= other.y() &&\n    self.x() + self.width() >= other.x() + other.width() &&\n    self.y() + self.height() >= other.y() + other.height()\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    self.x() <= other.x() &&\n    self.y() <= other.y() &&\n    self.x() + self.width() >= other.x() + other.width() &&\n    self.y() + self.height() >= other.y() + other.height()\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    self.x() <= other.x() &&\n    self.y() <= other.y() &&\n    self.x() + self.width() >= other.x() + other.width() &&\n    self.y() + self.height() >= other.y() + other.height()\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    self.x() <= other.x() &&\n    self.y() <= other.y() &&\n    self.x() + self.width() >= other.x() + other.width() &&\n    self.y() + self.height() >= other.y() + other.height()\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    self.x() <= other.x() && self.y() <= other.y() &&\n    self.x() + self.width() >= other.x() + other.width() &&\n    self.y() + self.height() >= other.y() + other.height()\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    self.x() <= other.x() && self.y() <= other.y() &&\n    self.x() + self.width() >= other.x() + other.width() &&\n    self.y() + self.height() >= other.y() + other.height()\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    self.x() <= other.x() && self.y() <= other.y() &&\n    self.x() + self.width() >= other.x() + other.width() &&\n    self.y() + self.height() >= other.y() + other.height()\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    self.x() <= other.x() && self.y() <= other.y() &&\n    self.x() + self.width() >= other.x() + other.width() &&\n    self.y() + self.height() >= other.y() + other.height()\n}"
    ],
    [
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\n    self.tree.get(value)\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.get(value)\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\n    self.tree.get(value)\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.get(value)\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.get(value)\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\n    self.tree.get(value)\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\n    self.tree.get(value)\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\n    self.tree.get(value)\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.get(value)\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.get(value)\n}"
    ],
    [
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.get_lftmost().map(|(v, _)| v)\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.get_lftmost().map(|(v, _)| v)\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.get_lftmost().map(|(v, _)| v)\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.get_lftmost().map(|(v, _)| v)\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.get_lftmost().map(|(v, _)| v)\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.get_lftmost().map(|(v, _)| v)\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.get_lftmost().map(|(v, _)| v)\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.get_lftmost().map(|(v, _)| v)\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.get_lftmost().map(|(v, _)| v)\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.get_lftmost().map(|(v, _)| v)\n}"
    ],
    [
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(v, _)| v)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(v, _)| v)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(v, _)| v)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(v, _)| v)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(v, _)| v)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(v, _)| v)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(v, _)| v)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(v, _)| v)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(v, _)| v)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(v, _)| v)\n}"
    ],
    [
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}"
    ],
    [
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\n    self.tree.remove(value)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\n    self.tree.remove(value)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\n    self.tree.remove(value)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\n    self.tree.remove(value)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\n    self.tree.remove(value)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\n    self.tree.remove(value)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\n    self.tree.remove(value)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.remove(value)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\n    self.tree.remove(value)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.remove(value)\n}"
    ],
    [
      "pub fn push (&mut self, item: T) {\n    self.tree.insert(item, ());\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.insert(item, ());\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.insert(item, ());\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.insert(item, ());\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.insert(item, ());\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.insert(item, ());\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.insert(item, ());\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.insert(item, ());\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.insert(item, ());\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.insert(item, ());\n}"
    ],
    [
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let size = self.read_u32()?;\n    let bytes = self.inner[self.offset..self.offset + size as usize].to_vec();\n    self.offset += size as usize;\n    Ok(bytes)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let size = self.read_u32()?;\n    let mut buf = vec![0; size as usize];\n    self.inner.read_exact(&mut buf)?;\n    Ok(buf)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let size = self.read_u32()?;\n    let mut bytes = vec![0; size as usize];\n    self.read_exact(&mut bytes)?;\n    Ok(bytes)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let size = self.read_u32()?;\n    let mut bytes = vec![0; size as usize];\n    if self.offset + size as usize > self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n    bytes.copy_from_slice(&self.inner[self.offset..self.offset + size as usize]);\n    self.offset += size as usize;\n    Ok(bytes)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let size = self.read_u32()?;\n    let mut buf = vec![0; size as usize];\n    self.inner.read_exact(&mut buf)?;\n    Ok(buf)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let size = self.read_u32()?;\n    let mut bytes = vec![0; size as usize];\n    self.read_exact(&mut bytes)?;\n    Ok(bytes)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let size = self.read_u32()?;\n    let mut bytes = vec![0; size as usize];\n    self.inner.read_exact(&mut bytes)?;\n    Ok(bytes)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let size = self.read_u32()?;\n    let bytes = &self.inner[self.offset..self.offset + size as usize];\n    self.offset += size as usize;\n    Ok(bytes.to_vec())\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let size = self.read_u32()?;\n    let mut buf = vec![0; size as usize];\n    self.inner.read_exact(&mut buf)?;\n    Ok(buf)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let size = self.read_u32()?;\n    let bytes = self.read_bytes_len(size as usize)?;\n    Ok(bytes)\n}"
    ],
    [
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let mut bytes = self.read_bytes()?;\n\n    // If most significant bit is set then drop the leading zero byte to\n    // avoid interpretation as a negative number.\n    if bytes.get(0).unwrap_or(&0) & 0x80 != 0 {\n        bytes.remove(0);\n    }\n\n    Ok(bytes)\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let bytes = self.read_bytes()?;\n    let mut result = bytes.to_vec();\n\n    // If the first byte is zero, drop it.\n    if result.get(0).unwrap_or(&0) == &0 {\n        result.remove(0);\n    }\n\n    Ok(result)\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let mut bytes = self.read_bytes()?;\n    // If the most significant bit of the first byte is set then\n    // the number is negative, otherwise it is positive.\n    // Positive numbers must be preceeded by a leading zero byte\n    // according to RFC 4251, section 5.\n    if bytes[0] & 0x80 != 0 {\n        bytes.remove(0);\n    }\n    Ok(bytes)\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let mut bytes = self.read_bytes()?;\n    // If most significant bit is set then drop the leading byte\n    // to avoid interpretation as a negative number.\n    if bytes.get(0).unwrap_or(&0) & 0x80 != 0 {\n        bytes.remove(0);\n    }\n    Ok(bytes)\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    let size = BigEndian::read_u32(&slice[..4]) as usize;\n    if slice.len() < size + 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += size + 4;\n    let mut result = slice[4..size + 4].to_vec();\n    if result[0] & 0x80 != 0 {\n        result.remove(0);\n    }\n\n    Ok(result)\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let mut result = self.read_bytes()?;\n\n    // If the first byte is zero then drop it.\n    if result.get(0).unwrap_or(&0) == &0 {\n        result.remove(0);\n    }\n\n    Ok(result)\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let bytes = self.read_bytes()?;\n    let mut result = bytes.to_vec();\n\n    // If most significant bit is set then drop the leading byte to\n    // avoid interpretation as a negative number.\n    if result.get(0).unwrap_or(&0) & 0x80 != 0 {\n        result.remove(0);\n    }\n\n    Ok(result)\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let mut mpint = self.read_bytes()?;\n    if mpint.len() > 0 && mpint[0] == 0 {\n        mpint.remove(0);\n    }\n    Ok(mpint)\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let mut bytes = self.read_bytes()?;\n\n    // If the most significant bit of the first byte is set then\n    // the number is negative, otherwise it is positive.\n    // Positive numbers must be preceeded by a leading zero byte according to RFC 4251, section 5.\n    if bytes.get(0).unwrap_or(&0) & 0x80 != 0 {\n        bytes.remove(0);\n    }\n\n    Ok(bytes)\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let bytes = self.read_bytes()?;\n    let mut result = bytes.to_vec();\n\n    // If most significant bit is set then drop the leading byte to\n    // avoid interpretation as a negative number.\n    if result.get(0).unwrap_or(&0) & 0x80 != 0 {\n        result.remove(0);\n    }\n\n    Ok(result)\n}"
    ],
    [
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    let result = String::from_utf8(bytes)?;\n    Ok(result)\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    let result = String::from_utf8(bytes)?;\n    Ok(result)\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    String::from_utf8(bytes).map_err(|e| Error::with_kind(ErrorKind::InvalidFormat))\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    String::from_utf8(bytes).map_err(|_| Error::with_kind(ErrorKind::InvalidFormat))\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    let result = String::from_utf8(bytes)?;\n    Ok(result)\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    let result = String::from_utf8(bytes)?;\n    Ok(result)\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    String::from_utf8(bytes).map_err(|_| Error::with_kind(ErrorKind::InvalidFormat))\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    String::from_utf8(bytes).map_err(|_| Error::with_kind(ErrorKind::InvalidFormat))\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    let result = String::from_utf8(bytes).map_err(|_| Error::with_kind(ErrorKind::InvalidFormat))?;\n    Ok(result)\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    let result = String::from_utf8(bytes).map_err(|_| Error::with_kind(ErrorKind::InvalidFormat))?;\n    Ok(result)\n}"
    ],
    [
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 4;\n    let value = BigEndian::read_u32(&slice[..4]);\n\n    Ok(value)\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 4;\n    let value = BigEndian::read_u32(&slice[..4]);\n\n    Ok(value)\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 4;\n    let value = BigEndian::read_u32(&slice[..4]);\n\n    Ok(value)\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 4;\n    let value = BigEndian::read_u32(&slice[..4]);\n\n    Ok(value)\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 4;\n    let value = BigEndian::read_u32(&slice[..4]);\n\n    Ok(value)\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 4;\n    let value = BigEndian::read_u32(&slice[..4]);\n\n    Ok(value)\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 4;\n    let value = BigEndian::read_u32(&slice[..4]);\n\n    Ok(value)\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 4;\n    let value = BigEndian::read_u32(&slice[..4]);\n\n    Ok(value)\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 4;\n    let value = BigEndian::read_u32(&slice[..4]);\n\n    Ok(value)\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 4;\n    let value = BigEndian::read_u32(&slice[..4]);\n\n    Ok(value)\n}"
    ],
    [
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}"
    ],
    [
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    self.write_u32(val.len() as u32);\n    self.inner.extend_from_slice(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    let size = val.len() as u32;\n    let mut bytes = vec![];\n    bytes.extend_from_slice(&size.to_be_bytes());\n    bytes.extend_from_slice(val);\n    self.inner.extend_from_slice(&bytes);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    let size = val.len() as u32;\n    self.inner.write_u32::<BigEndian>(size).unwrap();\n    self.inner.extend_from_slice(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    let size = val.len() as u32;\n    let mut bytes = Vec::new();\n    bytes.extend_from_slice(&size.to_be_bytes());\n    bytes.extend_from_slice(val);\n    self.inner.extend_from_slice(&bytes);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    let size = val.len() as u32;\n    self.write_u32(size);\n    self.inner.extend_from_slice(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    self.inner.extend_from_slice(&(val.len() as u32).to_be_bytes());\n    self.inner.extend_from_slice(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    let size = val.len() as u32;\n    self.inner.extend_from_slice(&size.to_be_bytes());\n    self.inner.extend_from_slice(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    let size = val.len() as u32;\n    self.write_u32(size);\n    self.write_bytes(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    self.write_u32(val.len() as u32);\n    self.inner.extend_from_slice(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    let size = val.len() as u32;\n    let mut bytes = vec![];\n    bytes.extend_from_slice(&size.to_be_bytes());\n    bytes.extend_from_slice(val);\n    self.inner.extend_from_slice(&bytes);\n}"
    ],
    [
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::CurDir => UnixStr::from_slice(b\".\"),\n        Component::ParentDir => UnixStr::from_slice(b\"..\"),\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::CurDir => UnixStr::from_slice(b\".\"),\n        Component::ParentDir => UnixStr::from_slice(b\"..\"),\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::CurDir => UnixStr::from_slice(b\".\"),\n        Component::ParentDir => UnixStr::from_slice(b\"..\"),\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::CurDir => UnixStr::CUR_DIR,\n        Component::ParentDir => UnixStr::PARENT_DIR,\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::CurDir => UnixStr::from_str(\".\"),\n        Component::ParentDir => UnixStr::from_str(\"..\"),\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::CurDir => UnixStr::from_slice(b\".\"),\n        Component::ParentDir => UnixStr::from_slice(b\"..\"),\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::CurDir => UnixStr::from_slice(b\".\"),\n        Component::ParentDir => UnixStr::from_slice(b\"..\"),\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::CurDir => UnixStr::from_slice(b\".\"),\n        Component::ParentDir => UnixStr::from_slice(b\"..\"),\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::CurDir => UnixStr::from_str(\".\"),\n        Component::ParentDir => UnixStr::from_str(\"..\"),\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::CurDir => UnixStr::CUR_DIR,\n        Component::ParentDir => UnixStr::PARENT_DIR,\n        Component::Normal(s) => s,\n    }\n}"
    ],
    [
      "pub fn as_path (&self) -> &'a Path {\n    unsafe { Path::from_u8_slice(self.as_u8_slice()) }\n}",
      "pub fn as_path (&self) -> &'a Path {\n    unsafe { Path::from_u8_slice(self.as_u8_slice()) }\n}",
      "pub fn as_path (&self) -> &'a Path {\n    unsafe { Path::from_u8_slice(self.as_u8_slice()) }\n}",
      "pub fn as_path (&self) -> &'a Path {\n    unsafe { Path::from_u8_slice(self.as_u8_slice()) }\n}",
      "pub fn as_path (&self) -> &'a Path {\n    let root = if self.front <= State::StartDir && self.has_physical_root {\n        1\n    } else {\n        0\n    };\n    let cur_dir = if self.front <= State::StartDir && self.include_cur_dir() {\n        1\n    } else {\n        0\n    };\n    let start = root + cur_dir;\n    let end = self.back + 1;\n    unsafe { Path::from_u8_slice(&self.inner[start..end]) }\n}",
      "pub fn as_path (&self) -> &'a Path {\n    unsafe { Path::from_u8_slice(self.as_u8_slice()) }\n}",
      "pub fn as_path (&self) -> &'a Path {\n    unsafe { Path::from_u8_slice(self.as_u8_slice()) }\n}",
      "pub fn as_path (&self) -> &'a Path {\n    let root = if self.front <= State::StartDir && self.has_physical_root {\n        1\n    } else {\n        0\n    };\n    let cur_dir = if self.front <= State::StartDir && self.include_cur_dir() {\n        1\n    } else {\n        0\n    };\n    let start = self.front.to_usize();\n    let end = self.back.to_usize();\n    let len = end - start + 1;\n    unsafe {\n        Path::from_u8_slice(&self.as_u8_slice()[start..start+len])\n    }\n}",
      "pub fn as_path (&self) -> &'a Path {\n    unsafe { Path::from_u8_slice(self.as_u8_slice()) }\n}",
      "pub fn as_path (&self) -> &'a Path {\n    let start = self.front;\n    let end = self.back;\n    let mut iter = self.inner.iter();\n    for _ in 0..start {\n        iter.next();\n    }\n    let mut components = Vec::new();\n    for _ in start..end {\n        components.push(iter.next().unwrap());\n    }\n    Path::new(components.as_slice())\n}"
    ],
    [
      "pub fn pop (&mut self) -> bool {\n    if self.parent().is_some() {\n        self.as_mut_vec().truncate(self.parent().unwrap().as_unix_str().len());\n        true\n    } else {\n        false\n    }\n}",
      "pub fn pop (&mut self) -> bool {\n    if let Some(parent) = self.parent() {\n        self.as_mut_vec().truncate(parent.as_unix_str().len());\n        true\n    } else {\n        false\n    }\n}",
      "pub fn pop (&mut self) -> bool {\n    if let Some(parent) = self.parent() {\n        self.as_mut_vec().truncate(parent.as_unix_str().len());\n        true\n    } else {\n        false\n    }\n}",
      "pub fn pop (&mut self) -> bool {\n    if self.parent().is_none() {\n        false\n    } else {\n        self.as_mut_vec().truncate(self.parent().unwrap().as_unix_str().len());\n        true\n    }\n}",
      "pub fn pop (&mut self) -> bool {\n    if let Some(parent) = self.parent() {\n        self.as_mut_vec().truncate(parent.as_unix_str().len());\n        true\n    } else {\n        false\n    }\n}",
      "pub fn pop (&mut self) -> bool {\n    if let Some(parent) = self.parent() {\n        self.as_mut_vec().truncate(parent.as_unix_str().len());\n        true\n    } else {\n        false\n    }\n}",
      "pub fn pop (&mut self) -> bool {\n    if let Some(parent) = self.parent() {\n        self.as_mut_vec().truncate(parent.as_unix_str().len());\n        true\n    } else {\n        false\n    }\n}",
      "pub fn pop (&mut self) -> bool {\n    if let Some(parent) = self.parent() {\n        self.as_mut_vec().truncate(parent.as_unix_str().len());\n        true\n    } else {\n        false\n    }\n}",
      "pub fn pop (&mut self) -> bool {\n    if let Some(parent) = self.parent() {\n        self.as_mut_vec().truncate(parent.as_unix_str().len());\n        true\n    } else {\n        false\n    }\n}",
      "pub fn pop (&mut self) -> bool {\n    if self.parent().is_some() {\n        self.as_mut_vec().truncate(self.parent().unwrap().as_unix_str().len());\n        true\n    } else {\n        false\n    }\n}"
    ],
    [
      "pub fn parent (&self) -> Option<&Path> {\n    let mut components = self.components();\n    components.next_back();\n    components.as_path()\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    let mut components = self.components();\n    components.next_back();\n    components.as_path()\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    let mut components = self.components();\n    components.next_back();\n    components.as_path()\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    let mut components = self.components();\n    components.next_back();\n    components.as_path()\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    let mut components = self.components();\n    components.next_back();\n    components.as_path()\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    let mut components = self.components();\n    components.next_back();\n    components.as_path()\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    let mut components = self.components();\n    components.next_back();\n    components.as_path()\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    self.components().next_back().and_then(|p| match p {\n        Component::Normal(_) => Some(self),\n        _ => None,\n    })\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    let mut components = self.components();\n    components.next_back();\n    components.as_path()\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    let mut components = self.components();\n    components.next_back();\n    components.as_path()\n}"
    ],
    [
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    let mut comps = self.components();\n    let comp = comps.next_back();\n    comp.and_then(|p| match p {\n        Component::Normal(s) => Some(s),\n        _ => None,\n    })\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    self.components().next_back().and_then(|c| match c {\n        Component::Normal(s) => Some(s),\n        _ => None,\n    })\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    self.components()\n        .last()\n        .and_then(|component| match component {\n            Component::Normal(name) => Some(name),\n            _ => None,\n        })\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    self.components().next_back().and_then(|c| match c {\n        Component::Normal(s) => Some(s),\n        _ => None,\n    })\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    let mut comps = self.components();\n    comps.next_back().and_then(|p| match p {\n        Component::Normal(s) => Some(s),\n        _ => None,\n    })\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    self.components().next_back().and_then(|p| match p {\n        Component::Normal(s) => Some(s),\n        _ => None,\n    })\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    self.components().next_back().and_then(|comp| match comp {\n        Component::Normal(name) => Some(name),\n        _ => None,\n    })\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    self.components()\n        .next_back()\n        .and_then(|comp| match comp {\n            Component::Normal(name) => Some(name),\n            _ => None,\n        })\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    let mut comps = self.components();\n    comps.next_back()\n        .and_then(|p| match p {\n            Component::Normal(n) => Some(n),\n            _ => None,\n        })\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    let mut comps = self.components();\n    let comp = comps.next_back();\n    comp.and_then(|p| match p {\n        Component::Normal(s) => Some(s),\n        _ => None,\n    })\n}"
    ],
    [
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    let cur_len = self.v.len();\n    if len >= cur_len {\n        self.v.reserve_exact(len - cur_len);\n    }\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    let cur_len = self.v.len();\n    if len >= cur_len {\n        self.v.reserve_exact(len - cur_len);\n    }\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    let cur_len = self.v.len();\n    if len >= cur_len {\n        self.v.reserve_exact(len - cur_len);\n    }\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    let cur_len = self.v.len();\n    if len >= cur_len {\n        self.v.reserve_exact(len - cur_len);\n    }\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    let cur_len = self.v.len();\n    if len >= cur_len {\n        self.v.reserve_exact(len - cur_len);\n    }\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    let cur_len = self.v.len();\n    if len >= cur_len {\n        self.v.reserve_exact(len - cur_len);\n    }\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    let cur_len = self.v.len();\n    if len >= cur_len {\n        self.v.reserve_exact(len - cur_len);\n    }\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    let cur_len = self.v.len();\n    if len >= cur_len {\n        self.v.reserve_exact(len - cur_len);\n    }\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    let cur_len = self.v.len();\n    if len >= cur_len {\n        self.v.reserve_exact(len - cur_len);\n    }\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    let cur_len = self.v.len();\n    if len >= cur_len {\n        self.v.reserve_exact(len - cur_len);\n    }\n}"
    ],
    [
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}"
    ],
    [
      "pub fn append (&mut self, other: &mut Self) {\n    for (key, value) in other.iter_mut() {\n        self.insert(value);\n    }\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    for (i, e) in other.v.iter_mut().enumerate() {\n        let remove = match *e {\n            Some(ref mut value) => !f(i, value),\n            None => false,\n        };\n        if remove {\n            *e = None;\n            self.n -= 1;\n        }\n    }\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    self.extend(other.drain());\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    self.extend(other.drain());\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    for (k, v) in other.iter_mut() {\n        self.insert(k, v);\n    }\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    for (key, value) in other.iter_mut() {\n        self.insert(key, value);\n    }\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    for (k, v) in other.iter_mut() {\n        self.insert(k, v.clone());\n    }\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    for (key, value) in other.iter_mut() {\n        self.insert(value);\n    }\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    self.extend(other.drain());\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    for (i, e) in other.v.iter_mut().enumerate() {\n        if let Some(value) = e.take() {\n            self.insert(i, value);\n        }\n    }\n}"
    ],
    [
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::new();\n    for (k, v) in self.drain() {\n        if k < at {\n            self.insert(k, v);\n        } else {\n            other.insert(k, v);\n        }\n    }\n    other\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::new();\n    for i in at..self.v.len() {\n        other.insert(i, self.v[i].take().unwrap());\n    }\n    other\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::new();\n    for (k, v) in self.iter_mut() {\n        if k >= at {\n            other.insert(k, v.take().unwrap());\n        }\n    }\n    other\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::new();\n    other.extend(self.drain(at..));\n    other\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut new_map = Self::new();\n    for i in at..self.v.len() {\n        new_map.insert(i, self.v[i].take().unwrap());\n    }\n    new_map\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut new = Self::with_capacity(self.capacity());\n    for i in at..self.v.len() {\n        new.v.push(self.v[i].take());\n    }\n    new.n = self.n - at;\n    self.n = at;\n    new\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::new();\n    for (key, value) in self.drain().skip(at) {\n        other.insert(key, value);\n    }\n    other\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut new_map = Self::with_capacity(self.capacity());\n    let mut new_key = 0;\n    for key in self.keys() {\n        if key >= at {\n            new_map.insert(new_key, self.remove(key).unwrap());\n            new_key += 1;\n        }\n    }\n    new_map\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::new();\n    other.v.reserve(self.v.len() - at);\n    for i in at..self.v.len() {\n        other.v.push(self.v.remove(i));\n    }\n    other.n = self.n - at;\n    self.n = at;\n    other\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::new();\n    other.n = self.n - at;\n    other.v = self.v.split_off(at);\n    self.n = at;\n    other\n}"
    ],
    [
      "pub fn get (&self, key: usize) -> Option<&V> {\n    if key >= self.v.len() {\n        return None;\n    }\n    match &self.v[key] {\n        Some(ref value) => Some(value),\n        None => None,\n    }\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    if key >= self.v.len() {\n        return None;\n    }\n    self.v[key].as_ref()\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    if key >= self.v.len() {\n        return None;\n    }\n    self.v[key].as_ref()\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    self.v.get(key).and_then(|v| v.as_ref())\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    if key >= self.v.len() {\n        return None;\n    }\n    let result = &self.v[key];\n    if result.is_some() {\n        return Some(result.as_ref().unwrap());\n    }\n    None\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    if key >= self.v.len() {\n        return None;\n    }\n    match self.v[key] {\n        Some(ref value) => Some(value),\n        None => None,\n    }\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    if key >= self.v.len() {\n        return None;\n    }\n    self.v[key].as_ref()\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    if key >= self.v.len() {\n        return None;\n    }\n    self.v[key].as_ref()\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    self.v.get(key).and_then(|x| x.as_ref())\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    self.v.get(key).and_then(|x| x.as_ref())\n}"
    ],
    [
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    let len = self.v.len();\n    if key >= len {\n        self.v.resize(key + 1, None);\n    }\n    let result = &mut self.v[key];\n    let was = result.take();\n    if was.is_some() {\n        self.n -= 1;\n    }\n    *result = Some(value);\n    self.n += 1;\n    was\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    let len = self.v.len();\n    if key >= len {\n        self.v.resize(key + 1, None);\n    }\n    let result = &mut self.v[key];\n    let was = result.take();\n    if was.is_some() {\n        self.n -= 1;\n    }\n    *result = Some(value);\n    self.n += 1;\n    was\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key >= self.v.len() {\n        self.v.resize(key + 1, None);\n    }\n    let result = &mut self.v[key];\n    let was = result.take();\n    if was.is_some() {\n        self.n -= 1;\n    }\n    *result = Some(value);\n    self.n += 1;\n    was\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    let mut pos = key;\n    if pos >= self.v.len() {\n        self.v.resize(pos + 1, None);\n    }\n    let result = &mut self.v[pos];\n    let was = result.replace(value);\n    if was.is_some() {\n        self.n -= 1;\n    }\n    was\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key >= self.v.len() {\n        self.v.resize(key + 1, None);\n    }\n    let result = &mut self.v[key];\n    let was = result.take();\n    if was.is_some() {\n        self.n -= 1;\n    }\n    *result = Some(value);\n    self.n += 1;\n    was\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key >= self.v.len() {\n        self.v.resize(key + 1, None);\n    }\n    let result = &mut self.v[key];\n    let was = result.take();\n    if was.is_some() {\n        self.n -= 1;\n    }\n    *result = Some(value);\n    self.n += 1;\n    was\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key >= self.v.len() {\n        self.v.resize(key + 1, None);\n    }\n    let result = &mut self.v[key];\n    let was = result.take();\n    if was.is_some() {\n        self.n -= 1;\n    }\n    *result = Some(value);\n    self.n += 1;\n    was\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    let old_value = self.get_mut(key);\n    if old_value.is_none() {\n        self.n += 1;\n    }\n    *old_value = Some(value);\n    old_value.take()\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key >= self.v.len() {\n        self.v.resize(key + 1, None);\n    }\n    let result = &mut self.v[key];\n    let was = result.take();\n    if was.is_some() {\n        self.n -= 1;\n    }\n    *result = Some(value);\n    self.n += 1;\n    was\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key >= self.v.len() {\n        self.v.resize(key + 1, None);\n    }\n    let result = &mut self.v[key];\n    let was = result.take();\n    if was.is_some() {\n        self.n -= 1;\n    }\n    *result = Some(value);\n    self.n += 1;\n    was\n}"
    ],
    [
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    let len = self.v.len();\n    if len <= key {\n        self.v.extend((0..key - len + 1).map(|_| None));\n    }\n    let was = replace(&mut self.v[key], None);\n    if was.is_some() {\n        self.n -= 1;\n    }\n    was\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    let len = self.v.len();\n    if len <= key {\n        return None;\n    }\n    let was = replace(&mut self.v[key], None);\n    if was.is_some() {\n        self.n -= 1;\n    }\n    was\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    if self.contains_key(key) {\n        let was = replace(&mut self.v[key], None);\n        self.n -= 1;\n        was\n    } else {\n        None\n    }\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    let len = self.v.len();\n    if len <= key {\n        return None;\n    }\n    let was = replace(&mut self.v[key], None);\n    if was.is_some() {\n        self.n -= 1;\n    }\n    was\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    if self.contains_key(key) {\n        let was = replace(&mut self.v[key], None);\n        self.n -= 1;\n        was\n    } else {\n        None\n    }\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    if key < self.v.len() {\n        let was = replace(&mut self.v[key], None);\n        if was.is_some() {\n            self.n -= 1;\n        }\n        was\n    } else {\n        None\n    }\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    let len = self.v.len();\n    if len <= key {\n        self.v.extend((0..key - len + 1).map(|_| None));\n    }\n    let was = replace(&mut self.v[key], None);\n    if was.is_some() {\n        self.n -= 1;\n    }\n    was\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    let len = self.v.len();\n    if len <= key {\n        self.v.extend((0..key - len + 1).map(|_| None));\n    }\n    let was = replace(&mut self.v[key], None);\n    if was.is_some() {\n        self.n -= 1;\n    }\n    was\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    if key < self.v.len() {\n        let was = replace(&mut self.v[key], None);\n        if was.is_some() {\n            self.n -= 1;\n        }\n        was\n    } else {\n        None\n    }\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    if key < self.v.len() {\n        let was = replace(&mut self.v[key], None);\n        if was.is_some() {\n            self.n -= 1;\n        }\n        was\n    } else {\n        None\n    }\n}"
    ],
    [
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    for i in 0..self.v.len() {\n        if let Some(ref mut value) = self.v[i] {\n            if !f(i, value) {\n                self.remove(i);\n            }\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    for i in 0..self.n {\n        if !f(i, &mut self.v[i]) {\n            self.remove(i);\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    let mut index = 0;\n    while index < self.v.len() {\n        if let Some(value) = self.v[index].as_mut() {\n            if !f(index, value) {\n                self.remove(index);\n            } else {\n                index += 1;\n            }\n        } else {\n            index += 1;\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    let mut i = 0;\n    while i < self.v.len() {\n        if let Some(value) = self.v[i].as_mut() {\n            if !f(i, value) {\n                self.remove(i);\n            } else {\n                i += 1;\n            }\n        } else {\n            i += 1;\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    let mut i = 0;\n    while i < self.v.len() {\n        if let Some(ref mut value) = self.v[i] {\n            if !f(i, value) {\n                self.remove(i);\n            } else {\n                i += 1;\n            }\n        } else {\n            i += 1;\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    let mut i = 0;\n    while i < self.v.len() {\n        if !f(i, &mut self.v[i]) {\n            self.v[i] = None;\n        } else {\n            i += 1;\n        }\n    }\n    self.v.retain(|x| x.is_some());\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    for i in 0..self.n {\n        if let Some(v) = self.v[i].as_mut() {\n            if !f(i, v) {\n                self.v[i].take();\n            }\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    let mut i = 0;\n    while i < self.v.len() {\n        if let Some(ref mut v) = self.v[i] {\n            if !f(i, v) {\n                self.v[i] = None;\n            }\n        }\n        i += 1;\n    }\n    self.n = self.v.iter().filter(|x| x.is_some()).count();\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    let mut i = 0;\n    while i < self.v.len() {\n        if let Some(value) = self.v[i].as_mut() {\n            if !f(i, value) {\n                self.v[i].take();\n            }\n        }\n        i += 1;\n    }\n    self.n = self.v.iter().filter(|x| x.is_some()).count();\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    let mut i = 0;\n    while i < self.v.len() {\n        if !f(i, &mut self.v[i]) {\n            self.v[i] = None;\n        } else {\n            i += 1;\n        }\n    }\n    self.n = i;\n}"
    ],
    [
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    if self.len() < self.capacity() {\n        unsafe {\n            // SAFETY:\n            // * unaliased as we had a mutable reference\n            // * can write uninitialized bytes as much as we want\n            ptr::write(self.end_mut_ptr(), val);\n            // SAFETY:\n            // * Just initialized one more element past the end. By the way, this can not\n            // overflow since the result is at most `self.capacity()`.\n            self.set_len(self.len() + 1);\n        }\n        Ok(())\n    } else {\n        Err(val)\n    }\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    if self.len() < self.capacity() {\n        unsafe {\n            // SAFETY:\n            // * `self.len()` is strictly less than `self.capacity()` so this is strictly in\n            //   bounds.\n            // * `self.capacity()` is the number of elements that can be stored in the\n            //   allocation.\n            // * `self.len()` is the number of elements that have been initialized in the\n            //   allocation.\n            // * `self.len() + 1` is the number of elements that will be initialized in the\n            //   allocation after this push.\n            // * `self.capacity() - self.len() - 1` is the number of elements that can be\n            //   initialized in the allocation after this push.\n            // * `self.capacity() - self.len() - 1` is strictly less than `self.capacity()` so\n            //   this is strictly in bounds.\n            ptr::write(self.end_mut_ptr(), val);\n            // SAFETY:\n            // * Just initialized one more element past the end. By the way, this can not\n            //   overflow since the result is at most `self.capacity()`.\n            self.set_len(self.len() + 1);\n        }\n        Ok(())\n    } else {\n        Err(val)\n    }\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    if self.len() == self.capacity() {\n        return Err(val);\n    }\n    unsafe {\n        // SAFETY:\n        // * `self.len() < self.capacity()` so this is strictly in bounds.\n        // * `self.len() == 0` so the memory is uninitialized.\n        // * `self.len() + 1 == self.capacity()` so the memory is big enough to hold at least one\n        //   more element.\n        ptr::write(self.end_mut_ptr(), val);\n        // SAFETY:\n        // * Just initialized one more element past the end. By the way, this can not overflow\n        //   since the result is at most `self.capacity()`.\n        self.set_len(self.len() + 1);\n    }\n    Ok(())\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    let unused = self.capacity() - self.len();\n    if unused == 0 {\n        return Err(val);\n    }\n    unsafe {\n        // SAFETY:\n        //  `capacity != len` so this is strictly in bounds. Also, this is behind the\n        //  vector so there can not be any references to it currently.\n        ptr::write(self.end_mut_ptr(), val);\n        // SAFETY:\n        //  Just initialized one more element past the end. By the way, this can not\n        //  overflow since the result is at most `self.capacity()`.\n        self.set_len(self.len() + 1);\n    }\n    Ok(())\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    let mut uninit = self.uninit.split_to_fit();\n    // SAFETY:\n    // * uninit is a valid Uninit for T\n    // * uninit is suitably aligned\n    // * uninit is not null\n    // * uninit is large enough to hold at least one T\n    unsafe {\n        // SAFETY:\n        // * uninit is a valid Uninit for T\n        // * uninit is suitably aligned\n        // * uninit is not null\n        // * uninit is large enough to hold at least one T\n        ptr::write(uninit.as_ptr(), val);\n        // SAFETY:\n        // * uninit is a valid Uninit for T\n        // * uninit is suitably aligned\n        // * uninit is not null\n        // * uninit is large enough to hold at least one T\n        self.uninit.set_len(self.uninit.len() + 1);\n    }\n    Ok(())\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    if self.length == self.capacity() {\n        return Err(val);\n    }\n    unsafe {\n        // SAFETY:\n        //  * `self.length` is strictly less than `self.capacity()` so this is strictly in bounds.\n        //  * `self.length` is strictly less than `self.capacity()` so this is strictly in bounds.\n        //  * `self.length` is strictly less than `self.capacity()` so this is strictly in bounds.\n        //  * `self.length` is strictly less than `self.capacity()` so this is strictly in bounds.\n        //  * `self.length` is strictly less than `self.capacity()` so this is strictly in bounds.\n        //  * `self.length` is strictly less than `self.capacity()` so this is strictly in bounds.\n        //  * `self.length` is strictly less than `self.capacity()` so this is strictly in bounds.\n        //  * `self.length` is strictly less than `self.capacity()` so this is strictly in bounds.\n        //  * `self.length` is strictly less than `self.capacity()` so this is strictly in bounds.\n        //  * `self.length` is strictly less than `self.capacity()` so this is strictly in bounds.\n        //  * `self.length` is strictly less than `self.capacity()` so this is strictly in bounds.\n        //  * `self.length` is strictly less than `self.capacity()` so this is strictly in bounds.\n        //  * `self.length` is strictly less than `self.capacity()` so this is strictly in bounds.\n        //  * `self.length` is strictly less than `self.capacity()` so this is strictly in bounds.\n        //  * `self.length` is strictly less than `self.capacity()` so this is strictly in bounds.\n        //  * `self.length` is strictly less than `self.capacity()` so this is strictly in bounds.\n        //  * `self.length` is strictly less than `self.capacity()` so this is strictly in bounds.\n}\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    let uninit = self.uninit.split_to_fit();\n    unsafe {\n        // SAFETY:\n        // * unaliased as we had a mutable reference\n        // * can write uninitialized bytes as much as we want\n        ptr::write(uninit.as_ptr(), val);\n        // SAFETY:\n        // Just initialized one more element past the end. By the way, this can not overflow since\n        // the result is at most `self.capacity()`.\n        self.uninit.set_len(self.uninit.len() + 1);\n    }\n    Ok(())\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    // Check if there is enough space for the new element.\n    if self.len() == self.capacity() {\n        return Err(val);\n    }\n    // Write the value to the end of the vector.\n    unsafe {\n        // SAFETY:\n        // * `capacity != len` so this is strictly in bounds. Also, this is behind the\n        // vector so there can not be any references to it currently.\n        ptr::write(self.end_mut_ptr(), val);\n        // SAFETY:\n        // Just initialized one more element past the end. By the way, this can not\n        // overflow since the result is at most `self.capacity()`.\n        self.set_len(self.len() + 1);\n    }\n    Ok(())\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    let uninit = self.uninit.split_to_fit();\n    unsafe {\n        // SAFETY:\n        // * uninit is suitably aligned and large enough to hold at least one `T`\n        // * uninit is not used for anything else\n        // * the caller must ensure that all newly referenced elements are properly initialized.\n        ptr::write(uninit.as_ptr(), val);\n        // SAFETY:\n        // * uninit is suitably aligned and large enough to hold at least one `T`\n        // * uninit is not used for anything else\n        // * the caller must ensure that all newly referenced elements are properly initialized.\n        self.uninit.set_len(self.length + 1);\n    }\n    Ok(())\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    let uninit = self.uninit.split_to_fit();\n    if let Ok(uninit) = uninit.cast::<T>() {\n        unsafe {\n            // SAFETY:\n            // * `uninit` is suitably aligned and large enough to hold `T`.\n            // * `uninit` is unused.\n            // * `val` is valid and not yet dropped.\n            ptr::write(uninit.as_ptr(), val);\n            // SAFETY:\n            // * `uninit` is suitably aligned and large enough to hold `T`.\n            // * `uninit` is unused.\n            // * `val` is valid and not yet dropped.\n            self.uninit.set_len(self.length + 1);\n        }\n        Ok(())\n    } else {\n        Err(val)\n    }\n}"
    ],
    [
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity(), \"`at` out of bounds\");\n    // `self.length` is always smaller than `split_at`.\n    let new_uninit = self.uninit.split_at(at).unwrap();\n    // The first `at` elements stay in this vec.\n    let new_len = self.length.saturating_sub(at);\n    self.length -= new_len;\n    FixedVec {\n        uninit: new_uninit,\n        length: new_len,\n    }\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity(), \"`at` out of bounds\");\n    // `self.length` is always smaller than `split_at`.\n    let new_uninit = self.uninit.split_at(at).unwrap();\n    // The first `at` elements stay in this vec.\n    let new_len = self.length.saturating_sub(at);\n    self.length -= new_len;\n    FixedVec {\n        uninit: new_uninit,\n        length: new_len,\n    }\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity(), \"`at` out of bounds\");\n    // `self.length` is always smaller than `split_at`.\n    let new_uninit = self.uninit.split_at(at).unwrap();\n    // The first `at` elements stay in this vec.\n    let new_len = self.length.saturating_sub(at);\n    self.length -= new_len;\n    FixedVec {\n        uninit: new_uninit,\n        length: new_len,\n    }\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity(), \"`at` out of bounds\");\n    // `self.length` is always smaller than `split_at`.\n    let new_uninit = self.uninit.split_at(at).unwrap();\n    // The first `at` elements stay in this vec.\n    let new_len = self.length.saturating_sub(at);\n    self.length -= new_len;\n    FixedVec {\n        uninit: new_uninit,\n        length: new_len,\n    }\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    // NOTE: Slice pointers are blocked by Rust stabilization we can not create one from a real\n    // reference to slice as that would restrict us to the memory covered by the reference.\n    // NOTE: Tracked here https://github.com/rust-lang/rust/issues/36925\n    let bytes = match at.checked_mul(mem::size_of::<T>()) {\n        None => return FixedVec::new(Uninit::decast(self)),\n        Some(byte) if byte > self.capacity() => return FixedVec::new(Uninit::decast(self)),\n        Some(byte) => byte,\n    };\n\n    let next_len = self.length - at;\n    self.length = at;\n\n    let base = self.head_tail_mut().0.as_ptr() as *mut u8;\n    // SAFETY: was previously in bounds.\n    let next_base = unsafe { ptr::NonNull::new_unchecked(base.add(bytes)) };\n    FixedVec {\n        uninit: Uninit::from_memory(next_base.cast(), next_len),\n        length: next_len,\n    }\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity(), \"`at` out of bounds\");\n    // `self.length` is always smaller than `split_at`.\n    let new_uninit = self.uninit.split_at(at).unwrap();\n    // The first `at` elements stay in this vec.\n    let new_len = self.length.saturating_sub(at);\n    self.length -= new_len;\n    FixedVec {\n        uninit: new_uninit,\n        length: new_len,\n    }\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity(), \"`at` out of bounds\");\n    // `self.length` is always smaller than `split_at`.\n    let new_uninit = self.uninit.split_at(at).unwrap();\n    // The first `at` elements stay in this vec.\n    let new_len = self.length.saturating_sub(at);\n    self.length -= new_len;\n    FixedVec {\n        uninit: new_uninit,\n        length: new_len,\n    }\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity(), \"`at` out of bounds\");\n    // `self.length` is always smaller than `split_at`.\n    let new_uninit = self.uninit.split_at(at).unwrap();\n    // The first `at` elements stay in this vec.\n    let new_len = self.length.saturating_sub(at);\n    self.length -= new_len;\n    FixedVec {\n        uninit: new_uninit,\n        length: new_len,\n    }\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity(), \"`at` out of bounds\");\n    // `self.length` is always smaller than `split_at`.\n    let new_uninit = self.uninit.split_at(at).unwrap();\n    // The first `at` elements stay in this vec.\n    let new_len = self.length.saturating_sub(at);\n    self.length -= new_len;\n    FixedVec {\n        uninit: new_uninit,\n        length: new_len,\n    }\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity(), \"`at` out of bounds\");\n    // `self.length` is always smaller than `split_at`.\n    let new_uninit = self.uninit.split_at(at).unwrap();\n    // The first `at` elements stay in this vec.\n    let new_len = self.length.saturating_sub(at);\n    self.length -= new_len;\n    FixedVec {\n        uninit: new_uninit,\n        length: new_len,\n    }\n}"
    ],
    [
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.strong_count() != 0 {\n        // Note: implicitely increments `strong`\n        Some(Rc { inner: self.inner })\n    } else {\n        None\n    }\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.strong_count() == 0 {\n        None\n    } else {\n        let ptr = self.inner.as_non_null();\n        let len = self.inner.size();\n        unsafe {\n            // SAFETY: restored the memory that an rc has originally provided to the `Weak`. We are\n            // the only reference to it, so it is fine to restore the original unqiue allocation\n            // reference.\n            Some(Rc::from_raw(Uninit::from_memory(ptr.cast(), len)))\n        }\n    }\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.strong_count() != 0 {\n        Some(Rc::from_raw(self.clone()))\n    } else {\n        None\n    }\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.strong_count() != 0 {\n        let inner = self.inner.as_non_null();\n        let len = self.inner.size();\n        unsafe {\n            // SAFETY: restored the memory that an rc has originally provided to the `Weak`. We are\n            // the only reference to it, so it is fine to restore the original unqiue allocation\n            // reference.\n            Some(Rc::from_raw(Uninit::from_memory(inner.cast(), len)))\n        }\n    }\n    None\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.strong_count() != 0 {\n        let inner = self.inner();\n        let inner = unsafe { inner.as_ref() };\n        Some(Rc { inner })\n    } else {\n        None\n    }\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.strong_count() == 0 {\n        return None;\n    }\n    let ptr = self.inner.as_non_null();\n    let len = self.inner.size();\n    unsafe {\n        // SAFETY: restored the memory that an rc has originally provided to the `Weak`. We are\n        // the only reference to it, so it is fine to restore the original unqiue allocation\n        // reference.\n        Some(Rc::from_raw(Uninit::from_memory(ptr.cast(), len)))\n    }\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.strong_count() == 0 {\n        None\n    } else {\n        Some(Rc {\n            inner: self.inner.clone(),\n            phantom: PhantomData,\n        })\n    }\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.strong_count() == 0 {\n        return None;\n    }\n    let inner = self.inner();\n    let inner = unsafe { inner.as_ref() };\n    let strong = inner.strong.get();\n    let weak = inner.weak.get();\n    if strong == weak {\n        return None;\n    }\n    let ptr = self.inner.as_non_null();\n    let len = self.inner.size();\n    unsafe {\n        // SAFETY: restored the memory that an rc has originally provided to the `Weak`. We are\n        // the only reference to it, so it is fine to restore the original unqiue allocation\n        // reference.\n        Some(Rc::from_raw(Uninit::from_memory(ptr.cast(), len)))\n    }\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.strong_count() == 0 {\n        return None;\n    }\n    let ptr = self.inner.as_non_null();\n    let len = self.inner.size();\n    unsafe {\n        // SAFETY: restored the memory that an rc has originally provided to the `Weak`. We are\n        // the only reference to it, so it is fine to restore the original unqiue allocation\n        // reference.\n        Some(Rc::from_memory(ptr.cast(), len))\n    }\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.strong_count() == 0 {\n        None\n    } else {\n        Some(Rc { inner: self.inner })\n    }\n}"
    ]
  ]
}