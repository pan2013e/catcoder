{
  "benchmark": "rusteval_xc",
  "lastest_eval": {
    "compile@1": 0.6511111111111111,
    "pass@1": 0.5266666666666666,
    "compile@3": 0.7554629629629629,
    "pass@3": 0.62,
    "compile@5": 0.7894179894179894,
    "pass@5": 0.6588624338624338
  },
  "n": 10,
  "k": [
    1,
    3,
    5
  ],
  "fn_codes": [
    [
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut bit_vec = BitVec::with_capacity(nbits);\n    for _ in 0..nbits {\n        bit_vec.push(bit);\n    }\n    bit_vec\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut bv = BitVec::with_capacity(nbits);\n    for _ in 0..nbits {\n        bv.push(bit);\n    }\n    bv\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut bv = BitVec::with_capacity(nbits);\n    bv.set_all();\n    bv.set_len(nbits);\n    bv\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut bit_vec = BitVec::with_capacity(nbits);\n    for _ in 0..nbits {\n        bit_vec.push(bit);\n    }\n    bit_vec\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut bit_vec = BitVec::with_capacity(nbits);\n    for _ in 0..nbits {\n        bit_vec.push(bit);\n    }\n    bit_vec\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut bv = BitVec::with_capacity(nbits);\n    for _ in 0..nbits {\n        bv.push(bit);\n    }\n    bv\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut bit_vec = BitVec::with_capacity(nbits);\n    bit_vec.set_all();\n    bit_vec.negate();\n    bit_vec\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut bit_vec = BitVec::with_capacity(nbits);\n    for _ in 0..nbits {\n        bit_vec.push(bit);\n    }\n    bit_vec\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut bit_vec = BitVec::with_capacity(nbits);\n    for _ in 0..nbits {\n        bit_vec.push(bit);\n    }\n    bit_vec\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut bit_vec = BitVec::with_capacity(nbits);\n    for _ in 0..nbits {\n        bit_vec.push(bit);\n    }\n    bit_vec\n}"
    ],
    [
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bit_vec = BitVec::with_capacity(len);\n    for i in 0..len {\n        bit_vec.push(f(i));\n    }\n    bit_vec\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bit_vec = BitVec::with_capacity(len);\n    for i in 0..len {\n        bit_vec.push(f(i));\n    }\n    bit_vec\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bit_vec = BitVec::with_capacity(len);\n    for i in 0..len {\n        bit_vec.push(f(i));\n    }\n    bit_vec\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bit_vec = BitVec::with_capacity(len);\n    for i in 0..len {\n        bit_vec.push(f(i));\n    }\n    bit_vec\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bit_vec = BitVec::with_capacity(len);\n    for i in 0..len {\n        bit_vec.push(f(i));\n    }\n    bit_vec\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bit_vec = BitVec::with_capacity(len);\n    for i in 0..len {\n        bit_vec.push(f(i));\n    }\n    bit_vec\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bit_vec = BitVec::with_capacity(len);\n    for i in 0..len {\n        bit_vec.push(f(i));\n    }\n    bit_vec\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bit_vec = BitVec::with_capacity(len);\n    for i in 0..len {\n        bit_vec.push(f(i));\n    }\n    bit_vec\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bit_vec = BitVec::with_capacity(len);\n    for i in 0..len {\n        bit_vec.push(f(i));\n    }\n    bit_vec\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bit_vec = BitVec::with_capacity(len);\n    for i in 0..len {\n        bit_vec.push(f(i));\n    }\n    bit_vec\n}"
    ],
    [
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i < self.nbits {\n        let w = i / B::bits();\n        let b = i % B::bits();\n        let flag = B::one() << b;\n        Some((self.storage[w] & flag) != B::zero())\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i < self.nbits {\n        let w = i / B::bits();\n        let b = i % B::bits();\n        let flag = B::one() << b;\n        Some((self.storage[w] & flag) != B::zero())\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i < self.nbits {\n        let w = i / B::bits();\n        let b = i % B::bits();\n        let flag = B::one() << b;\n        Some((self.storage[w] & flag) != B::zero())\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i < self.nbits {\n        let w = i / B::bits();\n        let b = i % B::bits();\n        let flag = B::one() << b;\n        Some((self.storage[w] & flag) != B::zero())\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i < self.nbits {\n        let w = i / B::bits();\n        let b = i % B::bits();\n        let flag = B::one() << b;\n        Some((self.storage[w] & flag) != B::zero())\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i < self.nbits {\n        let w = i / B::bits();\n        let b = i % B::bits();\n        let flag = B::one() << b;\n        Some((self.storage[w] & flag) != B::zero())\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i >= self.nbits {\n        return None;\n    }\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let flag = B::one() << b;\n    let val = self.storage[w] & flag;\n    Some(val != B::zero())\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i < self.nbits {\n        let w = i / B::bits();\n        let b = i % B::bits();\n        let flag = B::one() << b;\n        Some((self.storage[w] & flag) != B::zero())\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i >= self.nbits {\n        return None;\n    }\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let flag = B::one() << b;\n    Some((self.storage[w] & flag) != B::zero())\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i >= self.nbits {\n        None\n    } else {\n        let w = i / B::bits();\n        let b = i % B::bits();\n        let flag = B::one() << b;\n        Some((self.storage[w] & flag) != B::zero())\n    }\n}"
    ],
    [
      "pub fn set (&mut self, i: usize, x: bool) {\n    self.ensure_invariant();\n    if i >= self.nbits {\n        panic!(\"index out of bounds\");\n    }\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let mask = B::one() << b;\n    if x {\n        self.storage[w] = self.storage[w] | mask;\n    } else {\n        self.storage[w] = self.storage[w] & !mask;\n    }\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    self.ensure_invariant();\n    if i >= self.nbits {\n        panic!(\"index out of bounds\");\n    }\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let mask = B::one() << b;\n    if x {\n        self.storage[w] = self.storage[w] | mask;\n    } else {\n        self.storage[w] = self.storage[w] & !mask;\n    }\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    self.ensure_invariant();\n    assert!(i < self.nbits, \"index out of bounds\");\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let bit = B::one() << b;\n    let val = if x { self.storage[w] | bit } else { self.storage[w] & !bit };\n    self.storage[w] = val;\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    self.ensure_invariant();\n    if i >= self.nbits {\n        panic!(\"index out of bounds\");\n    }\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let block = &mut self.storage[w];\n    if x {\n        *block = *block | (B::one() << b);\n    } else {\n        *block = *block & !(B::one() << b);\n    }\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    self.ensure_invariant();\n    assert!(i < self.nbits, \"index out of bounds\");\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let mask = B::one() << b;\n    let flag = if x { mask } else { B::zero() };\n    self.storage[w] = self.storage[w] & !mask | flag;\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    self.ensure_invariant();\n    assert!(i < self.nbits, \"`i` out of bounds\");\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let flag = B::one() << b;\n    if x {\n        self.storage[w] |= flag;\n    } else {\n        self.storage[w] &= !flag;\n    }\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    self.ensure_invariant();\n    if i >= self.nbits {\n        panic!(\"index out of bounds\");\n    }\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let bit = B::one() << b;\n    let block = &mut self.storage[w];\n    if x {\n        *block = *block | bit;\n    } else {\n        *block = *block & !bit;\n    }\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    self.ensure_invariant();\n    assert!(i < self.nbits, \"index out of bounds\");\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let flag = B::one() << b;\n    let val = if x { self.storage[w] | flag } else { self.storage[w] & !flag };\n    self.storage[w] = val;\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    self.ensure_invariant();\n    assert!(i < self.nbits, \"index out of bounds\");\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let flag = B::one() << b;\n    if x {\n        self.storage[w] |= flag;\n    } else {\n        self.storage[w] &= !flag;\n    }\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    self.ensure_invariant();\n    if i >= self.nbits {\n        panic!(\"index out of bounds\");\n    }\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let mask = B::one() << b;\n    let flag = if x { mask } else { B::zero() };\n    self.storage[w] = self.storage[w] & !mask | flag;\n}"
    ],
    [
      "pub fn negate (&mut self) {\n    for w in &mut self.storage {\n        *w = !*w;\n    }\n    self.fix_last_block();\n}",
      "pub fn negate (&mut self) {\n    for w in &mut self.storage {\n        *w = !*w;\n    }\n    self.fix_last_block();\n}",
      "pub fn negate (&mut self) {\n    for w in &mut self.storage { *w = !*w; }\n    self.fix_last_block();\n}",
      "pub fn negate (&mut self) {\n    for w in &mut self.storage { *w = !*w; }\n}",
      "pub fn negate (&mut self) {\n    self.storage.iter_mut().for_each(|x| *x = !*x);\n    self.fix_last_block();\n}",
      "pub fn negate (&mut self) {\n    for w in &mut self.storage {\n        *w = !*w;\n    }\n    self.fix_last_block_with_ones();\n}",
      "pub fn negate (&mut self) {\n    self.storage.iter_mut().for_each(|x| *x = !*x);\n}",
      "pub fn negate (&mut self) {\n    self.ensure_invariant();\n    for w in &mut self.storage { *w = !*w; }\n    self.fix_last_block();\n}",
      "pub fn negate (&mut self) {\n    self.storage.iter_mut().for_each(|x| *x = !*x);\n    self.fix_last_block();\n}",
      "pub fn negate (&mut self) {\n    for w in &mut self.storage {\n        *w = !*w;\n    }\n    self.fix_last_block();\n}"
    ],
    [
      "pub fn all (&self) -> bool {\n    self.blocks().all(|w| w == !B::zero())\n}",
      "pub fn all (&self) -> bool {\n    self.blocks().all(|w| w == !B::zero())\n}",
      "pub fn all (&self) -> bool {\n    self.blocks().all(|w| w == !B::zero())\n}",
      "pub fn all (&self) -> bool {\n    self.blocks().all(|w| w == !B::zero())\n}",
      "pub fn all (&self) -> bool {\n    self.blocks().all(|w| w == !B::zero())\n}",
      "pub fn all (&self) -> bool {\n    self.blocks().all(|w| w == !B::zero())\n}",
      "pub fn all (&self) -> bool {\n    self.blocks().all(|w| w == !B::zero())\n}",
      "pub fn all (&self) -> bool {\n    self.blocks().all(|w| w == !B::zero())\n}",
      "pub fn all (&self) -> bool {\n    self.blocks().all(|w| w == !B::zero())\n}",
      "pub fn all (&self) -> bool {\n    self.blocks().all(|w| w == !B::zero())\n}"
    ],
    [
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::with_capacity(self.nbits / 8);\n    let mut i = 0;\n    let mut word = 0;\n    let mut byte = 0;\n    while i < self.nbits {\n        if i % 8 == 0 {\n            word = self.storage[i / B::bits()];\n            byte = 0;\n        }\n        if word & (B::one() << (B::bits() - 1)) != 0 {\n            byte |= 1 << (7 - i % 8);\n        }\n        i += 1;\n        if i % 8 == 0 {\n            bytes.push(byte);\n        }\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::with_capacity(self.nbits / 8);\n    let mut i = 0;\n    let mut word = 0;\n    for b in self.storage.iter() {\n        word |= *b << i;\n        i += B::bits();\n        if i == 8 {\n            bytes.push(word as u8);\n            word = 0;\n            i = 0;\n        }\n    }\n    if i > 0 {\n        bytes.push(word as u8);\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::with_capacity(self.nbits / 8);\n    let mut word_index = 0;\n    let mut byte = 0;\n    let mut bit = 7;\n    let mut bit_index = 0;\n    while bit_index < self.nbits {\n        if self.get(bit_index).unwrap() {\n            byte |= 1 << bit;\n        }\n        bit_index += 1;\n        bit -= 1;\n        if bit < 0 {\n            bytes.push(byte);\n            byte = 0;\n            bit = 7;\n        }\n    }\n    if bit != 7 {\n        bytes.push(byte);\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::new();\n    let mut byte = 0;\n    let mut bit = 0;\n    for i in 0..self.nbits {\n        if self.get(i).unwrap() {\n            byte |= 1 << (7 - bit);\n        }\n        bit += 1;\n        if bit == 8 {\n            bytes.push(byte);\n            byte = 0;\n            bit = 0;\n        }\n    }\n    if bit != 0 {\n        bytes.push(byte);\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::with_capacity(self.nbits / 8);\n    let mut byte = 0;\n    let mut byte_idx = 0;\n    let mut bit_idx = 0;\n    let mut bit = 0;\n    let mut bit_mask = 0b10000000;\n    let mut last_byte = 0;\n    let mut last_byte_mask = 0b10000000;\n    for i in 0..self.nbits {\n        if bit_idx == 0 {\n            byte = self.storage[byte_idx];\n            bit_idx = 8;\n            byte_idx += 1;\n        }\n        bit = byte & bit_mask;\n        if bit != 0 {\n            last_byte |= last_byte_mask;\n        }\n        bit_mask >>= 1;\n        bit_idx -= 1;\n        if bit_idx == 0 {\n            bytes.push(last_byte);\n            last_byte = 0;\n            last_byte_mask = 0b10000000;\n        } else {\n            last_byte_mask >>= 1;\n        }\n    }\n    if bit_idx != 8 {\n        bytes.push(last_byte);\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::with_capacity(self.nbits / 8);\n    let mut byte = 0;\n    let mut bit = 0;\n    for (i, &b) in self.storage.iter().enumerate() {\n        for _ in 0..B::bits() {\n            if bit == 8 {\n                bytes.push(byte);\n                byte = 0;\n                bit = 0;\n            }\n            if i * B::bits() + bit >= self.nbits {\n                break;\n            }\n            byte |= (b & (1 << bit)) >> bit;\n            bit += 1;\n        }\n    }\n    if bit != 0 {\n        bytes.push(byte);\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::with_capacity(self.nbits / 8);\n    let mut word_idx = 0;\n    let mut bit_idx = 0;\n    let mut word = self.storage[word_idx];\n    while bit_idx < self.nbits {\n        if bit_idx % 8 == 0 {\n            bytes.push(word.to_be_bytes()[0]);\n            word_idx += 1;\n            word = self.storage[word_idx];\n        }\n        let bit = word & (1 << (7 - bit_idx % 8));\n        if bit != 0 {\n            bytes.push(1);\n        } else {\n            bytes.push(0);\n        }\n        bit_idx += 1;\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::new();\n    let mut byte = 0;\n    let mut bit = 0;\n    for &b in self.storage() {\n        for i in 0..B::bits() {\n            if b & (1 << i) != 0 {\n                byte |= 1 << (B::bits() - 1 - i);\n            }\n            bit += 1;\n            if bit == 8 {\n                bytes.push(byte);\n                byte = 0;\n                bit = 0;\n            }\n        }\n    }\n    if bit != 0 {\n        bytes.push(byte);\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::with_capacity(self.nbits / 8);\n    let mut byte = 0;\n    let mut bit = 0;\n    for (i, bit) in self.iter().enumerate() {\n        if bit {\n            byte |= 1 << (7 - i % 8);\n        }\n        if i % 8 == 7 {\n            bytes.push(byte);\n            byte = 0;\n        }\n    }\n    if bit {\n        bytes.push(byte);\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::new();\n    let mut byte = 0u8;\n    let mut byte_index = 0;\n    for (i, bit) in self.iter().enumerate() {\n        if bit {\n            byte |= 1 << (7 - byte_index);\n        }\n        byte_index += 1;\n        if byte_index == 8 {\n            bytes.push(byte);\n            byte_index = 0;\n            byte = 0;\n        }\n    }\n    if byte_index > 0 {\n        bytes.push(byte);\n    }\n    bytes\n}"
    ],
    [
      "pub fn grow (&mut self, n: usize, value: bool) {\n    self.reserve(n);\n    for _ in 0..n {\n        self.push(value);\n    }\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    let new_nbits = self.nbits.checked_add(n).expect(\"capacity overflow\");\n    let new_nblocks = blocks_for_bits::<B>(new_nbits);\n    self.storage.reserve(new_nblocks - self.storage.len());\n    for _ in 0..n {\n        self.storage.push(if value { !B::zero() } else { B::zero() });\n    }\n    self.nbits = new_nbits;\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    let new_len = self.len() + n;\n    self.reserve(n);\n    if value {\n        for i in self.len()..new_len {\n            self.set(i, true);\n        }\n    } else {\n        self.nbits = new_len;\n    }\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    let nbits = self.len();\n    let new_nbits = nbits + n;\n    if new_nbits > self.capacity() {\n        self.reserve(new_nbits - self.capacity());\n    }\n    let mut w = nbits / B::bits();\n    let b = nbits % B::bits();\n    let mut flag = B::one() << b;\n    if value {\n        if b != 0 {\n            self.storage[w] |= flag;\n        }\n        w += 1;\n        for _ in 0..n {\n            self.storage.push(B::max_value());\n        }\n    } else {\n        if b != 0 {\n            self.storage[w] &= !flag;\n        }\n        w += 1;\n        for _ in 0..n {\n            self.storage.push(B::zero());\n        }\n    }\n    self.nbits = new_nbits;\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    let old_len = self.len();\n    let new_len = old_len.checked_add(n).expect(\"capacity overflow\");\n    self.reserve(n);\n    for i in old_len..new_len {\n        self.set(i, value);\n    }\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    self.reserve(n);\n    let nblocks = n / B::bits();\n    let nbits = n % B::bits();\n    let mut block = if value { !B::zero() } else { B::zero() };\n    for _ in 0..nbits {\n        block = block << 1 | B::one();\n    }\n    self.storage.extend(repeat(block).take(nblocks));\n    self.nbits += n;\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    let old_len = self.len();\n    let new_len = old_len.checked_add(n).expect(\"capacity overflow\");\n    self.reserve(n);\n    if value {\n        self.storage.extend(repeat(if value { !B::zero() } else { B::zero() }));\n    } else {\n        self.storage.extend(repeat(B::zero()));\n    }\n    self.nbits = new_len;\n    self.fix_last_block();\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    let old_len = self.len();\n    let new_len = old_len + n;\n    if new_len > self.capacity() {\n        self.reserve(new_len - self.len());\n    }\n    for _ in 0..n {\n        self.set(old_len, value);\n    }\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    self.ensure_invariant();\n    let new_nbits = self.nbits + n;\n    let new_nblocks = blocks_for_bits::<B>(new_nbits);\n    self.storage.reserve(new_nblocks - self.storage.len());\n    let mut new_blocks = vec![if value { !B::zero() } else { B::zero() }; new_nblocks - self.storage.len()];\n    new_blocks.extend_from_slice(&self.storage);\n    self.storage = new_blocks;\n    self.nbits = new_nbits;\n    self.fix_last_block();\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    let nblocks = blocks_for_bits::<B>(n);\n    self.storage.grow(nblocks, if value { !B::zero() } else { B::zero() });\n    self.nbits += n;\n}"
    ],
    [
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.is_empty() {\n        return None;\n    }\n    let last_bit = self.get(self.len() - 1).unwrap();\n    self.set(self.len() - 1, false);\n    self.nbits -= 1;\n    self.fix_last_block();\n    Some(last_bit)\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.is_empty() {\n        None\n    } else {\n        let last_bit = self.get(self.len() - 1).unwrap();\n        self.set(self.len() - 1, false);\n        self.nbits -= 1;\n        self.fix_last_block();\n        Some(last_bit)\n    }\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.is_empty() {\n        return None;\n    }\n\n    let bit_index = self.len() - 1;\n    let bit = self.get(bit_index).unwrap();\n    self.set(bit_index, false);\n    self.nbits -= 1;\n    self.fix_last_block();\n    Some(bit)\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.len() == 0 {\n        None\n    } else {\n        let result = self.get(self.len() - 1).unwrap();\n        self.set(self.len() - 1, false);\n        self.nbits -= 1;\n        Some(result)\n    }\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.len() == 0 {\n        return None;\n    }\n    let result = self.get(self.len() - 1).unwrap();\n    self.set(self.len() - 1, false);\n    self.nbits -= 1;\n    Some(result)\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.is_empty() {\n        return None;\n    }\n    let bit = self.get(self.len() - 1).unwrap();\n    self.set(self.len() - 1, false);\n    self.nbits -= 1;\n    self.fix_last_block();\n    Some(bit)\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.is_empty() {\n        return None;\n    }\n\n    let bit_index = self.len() - 1;\n    let block_index = bit_index / B::bits();\n    let bit_mask = B::one() << (bit_index % B::bits());\n\n    let result = (self.storage[block_index] & bit_mask) != B::zero();\n    self.storage[block_index] &= !bit_mask;\n    self.nbits -= 1;\n\n    if block_index == self.storage.len() - 1 {\n        self.storage.pop();\n    }\n\n    Some(result)\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.is_empty() {\n        return None;\n    }\n\n    let (block_idx, bit_idx) = (self.nbits - 1) / B::bits() as usize;\n    let bit_mask = 1 << (self.nbits - 1) % B::bits() as usize;\n    let bit = self.storage[block_idx] & bit_mask != 0;\n    self.storage[block_idx] &= !bit_mask;\n    self.nbits -= 1;\n\n    if self.nbits % B::bits() as usize == 0 {\n        self.storage.pop();\n    }\n\n    Some(bit)\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.len() == 0 {\n        return None;\n    }\n    let result = self.get(self.len() - 1).unwrap();\n    self.set(self.len() - 1, false);\n    self.nbits -= 1;\n    Some(result)\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    self.ensure_invariant();\n    if self.len() == 0 {\n        return None;\n    }\n    let last_idx = self.len() - 1;\n    let last_bit = self.get(last_idx).unwrap();\n    self.set(last_idx, false);\n    self.nbits -= 1;\n    self.fix_last_block();\n    Some(last_bit)\n}"
    ],
    [
      "pub fn push (&mut self, elem: bool) {\n    self.nbits += 1;\n    let w = self.nbits / B::bits();\n    let b = self.nbits % B::bits();\n    let flag = B::one() << b;\n    let val = if elem { self.storage[w] | flag }\n              else { self.storage[w] & !flag };\n    self.storage[w] = val;\n}",
      "pub fn push (&mut self, elem: bool) {\n    let i = self.len();\n    self.set(i, elem);\n}",
      "pub fn push (&mut self, elem: bool) {\n    self.nbits += 1;\n    let w = self.nbits / B::bits();\n    let b = self.nbits % B::bits();\n    let flag = B::one() << b;\n    if elem {\n        self.storage[w] |= flag;\n    } else {\n        self.storage[w] &= !flag;\n    }\n}",
      "pub fn push (&mut self, elem: bool) {\n    self.nbits += 1;\n    if self.nbits % B::bits() == 0 {\n        self.storage.push(if elem { !B::zero() } else { B::zero() });\n    } else {\n        let w = self.nbits / B::bits();\n        let b = self.nbits % B::bits();\n        let flag = B::one() << b;\n        let val = if elem { self.storage[w] | flag }\n                  else { self.storage[w] & !flag };\n        self.storage[w] = val;\n    }\n}",
      "pub fn push (&mut self, elem: bool) {\n    let nbits = self.nbits;\n    self.nbits = nbits + 1;\n    self.storage.push(if elem { !B::zero() } else { B::zero() });\n}",
      "pub fn push (&mut self, elem: bool) {\n    let i = self.nbits;\n    self.nbits += 1;\n    self.set(i, elem);\n}",
      "pub fn push (&mut self, elem: bool) {\n    self.nbits += 1;\n    let w = self.nbits / B::bits();\n    let b = self.nbits % B::bits();\n    let flag = B::one() << b;\n    if elem {\n        self.storage[w] |= flag;\n    } else {\n        self.storage[w] &= !flag;\n    }\n}",
      "pub fn push (&mut self, elem: bool) {\n    self.nbits += 1;\n    let w = self.nbits / B::bits();\n    let b = self.nbits % B::bits();\n    let flag = B::one() << b;\n    let val = if elem { self.storage[w] | flag }\n              else { self.storage[w] & !flag };\n    self.storage[w] = val;\n}",
      "pub fn push (&mut self, elem: bool) {\n    self.nbits += 1;\n    let w = self.nbits / B::bits();\n    let b = self.nbits % B::bits();\n    let flag = B::one() << b;\n    let val = if elem { self.storage[w] | flag }\n              else { self.storage[w] & !flag };\n    self.storage[w] = val;\n}",
      "pub fn push (&mut self, elem: bool) {\n    self.nbits += 1;\n    let w = self.nbits / B::bits();\n    let b = self.nbits % B::bits();\n    let flag = B::one() << b;\n    if elem {\n        self.storage[w] |= flag;\n    } else {\n        self.storage[w] &= !flag;\n    }\n}"
    ],
    [
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let coefficients = match degree {\n        PolynomialDegree::Infinity => vec![],\n        PolynomialDegree::Finite(degree) => {\n            let n = degree + 1;\n            let mut coefficients = vec![Scalar::random(); n as usize];\n            coefficients[0] = Scalar::zero();\n            coefficients\n        }\n    };\n    Self { coefficients }\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let coefficients = match degree {\n        PolynomialDegree::Infinity => vec![],\n        PolynomialDegree::Finite(degree) => {\n            let mut coefficients = vec![Scalar::random(); degree as usize];\n            coefficients.push(Scalar::zero());\n            coefficients\n        }\n    };\n    Self { coefficients }\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let coefficients = match degree {\n        PolynomialDegree::Infinity => vec![],\n        PolynomialDegree::Finite(degree) => (0..degree)\n            .map(|_| Scalar::random())\n            .collect::<Vec<_>>(),\n    };\n    Self { coefficients }\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let coefficients = match degree {\n        PolynomialDegree::Infinity => vec![],\n        PolynomialDegree::Finite(degree) => {\n            let mut rng = rand::thread_rng();\n            iter::repeat_with(|| Scalar::random())\n                .take(degree as usize + 1)\n                .collect::<Vec<_>>()\n        }\n    };\n    Self { coefficients }\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let coefficients = match degree {\n        PolynomialDegree::Infinity => vec![],\n        PolynomialDegree::Finite(degree) => (0..=degree).map(|_| Scalar::random()).collect(),\n    };\n    Self { coefficients }\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let coefficients = match degree {\n        PolynomialDegree::Infinity => vec![],\n        PolynomialDegree::Finite(degree) => {\n            let mut coefficients = vec![Scalar::random(); degree as usize + 1];\n            coefficients[0] = Scalar::zero();\n            coefficients\n        }\n    };\n    Self { coefficients }\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let coefficients = match degree {\n        PolynomialDegree::Infinity => vec![],\n        PolynomialDegree::Finite(degree) => {\n            let n = degree as usize;\n            let mut rng = rand::thread_rng();\n            (0..n)\n                .map(|_| Scalar::random())\n                .collect::<Vec<_>>()\n        }\n    };\n    Self { coefficients }\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let coefficients = match degree {\n        PolynomialDegree::Infinity => vec![],\n        PolynomialDegree::Finite(degree) => {\n            let mut rng = rand::thread_rng();\n            iter::repeat_with(|| Scalar::random())\n                .take(degree as usize)\n                .collect::<Vec<_>>()\n        }\n    };\n    Self { coefficients }\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let coefficients = match degree {\n        PolynomialDegree::Infinity => vec![],\n        PolynomialDegree::Finite(degree) => {\n            let mut rng = rand::thread_rng();\n            (0..=degree)\n                .map(|_| Scalar::random())\n                .collect::<Vec<_>>()\n        }\n    };\n    Self { coefficients }\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let coefficients = match degree {\n        PolynomialDegree::Infinity => vec![],\n        PolynomialDegree::Finite(degree) => {\n            let mut coefficients = vec![Scalar::random(); degree as usize];\n            // make sure the constant term is not zero\n            coefficients[0] = Scalar::random();\n            coefficients\n        }\n    };\n    Self { coefficients }\n}"
    ],
    [
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = vec![Scalar::zero(); usize::from(n) + 1];\n    coefficients[0] = const_term;\n    for i in 1..=n {\n        coefficients[usize::from(i)] = Scalar::random();\n    }\n    Self::from_coefficients(coefficients)\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = Vec::with_capacity(usize::from(n) + 1);\n    coefficients.push(const_term);\n    for _ in 0..n {\n        coefficients.push(Scalar::random());\n    }\n    Self::from_coefficients(coefficients)\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = Vec::with_capacity(usize::from(n) + 1);\n    coefficients.push(const_term);\n    coefficients.extend(iter::repeat_with(Scalar::random).take(usize::from(n)));\n    Self::from_coefficients(coefficients)\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = vec![const_term];\n    coefficients.extend(iter::repeat_with(Scalar::random).take(usize::from(n)));\n    Self::from_coefficients(coefficients)\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = vec![const_term];\n    coefficients.extend(iter::repeat_with(Scalar::random).take(usize::from(n)));\n    Self::from_coefficients(coefficients)\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = Vec::with_capacity(usize::from(n) + 1);\n    coefficients.push(const_term);\n    for _ in 0..n {\n        coefficients.push(Scalar::random());\n    }\n    Self::from_coefficients(coefficients)\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = vec![Scalar::zero(); usize::from(n) + 1];\n    coefficients[0] = const_term;\n    for i in 1..=n {\n        coefficients[usize::from(i)] = Scalar::random();\n    }\n    Self::from_coefficients(coefficients)\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = Vec::with_capacity(n as usize + 1);\n    coefficients.push(const_term);\n    coefficients.extend(iter::repeat_with(Scalar::random).take(n as usize));\n    Self::from_coefficients(coefficients)\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = vec![Scalar::zero(); usize::from(n) + 1];\n    coefficients[0] = const_term;\n    for i in 1..=n {\n        coefficients[usize::from(i)] = Scalar::random();\n    }\n    Self::from_coefficients(coefficients)\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = vec![Scalar::zero(); usize::from(n) + 1];\n    coefficients[0] = const_term;\n    for i in 1..usize::from(n) + 1 {\n        coefficients[i] = Scalar::random();\n    }\n    Self::from_coefficients(coefficients)\n}"
    ],
    [
      "pub fn degree (&self) -> PolynomialDegree {\n    self.coefficients.iter().rposition(|c| !c.is_zero()).map_or(PolynomialDegree::Infinity, |i| i.into())\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    let mut degree = 0;\n    for (i, coefficient) in self.coefficients.iter().enumerate() {\n        if !coefficient.is_zero() {\n            degree = i;\n        }\n    }\n    degree.into()\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    self.coefficients.iter().rposition(|x| !x.is_zero()).map_or(PolynomialDegree::Infinity, |i| i.into())\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    self.coefficients\n        .iter()\n        .rposition(|&coef| !coef.is_zero())\n        .map(u16::try_from)\n        .transpose()\n        .map(PolynomialDegree::Finite)\n        .unwrap_or(PolynomialDegree::Infinity)\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    let last_non_zero = self.coefficients.iter().rposition(|coef| !coef.is_zero());\n    match last_non_zero {\n        Some(last_non_zero) => (last_non_zero as u16).into(),\n        None => PolynomialDegree::Infinity,\n    }\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    self.coefficients.iter().rposition(|c| !c.is_zero()).map_or(PolynomialDegree::Infinity, |i| i.into())\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    match self.coefficients.iter().rposition(|c| !c.is_zero()) {\n        Some(i) => PolynomialDegree::Finite(i as u16),\n        None => PolynomialDegree::Infinity,\n    }\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    self.coefficients.iter().rposition(|c| !c.is_zero()).map_or(PolynomialDegree::Infinity, |i| i.into())\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    match self.coefficients.iter().rposition(|c| !c.is_zero()) {\n        Some(degree) => PolynomialDegree::Finite(degree.try_into().unwrap()),\n        None => PolynomialDegree::Infinity,\n    }\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    let mut degree = 0;\n    for (i, coef) in self.coefficients.iter().enumerate() {\n        if coef.is_zero() {\n            break;\n        }\n        degree = i;\n    }\n    degree.into()\n}"
    ],
    [
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = Scalar::zero();\n    for (i, coefficient) in self.coefficients.iter().enumerate() {\n        let mut term = Scalar::zero();\n        for j in 0..i {\n            term = term + &self.coefficients[i - j - 1] * &point_x.pow(j as u32);\n        }\n        result = result + &coefficient * &term;\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = Scalar::zero();\n    for (i, coefficient) in self.coefficients.iter().enumerate() {\n        let mut term = coefficient.clone();\n        for j in 0..i {\n            term *= point_x.clone();\n        }\n        result += term;\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = Scalar::zero();\n    for (i, c) in self.coefficients.iter().enumerate() {\n        let mut term = point_x.clone();\n        for _ in 0..i {\n            term *= point_x;\n        }\n        result += c * term;\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = Scalar::zero();\n    for (i, coefficient) in self.coefficients.iter().enumerate() {\n        result += coefficient * point_x.pow(i as u32);\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = Scalar::zero();\n    for (i, c) in self.coefficients.iter().enumerate() {\n        let mut term = c.clone();\n        for j in 0..i {\n            term *= point_x;\n        }\n        result += term;\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = Scalar::zero();\n    for (i, coeff) in self.coefficients.iter().enumerate() {\n        let mut term = Scalar::zero();\n        for j in 0..i+1 {\n            term = term + &coeff[j] * &point_x.pow([j as u32]);\n        }\n        result = result + &term;\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = Scalar::zero();\n    for (i, c) in self.coefficients.iter().enumerate() {\n        let mut term = c.clone();\n        for j in 0..i {\n            term = term * point_x;\n        }\n        result = result + term;\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = Scalar::zero();\n    for (i, coefficient) in self.coefficients.iter().enumerate() {\n        result = result + coefficient * point_x.pow(i as u32);\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut y = Scalar::zero();\n    for (i, coefficient) in self.coefficients.iter().enumerate() {\n        let mut term = coefficient.clone();\n        for j in 0..i {\n            term *= &point_x;\n        }\n        y += term;\n    }\n    y\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut y = Scalar::zero();\n    for (i, coeff) in self.coefficients.iter().enumerate() {\n        let mut term = coeff.clone();\n        for j in 0..i {\n            term *= point_x.clone();\n        }\n        y += term;\n    }\n    y\n}"
    ],
    [
      "pub fn back (&self) -> Option<&T> {\n    let index = self.tail?;\n    match &self.entries[index.get()] {\n        Entry::Occupied(entry) => Some(&entry.value),\n        _ => None,\n    }\n}",
      "pub fn back (&self) -> Option<&T> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    Some(&entry.value)\n}",
      "pub fn back (&self) -> Option<&T> {\n    let index = self.tail?.get();\n    match &self.entries[index] {\n        Entry::Occupied(entry) => Some(&entry.value),\n        _ => None,\n    }\n}",
      "pub fn back (&self) -> Option<&T> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    self.get(index)\n}",
      "pub fn back (&self) -> Option<&T> {\n    let index = self.tail?;\n    match &self.entries[index.get()] {\n        Entry::Occupied(entry) => Some(&entry.value),\n        _ => None,\n    }\n}",
      "pub fn back (&self) -> Option<&T> {\n    let index = self.tail?.get();\n\n    match &self.entries[index] {\n        Entry::Occupied(entry) => Some(&entry.value),\n        _ => None,\n    }\n}",
      "pub fn back (&self) -> Option<&T> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    self.get(index)\n}",
      "pub fn back (&self) -> Option<&T> {\n    let index = self.tail?;\n    match &self.entries[index.get()] {\n        Entry::Occupied(entry) => Some(&entry.value),\n        _ => None,\n    }\n}",
      "pub fn back (&self) -> Option<&T> {\n    let index = self.tail?.get();\n    match &self.entries[index] {\n        Entry::Occupied(entry) => Some(&entry.value),\n        _ => None,\n    }\n}",
      "pub fn back (&self) -> Option<&T> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    self.get(index)\n}"
    ],
    [
      "pub fn back_index (&self) -> Option<Index<T>> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    Some(index)\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    Some(index)\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    Some(index)\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    Some(index)\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    Some(index)\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    Some(index)\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    Some(index)\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    Some(index)\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    Some(index)\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    let index = self.tail?;\n    let entry = self.entries[index.get()].occupied_ref();\n    let index = Index::new(index, entry.generation);\n    Some(index)\n}"
    ],
    [
      "pub fn clear (&mut self) {\n    self.entries.clear();\n    self.head = None;\n    self.tail = None;\n    self.length = 0;\n    self.vacant_head = None;\n}",
      "pub fn clear (&mut self) {\n    self.entries.clear();\n    self.head = None;\n    self.length = 0;\n    self.tail = None;\n    self.vacant_head = None;\n}",
      "pub fn clear (&mut self) {\n    self.entries.clear();\n    self.head = None;\n    self.length = 0;\n    self.tail = None;\n}",
      "pub fn clear (&mut self) {\n    self.entries.clear();\n    self.head = None;\n    self.tail = None;\n    self.length = 0;\n}",
      "pub fn clear (&mut self) {\n    self.entries.clear();\n    self.head = None;\n    self.length = 0;\n    self.tail = None;\n}",
      "pub fn clear (&mut self) {\n    self.entries.clear();\n    self.head = None;\n    self.length = 0;\n    self.tail = None;\n    self.vacant_head = None;\n}",
      "pub fn clear (&mut self) {\n    self.entries.clear();\n    self.head = None;\n    self.tail = None;\n    self.length = 0;\n}",
      "pub fn clear (&mut self) {\n    self.entries.clear();\n    self.head = None;\n    self.tail = None;\n    self.length = 0;\n    self.vacant_head = None;\n}",
      "pub fn clear (&mut self) {\n    self.entries.clear();\n    self.head = None;\n    self.tail = None;\n    self.length = 0;\n    self.vacant_head = None;\n}",
      "pub fn clear (&mut self) {\n    self.head = None;\n    self.tail = None;\n    self.length = 0;\n    self.generation = 0;\n    self.entries.clear();\n}"
    ],
    [
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?;\n    let entry = self.entries[index.get()].occupied_mut();\n    Some(&mut entry.value)\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?.get();\n    match &mut self.entries[index] {\n        Entry::Occupied(entry) => Some(&mut entry.value),\n        _ => None,\n    }\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?.get();\n    match &mut self.entries[index] {\n        Entry::Occupied(entry) => Some(&mut entry.value),\n        _ => None,\n    }\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?.get();\n    match &mut self.entries[index] {\n        Entry::Occupied(entry) => Some(&mut entry.value),\n        _ => None,\n    }\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?;\n    let entry = self.entries[index.get()].occupied_mut();\n    Some(&mut entry.value)\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?.get();\n    match &mut self.entries[index] {\n        Entry::Occupied(entry) => Some(&mut entry.value),\n        _ => None,\n    }\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?;\n    let entry = self.entries[index.get()].occupied_mut();\n    Some(&mut entry.value)\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?;\n    let entry = self.entries[index.get()].occupied_mut();\n    Some(&mut entry.value)\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?.get();\n    match &mut self.entries[index] {\n        Entry::Occupied(entry) => Some(&mut entry.value),\n        _ => None,\n    }\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?.get();\n    match &mut self.entries[index] {\n        Entry::Occupied(entry) => Some(&mut entry.value),\n        _ => None,\n    }\n}"
    ],
    [
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let index = index.index();\n    match &self.entries[index] {\n        Entry::Occupied(entry) if entry.generation == index.generation => Some(&entry.value),\n        _ => None,\n    }\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let index = index.index();\n    match &self.entries[index] {\n        Entry::Occupied(entry) if entry.generation == index.generation => Some(&entry.value),\n        _ => None,\n    }\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let index = index.index();\n    if index < self.length && self.entries[index].generation == index.generation {\n        match &self.entries[index] {\n            Entry::Occupied(entry) => Some(&entry.value),\n            _ => None,\n        }\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let index = index.index();\n    match &self.entries[index] {\n        Entry::Occupied(entry) if entry.generation == index.generation => Some(&entry.value),\n        _ => None,\n    }\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let index = index.index();\n    match &self.entries[index] {\n        Entry::Occupied(entry) if entry.generation == index.generation => Some(&entry.value),\n        _ => None,\n    }\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let index = index.index();\n    match &self.entries[index] {\n        Entry::Occupied(entry) if entry.generation == index.generation => Some(&entry.value),\n        _ => None,\n    }\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let index = index.index();\n    match &self.entries[index] {\n        Entry::Occupied(entry) if entry.generation == index.generation => Some(&entry.value),\n        _ => None,\n    }\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let index = index.index();\n    match &self.entries[index] {\n        Entry::Occupied(entry) if entry.generation == index.generation => Some(&entry.value),\n        _ => None,\n    }\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let index = index.index();\n    if index < self.entries.len() && self.entries[index].generation == index.generation {\n        match &self.entries[index] {\n            Entry::Occupied(entry) => Some(&entry.value),\n            _ => None,\n        }\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let index = index.index();\n    match &self.entries[index] {\n        Entry::Occupied(entry) if entry.generation == index.generation => Some(&entry.value),\n        _ => None,\n    }\n}"
    ],
    [
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    match self.entries.get(index.index())? {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            let next_index = entry.next?;\n            let next_entry = self.entries[next_index.get()].occupied_ref();\n            Some(Index::new(next_index, next_entry.generation))\n        }\n        _ => None,\n    }\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    match self.entries.get(index.index())? {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            let next_index = entry.next?;\n            let next_entry = self.entries[next_index.get()].occupied_ref();\n            Some(Index::new(next_index, next_entry.generation))\n        }\n        _ => None,\n    }\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    match self.entries.get(index.index())? {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            let next_index = entry.next?;\n            let next_entry = self.entries[next_index.get()].occupied_ref();\n            Some(Index::new(next_index, next_entry.generation))\n        }\n        _ => None,\n    }\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    match self.entries.get(index.index())? {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            let next_index = entry.next?;\n            let next_entry = self.entries[next_index.get()].occupied_ref();\n            Some(Index::new(next_index, next_entry.generation))\n        }\n        _ => None,\n    }\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    match self.entries.get(index.index())? {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            let next_index = entry.next?;\n            let next_entry = self.entries[next_index.get()].occupied_ref();\n            Some(Index::new(next_index, next_entry.generation))\n        }\n        _ => None,\n    }\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    match self.entries.get(index.index())? {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            let next_index = entry.next?;\n            let next_entry = self.entries[next_index.get()].occupied_ref();\n            Some(Index::new(next_index, next_entry.generation))\n        }\n        _ => None,\n    }\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    match self.entries.get(index.index())? {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            let next_index = entry.next?;\n            let next_entry = self.entries[next_index.get()].occupied_ref();\n            Some(Index::new(next_index, next_entry.generation))\n        }\n        _ => None,\n    }\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    match self.entries.get(index.index())? {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            let next_index = entry.next?;\n            let next_entry = self.entries[next_index.get()].occupied_ref();\n            Some(Index::new(next_index, next_entry.generation))\n        }\n        _ => None,\n    }\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    match self.entries.get(index.index())? {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            let next_index = entry.next?;\n            let next_entry = self.entries[next_index.get()].occupied_ref();\n            Some(Index::new(next_index, next_entry.generation))\n        }\n        _ => None,\n    }\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    match self.entries.get(index.index())? {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            let next_index = entry.next?;\n            let next_entry = self.entries[next_index.get()].occupied_ref();\n            Some(Index::new(next_index, next_entry.generation))\n        }\n        _ => None,\n    }\n}"
    ],
    [
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    let (previous_index, next_index) = match &self.entries[index.index()] {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            (entry.previous, entry.next)\n        }\n}\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    let (previous_index, next_index) = match &self.entries[index.index()] {\n        Entry::Occupied(entry) if entry.generation == index.generation => (entry.previous, entry.next),\n    };\n    self.update_link(previous_index, next_index);\n    self.update_link(next_index, Some(target));\n    self.update_link(Some(target), Some(index));\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    let (previous_index, next_index) = match &self.entries[index.index()] {\n        Entry::Occupied(entry) if entry.generation == index.generation() => {\n            (entry.previous(), entry.next())\n        }\n}\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    let (previous_index, next_index) = match &self.entries[index.index()] {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            (entry.previous, entry.next)\n        }\n}\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    let (previous_index, next_index) = match &self.entries[index.index()] {\n        Entry::Occupied(entry) if entry.generation == index.generation() => (entry.previous, entry.next),\n    };\n    let (previous_target, next_target) = match &self.entries[target.index()] {\n        Entry::Occupied(entry) if entry.generation == target.generation() => (entry.previous, entry.next),\n    };\n    self.update_link(previous_index, Some(target));\n    self.update_link(Some(index), next_target);\n    self.update_link(previous_target, Some(index));\n    self.update_link(next_target, next_index);\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    let (previous_index, next_index) = match &self.entries[index.index()] {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            (entry.previous, entry.next)\n        }\n        _ => panic!(\"index is invalidated\"),\n    };\n    if previous_index == Some(target) {\n        panic!(\"cannot move node after itself\");\n    }\n    let next_index = match next_index {\n        Some(next_index) if next_index.get() != target.index() => next_index,\n        _ => panic!(\"target is invalidated\"),\n    };\n    self.update_link(previous_index, Some(next_index));\n    self.update_link(Some(index), Some(target));\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    let (previous_index, next_index) = match &self.entries[index.index()] {\n        Entry::Occupied(entry) if entry.generation == index.generation() => {\n            (entry.previous, entry.next)\n        }\n}\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    let (previous_index, next_index) = match &self.entries[index.index()] {\n        Entry::Occupied(entry) if entry.generation == index.generation => (entry.previous, entry.next),\n        _ => panic!(\"expected valid index\"),\n    };\n    self.update_link(previous_index, next_index);\n    self.update_link(next_index, Some(target));\n    self.update_link(Some(target), Some(index));\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    let (previous_index, next_index) = match &self.entries[index.index()] {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            (entry.previous, entry.next)\n        }\n        _ => panic!(\"invalid index\"),\n    };\n    let (previous_target, next_target) = match &self.entries[target.index()] {\n        Entry::Occupied(entry) if entry.generation == target.generation => {\n            (entry.previous, entry.next)\n        }\n        _ => panic!(\"invalid target\"),\n    };\n    if index == target {\n        panic!(\"cannot move to the same index\");\n    }\n    self.update_link(previous_index, next_target);\n    self.update_link(next_index, previous_target);\n    self.update_link(Some(index), Some(target));\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    let (previous_index, next_index) = match &self.entries[index.index()] {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            (entry.previous, entry.next)\n        }\n        _ => panic!(\"invalid index\"),\n    };\n    let (previous_target, next_target) = match &self.entries[target.index()] {\n        Entry::Occupied(entry) if entry.generation == target.generation => {\n            (entry.previous, entry.next)\n        }\n        _ => panic!(\"invalid target\"),\n    };\n    if previous_index == Some(target) {\n        panic!(\"index is the same as target\");\n    }\n    self.update_link(previous_index, Some(next_target));\n    self.update_link(Some(index), next_index);\n    self.update_link(previous_target, Some(index));\n    self.update_link(next_target, next_index);\n}"
    ],
    [
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let index = self.insert_new(value, None, Some(index.index()));\n    self.entries[index.get()].occupied_mut().next = Some(index);\n    self.entries[index.get()].occupied_mut().previous = Some(index);\n    Index::new(index, self.generation)\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    match self.entries.get_mut(index.index()) {\n        Some(Entry::Occupied(entry)) if entry.generation == index.generation => {\n            let previous_index = entry.previous;\n            let next_index = entry.next;\n            let new_index = self.insert_new(value, previous_index, next_index);\n            if let Some(previous_index) = previous_index {\n                self.entries[previous_index.get()].occupied_mut().next = Some(new_index);\n            }\n            if let Some(next_index) = next_index {\n                self.entries[next_index.get()].occupied_mut().previous = Some(new_index);\n            }\n            if Some(new_index) == self.head {\n                self.head = Some(new_index);\n            }\n            Index::new(new_index, self.generation)\n        }\n        _ => panic!(\"index not in the list anymore or invalidated\"),\n    }\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let previous_index = self.get_previous_index(index);\n    let next_index = self.get_next_index(index);\n    let new_index = self.insert_new(value, previous_index, next_index);\n    self.update_link(previous_index, Some(new_index));\n    self.update_link(Some(new_index), next_index);\n    Index::new(new_index, self.generation)\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let index = self.insert_new(value, None, Some(index.index()));\n    self.entries[index.get()].occupied_mut().next = Some(index);\n    Index::new(index, self.generation)\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let previous_index = match self.get_previous_index(index) {\n        Some(index) => index,\n        None => return self.insert_empty(value),\n    };\n    let index = self.insert_new(value, Some(previous_index), Some(index));\n    self.entries[previous_index.index()].occupied_mut().next = Some(index);\n    self.entries[index.index()].occupied_mut().previous = Some(previous_index);\n    Index::new(index, self.generation)\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    match self.entries.get_mut(index.index()) {\n        Some(entry) if entry.generation == index.generation => {\n            let previous_index = entry.previous;\n            let new_index = self.insert_new(value, previous_index, Some(index.index()));\n            if let Some(previous_index) = previous_index {\n                self.entries[previous_index.get()].occupied_mut().next = Some(new_index);\n            }\n            entry.previous = Some(new_index);\n            Index::new(new_index, self.generation)\n        }\n        _ => panic!(\"index not valid\"),\n    }\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let previous_index = match self.get_previous_index(index) {\n        Some(index) => index,\n        None => return self.insert_empty(value),\n    };\n    let index = self.insert_new(value, Some(previous_index), Some(index));\n    self.entries[previous_index.index()].occupied_mut().next = Some(index);\n    self.entries[index.index()].occupied_mut().previous = Some(previous_index);\n    Index::new(index, self.generation)\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let previous_index = match self.get_previous_index(index) {\n        Some(index) => index,\n        None => return self.insert_empty(value),\n    };\n    let index = self.insert_new(value, Some(previous_index), Some(index));\n    self.entries[previous_index.index()].occupied_mut().next = Some(index);\n    self.entries[index.index()].occupied_mut().previous = Some(previous_index);\n    Index::new(index, self.generation)\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    match self.entries.get_mut(index.index()) {\n        Some(Entry::Occupied(entry)) if entry.generation == index.generation => {\n            let previous_index = entry.previous;\n            let index = self.insert_new(value, previous_index, Some(index.index()));\n            if let Some(previous_index) = previous_index {\n                self.entries[previous_index.get()].occupied_mut().next = Some(index);\n            }\n            entry.previous = Some(index);\n            Index::new(index, self.generation)\n        }\n        _ => panic!(\"index not in list anymore or invalidated\"),\n    }\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let index = match self.entries.get_mut(index.index()) {\n        Some(Entry::Occupied(entry)) if entry.generation == index.generation => {\n            let previous_index = entry.previous;\n            let new_index = self.insert_new(value, previous_index, Some(index.index()));\n            if let Some(previous_index) = previous_index {\n                self.entries[previous_index.get()].occupied_mut().next = Some(new_index);\n            }\n            self.entries[index.index()].occupied_mut().previous = Some(new_index);\n            new_index\n        }\n        _ => panic!(\"index not valid\"),\n    };\n    Index::new(index, self.generation)\n}"
    ],
    [
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    if self.length() < minimum_capacity {\n        panic!(\"minimum capacity is less than the current length\");\n    }\n    let mut map = HashMap::new();\n    let mut new_index = 0;\n    let mut previous_index = None;\n    let mut current_index = self.head();\n    while let Some(index) = current_index {\n        let entry = self.entries[index.get()].occupied_ref();\n        if entry.previous().is_none() {\n            self.head = Some(NonMaxUsize::new(new_index).unwrap());\n        }\n        self.update_link(entry.previous(), Some(NonMaxUsize::new(new_index).unwrap()));\n        self.update_link(Some(NonMaxUsize::new(new_index).unwrap()), entry.next());\n        map.insert(index, Index::new(new_index, self.generation));\n        previous_index = Some(NonMaxUsize::new(new_index).unwrap());\n        new_index += 1;\n        current_index = entry.next();\n    }\n    self.length = new_index;\n    self.tail = previous_index;\n    self.vacant_head = None;\n    map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    if minimum_capacity < self.len() {\n        panic!(\"minimum capacity must be at least the current length\");\n    }\n\n    let mut map = HashMap::new();\n    let mut index = 0;\n\n    for entry in self.entries.iter_mut() {\n        match entry {\n            Entry::Occupied(entry) => {\n                let new_index = NonMaxUsize::new(index).unwrap();\n                let old_index = entry.index;\n                entry.index = new_index;\n                map.insert(Index::new(old_index.get(), self.generation), Index::new(index, self.generation));\n                index += 1;\n            }\n            Entry::Vacant(_) => {}\n        }\n    }\n\n    self.entries.truncate(minimum_capacity);\n    self.vacant_head = None;\n    self.generation += 1;\n\n    map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    if minimum_capacity < self.len() {\n        panic!(\"minimum capacity must be at least the current length\");\n    }\n\n    let mut map = HashMap::new();\n    let mut previous_index = None;\n\n    for index in self.indices() {\n        let entry = self.entries[index.index.get()].occupied_ref();\n        let next_index = entry.next;\n\n        let new_index = self.insert_new(entry.value.clone(), previous_index, next_index);\n\n        map.insert(index, new_index);\n        previous_index = Some(new_index);\n    }\n\n    self.vacant_head = None;\n\n    map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    if self.length == 0 {\n        return HashMap::new();\n    }\n\n    let mut map = HashMap::new();\n    let mut previous_index = self.head;\n    let mut index = self.head;\n\n    while let Some(index) = index {\n        let next_index = self.entries[index.get()].occupied_ref().next;\n        let index = self.remove_helper(previous_index, index.get(), next_index);\n        map.insert(index, index);\n        previous_index = Some(index);\n        index = next_index;\n    }\n\n    self.head = previous_index;\n    self.tail = previous_index;\n    self.vacant_head = None;\n\n    self.entries.truncate(self.length);\n\n    if self.entries.capacity() > minimum_capacity {\n        self.entries.shrink_to_fit();\n    }\n\n    map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    if minimum_capacity < self.len() {\n        panic!(\"minimum capacity must be greater than or equal to the current length\");\n    }\n\n    let mut map = HashMap::new();\n\n    let mut index = self.head;\n    while let Some(non_max_index) = index {\n        let index = Index::new(non_max_index.get(), self.generation);\n        map.insert(index, index);\n        index = self.entries[non_max_index.get()].occupied_ref().next;\n    }\n\n    self.entries.truncate(minimum_capacity);\n    self.entries.shrink_to_fit();\n\n    self.head = None;\n    self.tail = None;\n    self.vacant_head = None;\n\n    map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    if minimum_capacity < self.len() {\n        panic!(\"minimum capacity must be greater than or equal to length\");\n    }\n\n    let mut map = HashMap::new();\n\n    let mut previous_index = None;\n    let mut next_index = self.head;\n\n    while let Some(index) = next_index {\n        let entry = self.entries[index.get()].occupied_ref();\n        let next = entry.next;\n\n        if entry.generation != self.generation {\n            panic!(\"index has been invalidated\");\n        }\n\n        let new_index = self.insert_new(entry.value.clone(), previous_index, next);\n        map.insert(index, new_index);\n\n        previous_index = Some(new_index);\n        next_index = next;\n    }\n\n    self.vacant_head = previous_index;\n    self.head = self.tail;\n    self.tail = None;\n\n    self.entries.truncate(minimum_capacity);\n    self.entries.shrink_to_fit();\n\n    map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    if self.length() < minimum_capacity {\n        panic!(\"minimum capacity must be at least the current length\");\n    }\n\n    let mut map = HashMap::new();\n\n    if self.is_empty() {\n        return map;\n    }\n\n    let mut new_entries = Vec::with_capacity(minimum_capacity);\n    let mut new_generation = self.generation;\n\n    let mut current_index = self.head.unwrap();\n    let mut previous_index = None;\n\n    while let Some(index) = current_index {\n        let entry = self.entries[index.get()].occupied_ref();\n\n        if let Some(previous_index) = previous_index {\n            self.update_link(Some(previous_index), Some(index));\n        }\n\n        new_entries.push(Entry::Occupied(OccupiedEntry::new(\n            new_generation,\n            previous_index,\n            entry.next,\n            entry.value.clone(),\n        )));\n\n        map.insert(Index::new(index.get(), new_generation), index);\n\n        new_generation += 1;\n        previous_index = Some(index);\n        current_index = entry.next;\n    }\n\n    self.generation = new_generation;\n    self.entries = new_entries;\n    self.head = previous_index;\n    self.vacant_head = None;\n\n    map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    if self.length == 0 {\n        return HashMap::new();\n    }\n\n    if minimum_capacity < self.length {\n        panic!(\"minimum capacity must be greater than or equal to the current length\");\n    }\n\n    let mut map = HashMap::new();\n    let mut previous = None;\n    let mut index = self.head;\n    while let Some(current) = index {\n        let next = self.entries[current.get()].occupied_ref().next;\n        let index = Index::new(current, self.generation);\n        map.insert(index, index);\n        previous = Some(current);\n        index = next;\n    }\n\n    let mut index = self.tail;\n    while let Some(current) = index {\n        let previous = self.entries[current.get()].occupied_ref().previous;\n        let index = Index::new(current, self.generation);\n        map.insert(index, index);\n        index = previous;\n    }\n\n    self.entries.truncate(self.length);\n    self.head = None;\n    self.tail = None;\n    self.generation += 1;\n    self.vacant_head = None;\n\n    for (index, entry) in self.entries.iter_mut().enumerate() {\n        if let Entry::Occupied(entry) = entry {\n            entry.previous = previous;\n            entry.next = None;\n            previous = Some(NonMaxUsize::new(index).unwrap());\n        }\n    }\n\n    for (index, entry) in self.entries.iter_mut().enumerate() {\n        if let Entry::Occupied(entry) = entry {\n            entry.next = previous;\n            previous = Some(NonMaxUsize::new(index).unwrap());\n        }\n    }\n\n    self.head = previous;\n    self.tail = previous;\n    self.vacant_head = previous;\n\n    map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    if minimum_capacity < self.length {\n        panic!(\"minimum capacity is less than length\");\n    }\n\n    let mut map = HashMap::new();\n    let mut previous_index = None;\n\n    for index in self.indices() {\n        let value = self.remove(index).unwrap();\n        let new_index = self.push_back(value);\n\n        if let Some(previous_index) = previous_index {\n            map.insert(Index::new(previous_index, self.generation), previous_index);\n        }\n\n        map.insert(index, new_index);\n        previous_index = Some(new_index);\n    }\n\n    self.reserve(minimum_capacity);\n    map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    if self.capacity() < minimum_capacity {\n        panic!(\"new capacity must be at least the current length\");\n    }\n\n    let mut map = HashMap::new();\n    let mut index = self.head;\n    let mut new_index = None;\n\n    while let Some(index) = index {\n        let entry = self.entries[index.get()].occupied_ref();\n        let value = entry.value.clone();\n        let new_index = self.insert_new(value, None, new_index);\n        map.insert(Index::new(entry.generation, index.get()), new_index);\n        index = entry.next;\n    }\n\n    map\n}"
    ],
    [
      "pub fn pop_back (&mut self) -> Option<T> {\n    self.remove_entry(self.tail?).map(|entry| entry.value)\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    self.remove_entry(self.tail?).map(|entry| entry.value)\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    self.remove_entry(self.tail?).map(|entry| entry.value)\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    self.remove_entry(self.tail?).map(|entry| entry.value)\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    self.remove_entry(self.tail?).map(|entry| entry.value)\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    self.remove_entry(self.tail?).map(|entry| entry.value)\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    self.remove_entry(self.tail?).map(|entry| entry.value)\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    self.remove_entry(self.tail?).map(|entry| entry.value)\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    self.remove_entry(self.tail?).map(|entry| entry.value)\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    self.remove_entry(self.tail?).map(|entry| entry.value)\n}"
    ],
    [
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let tail_index = match self.tail {\n        Some(index) => index,\n        None => return self.insert_empty(value),\n    };\n    let index = self.insert_new(value, Some(tail_index), None);\n    self.entries[tail_index.get()].occupied_mut().next = Some(index);\n    self.tail = Some(index);\n    Index::new(index, self.generation)\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let tail_index = match self.tail {\n        Some(index) => index,\n        None => return self.insert_empty(value),\n    };\n    let index = self.insert_new(value, Some(tail_index), None);\n    self.entries[tail_index.get()].occupied_mut().next = Some(index);\n    self.tail = Some(index);\n    Index::new(index, self.generation)\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let tail_index = match self.tail {\n        Some(index) => index,\n        None => return self.insert_empty(value),\n    };\n    let index = self.insert_new(value, Some(tail_index), None);\n    self.entries[tail_index.get()].occupied_mut().next = Some(index);\n    self.tail = Some(index);\n    Index::new(index, self.generation)\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let tail_index = match self.tail {\n        Some(index) => index,\n        None => return self.insert_empty(value),\n    };\n    let index = self.insert_new(value, Some(tail_index), None);\n    self.entries[tail_index.get()].occupied_mut().next = Some(index);\n    self.tail = Some(index);\n    Index::new(index, self.generation)\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let tail_index = match self.tail {\n        Some(index) => index,\n        None => return self.insert_empty(value),\n    };\n    let index = self.insert_new(value, Some(tail_index), None);\n    self.entries[tail_index.get()].occupied_mut().next = Some(index);\n    self.tail = Some(index);\n    Index::new(index, self.generation)\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let tail_index = match self.tail {\n        Some(index) => index,\n        None => return self.insert_empty(value),\n    };\n    let index = self.insert_new(value, Some(tail_index), None);\n    self.entries[tail_index.get()].occupied_mut().next = Some(index);\n    self.tail = Some(index);\n    Index::new(index, self.generation)\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let tail_index = match self.tail {\n        Some(index) => index,\n        None => return self.insert_empty(value),\n    };\n    let index = self.insert_new(value, Some(tail_index), None);\n    self.entries[tail_index.get()].occupied_mut().next = Some(index);\n    self.tail = Some(index);\n    Index::new(index, self.generation)\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let tail_index = match self.tail {\n        Some(index) => index,\n        None => return self.insert_empty(value),\n    };\n    let index = self.insert_new(value, Some(tail_index), None);\n    self.entries[tail_index.get()].occupied_mut().next = Some(index);\n    self.tail = Some(index);\n    Index::new(index, self.generation)\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let tail_index = match self.tail {\n        Some(index) => index,\n        None => return self.insert_empty(value),\n    };\n    let index = self.insert_new(value, Some(tail_index), None);\n    self.entries[tail_index.get()].occupied_mut().next = Some(index);\n    self.tail = Some(index);\n    Index::new(index, self.generation)\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let tail_index = match self.tail {\n        Some(index) => index,\n        None => return self.insert_empty(value),\n    };\n    let index = self.insert_new(value, Some(tail_index), None);\n    self.entries[tail_index.get()].occupied_mut().next = Some(index);\n    self.tail = Some(index);\n    Index::new(index, self.generation)\n}"
    ],
    [
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut previous_index = None;\n    let mut index = self.head;\n    while let Some(index) = index {\n        let next_index = self.entries[index.get()].next;\n        let entry = &mut self.entries[index.get()];\n        if predicate(&mut entry.value) {\n            previous_index = Some(index);\n        } else {\n            self.remove_helper(previous_index, index, next_index);\n        }\n        index = next_index;\n    }\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut index = self.head;\n    while let Some(current_index) = index {\n        let next_index = self.entries[current_index.get()].next;\n        if !predicate(&mut self.entries[current_index.get()].value) {\n            self.remove_entry(current_index);\n        }\n        index = next_index;\n    }\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\nlet mut previous_index = None;\nlet mut index = self.head;\nwhile let Some(index) = index {\nlet next_index = self.entries[index.get()].next;\nif predicate(&mut self.entries[index.get()].value) {\nprevious_index = Some(index);\n} else {\nself.remove_helper(previous_index, index, next_index);\n}\nindex = next_index;\n}\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\nlet mut previous_index = self.head;\nwhile let Some(index) = previous_index {\nlet next_index = self.get_next_index(index);\nif predicate(&mut self.entries[index.get()].value) {\nprevious_index = next_index;\n} else {\nself.remove_entry(index);\n}\n}\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut previous_index = None;\n    let mut index = self.head;\n    while let Some(index) = index {\n        let next_index = self.entries[index.get()].next;\n        if predicate(&mut self.entries[index.get()].value) {\n            previous_index = Some(index);\n        } else {\n            self.remove_helper(previous_index, index, next_index);\n        }\n        index = next_index;\n    }\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut previous_index = None;\n    let mut index = self.head;\n    while let Some(index) = index {\n        let entry = &mut self.entries[index.get()];\n        if !predicate(&mut entry.value) {\n            let next_index = entry.next;\n            self.remove_helper(previous_index, index, next_index);\n            previous_index = next_index;\n        } else {\n            previous_index = Some(index);\n        }\n        index = entry.next;\n    }\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut previous_index = None;\n    let mut index = self.head;\n    while let Some(next_index) = index {\n        let next_index = next_index.get();\n        let entry = &mut self.entries[next_index];\n        if predicate(&mut entry.value) {\n            previous_index = Some(next_index);\n            index = entry.next;\n        } else {\n            self.remove_helper(previous_index, next_index, entry.next);\n            index = entry.next;\n        }\n    }\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\nlet mut previous_index = None;\nlet mut next_index = self.head;\nwhile let Some(index) = next_index {\nlet next_index = self.get_next_index(index);\nif !predicate(&mut self.entries[index.index()].value) {\nself.remove_helper(previous_index, index.index(), next_index);\n} else {\nprevious_index = Some(index);\n}\nnext_index = next_index;\n}\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut previous_index = None;\n    let mut next_index = self.head;\n    while let Some(index) = next_index {\n        let (next_next_index, entry) = match &mut self.entries[index.get()] {\n            Entry::Occupied(entry) => (entry.next, entry),\n            Entry::Vacant(_) => unreachable!(),\n        };\n        if predicate(&mut entry.value) {\n            if let Some(previous_index) = previous_index {\n                self.update_link(previous_index, Some(index));\n            } else {\n                self.head = Some(index);\n            }\n            previous_index = Some(index);\n        } else {\n            self.remove_helper(previous_index, index, next_next_index);\n        }\n        next_index = next_next_index;\n    }\n    if let Some(previous_index) = previous_index {\n        self.update_link(previous_index, None);\n    } else {\n        self.head = None;\n    }\n    self.length = self.entries.len();\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut index = self.head;\n    while let Some(index) = index {\n        let next_index = self.entries[index.get()].next;\n        if !predicate(&mut self.entries[index.get()].value) {\n            self.remove_entry(index);\n        }\n        index = next_index;\n    }\n}"
    ],
    [
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut last_free_sector = 0;\n    let mut last_used_sector = 0;\n    for (i, partition) in self.partitions.iter().enumerate() {\n        if partition.is_unused() {\n            if last_used_sector != 0 {\n                free_sectors.push((last_used_sector, last_free_sector - last_used_sector));\n            }\n            last_free_sector = partition.starting_lba;\n            last_used_sector = 0;\n        } else {\n            last_used_sector = partition.ending_lba + 1;\n        }\n    }\n    if last_used_sector != 0 {\n        free_sectors.push((last_used_sector, last_free_sector - last_used_sector));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut last_free_sector = self.header.first_usable_lba;\n    let mut last_free_sector_size = 0;\n    for partition in &self.partitions {\n        if last_free_sector < partition.starting_lba {\n            free_sectors.push((last_free_sector, last_free_sector_size));\n        }\n        last_free_sector = partition.ending_lba + 1;\n        last_free_sector_size = partition.ending_lba - last_free_sector + 1;\n    }\n    if last_free_sector < self.header.last_usable_lba {\n        free_sectors.push((last_free_sector, last_free_sector_size));\n    }\n    free_sectors\n        .into_iter()\n        .map(|(start, size)| (start, size / self.align * self.align))\n        .collect()\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut last_free_sector = 0;\n    let mut last_free_size = 0;\n    for partition in &self.partitions {\n        let range = partition.range().unwrap_or((0, 0));\n        let size = range.end - range.start;\n        if range.start > last_free_sector {\n            free_sectors.push((last_free_sector, last_free_size));\n        }\n        last_free_sector = range.end + size;\n        last_free_size = size;\n    }\n    if last_free_sector > self.header.first_usable_lba {\n        free_sectors.push((last_free_sector, last_free_size));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut last_lba = self.header.first_usable_lba;\n    for partition in self.partitions.iter() {\n        let start = partition.starting_lba;\n        let end = partition.ending_lba;\n        if start > last_lba {\n            free_sectors.push((last_lba, start - last_lba));\n        }\n        last_lba = end + 1;\n    }\n    if last_lba < self.header.last_usable_lba {\n        free_sectors.push((last_lba, self.header.last_usable_lba - last_lba + 1));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut last_lba = self.header.first_usable_lba;\n    for partition in &self.partitions {\n        let start = partition.starting_lba;\n        let end = partition.ending_lba;\n        if start > last_lba {\n            free_sectors.push((last_lba, start - last_lba));\n        }\n        last_lba = end + 1;\n    }\n    if last_lba < self.header.last_usable_lba {\n        free_sectors.push((last_lba, self.header.last_usable_lba - last_lba + 1));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut current_free_start = self.header.first_usable_lba;\n    let mut current_free_size = 0;\n    for partition in self.partitions.iter() {\n        if current_free_size > 0 {\n            if partition.starting_lba > current_free_start {\n                free_sectors.push((current_free_start, current_free_size));\n            }\n            current_free_start = partition.ending_lba + 1;\n            current_free_size = 0;\n        }\n        current_free_size = partition.ending_lba - current_free_start + 1;\n    }\n    if current_free_size > 0 {\n        free_sectors.push((current_free_start, current_free_size));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut last_free_sector = 0;\n    let mut last_free_size = 0;\n    for (i, partition) in self.partitions.iter().enumerate() {\n        if i == 0 {\n            last_free_sector = partition.starting_lba;\n            last_free_size = partition.starting_lba;\n            continue;\n        }\n        let current_free_sector = partition.starting_lba;\n        let current_free_size = current_free_sector - last_free_sector;\n        if current_free_size > 0 {\n            free_sectors.push((last_free_sector, current_free_size));\n        }\n        last_free_sector = current_free_sector;\n        last_free_size = current_free_size;\n    }\n    let current_free_sector = self.header.last_usable_lba + 1;\n    let current_free_size = current_free_sector - last_free_sector;\n    if current_free_size > 0 {\n        free_sectors.push((last_free_sector, current_free_size));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut last_lba = self.header.first_usable_lba;\n    for partition in &self.partitions {\n        let range = partition.range().unwrap_or(0..0);\n        let start = range.start;\n        let end = range.end;\n        if start > last_lba {\n            free_sectors.push((last_lba, start - last_lba));\n        }\n        last_lba = end + 1;\n    }\n    if last_lba < self.header.last_usable_lba {\n        free_sectors.push((last_lba, self.header.last_usable_lba - last_lba + 1));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut last_lba = self.header.first_usable_lba;\n    for partition in &self.partitions {\n        let partition_range = partition.range().unwrap();\n        let partition_size = partition_range.end - partition_range.start;\n        let partition_lba = partition_range.start;\n        if partition_lba > last_lba {\n            free_sectors.push((last_lba, partition_lba - last_lba));\n        }\n        last_lba = partition_range.end + partition_size;\n    }\n    if last_lba < self.header.last_usable_lba {\n        free_sectors.push((last_lba, self.header.last_usable_lba - last_lba));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut last_lba = self.header.first_usable_lba;\n    for partition in &self.partitions {\n        let partition_range = partition.range().unwrap();\n        let partition_size = partition_range.end - partition_range.start + 1;\n        if last_lba < partition_range.start {\n            free_sectors.push((last_lba, partition_range.start - last_lba));\n        }\n        last_lba = partition_range.end + 1;\n    }\n    if last_lba < self.header.last_usable_lba {\n        free_sectors.push((last_lba, self.header.last_usable_lba - last_lba + 1));\n    }\n    free_sectors\n}"
    ],
    [
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    let mut optimal_place = None;\n    let mut optimal_size = None;\n    for (start, size) in self.find_free_sectors() {\n        if size >= size && (optimal_size.is_none() || size < optimal_size.unwrap()) {\n            optimal_place = Some(start);\n            optimal_size = Some(size);\n        }\n    }\n    optimal_place\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    let mut optimal_place = None;\n    let mut optimal_size = 0;\n    for (start, end) in self.find_free_sectors() {\n        let size = end - start;\n        if size < optimal_size {\n            continue;\n        }\n        if size == optimal_size {\n            if start < optimal_place.unwrap() {\n                optimal_place = Some(start);\n            }\n            continue;\n        }\n        optimal_place = Some(start);\n        optimal_size = size;\n    }\n    optimal_place\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    self.find_free_sectors()\n        .into_iter()\n        .filter(|(_, s)| *s >= size)\n        .min_by_key(|(_, s)| *s)\n        .map(|(s, _)| s)\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    let mut optimal_place = None;\n    let mut optimal_size = None;\n    for (start, end) in self.find_free_sectors() {\n        let size = end - start;\n        if size >= size && (optimal_size.is_none() || size < optimal_size.unwrap()) {\n            optimal_place = Some(start);\n            optimal_size = Some(size);\n        }\n    }\n    optimal_place\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    self.find_free_sectors()\n        .into_iter()\n        .filter(|(_, size)| *size >= size)\n        .min_by_key(|(_, size)| *size)\n        .map(|(start, _)| start)\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    let mut optimal_place: Option<u64> = None;\n    let mut optimal_size: u64 = 0;\n    for (start, end) in self.find_free_sectors() {\n        let size = end - start;\n        if size < optimal_size {\n            continue;\n        }\n        if size > optimal_size {\n            optimal_size = size;\n            optimal_place = None;\n        }\n        if size == optimal_size {\n            optimal_place = Some(start);\n        }\n    }\n    optimal_place\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    let mut optimal_place: Option<u64> = None;\n    let mut optimal_size: u64 = u64::max_value();\n    let mut last_place: Option<u64> = None;\n    let mut last_size: u64 = u64::max_value();\n    let mut first_place: Option<u64> = None;\n    let mut first_size: u64 = u64::max_value();\n    for (start, end) in self.find_free_sectors() {\n        let size = end - start;\n        if size < optimal_size {\n            optimal_place = Some(start);\n            optimal_size = size;\n        }\n        if size < last_size {\n            last_place = Some(start);\n            last_size = size;\n        }\n        if size < first_size {\n            first_place = Some(start);\n            first_size = size;\n        }\n    }\n    if optimal_size < size {\n        return None;\n    }\n    if optimal_place.is_some() {\n        return optimal_place;\n    }\n    if last_place.is_some() {\n        return last_place;\n    }\n    if first_place.is_some() {\n        return first_place;\n    }\n    None\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    self.find_free_sectors()\n        .into_iter()\n        .filter(|(_, s)| *s >= size)\n        .min_by_key(|(_, s)| *s)\n        .map(|(l, _)| l)\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    self.find_free_sectors()\n        .into_iter()\n        .filter(|(_, s)| *s >= size)\n        .min_by_key(|(_, s)| *s)\n        .map(|(s, _)| s)\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    self.find_free_sectors()\n        .into_iter()\n        .filter(|(_, s)| *s >= size)\n        .min_by_key(|(_, s)| *s)\n        .map(|(l, _)| l)\n}"
    ],
    [
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let mut max = 0;\n    for (i, partition) in self.partitions.iter().enumerate() {\n        if partition.is_used() {\n            let mut size = partition.ending_lba - partition.starting_lba + 1;\n            if i == self.partitions.len() - 1 {\n                size = self.header.last_usable_lba - partition.starting_lba + 1;\n            }\n            if size > max {\n                max = size;\n            }\n        }\n    }\n    Ok(max)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let mut max = 0;\n    for (i, partition) in self.partitions.iter().enumerate() {\n        if partition.is_unused() {\n            let mut size = partition.ending_lba - partition.starting_lba + 1;\n            if size > max {\n                max = size;\n            }\n        }\n    }\n    let mut align = self.align;\n    if align == 0 {\n        align = 1;\n    }\n    let mut size = max / align * align;\n    if size < align {\n        size = align;\n    }\n    Ok(size)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let align = self.align;\n    let mut size = self.header.last_usable_lba + 1 - self.header.first_usable_lba;\n    if align > 0 {\n        size -= size % align;\n    }\n    Ok(size)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let mut last_lba = self.header.last_usable_lba;\n    let mut last_size = last_lba - self.header.first_usable_lba;\n    for (i, partition) in self.iter().enumerate() {\n        if i == 0 {\n            continue;\n        }\n        let size = partition.ending_lba - partition.starting_lba;\n        if size > last_size {\n            last_size = size;\n            last_lba = partition.starting_lba;\n        }\n    }\n    let align = self.align;\n    let mut size = last_lba - self.header.first_usable_lba;\n    if size % align != 0 {\n        size = (size / align + 1) * align;\n    }\n    Ok(size)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let mut max_size = self.header.last_usable_lba + 1 - self.header.first_usable_lba;\n    for partition in &self.partitions {\n        if partition.is_used() {\n            let size = partition.ending_lba + 1 - partition.starting_lba;\n            if size < max_size {\n                max_size = size;\n            }\n        }\n    }\n    if max_size < self.align {\n        return Err(Error::NoSpaceLeft);\n    }\n    Ok(max_size - max_size % self.align)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let mut max_size = self.header.last_usable_lba + 1 - self.header.first_usable_lba;\n    if self.align > 0 {\n        max_size -= self.align;\n    }\n    Ok(max_size)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let mut max_size = self.header.last_usable_lba - self.header.first_usable_lba;\n    let align = self.align;\n    if align > 0 {\n        max_size = max_size - max_size % align;\n    }\n    Ok(max_size)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let mut size = self.header.last_usable_lba + 1 - self.header.first_usable_lba;\n    size -= self.header.first_usable_lba;\n    size -= self.header.last_usable_lba;\n    size -= self.header.first_usable_lba;\n    size -= self.header.last_usable_lba;\n    size -= self.header.first_usable_lba;\n    size -= self.header.last_usable_lba;\n    size -= self.header.first_usable_lba;\n    size -= self.header.last_usable_lba;\n    size -= self.header.first_usable_lba;\n    size -= self.header.last_usable_lba;\n    size -= self.header.first_usable_lba;\n    size -= self.header.last_usable_lba;\n    size -= self.header.first_usable_lba;\n    size -= self.header.last_usable_lba;\n    size -= self.header.first_usable_lba;\n    size -= self.header.last_usable_lba;\n    size -= self.header.first_usable_lba;\n    size -= self.header.last_usable_lba;\n    size -= self.header.first_usable_lba;\n    size -= self.header.last_usable_lba;\n    size -= self.header.first_usable_lba;\n    size -= self.header.last_usable_lba;\n    size -= self.header.first_usable_lba;\n    size -= self.header.last_usable_lba;\n    size -= self.header.first_usable_lba;\n    size -= self.header.last_usable_lba;\n    size -= self.header.first_usable_lba;\n    size -= self.header.last_usable_lba;\n    size -= self.header.first_usable_lba;\n    size -= self.header.last_usable_lba;\n    size -= self.header.first_usable_lba;\n    size -= self.header.last_usable_lba;\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let mut max_size = self.header.last_usable_lba - self.header.first_usable_lba;\n    for partition in &self.partitions {\n        if partition.is_used() {\n            max_size = max_size.min(partition.starting_lba - self.header.first_usable_lba);\n        }\n    }\n    Ok(max_size)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let mut max_size = self.header.last_usable_lba - self.header.first_usable_lba;\n    for partition in &self.partitions {\n        if partition.is_unused() {\n            continue;\n        }\n        max_size = max_size.min(partition.starting_lba - self.header.first_usable_lba);\n    }\n    Ok(max_size)\n}"
    ],
    [
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let partition = &self.partitions[partition_number as usize - 1];\n    if partition.is_unused() {\n        return Err(Error::UnusedPartition);\n    }\n    let start = partition.starting_lba * self.sector_size;\n    let end = partition.ending_lba * self.sector_size;\n    if end < start {\n        return Err(Error::InvalidPartitionBoundaries);\n    }\n    Ok(start..=end)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let partition = &self[partition_number];\n    let starting_lba = partition.starting_lba;\n    let ending_lba = partition.ending_lba;\n    let sector_size = self.sector_size;\n    let first_usable_lba = self.header.first_usable_lba;\n    let last_usable_lba = self.header.last_usable_lba;\n    let first_byte = (first_usable_lba * sector_size) as u64;\n    let last_byte = (last_usable_lba * sector_size) as u64;\n    let starting_byte = (starting_lba * sector_size) as u64;\n    let ending_byte = (ending_lba * sector_size) as u64;\n    if starting_lba < first_usable_lba || ending_lba > last_usable_lba {\n        return Err(Error::InvalidPartitionBoundaries);\n    }\n    if ending_lba < starting_lba {\n        return Err(Error::InvalidPartitionBoundaries);\n    }\n    Ok(starting_byte..=ending_byte)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let entry = &self[partition_number];\n    if entry.is_unused() {\n        return Err(Error::UnusedPartition);\n    }\n\n    let start = entry.starting_lba * self.sector_size;\n    let end = entry.ending_lba * self.sector_size;\n\n    if end < start {\n        return Err(Error::InvalidPartitionBoundaries);\n    }\n\n    Ok(start..=end)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let partition = &self[partition_number];\n    let start_byte = partition.starting_lba * self.sector_size;\n    let end_byte = partition.ending_lba * self.sector_size;\n    Ok(start_byte..=end_byte)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let partition = &self.partitions[partition_number as usize];\n    if partition.is_unused() {\n        return Err(Error::UnusedPartition);\n    }\n    let starting_lba = partition.starting_lba;\n    let ending_lba = partition.ending_lba;\n    if ending_lba < starting_lba {\n        return Err(Error::InvalidPartitionBoundaries);\n    }\n    let starting_byte = self.sector_size * starting_lba;\n    let ending_byte = self.sector_size * ending_lba;\n    Ok(starting_byte..=ending_byte)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let partition = &self[partition_number];\n    let start = partition.starting_lba * self.sector_size;\n    let end = partition.ending_lba * self.sector_size;\n    Ok(start..=end)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let entry = &self[partition_number];\n    let start = entry.starting_lba * self.sector_size;\n    let end = entry.ending_lba * self.sector_size;\n    Ok(start..=end)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let entry = &self[partition_number];\n    let sector_size = self.sector_size as u64;\n    let start = entry.starting_lba * sector_size;\n    let end = entry.ending_lba * sector_size;\n    Ok(start..=end)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let partition = &self[partition_number];\n    let starting_byte = partition.starting_lba * self.sector_size;\n    let ending_byte = partition.ending_lba * self.sector_size;\n    Ok(starting_byte..=ending_byte)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let entry = &self[partition_number];\n    let range = entry.range()?;\n    Ok(range.start * self.sector_size..=range.end * self.sector_size)\n}"
    ],
    [
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}"
    ],
    [
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\nlet (m, n): (usize, usize) = self.dim();\ndebug_assert_eq!(m, n, \"Unable to calculate the trace of a non-square matrix\");\nlet mut tr: T = T::zero();\nfor i in 0..m {\ntr += self[[i, i]];\n}\ntr\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\ndebug_assert_eq!(self.m, self.n, \"Unable to calculate the trace of a non-square matrix\");\ndebug_assert_ne!(self.m, 0, \"Unable to calculate the trace of an empty matrix\");\nlet mut tr: T = T::zero();\nfor i in 0..self.m {\ntr += self[[i, i]];\n}\ntr\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\nlet (m, n): (usize, usize) = self.dim();\ndebug_assert_eq!(m, n, \"Unable to calculate the trace of a non-square matrix\");\ndebug_assert_ne!(m, 0, \"Unable to calculate the trace of an empty matrix\");\nlet mut tr: T = T::zero();\nfor i in 0..m\n{\ntr += self.data[i * m + i];\n}\ntr\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\nlet (m, n): (usize, usize) = self.dim();\ndebug_assert_eq!(m, n, \"Unable to calculate the trace of a non-square matrix\");\nlet mut tr: T = T::zero();\nfor i in 0..m {\ntr += self[[i, i]];\n}\ntr\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\nlet (m, n): (usize, usize) = self.dim();\ndebug_assert_eq!(m, n, \"Unable to calculate the trace of a non-square matrix\");\ndebug_assert_ne!(m, 0, \"Unable to calculate the trace of an empty matrix\");\nlet mut tr: T = T::zero();\nfor i in 0..m\n{\ntr += self.data[i * m + i];\n}\ntr\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\ndebug_assert_eq!(self.m, self.n, \"Unable to calculate the trace of a non-square matrix\");\nlet mut tr: T = T::zero();\nfor i in 0..self.m {\ntr = tr + self[[i, i]];\n}\ntr\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\nlet (m, n): (usize, usize) = self.dim();\ndebug_assert_eq!(m, n, \"Unable to calculate the trace of a non-square matrix\");\ndebug_assert_ne!(m, 0, \"Unable to calculate the trace of an empty matrix.\");\nlet mut tr: T = T::zero();\nfor i in 0..m {\ntr += self[[i, i]];\n}\ntr\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\nlet (m, n): (usize, usize) = self.dim();\ndebug_assert_eq!(m, n, \"Unable to calculate the trace of a non-square matrix\");\ndebug_assert_ne!(m, 0, \"Unable to calculate the trace of an empty matrix.\");\nlet mut tr: T = T::zero();\nfor i in 0..m {\ntr += self[(i, i)];\n}\ntr\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\ndebug_assert_eq!(self.m, self.n, \"Unable to calculate the trace of a non-square matrix\");\nlet mut tr: T = T::zero();\nfor i in 0..self.m {\ntr = tr + self[[i, i]];\n}\ntr\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\nlet (m, n): (usize, usize) = self.dim();\ndebug_assert_eq!(m, n, \"Unable to calculate the trace of a non-square matrix\");\ndebug_assert_ne!(m, 0, \"Unable to calculate the trace of an empty matrix.\");\nlet mut tr: T = T::zero();\nfor i in 0..m {\ntr += self[[i, i]];\n}\ntr\n}"
    ],
    [
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\nlet (m, n): (usize, usize) = self.dim();\ndebug_assert!(row_s < m);\ndebug_assert!(row_e < m);\ndebug_assert!(column_s < n);\ndebug_assert!(column_e < n);\ndebug_assert!(row_s <= row_e);\ndebug_assert!(column_s <= column_e);\n\nlet mut slice: General<T> = General::zero(row_e - row_s + 1, column_e - column_s + 1);\n\nfor r in row_s..(row_e + 1)\n{\nfor c in column_s..(column_e + 1)\n{\nslice[[r - row_s, c - column_s]] = self[[r, c]];\n}\n}\nslice\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\nlet mut slice: General<T> = General::zero(row_e - row_s + 1, column_e - column_s + 1);\n\nfor r in row_s..(row_e + 1) {\nfor c in column_s..(column_e + 1) {\nslice[[r - row_s, c - column_s]] = self[[r, c]];\n}\n}\nslice\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\nlet (m, n): (usize, usize) = self.dim();\ndebug_assert!(row_s < m);\ndebug_assert!(row_e < m);\ndebug_assert!(column_s < n);\ndebug_assert!(column_e < n);\ndebug_assert!(row_s <= row_e);\ndebug_assert!(column_s <= column_e);\nlet mut slice: General<T> = General::zero(row_e - row_s + 1, column_e - column_s + 1);\nfor r in row_s..(row_e + 1) {\nfor c in column_s..(column_e + 1) {\nslice[[r - row_s, c - column_s]] = self[[r, c]];\n}\n}\nslice\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\nlet (m, n): (usize, usize) = self.dim();\ndebug_assert!(row_s < m);\ndebug_assert!(row_e < m);\ndebug_assert!(column_s < n);\ndebug_assert!(column_e < n);\ndebug_assert!(row_s <= row_e);\ndebug_assert!(column_s <= column_e);\nlet mut slice: General<T> = General::zero(row_e - row_s + 1, column_e - column_s + 1);\nfor r in row_s..(row_e + 1)\n{\nfor c in column_s..(column_e + 1)\n{\nslice[[r - row_s, c - column_s]] = self[[r, c]];\n}\n}\nslice\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\nlet (m, n): (usize, usize) = self.dim();\ndebug_assert!(row_s < m);\ndebug_assert!(row_e < m);\ndebug_assert!(column_s < n);\ndebug_assert!(column_e < n);\ndebug_assert!(row_s <= row_e);\ndebug_assert!(column_s <= column_e);\n\nlet mut slice: General<T> = General::zero(row_e - row_s + 1, column_e - column_s + 1);\n\nfor r in row_s..(row_e + 1) {\nfor c in column_s..(column_e + 1) {\nslice[[r - row_s, c - column_s]] = self[[r, c]];\n}\n}\nslice\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\nlet (m, n): (usize, usize) = self.dim();\ndebug_assert!(row_s < m);\ndebug_assert!(row_e < m);\ndebug_assert!(column_s < n);\ndebug_assert!(column_e < n);\nlet mut slice: General<T> = General::zero(row_e - row_s + 1, column_e - column_s + 1);\n\nfor r in row_s..(row_e + 1)\n{\nfor c in column_s..(column_e + 1)\n{\nslice[[r - row_s, c - column_s]] = self[[r, c]];\n}\n}\nslice\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\nlet (m, n): (usize, usize) = self.dim();\ndebug_assert!(row_s < m);\ndebug_assert!(row_e < m);\ndebug_assert!(column_s < n);\ndebug_assert!(column_e < n);\ndebug_assert!(row_s <= row_e);\ndebug_assert!(column_s <= column_e);\n\nlet mut slice: General<T> = General::zero(row_e - row_s + 1, column_e - column_s + 1);\n\nfor r in row_s..(row_e + 1) {\nfor c in column_s..(column_e + 1) {\nslice[[r - row_s, c - column_s]] = self[[r, c]];\n}\n}\nslice\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\nlet mut slice: General<T> = General::zero(row_e - row_s + 1, column_e - column_s + 1);\n\nfor r in row_s..(row_e + 1) {\nfor c in column_s..(column_e + 1) {\nslice[[r - row_s, c - column_s]] = self[[r, c]];\n}\n}\nslice\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\nlet (m, n): (usize, usize) = self.dim();\ndebug_assert!(row_s < m);\ndebug_assert!(row_e < m);\ndebug_assert!(column_s < n);\ndebug_assert!(column_e < n);\nlet mut slice: General<T> = General::zero(row_e - row_s + 1, column_e - column_s + 1);\nfor r in row_s..(row_e + 1)\n{\nfor c in column_s..(column_e + 1)\n{\nslice[[r - row_s, c - column_s]] = self[[r, c]];\n}\n}\nslice\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\nlet (m, n): (usize, usize) = self.dim();\ndebug_assert!(row_s < m);\ndebug_assert!(row_e < m);\ndebug_assert!(column_s < n);\ndebug_assert!(column_e < n);\nlet mut slice: General<T> = General::zero(row_e - row_s + 1, column_e - column_s + 1);\nfor r in row_s..(row_e + 1)\n{\nfor c in column_s..(column_e + 1)\n{\nslice[[r - row_s, c - column_s]] = self[[r, c]];\n}\n}\nslice\n}"
    ],
    [
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    let (m, n): (usize, usize) = slice.dim();\n    debug_assert!(row + m <= self.m);\n    debug_assert!(column + n <= self.n);\n\n    for r in 0..m {\n        for c in 0..n {\n            self[[row + r, column + c]] = slice[[r, c]];\n        }\n    }\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    let (m, n): (usize, usize) = slice.dim();\n    debug_assert!(row + m <= self.m);\n    debug_assert!(column + n <= self.n);\n\n    for r in 0..m {\n        for c in 0..n {\n            self[[row + r, column + c]] = slice[[r, c]];\n        }\n    }\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    let (m, n): (usize, usize) = self.dim();\n    let (row_s, row_e, column_s, column_e): (usize, usize, usize, usize) = (row, row, column, column);\n    let (row_s, row_e, column_s, column_e): (usize, usize, usize, usize) = (row_s, row_e, column_s, column_e);\n    debug_assert!(row_s < m);\n    debug_assert!(row_e < m);\n    debug_assert!(column_s < n);\n    debug_assert!(column_e < n);\n\n    for r in row_s..(row_e + 1) {\n        for c in column_s..(column_e + 1) {\n            self[[r, c]] = slice[[r - row_s, c - column_s]];\n        }\n    }\n\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    let (m, n): (usize, usize) = self.dim();\n    let (slice_m, slice_n): (usize, usize) = slice.dim();\n    debug_assert!(row + slice_m <= m);\n    debug_assert!(column + slice_n <= n);\n\n    for r in 0..slice_m {\n        for c in 0..slice_n {\n            self[[row + r, column + c]] = slice[[r, c]];\n        }\n    }\n\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    let (m, n): (usize, usize) = self.dim();\n    let (m_slice, n_slice): (usize, usize) = slice.dim();\n    debug_assert!(row + m_slice <= m);\n    debug_assert!(column + n_slice <= n);\n\n    for r in 0..m_slice {\n        for c in 0..n_slice {\n            self[[row + r, column + c]] = slice[[r, c]];\n        }\n    }\n\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    let (m, n): (usize, usize) = slice.dim();\n    debug_assert!(row + m <= self.m);\n    debug_assert!(column + n <= self.n);\n\n    for r in 0..m {\n        for c in 0..n {\n            self[[row + r, column + c]] = slice[[r, c]];\n        }\n    }\n\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    let (m, n): (usize, usize) = self.dim();\n    debug_assert!(row < m);\n    debug_assert!(column < n);\n\n    for r in 0..slice.m {\n        for c in 0..slice.n {\n            self[[row + r, column + c]] = slice[[r, c]];\n        }\n    }\n\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    let (m, n): (usize, usize) = self.dim();\n    let (m_slice, n_slice): (usize, usize) = slice.dim();\n    debug_assert!(row + m_slice <= m);\n    debug_assert!(column + n_slice <= n);\n\n    for r in 0..m_slice {\n        for c in 0..n_slice {\n            self[[row + r, column + c]] = slice[[r, c]];\n        }\n    }\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    let (m, n): (usize, usize) = slice.dim();\n    debug_assert!(row + m <= self.m);\n    debug_assert!(column + n <= self.n);\n\n    for r in 0..m {\n        for c in 0..n {\n            self[[row + r, column + c]] = slice[[r, c]];\n        }\n    }\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    let (m, n): (usize, usize) = self.dim();\n    let (row_s, row_e, column_s, column_e): (usize, usize, usize, usize) = (row, row, column, column);\n    debug_assert!(row_s < m);\n    debug_assert!(row_e < m);\n    debug_assert!(column_s < n);\n    debug_assert!(column_e < n);\n    for r in row_s..(row_e + 1) {\n        for c in column_s..(column_e + 1) {\n            self[[r, c]] = slice[[r - row_s, c - column_s]];\n        }\n    }\n    self\n}"
    ],
    [
      "pub fn dotp (&self, rhs: &Self) -> T {\n    let (m, n) = self.dim();\n    let mut sum: T = T::zero();\n    for i in 0..m\n    {\n        sum = sum + self[i] * rhs[i];\n    }\n    sum\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    let (m, n) = self.dim();\n    debug_assert_eq!(m, rhs.dim());\n    let mut sum: T = T::zero();\n    for i in 0..m\n    {\n        sum = sum + self[i] * rhs[i];\n    }\n    sum\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    let (m, n) = self.dim();\n    debug_assert_eq!(m, rhs.dim());\n    let mut sum: T = T::zero();\n    for i in 0..m {\n        sum = sum + self[i] * rhs[i];\n    }\n    sum\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    let (m, n) = self.dim();\n    debug_assert_eq!(m, rhs.dim().0);\n    debug_assert_eq!(n, rhs.dim().1);\n    let mut res: T = T::zero();\n    for i in 0..m\n    {\n        res += self[i] * rhs[i];\n    }\n    res\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    let (m, n): (usize, usize) = self.dim();\n    debug_assert_eq!(m, rhs.dim().0);\n    debug_assert_eq!(n, rhs.dim().1);\n    let mut dotp: T = T::zero();\n    for i in 0..m {\n        dotp += self[i] * rhs[i];\n    }\n    dotp\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    let (m, n) = self.dim();\n    let mut sum: T = T::zero();\n    for idx in 0..m\n    {\n        sum += self[idx] * rhs[idx];\n    }\n    sum\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    let (m, n): (usize, usize) = self.dim();\n    debug_assert_eq!(m, rhs.dim().0);\n    debug_assert_eq!(n, rhs.dim().1);\n\n    let mut dotp: T = T::zero();\n    for i in 0..m\n    {\n        dotp += self[i] * rhs[i];\n    }\n\n    dotp\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    let (m, n): (usize, usize) = self.dim();\n    let mut sum: T = T::zero();\n\n    for idx in 0..m\n    {\n        sum = sum + self[idx] * rhs[idx];\n    }\n\n    sum\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    let (m, n): (usize, usize) = self.dim();\n    debug_assert_eq!(m, rhs.dim().0);\n    debug_assert_eq!(n, rhs.dim().1);\n    let mut sum: T = T::zero();\n    for i in 0..m {\n        sum = sum + self[i] * rhs[i];\n    }\n    sum\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    let (m, n): (usize, usize) = self.dim();\n    debug_assert_eq!(m, rhs.dim().0);\n    debug_assert_eq!(n, rhs.dim().1);\n\n    let mut dotp: T = T::zero();\n    for idx in 0..m\n    {\n        dotp += self[idx] * rhs[idx];\n    }\n\n    dotp\n}"
    ],
    [
      "pub fn argmax (&self) -> usize {\n    let (m, n) = self.dim();\n    let mut max_index: usize = 0;\n    let mut max: T = self[max_index];\n    let limit: usize = m.max(n);\n    debug_assert_ne!(limit, 0);\n    for idx in 0..limit\n    {\n        let element: T = self[idx];\n        if element > max\n        {\n            max_index = idx;\n            max = element;\n        }\n    }\n    max_index\n}",
      "pub fn argmax (&self) -> usize {\n    let (m, n) = self.dim();\n    let mut max_index: usize = 0;\n    let mut max: T = self[max_index];\n\n    let limit: usize = m.max(n);\n\n    debug_assert_ne!(limit, 0);\n\n    for idx in 0..limit {\n        let element: T = self[idx];\n        if element > max {\n            max_index = idx;\n            max = element;\n        }\n    }\n\n    max_index\n}",
      "pub fn argmax (&self) -> usize {\n    let (m, n) = self.dim();\n    let mut max_index: usize = 0;\n    let mut max: T = self[max_index];\n\n    let limit: usize = m.max(n);\n\n    debug_assert_ne!(limit, 0);\n\n    for idx in 0..limit {\n        let element: T = self[idx];\n        if element > max {\n            max_index = idx;\n            max = element;\n        }\n    }\n\n    max_index\n}",
      "pub fn argmax (&self) -> usize {\n    let (m, n) = self.dim();\n\n    let mut max_index: usize = 0;\n    let mut max: T = self[max_index];\n\n    let limit: usize = m.max(n);\n\n    debug_assert_ne!(limit, 0);\n\n    for idx in 0..limit {\n        let element: T = self[idx];\n        if element > max {\n            max_index = idx;\n            max = element;\n        }\n    }\n\n    max_index\n}",
      "pub fn argmax (&self) -> usize {\n    let (m, n) = self.dim();\n    let mut max_index: usize = 0;\n    let mut max: T = self[max_index];\n\n    let limit: usize = m.max(n);\n\n    debug_assert_ne!(limit, 0);\n\n    for idx in 0..limit {\n        let element: T = self[idx];\n        if element > max {\n            max_index = idx;\n            max = element;\n        }\n    }\n\n    max_index\n}",
      "pub fn argmax (&self) -> usize {\n    let (m, n) = self.dim();\n\n    let mut max_index: usize = 0;\n    let mut max: T = self[max_index];\n\n    let limit: usize = m.max(n);\n\n    debug_assert_ne!(limit, 0);\n\n    for idx in 0..limit {\n        let element: T = self[idx];\n        if element > max {\n            max_index = idx;\n            max = element;\n        }\n    }\n\n    max_index\n}",
      "pub fn argmax (&self) -> usize {\n    let (m, n) = self.dim();\n    let mut max_index: usize = 0;\n    let mut max: T = self[max_index];\n\n    let limit: usize = m.max(n);\n\n    debug_assert_ne!(limit, 0);\n\n    for idx in 0..limit\n    {\n        let element: T = self[idx];\n        if element > max\n        {\n            max_index = idx;\n            max = element;\n        }\n    }\n\n    max_index\n}",
      "pub fn argmax (&self) -> usize {\n    let (m, n) = self.dim();\n\n    let mut max_index: usize = 0;\n    let mut max: T = self[max_index];\n\n    let limit: usize = m.max(n);\n\n    debug_assert_ne!(limit, 0);\n\n    for idx in 0..limit {\n        let element: T = self[idx];\n        if element > max {\n            max_index = idx;\n            max = element;\n        }\n    }\n\n    max_index\n}",
      "pub fn argmax (&self) -> usize {\n    let (m, n) = self.dim();\n\n    let mut max_index: usize = 0;\n    let mut max: T = self[max_index];\n\n    let limit: usize = m.max(n);\n\n    debug_assert_ne!(limit, 0);\n\n    for idx in 0..limit\n    {\n        let element: T = self[idx];\n        if element > max\n        {\n            max_index = idx;\n            max = element;\n        }\n    }\n\n    max_index\n}",
      "pub fn argmax (&self) -> usize {\n    let (m, n) = self.dim();\n    let mut max_index: usize = 0;\n    let mut max: T = self[max_index];\n    let limit: usize = m.max(n);\n    debug_assert_ne!(limit, 0);\n    for idx in 0..limit {\n        let element: T = self[idx];\n        if element > max {\n            max_index = idx;\n            max = element;\n        }\n    }\n    max_index\n}"
    ],
    [
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    let (m, _n): (usize, usize) = self.dim();\n    debug_assert!(s <= e);\n    debug_assert!(e < m);\n    let mut slice: Vector<T> = Vector::new_column(vec![T::zero(); e - s + 1]);\n    for r in s..(e + 1)\n    {\n        slice[r - s] = self[r];\n    }\n    slice\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    let (m, _n): (usize, usize) = self.dim();\n    debug_assert!(s < m);\n    debug_assert!(e < m);\n    debug_assert!(s <= e);\n    let mut slice: Vector<T> = Vector::zero(e - s + 1);\n    for r in s..=(e) {\n        slice[r - s] = self[r];\n    }\n    slice\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    let (m, _n): (usize, usize) = self.dim();\n    debug_assert!(s <= e);\n    debug_assert!(e < m);\n    let mut slice: Vector<T> = Vector::zero(e - s + 1);\n    for r in s..(e + 1) {\n        slice[r - s] = self[r];\n    }\n    slice\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    let (m, _n): (usize, usize) = self.dim();\n    debug_assert!(s <= e);\n    debug_assert!(e < m);\n    let mut slice: Vector<T> = Vector::new_column(m - e);\n    for r in s..(e + 1)\n    {\n        slice[r - s] = self[r];\n    }\n    slice\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    let (m, _n): (usize, usize) = self.dim();\n    debug_assert!(s <= e);\n    debug_assert!(e < m);\n\n    let mut slice: Vector<T> = Vector::zero(e - s + 1);\n\n    for r in s..=(e) {\n        slice[r - s] = self[r];\n    }\n    slice\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    let (m, _n): (usize, usize) = self.dim();\n    debug_assert!(s < m);\n    debug_assert!(e < m);\n    debug_assert!(s <= e);\n\n    let mut slice: Vector<T> = Vector::new_column(vec![T::zero(); e - s + 1]);\n\n    for r in s..=(e) {\n        slice[r - s] = self[r];\n    }\n    slice\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    let (m, _n): (usize, usize) = self.dim();\n    debug_assert!(s <= e);\n    debug_assert!(e < m);\n    let mut v: Vector<T> = Vector::new_column(vec![T::zero(); e - s + 1]);\n    for r in s..(e + 1) {\n        v[r - s] = self[r];\n    }\n    v\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    let (m, _n): (usize, usize) = self.dim();\n    debug_assert!(s < m);\n    debug_assert!(e < m);\n    debug_assert!(s <= e);\n\n    let mut slice: Vector<T> = Vector::zero(e - s + 1);\n\n    for r in s..=(e) {\n        slice[r - s] = self[r];\n    }\n    slice\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    let (m, _n): (usize, usize) = self.dim();\n    debug_assert!(s < m);\n    debug_assert!(e < m);\n    debug_assert!(s <= e);\n\n    let mut slice: Vector<T> = Vector::new_column(vec![T::zero(); e - s + 1]);\n\n    for r in s..=(e) {\n        slice[r - s] = self[r];\n    }\n    slice\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    let (m, _n): (usize, usize) = self.dim();\n    debug_assert!(s <= e);\n    debug_assert!(e < m);\n\n    let mut slice: Vector<T> = Vector::zero(e - s + 1);\n\n    for r in s..=(e) {\n        slice[r - s] = self[r];\n    }\n    slice\n}"
    ],
    [
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, n): (usize, usize) = self.dim();\n    let (rhs_m, rhs_n): (usize, usize) = rhs.dim();\n    debug_assert!(s < m);\n    debug_assert!(rhs_m == rhs_n);\n    debug_assert!(rhs_m == n);\n\n    for r in s..(s + rhs_m) {\n        self[r] = rhs[r - s];\n    }\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, n): (usize, usize) = self.dim();\n    if m == 1 {\n        debug_assert!(s < n);\n    } else {\n        debug_assert!(s < m);\n    }\n\n    let (rhs_m, rhs_n): (usize, usize) = rhs.dim();\n    if rhs_m == 1 {\n        debug_assert!(rhs_n <= n - s);\n    } else {\n        debug_assert!(rhs_m <= m - s);\n    }\n\n    let mut slice: Vector<T> = Vector::zero(rhs_m);\n    for r in s..(s + rhs_m) {\n        slice[r - s] = rhs[r]\n    }\n\n    self.data = slice.data;\n}\n\nimpl<T> Display for Vector<T>\nwhere\n    T: Display,\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.data.fmt(f)\n    }\n}\n\nimpl<T> PartialEq<Self> for Vector<T>\nwhere\n    T: Scalar,",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, n): (usize, usize) = self.dim();\n    if m == 1 {\n        debug_assert!(s < n);\n    } else {\n        debug_assert!(s < m);\n    }\n\n    let mut slice: Vector<T> = rhs.get_slice(0, rhs.dim().1 - 1);\n\n    for r in s..(rhs.dim().1 + s) {\n        self[r] = slice[r - s]\n    }\n}\n\nimpl<T> PartialEq<Self> for Vector<T>\nwhere\n    T: Scalar,",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, n): (usize, usize) = self.dim();\n    if m == 1 {\n        debug_assert!(s < n);\n    } else {\n        debug_assert!(s < m);\n    }\n\n    let mut slice: Vector<T> = rhs.get_slice(0, rhs.dim().1 - 1);\n\n    for r in s..(s + rhs.dim().1) {\n        self[r] = slice[r - s]\n    }\n}\n\nimpl<T> PartialEq<Self> for Vector<T>\nwhere\n    T: Scalar,",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, n): (usize, usize) = self.dim();\n    if m == 1 {\n        debug_assert!(s < n);\n    } else {\n        debug_assert!(s < m);\n    }\n\n    let mut slice: Vector<T> = Vector::zero(rhs.dim().0);\n    for r in s..(s + rhs.dim().0) {\n        slice[r - s] = rhs[r]\n    }\n\n    self.data = slice.data;\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, n): (usize, usize) = self.dim();\n    if m == 1 {\n        debug_assert!(s < n);\n    } else {\n        debug_assert!(s < m);\n    }\n\n    let (rhs_m, rhs_n): (usize, usize) = rhs.dim();\n    if rhs_m == 1 {\n        debug_assert!(rhs_n <= n - s);\n    } else {\n        debug_assert!(rhs_m <= m - s);\n    }\n\n    let mut slice: Vector<T> = Vector::zero(rhs_m);\n    for r in s..(s + rhs_m) {\n        slice[r - s] = rhs[r];\n    }\n\n    self.data = slice.data;\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, n): (usize, usize) = self.dim();\n    if m == 1 {\n        debug_assert!(s < n);\n    } else {\n        debug_assert!(s < m);\n    }\n\n    let mut slice: Vector<T> = Vector::zero(rhs.dim().0);\n    for r in s..(s + rhs.dim().0) {\n        slice[r - s] = rhs[r]\n    }\n\n    self.data = slice.data;\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, n): (usize, usize) = self.dim();\n    let (rhs_m, rhs_n): (usize, usize) = rhs.dim();\n\n    if m == 1 {\n        debug_assert!(s < n);\n        debug_assert!(rhs_n <= n - s);\n    } else {\n        debug_assert!(s < m);\n        debug_assert!(rhs_m <= m - s);\n    }\n\n    for r in s..(s + rhs_m) {\n        self[r] = rhs[r - s];\n    }\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, n): (usize, usize) = self.dim();\n    let (rhs_m, rhs_n): (usize, usize) = rhs.dim();\n\n    if m == 1 {\n        debug_assert!(s < n);\n        debug_assert!(s + rhs_n <= n);\n    } else {\n        debug_assert!(s < m);\n        debug_assert!(s + rhs_m <= m);\n    }\n\n    for r in s..(s + rhs_m) {\n        for c in 0..rhs_n {\n            self[r][c] = rhs[r - s][c];\n        }\n    }\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, n): (usize, usize) = self.dim();\n    let (rhs_m, rhs_n): (usize, usize) = rhs.dim();\n\n    debug_assert!(s < m);\n    debug_assert!(rhs_m <= m);\n    debug_assert!(rhs_n <= n);\n\n    for r in s..(s + rhs_m) {\n        self[r] = rhs[r - s];\n    }\n}"
    ],
    [
      "fn abs (&self) -> Self {\n    let a: f64 = self.re.to_f64();\n    let b: f64 = self.im.to_f64();\n    let c: f64 = (a * a + b * b).sqrt();\n    Complex {\n        re: c,\n        im: 0.0,\n    }\n}",
      "fn abs (&self) -> Self {\n    Complex {\n        re: (self.re * self.re + self.im * self.im).sqrt(),\n        im: T::zero(),\n    }\n}",
      "fn abs (&self) -> Self {\n    Complex {\n        re: self.re.abs(),\n        im: self.im.abs(),\n    }\n}",
      "fn abs (&self) -> Self {\n    let abs: f64 = (self.re.pow(2) + self.im.pow(2)).sqrt();\n    Complex {\n        re: abs,\n        im: 0.0,\n    }\n}",
      "fn abs (&self) -> Self {\n    let a: f64 = self.re.to_f64().powf(2.0);\n    let b: f64 = self.im.to_f64().powf(2.0);\n    let c: f64 = (a + b).sqrt();\n    Complex::new(c, 0.0)\n}",
      "fn abs (&self) -> Self {\n    let a: Self = self.re.pow(2);\n    let b: Self = self.im.pow(2);\n    let c: Self = a + b;\n    let d: Self = c.sqrt();\n    d\n}",
      "fn abs (&self) -> Self {\n    let abs_re = self.re.abs();\n    let abs_im = self.im.abs();\n\n    if abs_re > abs_im\n    {\n        let re = abs_re.sqrt();\n        let im = abs_im / re;\n        Complex::new(re, im)\n    }\n    else\n    {\n        let im = abs_im.sqrt();\n        let re = abs_re / im;\n        Complex::new(re, im)\n    }\n}",
      "fn abs (&self) -> Self {\n    Complex {\n        re: (self.re * self.re + self.im * self.im).sqrt(),\n        im: T::zero(),\n    }\n}",
      "fn abs (&self) -> Self {\n    let re: T = self.re.powi(2);\n    let im: T = self.im.powi(2);\n    let sum: T = re + im;\n    let value: T = sum.sqrt();\n    Complex { re: value, im: T::zero() }\n}",
      "fn abs (&self) -> Self {\n    let re: T = self.re.abs();\n    let im: T = self.im.abs();\n    let max: T = re.max(im);\n    let min: T = re.min(im);\n    let res: T = max * (min / (max + min));\n    Complex { re: res, im: T::zero() }\n}"
    ],
    [
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty() {\n        panic!(\"The root is an empty vector\");\n    }\n\n    let n: usize = root.len();\n    let mut coef: Vec<T> = vec![T::zero(); n + 1];\n\n    coef[n] = T::one();\n\n    for i in 0..n {\n        for j in 0..n - i {\n            coef[j] = coef[j] - root[i + j] * coef[j + 1];\n        }\n    }\n\n    Polynomial { coef }\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\nif root.is_empty() {\npanic!(\"Root is an empty vector\");\n}\n\nlet mut coef: Vec<T> = vec![T::zero(); root.len() + 1];\n\nfor (i, r) in root.iter().enumerate() {\ncoef[i] = -r;\n}\n\ncoef[root.len()] = T::one();\n\nPolynomial { coef }\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty() {\n        panic!()\n    }\n    let mut coef: Vec<T> = vec![T::one(); root.len() + 1];\n    for i in 0..root.len() {\n        let mut factor: T = T::one();\n        for j in 0..root.len() {\n            if i != j {\n                factor = factor * (T::one() - root[i] * root[j]);\n            }\n        }\n        coef[i] = -factor;\n    }\n    Polynomial::from_coef(coef)\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty() {\n        panic!()\n    }\n\n    let n: usize = root.len();\n    let mut coef: Vec<T> = Vec::with_capacity(n + 1);\n\n    for i in 0..n {\n        let mut c: T = T::zero();\n        for j in 0..n {\n            if i == j {\n                continue;\n            }\n            c = c - root[j] * coef[i - j - 1];\n        }\n        coef.push(c);\n    }\n    coef.reverse();\n    Polynomial { coef }\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty() {\n        panic!(\"Root is an empty vector\");\n    }\n    let mut coef: Vec<T> = vec![T::zero(); root.len() + 1];\n    let mut k: usize = 0;\n    for r in root.iter() {\n        coef[k] = -r;\n        k += 1;\n    }\n    Polynomial { coef }\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty() {\n        panic!()\n    }\n    let n = root.len();\n    let mut coef: Vec<T> = vec![T::one(); n];\n    let mut k = n - 1;\n    for i in 0..n {\n        for j in 0..n {\n            if i != j {\n                coef[k] = -root[i] * root[j];\n                k -= 1;\n            }\n        }\n    }\n    Polynomial { coef }\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty() {\n        panic!(\"Root is an empty vector\");\n    }\n    let n = root.len();\n    let mut coef = vec![T::zero(); n + 1];\n    coef[n] = T::one();\n    for i in 0..n {\n        let mut c = T::one();\n        for j in 0..n {\n            if i != j {\n                c *= root[i] - root[j];\n            }\n        }\n        coef[n - i - 1] = c;\n    }\n    Polynomial { coef }\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty() {\n        panic!()\n    }\n\n    let mut coef: Vec<T> = Vec::with_capacity(root.len() + 1);\n\n    let mut n: usize = 0;\n    let mut p: usize = 0;\n\n    let mut sum: T = T::zero();\n\n    while n < root.len() {\n        sum = T::zero();\n\n        for i in 0..n {\n            sum = sum + (root[i] * coef[i]);\n        }\n\n        coef.push((-sum) / (T::from_f64(n as f64) + T::one()));\n\n        n = n + 1;\n    }\n\n    coef.reverse();\n\n    Polynomial { coef }\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty() {\n        panic!()\n    }\n    let n = root.len();\n    let mut coef: Vec<T> = Vec::with_capacity(n);\n    coef.push(T::one());\n    for i in 1..n {\n        let mut c: T = T::zero();\n        for j in 0..i {\n            c = c - root[j] * coef[i - j - 1];\n        }\n        coef.push(c);\n    }\n    Polynomial { coef }\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\nif root.is_empty() {\npanic!()\n}\nlet n = root.len();\nlet mut coef: Vec<T> = vec![T::one(); n];\n\nfor i in 0..n {\ncoef[i] = coef[i] * root[i];\n}\n\nfor i in 0..n {\nfor j in i+1..n {\ncoef[j] = coef[j] - root[i] * coef[j-1];\n}\n}\n\nPolynomial::from_coef(coef)\n}"
    ],
    [
      "pub fn eval (&self, x: T) -> T {\n    let mut res: T = T::zero();\n    for i in 0..self.coef.len() {\n        res += self.coef[i] * x.powi(i as i32);\n    }\n    res\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut result: T = T::zero();\n    for (i, c) in self.coef.iter().enumerate()\n    {\n        result += c * x.pow(i as u32);\n    }\n    result\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut result: T = T::zero();\n    for (i, c) in self.coef.iter().enumerate()\n    {\n        result += c * x.powi(i as i32);\n    }\n    result\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut result: T = T::zero();\n    for (i, c) in self.coef.iter().enumerate()\n    {\n        result += *c * x.pow(i as u32);\n    }\n    result\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut y: T = T::zero();\n    for (i, c) in self.coef.iter().enumerate()\n    {\n        y += c * x.powi(i as i32);\n    }\n    y\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut y: T = T::zero();\n    for (i, &c) in self.coef.iter().enumerate()\n    {\n        y += c * x.powi(i as i32);\n    }\n    y\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut res: T = T::zero();\n    for i in 0..self.coef.len() {\n        res += self.coef[i] * x.powi(i as i32);\n    }\n    res\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut result: T = T::zero();\n    for (i, coef) in self.coef.iter().enumerate()\n    {\n        result += coef * x.powi(i as i32);\n    }\n    result\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut res: T = T::zero();\n    for (i, c) in self.coef.iter().enumerate() {\n        res = res * x + c;\n    }\n    res\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut result: T = T::zero();\n    for (i, c) in self.coef.iter().enumerate()\n    {\n        result += c * x.pow(i as u32);\n    }\n    result\n}"
    ],
    [
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut coef_deriv = Vec::with_capacity(self.degree());\n    for i in 0..self.degree() {\n        coef_deriv.push(self.coef[i + 1] * (i as f64 + 1.0));\n    }\n    Polynomial { coef: coef_deriv }\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut coef_diff = Vec::with_capacity(self.degree());\n    for i in 0..self.degree() {\n        coef_diff.push(self.coef[i] * (self.degree() - i as u32));\n    }\n    Polynomial { coef: coef_diff }\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut coef_deriv = Vec::with_capacity(self.degree());\n    for i in 0..self.degree() {\n        coef_deriv.push(self.coef[i + 1] * (i + 1) as f64);\n    }\n    Polynomial { coef: coef_deriv }\n}",
      "pub fn differentiate (&self) -> Polynomial<T> where\n    T: Field + Scalar + AbsDiffEq<Epsilon = T>,\n{\n    let mut coef_diff = Vec::with_capacity(self.degree());\n    for i in 0..self.degree() {\n        coef_diff.push(self.coef[i] * (i as f64 + 1.0));\n    }\n\n    Polynomial { coef: coef_diff }\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut coef_der = Vec::with_capacity(self.degree());\n    for i in 0..self.degree() {\n        coef_der.push(self.coef[i] * (self.degree() - i) as f64);\n    }\n    Polynomial { coef: coef_der }\n}",
      "pub fn differentiate (&self) -> Polynomial<T> where\n    T: Field + Scalar + AbsDiffEq<Epsilon = T>,\n{\n    let mut coef_diff = Vec::with_capacity(self.degree());\n    for i in 0..self.degree() {\n        coef_diff.push(self.coef[i] * (i as f64 + 1) as T);\n    }\n    Polynomial { coef: coef_diff }\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut coef_diff = Vec::with_capacity(self.degree());\n    for i in 0..self.degree() {\n        coef_diff.push(self.coef[i] * (i as f64 + 1.0));\n    }\n    Polynomial { coef: coef_diff }\n}",
      "pub fn differentiate (&self) -> Polynomial<T> where\n    T: Field + Scalar + AbsDiffEq<Epsilon = T>,\n{\n    let mut coef_deriv = Vec::with_capacity(self.degree());\n    for i in 0..self.degree() {\n        coef_deriv.push(self.coef[i + 1] * (i + 1) as T);\n    }\n    Polynomial { coef: coef_deriv }\n}",
      "pub fn differentiate (&self) -> Polynomial<T> where\n    T: Field + Scalar + AbsDiffEq<Epsilon = T>,\n{\n    let mut coef_diff = Vec::with_capacity(self.degree());\n    for i in 1..self.degree() + 1 {\n        let c: T = self.coef[i];\n        let r: T = self.coef[i - 1];\n        coef_diff.push(c * (T::from_f64(i as f64)));\n    }\n    Polynomial { coef: coef_diff }\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut coef_diff = Vec::with_capacity(self.degree());\n    for i in 0..self.degree() {\n        coef_diff.push(self.coef[i] * (self.degree() - i) as f64);\n    }\n    Polynomial { coef: coef_diff }\n}"
    ],
    [
      "pub fn integrate (&self) -> Polynomial<T> where\n    T: Field + Scalar + AbsDiffEq<Epsilon = T>,\n{\n    let mut coef: Vec<T> = Vec::new();\n\n    for i in 0..self.coef.len() {\n        coef.push(self.coef[i] / (i as f64 + 1.0));\n    }\n\n    Polynomial { coef }\n}",
      "pub fn integrate (&self) -> Polynomial<T> where\n    T: Field + Scalar + AbsDiffEq<Epsilon = T>,\n{\n    let mut coef: Vec<T> = Vec::new();\n\n    for i in 0..self.coef.len() {\n        coef.push(self.coef[i] / (i as T + T::one()));\n    }\n\n    Polynomial { coef }\n}",
      "pub fn integrate (&self) -> Polynomial<T> where\n    T: Field + Scalar + AbsDiffEq<Epsilon = T>,\n{\n    let mut coef: Vec<T> = vec![T::zero(); self.coef.len() + 1];\n    coef[0] = T::one();\n    for i in 0..self.coef.len() {\n        coef[i + 1] = self.coef[i] / (i as f64 + 1.0);\n    }\n    Polynomial { coef }\n}",
      "pub fn integrate (&self) -> Polynomial<T> where\n    T: Field + Scalar + AbsDiffEq<Epsilon = T>,\n{\n    let mut coef: Vec<T> = Vec::with_capacity(self.coef.len() + 1);\n\n    for i in 0..self.coef.len() {\n        coef.push(self.coef[i] / (i as T + 1));\n    }\n\n    Polynomial { coef }\n}",
      "pub fn integrate (&self) -> Polynomial<T> where\n        T: Field + Scalar + AbsDiffEq<Epsilon = T>,\n{\n    let mut coef_int: Vec<T> = Vec::new();\n    for i in 0..self.coef.len() {\n        coef_int.push(self.coef[i] * (i as f64 + 1.0));\n    }\n    Polynomial { coef: coef_int }\n}",
      "pub fn integrate (&self) -> Polynomial<T> where\n    T: Field + Scalar + AbsDiffEq<Epsilon = T>,\n{\n    let mut coef: Vec<T> = Vec::new();\n\n    for i in 0..self.coef.len() {\n        coef.push(self.coef[i] / (i as T + 1));\n    }\n\n    Polynomial { coef }\n}",
      "pub fn integrate (&self) -> Polynomial<T> where\n    T: Field + Scalar + AbsDiffEq<Epsilon = T>,\n{\n    let mut coef: Vec<T> = Vec::new();\n\n    for i in 0..self.coef.len() {\n        coef.push(self.coef[i] / (i as f64 + 1.0));\n    }\n\n    Polynomial { coef }\n}",
      "pub fn integrate (&self) -> Polynomial<T> {\n    Polynomial {\n        coef: self.coef.clone().into_iter().enumerate().map(|(i, x)| x * (i as f64 + 1.0)).collect::<Vec<T>>(),\n    }\n}",
      "pub fn integrate (&self) -> Polynomial<T> where\n    T: Field + Scalar + AbsDiffEq<Epsilon = T>,\n{\n    let mut coef_int: Vec<T> = Vec::with_capacity(self.coef.len() + 1);\n    for i in 0..self.coef.len() {\n        coef_int.push(self.coef[i] / (i as f64 + 1.0));\n    }\n    Polynomial { coef: coef_int }\n}",
      "pub fn integrate (&self) -> Polynomial<T> where\n        T: Field + Scalar + AbsDiffEq<Epsilon = T>,\n{\n    let mut coef_int: Vec<T> = Vec::new();\n    let mut c: T = T::zero();\n    for i in 0..self.coef.len() {\n        c += self.coef[i] / (i as f64 + 1.0);\n        coef_int.push(c);\n    }\n    Polynomial { coef: coef_int }\n}"
    ],
    [
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    match self.elem_counts.entry(val) {\n        Entry::Occupied(mut entry) => {\n            let count = entry.get_mut();\n            *count += n;\n        }\n        Entry::Vacant(entry) => {\n            entry.insert(n);\n        }\n    }\n    self.size += n;\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    match self.elem_counts.entry(val) {\n        Entry::Occupied(mut entry) => {\n            *entry.get_mut() += n;\n        }\n        Entry::Vacant(entry) => {\n            entry.insert(n);\n        }\n    }\n    self.size += n;\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    match self.elem_counts.entry(val) {\n        Entry::Vacant(e) => {\n            e.insert(n);\n            self.size += n;\n        }\n        Entry::Occupied(mut e) => {\n            let count = e.get_mut();\n            *count += n;\n            self.size += n;\n        }\n    }\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    match self.elem_counts.entry(val) {\n        Entry::Occupied(mut entry) => {\n            let count = entry.get_mut();\n            *count += n;\n        }\n        Entry::Vacant(entry) => {\n            entry.insert(n);\n        }\n    }\n    self.size += n;\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    match self.elem_counts.entry(val) {\n        Entry::Vacant(entry) => {\n            entry.insert(n);\n            self.size += n;\n        }\n        Entry::Occupied(mut entry) => {\n            let count = entry.get_mut();\n            *count += n;\n            self.size += n;\n        }\n    }\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    match self.elem_counts.entry(val) {\n        Entry::Occupied(mut entry) => {\n            let count = entry.get_mut();\n            *count += n;\n        }\n        Entry::Vacant(entry) => {\n            entry.insert(n);\n        }\n    }\n    self.size += n;\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    match self.elem_counts.entry(val) {\n        Entry::Vacant(e) => {\n            e.insert(n);\n            self.size += n;\n        }\n        Entry::Occupied(mut e) => {\n            let count = e.get_mut();\n            *count += n;\n            self.size += n;\n        }\n    }\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    match self.elem_counts.entry(val) {\n        Entry::Occupied(mut entry) => {\n            let count = entry.get_mut();\n            *count += n;\n        }\n        Entry::Vacant(entry) => {\n            entry.insert(n);\n        }\n    }\n    self.size += n;\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    match self.elem_counts.entry(val) {\n        Entry::Vacant(e) => {\n            e.insert(n);\n            self.size += n;\n        }\n        Entry::Occupied(mut e) => {\n            let count = e.get_mut();\n            *count += n;\n            self.size += n;\n        }\n    }\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    match self.elem_counts.entry(val) {\n        Entry::Vacant(e) => {\n            e.insert(n);\n            self.size += n;\n        }\n        Entry::Occupied(mut e) => {\n            let count = e.get_mut();\n            *count += n;\n            self.size += n;\n        }\n    }\n}"
    ],
    [
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    let count = self.count_of(val);\n    if count < times {\n        return 0;\n    }\n    let removed = count - times;\n    self.size -= times;\n    match self.elem_counts.entry(val.clone()) {\n        Entry::Vacant(_) => {\n            panic!(\"The multiset is corrupted!\");\n        },\n        Entry::Occupied(mut view) => {\n            let v = view.get_mut();\n            if removed == 0 {\n                view.remove();\n            } else {\n                *v -= times;\n            }\n        },\n    }\n    removed\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    if times == 0 {\n        return 0;\n    }\n    let count = self.count_of(val);\n    if count == 0 {\n        return 0;\n    }\n    let mut removed = 0;\n    if times >= count {\n        removed = count;\n        self.remove_all(val);\n    } else {\n        removed = times;\n        let mut entry = self.elem_counts.entry(val.clone()).or_insert(0);\n        *entry -= times;\n        if *entry == 0 {\n            self.elem_counts.remove(val);\n        }\n    }\n    self.size -= removed;\n    removed\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    match self.elem_counts.entry(val.clone()) {\n        Entry::Vacant(_) => 0,\n        Entry::Occupied(mut view) => {\n            let count = view.get_mut();\n            let removed = if *count < times {\n                *count\n            } else {\n                times\n            };\n            *count -= removed;\n            self.size -= removed;\n            removed\n        }\n    }\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    match self.elem_counts.entry(val.clone()) {\n        Entry::Vacant(_) => 0,\n        Entry::Occupied(mut view) => {\n            let count = view.get_mut();\n            let removed = if times >= *count {\n                *count\n            } else {\n                *count - times\n            };\n            *count -= removed;\n            self.size -= removed;\n            removed\n        }\n    }\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    let count = self.count_of(val);\n    if count < times {\n        return 0;\n    }\n    self.size -= times;\n    match self.elem_counts.entry(val.clone()) {\n        Entry::Vacant(_) => panic!(\"Attempted to remove nonexistent element\"),\n        Entry::Occupied(mut view) => {\n            let v = view.get_mut();\n            *v -= times;\n            if *v == 0 {\n                view.remove();\n            }\n        }\n    }\n    times\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    match self.elem_counts.entry(val.clone()) {\n        hash_map::Entry::Vacant(_) => 0,\n        hash_map::Entry::Occupied(mut view) => {\n            let count = *view.get();\n            if count > times {\n                *view.get_mut() -= times;\n                self.size -= times;\n                times\n            } else {\n                self.size -= count;\n                view.remove();\n                count\n            }\n        }\n    }\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    let count = self.count_of(val);\n    if count < times {\n        return 0;\n    }\n    self.size -= times;\n    match self.elem_counts.entry(val.clone()) {\n        Entry::Vacant(_) => {\n            unreachable!();\n        },\n        Entry::Occupied(mut view) => {\n            let v = view.get_mut();\n            *v -= times;\n            if *v == 0 {\n                view.remove();\n            }\n        },\n    }\n    times\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    if times == 0 {\n        return 0;\n    }\n    match self.elem_counts.entry(val.clone()) {\n        Entry::Vacant(_) => 0,\n        Entry::Occupied(mut view) => {\n            let v = view.get_mut();\n            let n = *v;\n            if n > times {\n                *v -= times;\n                self.size -= times;\n                times\n            } else {\n                self.size -= n;\n                view.remove();\n                n\n            }\n        }\n    }\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    if times == 0 {\n        return 0;\n    }\n    match self.elem_counts.entry(val.clone()) {\n        Entry::Vacant(_) => 0,\n        Entry::Occupied(mut view) => {\n            let count = *view.get();\n            if count > times {\n                *view.get_mut() -= times;\n                self.size -= times;\n                times\n            } else {\n                self.size -= count;\n                view.remove();\n                count\n            }\n        }\n    }\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    let count = self.elem_counts.get(val).unwrap_or(&0);\n    if times <= *count {\n        self.size -= times;\n        self.elem_counts.insert(val, count - times);\n        times\n    } else {\n        self.remove(val);\n        *count\n    }\n}"
    ],
    [
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret = self.clone();\n    for val in rhs.distinct_elements() {\n        let count = rhs.count_of(val);\n        ret.insert_times(val, count);\n    }\n    ret\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret = self.clone();\n    for val in rhs.distinct_elements() {\n        let count = rhs.count_of(val);\n        ret.insert_times(val, count);\n    }\n    ret\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret = self.clone();\n    for val in rhs.distinct_elements() {\n        let count = rhs.count_of(val);\n        ret.insert_times(val, count);\n    }\n    ret\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret = self.clone();\n    for val in rhs.distinct_elements() {\n        let count = rhs.count_of(val);\n        ret.insert_times(val, count);\n    }\n    ret\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret = self.clone();\n    for val in rhs.distinct_elements() {\n        let count = rhs.count_of(val);\n        ret.insert_times(val, count);\n    }\n    ret\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret = self.clone();\n    for val in rhs.distinct_elements() {\n        let count = rhs.count_of(val);\n        ret.insert_times(val.clone(), count);\n    }\n    ret\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret = self.clone();\n    for val in rhs.distinct_elements() {\n        let count = rhs.count_of(val);\n        ret.insert_times(val, count);\n    }\n    ret\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret = self.clone();\n    for val in rhs.distinct_elements() {\n        let count = rhs.count_of(val);\n        ret.insert_times(val.clone(), count);\n    }\n    ret\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret = self.clone();\n    for val in rhs.distinct_elements() {\n        let count = rhs.count_of(val);\n        ret.insert_times(val, count);\n    }\n    ret\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret = self.clone();\n    for val in rhs.distinct_elements() {\n        let count = rhs.count_of(val);\n        ret.insert_times(val.clone(), count);\n    }\n    ret\n}"
    ],
    [
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        let rhs_count = rhs.count_of(val);\n        let count = count.saturating_sub(rhs_count);\n        ret.insert_times((*val).clone(), count);\n    }\n    ret\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        let rhs_count = rhs.count_of(val);\n        if count > rhs_count {\n            ret.insert_times((*val).clone(), count - rhs_count);\n        }\n    }\n    ret\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        let remove = rhs.count_of(val);\n        if count > remove {\n            ret.insert_times((*val).clone(), count - remove);\n        }\n    }\n    ret\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        let rhs_count = rhs.count_of(val);\n        if count > rhs_count {\n            ret.insert_times((*val).clone(), count - rhs_count);\n        }\n    }\n    ret\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        if count > rhs.count_of(val) {\n            ret.insert_times((*val).clone(), count - rhs.count_of(val));\n        }\n    }\n    ret\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        if count > rhs.count_of(val) {\n            ret.insert_times((*val).clone(), count - rhs.count_of(val));\n        }\n    }\n    ret\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        if count > rhs.count_of(val) {\n            ret.insert_times((*val).clone(), count - rhs.count_of(val));\n        }\n    }\n    ret\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        if count > rhs.count_of(val) {\n            ret.insert_times((*val).clone(), count - rhs.count_of(val));\n        }\n    }\n    ret\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        let mut remove = 0;\n        if let Some(rhs_count) = rhs.count_of(val) {\n            remove = if count > rhs_count { rhs_count } else { count };\n        }\n        ret.insert_times((*val).clone(), count - remove);\n    }\n    ret\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        let rhs_count = rhs.count_of(val);\n        if count > rhs_count {\n            ret.insert_times((*val).clone(), count - rhs_count);\n        }\n    }\n    ret\n}"
    ],
    [
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(b) => Cow::Borrowed(RawStr::new(b)),\n        Cow::Owned(b) => Cow::Owned(RawStr::new(b).into_string()),\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(b) => Cow::Borrowed(RawStr::new(b)),\n        Cow::Owned(b) => Cow::Owned(RawStr::new(b)),\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(b) => Cow::Borrowed(RawStr::new(b)),\n        Cow::Owned(b) => Cow::Owned(RawStr::new(b)),\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(b) => Cow::Borrowed(RawStr::new(b)),\n        Cow::Owned(b) => Cow::Owned(RawStr::new(b)),\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(b) => Cow::Borrowed(RawStr::new(b)),\n        Cow::Owned(b) => Cow::Owned(RawStr::new(b)),\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(b) => Cow::Borrowed(RawStr::new(b)),\n        Cow::Owned(b) => Cow::Owned(RawStr::new(b)),\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(b) => Cow::Borrowed(RawStr::new(b)),\n        Cow::Owned(b) => Cow::Owned(RawStr::new(b)),\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(b) => Cow::Borrowed(RawStr::new(b)),\n        Cow::Owned(b) => Cow::Owned(RawStr::new(b)),\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(b) => Cow::Borrowed(RawStr::new(b)),\n        Cow::Owned(b) => Cow::Owned(RawStr::new(b)),\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(b) => Cow::Borrowed(RawStr::new(b)),\n        Cow::Owned(b) => Cow::Owned(RawStr::new(b)),\n    }\n}"
    ],
    [
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let string = self.as_str();\n    let mut escaped = String::with_capacity(string.len());\n    for c in string.chars() {\n        match c {\n            '<' => escaped.push_str(\"&lt;\"),\n            '>' => escaped.push_str(\"&gt;\"),\n            '&' => escaped.push_str(\"&amp;\"),\n            '\"' => escaped.push_str(\"&quot;\"),\n            '\\'' => escaped.push_str(\"&#x27;\"),\n            '/' => escaped.push_str(\"&#x2F;\"),\n            '`' => escaped.push_str(\"&#x60;\"),\n            c => escaped.push(c),\n        }\n    }\n    Cow::Owned(escaped)\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let string = self.as_str();\n    let mut escaped = String::with_capacity(string.len());\n    for c in string.chars() {\n        match c {\n            '&' => escaped.push_str(\"&amp;\"),\n            '<' => escaped.push_str(\"&lt;\"),\n            '>' => escaped.push_str(\"&gt;\"),\n            '\"' => escaped.push_str(\"&quot;\"),\n            '\\'' => escaped.push_str(\"&#x27;\"),\n            '/' => escaped.push_str(\"&#x2F;\"),\n            '`' => escaped.push_str(\"&#x60;\"),\n            _ => escaped.push(c),\n        }\n    }\n    escaped.into()\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let mut escaped = String::new();\n    for c in self.as_str().chars() {\n        match c {\n            '&' => escaped.push_str(\"&amp;\"),\n            '<' => escaped.push_str(\"&lt;\"),\n            '>' => escaped.push_str(\"&gt;\"),\n            '\"' => escaped.push_str(\"&quot;\"),\n            '\\'' => escaped.push_str(\"&#x27;\"),\n            '/' => escaped.push_str(\"&#x2F;\"),\n            '`' => escaped.push_str(\"&#x60;\"),\n            _ => escaped.push(c),\n        }\n    }\n    escaped.into()\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let mut escaped = String::new();\n    for c in self.as_str().chars() {\n        match c {\n            '&' => escaped.push_str(\"&amp;\"),\n            '<' => escaped.push_str(\"&lt;\"),\n            '>' => escaped.push_str(\"&gt;\"),\n            '\"' => escaped.push_str(\"&quot;\"),\n            '\\'' => escaped.push_str(\"&#x27;\"),\n            '/' => escaped.push_str(\"&#x2F;\"),\n            '`' => escaped.push_str(\"&#x60;\"),\n            _ => escaped.push(c),\n        }\n    }\n    escaped.into()\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let string = self.as_str();\n    let mut escaped = String::with_capacity(string.len());\n    for c in string.chars() {\n        match c {\n            '&' => escaped.push_str(\"&amp;\"),\n            '<' => escaped.push_str(\"&lt;\"),\n            '>' => escaped.push_str(\"&gt;\"),\n            '\"' => escaped.push_str(\"&quot;\"),\n            '\\'' => escaped.push_str(\"&#x27;\"),\n            '/' => escaped.push_str(\"&#x2F;\"),\n            '`' => escaped.push_str(\"&#x60;\"),\n            _ => escaped.push(c),\n        }\n    }\n    escaped.into()\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let string = self.as_str();\n    let mut result = String::with_capacity(string.len());\n    for c in string.chars() {\n        match c {\n            '<' => result.push_str(\"&lt;\"),\n            '>' => result.push_str(\"&gt;\"),\n            '\"' => result.push_str(\"&quot;\"),\n            '\\'' => result.push_str(\"&#x27;\"),\n            '/' => result.push_str(\"&#x2F;\"),\n            '`' => result.push_str(\"&#x60;\"),\n            '&' => result.push_str(\"&amp;\"),\n            c => result.push(c),\n        }\n    }\n    Cow::Owned(result)\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let mut string = self.as_str().to_owned();\n    string.replace_range(0..1, \"&\");\n    string.replace_range(1..2, \"<\");\n    string.replace_range(2..3, \">\");\n    string.replace_range(3..4, \"\\\"\");\n    string.replace_range(4..5, \"'\");\n    string.replace_range(5..6, \"/\");\n    string.replace_range(6..7, \"<\");\n    string.replace_range(7..8, \">\");\n    string.replace_range(8..9, \"\\\"\");\n    string.replace_range(9..10, \"'\");\n    string.replace_range(10..11, \"/\");\n    string.replace_range(11..12, \"<\");\n    string.replace_range(12..13, \">\");\n    string.replace_range(13..14, \"\\\"\");\n    string.replace_range(14..15, \"'\");\n    string.replace_range(15..16, \"/\");\n    string.replace_range(16..17, \"<\");\n    string.replace_range(17..18, \">\");\n    string.replace_range(18..19, \"\\\"\");\n    string.replace_range(19..20, \"'\");\n    string.replace_range(20..21, \"/\");\n    string.replace_range(21..22, \"<\");\n    string.replace_range(22..23, \">\");\n    string.replace_range(23..24, \"\\\"\");\n    string.replace_range(24..25, \"'\");\n    string.replace_range(25..26, \"/\");\n    string.replace_range(26..27, \"<\");\n    string.replace_range(27..28, \">\");\n    string.replace_range(28..29, \"\\\"\");\n    string.replace_range(29..30, \"'\");\n    string.replace_range(30..31, \"/\");\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let string = self.as_str();\n    let mut escaped = String::with_capacity(string.len());\n    for c in string.chars() {\n        match c {\n            '<' => escaped.push_str(\"&lt;\"),\n            '>' => escaped.push_str(\"&gt;\"),\n            '&' => escaped.push_str(\"&amp;\"),\n            '\"' => escaped.push_str(\"&quot;\"),\n            '\\'' => escaped.push_str(\"&#x27;\"),\n            '/' => escaped.push_str(\"&#x2F;\"),\n            '`' => escaped.push_str(\"&#x60;\"),\n            _ => escaped.push(c),\n        }\n    }\n    escaped.into()\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let string = self.as_str();\n    let mut escaped = String::with_capacity(string.len());\n    for c in string.chars() {\n        match c {\n            '<' => escaped.push_str(\"&lt;\"),\n            '>' => escaped.push_str(\"&gt;\"),\n            '&' => escaped.push_str(\"&amp;\"),\n            '\"' => escaped.push_str(\"&quot;\"),\n            '\\'' => escaped.push_str(\"&#x27;\"),\n            '/' => escaped.push_str(\"&#x2F;\"),\n            '`' => escaped.push_str(\"&#x60;\"),\n            _ => escaped.push(c),\n        }\n    }\n    escaped.into()\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let string = self.as_str();\n    let mut escaped = String::with_capacity(string.len());\n    for c in string.chars() {\n        match c {\n            '<' => escaped.push_str(\"&lt;\"),\n            '>' => escaped.push_str(\"&gt;\"),\n            '&' => escaped.push_str(\"&amp;\"),\n            '\"' => escaped.push_str(\"&quot;\"),\n            '\\'' => escaped.push_str(\"&#x27;\"),\n            '/' => escaped.push_str(\"&#x2F;\"),\n            '`' => escaped.push_str(\"&#x60;\"),\n            _ => escaped.push(c),\n        }\n    }\n    Cow::Owned(escaped)\n}"
    ],
    [
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let bytes = self.as_bytes();\n    let mut i = 0;\n    while i < bytes.len() && bytes[i] != b {\n        i += 1;\n    }\n    if i == bytes.len() {\n        (self, RawStr::new(\"\"))\n    } else {\n        (RawStr::new(&bytes[0..i]), RawStr::new(&bytes[i+1..]))\n    }\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    if let Some(i) = self.as_bytes().iter().position(|&c| c == b) {\n        (&self[..i], &self[i+1..])\n    } else {\n        (self, &self[..0])\n    }\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    if let Some(i) = self.as_bytes().iter().position(|&x| x == b) {\n        let before = RawStr::new(&self.as_bytes()[..i]);\n        let after = RawStr::new(&self.as_bytes()[i + 1..]);\n        (before, after)\n    } else {\n        (self, RawStr::new(\"\"))\n    }\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let bytes = self.as_bytes();\n    let mut i = 0;\n    while i < bytes.len() {\n        if bytes[i] == b {\n            break;\n        }\n        i += 1;\n    }\n    (&self[..i], &self[i + 1..])\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    if b > 127 {\n        return (self, RawStr::new(\"\"));\n    }\n\n    let mut iter = self.as_str().bytes();\n    let mut i = 0;\n    let mut j = 0;\n    while let Some(c) = iter.next() {\n        if c == b {\n            break;\n        }\n\n        i += 1;\n        j += 1;\n    }\n\n    (RawStr::new(&self.as_str()[..i]), RawStr::new(&self.as_str()[i + 1..]))\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let bytes = self.as_bytes();\n    let mut i = 0;\n    while i < bytes.len() {\n        if bytes[i] == b {\n            return (&self[..i], &self[i + 1..]);\n        }\n        i += 1;\n    }\n    (self, &self[self.len()..])\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let mut iter = self.as_str().bytes();\n    let mut before = String::new();\n    let mut after = String::new();\n    while let Some(c) = iter.next() {\n        if c == b {\n            after = String::from_utf8(iter.collect()).unwrap();\n            break;\n        }\n        before.push(c as char);\n    }\n    (RawStr::new(&before), RawStr::new(&after))\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let mut iter = self.as_str().bytes();\n    let mut before = \"\";\n    let mut after = \"\";\n    while let Some(c) = iter.next() {\n        if c == b {\n            after = iter.as_str();\n            break;\n        }\n        before = before.push(c as char);\n    }\n    (RawStr::new(before), RawStr::new(after))\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let bytes = self.as_bytes();\n    let mut i = 0;\n    while i < bytes.len() {\n        if bytes[i] == b {\n            return (&self[..i], &self[i+1..]);\n        }\n        i += 1;\n    }\n    (self, RawStr::new(\"\"))\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let bytes = self.as_bytes();\n    let mut i = 0;\n    while i < bytes.len() {\n        if bytes[i] == b {\n            return (RawStr::new(&bytes[..i]), RawStr::new(&bytes[i + 1..]));\n        }\n        i += 1;\n    }\n    (self, RawStr::new(\"\"))\n}"
    ],
    [
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Get | Method::Head | Method::Connect | Method::Trace | Method::Options => false,\n        Method::Put | Method::Post | Method::Delete | Method::Patch => true,\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Get | Method::Head | Method::Connect | Method::Trace | Method::Options => false,\n        Method::Put | Method::Post | Method::Delete | Method::Patch => true\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Get | Method::Head | Method::Connect | Method::Trace | Method::Options => false,\n        Method::Put | Method::Post | Method::Delete | Method::Patch => true\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Get | Method::Head | Method::Connect | Method::Trace | Method::Options => false,\n        Method::Put | Method::Post | Method::Delete | Method::Patch => true\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Get | Method::Head | Method::Connect | Method::Trace | Method::Options => false,\n        _ => true\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Get | Method::Head | Method::Connect | Method::Trace | Method::Options => false,\n        _ => true,\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Get | Method::Head | Method::Connect | Method::Trace | Method::Options => false,\n        Method::Put | Method::Post | Method::Delete | Method::Patch => true,\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Get | Method::Head | Method::Connect | Method::Trace | Method::Options => false,\n        Method::Put | Method::Post | Method::Delete | Method::Patch => true,\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Get | Method::Head | Method::Connect | Method::Trace | Method::Options => false,\n        _ => true,\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Get | Method::Head | Method::Connect | Method::Trace | Method::Options => false,\n        _ => true\n    }\n}"
    ],
    [
      "pub const fn is_valid_name (name: &str) -> bool {\n    if name.is_empty() {\n        return false;\n    }\n\n    for c in name.chars() {\n        match c {\n            '!' | '#' | '$' | '%' | '&' | '\\'' | '*' | '+' | '-' | '.' | '^' | '_' | '`' | '|' | '~' |\n            '0'..='9' | 'A'..='Z' | 'a'..='z' => (),\n            _ => return false,\n        }\n    }\n\n    true\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    name.chars().all(|c| {\n        c == '!' || c == '#' || c == '$' || c == '%' || c == '&' || c == '\\'' || c == '*' ||\n        c == '+' || c == '-' || c == '.' || c == '^' || c == '_' || c == '`' || c == '|' ||\n        c == '~' || c.is_digit(10) || c.is_alphabetic()\n    })\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    if name.is_empty() {\n        return false;\n    }\n\n    let mut chars = name.chars();\n    let first = chars.next().unwrap();\n    if !first.is_ascii_alphanumeric() && first != '!' && first != '#' && first != '$' && first != '%' && first != '&' && first != '\\'' && first != '*' && first != '+' && first != '-' && first != '.' && first != '^' && first != '_' && first != '`' && first != '|' && first != '~' {\n        return false;\n    }\n\n    for c in chars {\n        if !c.is_ascii_alphanumeric() && c != '!' && c != '#' && c != '$' && c != '%' && c != '&' && c != '\\'' && c != '*' && c != '+' && c != '-' && c != '.' && c != '^' && c != '_' && c != '`' && c != '|' && c != '~' && c != ' ' && c != '\\t' {\n            return false;\n        }\n    }\n\n    true\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    if name.is_empty() {\n        return false;\n    }\n\n    let mut chars = name.chars();\n    let first = chars.next().unwrap();\n    if first.is_ascii_alphabetic() {\n        for c in chars {\n            if !c.is_ascii_alphanumeric() && !c.is_ascii_punctuation() {\n                return false;\n            }\n        }\n    } else if first == '!' || first == '#' || first == '$' || first == '%' || first == '&' || first == '\\'' || first == '*' || first == '+' || first == '-' || first == '.' || first == '^' || first == '_' || first == '`' || first == '|' || first == '~' || first.is_ascii_digit() {\n        for c in chars {\n            if !c.is_ascii_alphanumeric() && !c.is_ascii_punctuation() {\n                return false;\n            }\n        }\n    } else {\n        return false;\n    }\n\n    true\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    !name.is_empty() && name.chars().all(|c| {\n        matches!(c, '!' | '#' | '$' | '%' | '&' | '\\'' | '*' | '+' | '-' | '.' | '^' | '_' | '`' | '|' | '~' |\n            '0'..='9' | 'a'..='z' | 'A'..='Z')\n    })\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    !name.is_empty() && name.chars().all(|c| c.is_ascii_alphanumeric() || c == '!' || c == '#' || c == '$' || c == '%' || c == '&' || c == '\\'' || c == '*' || c == '+' || c == '-' || c == '.' || c == '^' || c == '_' || c == '`' || c == '|' || c == '~')\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    name.chars().all(|c| {\n        matches!(c, '!' | '#' | '$' | '%' | '&' | '\\'' | '*' | '+' | '-' | '.' | '^' | '_' | '`' | '|' | '~' |\n                      '!' | '#' | '$' | '%' | '&' | '\\'' | '*' | '+' | '-' | '.' | '^' | '_' | '`' | '|' | '~' |\n                      '0'..='9' | 'A'..='Z' | 'a'..='z')\n    })\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    !name.is_empty() && name.chars().all(|c| c.is_ascii_alphanumeric() || c == '!' || c == '#' || c == '$' || c == '%' || c == '&' || c == '\\'' || c == '*' || c == '+' || c == '-' || c == '.' || c == '^' || c == '_' || c == '`' || c == '|' || c == '~')\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    if name.is_empty() {\n        return false;\n    }\n\n    let mut iter = name.chars();\n    let first = iter.next().unwrap();\n    if !(first.is_ascii_alphabetic() || first == '!') {\n        return false;\n    }\n\n    iter.all(|c| {\n        c.is_ascii_alphanumeric() || c == '!' || c == '#' || c == '$' || c == '%' || c == '&' || c == '\\'' || c == '*' || c == '+' || c == '-' || c == '.' || c == '^' || c == '_' || c == '`' || c == '|' || c == '~'\n    })\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    name.chars().all(|c| {\n        matches!(c, '!' | '#' | '$' | '%' | '&' | '\\'' | '*' | '+' | '-' | '.' | '^' | '_' | '`' | '|' | '~' | '!'..='~' | '!'..='~')\n    })\n}"
    ],
    [
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    let name = Uncased::new(name);\n    let entry = self.headers.entry(name);\n    match entry {\n        IndexMapEntry::Vacant(entry) => {\n            entry.insert(values.drain(..).collect());\n        }\n        IndexMapEntry::Occupied(mut entry) => {\n            entry.get_mut().extend(values.drain(..));\n        }\n    }\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    self.headers.entry(Uncased::new(name)).or_insert(vec![]).append(values);\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    self.headers.entry(Uncased::new(name)).or_insert(vec![]).append(values);\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    self.headers.entry(Uncased::new(name)).or_insert(vec![]).append(values);\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    let name = Uncased::new(name);\n    let values = mem::replace(values, Vec::new());\n    self.headers.entry(name).or_insert(Vec::new()).extend(values);\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    self.headers.entry(Uncased::new(name)).or_insert(vec![]).append(values);\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    let name = Uncased::new(name);\n    let values = mem::take(values);\n    let existing = self.headers.entry(name).or_insert(vec![]);\n    existing.extend(values);\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    let name = Uncased::new(name);\n    if let Some(vec) = self.headers.get_mut(&name) {\n        vec.append(values);\n    } else {\n        self.headers.insert(name, values.to_owned());\n    }\n    values.clear();\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    self.headers.entry(Uncased::new(name)).or_insert(vec![]).append(values);\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    let name = Uncased::new(name);\n    if let Some(vals) = self.headers.get_mut(&name) {\n        vals.append(values);\n    } else {\n        self.headers.insert(name, values.to_vec());\n    }\n    values.clear();\n}"
    ],
    [
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}"
    ],
    [
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}"
    ],
    [
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}"
    ],
    [
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    let (name, value) = self.segments.get(self.pos + n)?;\n    Some((name, value))\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    let n = self.pos + n;\n    if n < self.segments.len() {\n        let segment = &self.segments[n];\n        let (key, value) = segment.split_at(segment.find('=').unwrap_or(segment.len()));\n        Some((key, &value[1..]))\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    if n >= self.len() {\n        return None;\n    }\n\n    let mut pos = self.pos;\n    let mut i = 0;\n    let mut key = \"\";\n    let mut value = \"\";\n\n    for (k, v) in self.segments.iter() {\n        if i == n {\n            key = k;\n            value = v;\n            break;\n        }\n\n        i += 1;\n        pos += 1;\n    }\n\n    self.pos = pos;\n    Some((key, value))\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    let segments = self.segments;\n    let pos = self.pos;\n    if n < segments.len() - pos {\n        let (key, value) = segments.get(n + pos).unwrap();\n        Some((key, value))\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    let mut i = 0;\n    for segment in self.segments.iter() {\n        if i == n {\n            return Some((segment.0, segment.1));\n        }\n        i += 1;\n    }\n    None\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    let n = self.pos + n;\n    if n >= self.segments.len() {\n        return None;\n    }\n\n    let mut iter = self.segments[n].splitn(2, '=');\n    let key = iter.next().unwrap();\n    let value = match iter.next() {\n        Some(value) => value,\n        None => \"\",\n    };\n\n    Some((key, value))\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    let n = self.pos + n;\n    if n >= self.segments.len() {\n        return None;\n    }\n\n    let (key, value) = self.segments[n];\n    Some((key, value))\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    if n >= self.segments.len() {\n        return None;\n    }\n    let segment = &self.segments[n];\n    let mut iter = segment.splitn(2, '=');\n    let key = iter.next().unwrap();\n    let value = iter.next().unwrap_or(\"\");\n    Some((key, value))\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    if n >= self.len() {\n        return None;\n    }\n    let s = &self.segments[self.pos + n];\n    let mut iter = s.splitn(2, '=');\n    let key = iter.next().unwrap();\n    let value = iter.next().unwrap_or(\"\");\n    Some((key, value))\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    let n = self.pos + n;\n    if n >= self.segments.len() {\n        return None;\n    }\n\n    let (key, value) = self.segments[n];\n    Some((key, value))\n}"
    ],
    [
      "pub fn is_normalized (&self) -> bool {\n    self.scheme.is_indexed() && self.path.is_indexed() && self.query.is_indexed()\n}",
      "pub fn is_normalized (&self) -> bool {\n    if self.scheme.is_indexed() {\n        if self.authority.is_some() {\n            if self.path.is_indexed() {\n                if self.query.is_some() {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}",
      "pub fn is_normalized (&self) -> bool {\n    if let Some(query) = &self.query {\n        return query.is_empty();\n    }\n\n    true\n}",
      "pub fn is_normalized (&self) -> bool {\n    self.scheme.is_known() && self.path.is_normalized() && self.query.is_none()\n}",
      "pub fn is_normalized (&self) -> bool {\n    self.scheme.is_known() && self.path.is_normalized() && self.query.is_normalized()\n}",
      "pub fn is_normalized (&self) -> bool {\n    self.scheme().is_empty() && self.authority().is_none() && self.path().is_empty() && self.query().is_none()\n}",
      "pub fn is_normalized (&self) -> bool {\n    self.scheme().is_normalized() &&\n    self.authority().map_or(true, |a| a.is_normalized()) &&\n    self.path().is_normalized() &&\n    self.query().map_or(true, |q| q.is_normalized())\n}",
      "pub fn is_normalized (&self) -> bool {\n    self.path().is_normalized()\n        && self.query().map_or(true, |q| q.is_normalized())\n        && self.scheme().is_normalized()\n        && self.authority().map_or(true, |a| a.is_normalized())\n}",
      "pub fn is_normalized (&self) -> bool {\n    if self.path().is_empty() {\n        return false;\n    }\n\n    self.path().segments().is_normalized()\n}",
      "pub fn is_normalized (&self) -> bool {\n    self.path().is_normalized() && self.query().map_or(true, |q| q.is_normalized())\n}"
    ],
    [
      "pub fn top_left (&self) -> Point {\n    Point::new(self.left(), self.top())\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.left(), self.top())\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.left(), self.top())\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.left(), self.top())\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.left(), self.top())\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.left(), self.top())\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.left(), self.top())\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.left(), self.top())\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.left(), self.top())\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.left(), self.top())\n}"
    ],
    [
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}"
    ],
    [
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nx >= self.left() && x < self.right() && y >= self.top() && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nx >= self.left() && x < self.right() && y >= self.top() && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nx >= self.left() && x < self.right() && y >= self.top() && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nx >= self.left() && x < self.right() && y >= self.top() && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nx >= self.left() && x < self.right() && y >= self.top() && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nx >= self.left() && x < self.right() && y >= self.top() && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nx >= self.left() && x < self.right() && y >= self.top() && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nx >= self.left() && x < self.right() && y >= self.top() && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nx >= self.left() && x < self.right() && y >= self.top() && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nx >= self.left() && x < self.right() && y >= self.top() && y < self.bottom()\n}"
    ],
    [
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    self.left() <= other.left() && self.right() >= other.right() && self.top() <= other.top() && self.bottom() >= other.bottom()\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    self.left() <= other.left() &&\n    self.right() >= other.right() &&\n    self.top() <= other.top() &&\n    self.bottom() >= other.bottom()\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    self.left() <= other.left() &&\n    self.right() >= other.right() &&\n    self.top() <= other.top() &&\n    self.bottom() >= other.bottom()\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    self.left() <= other.left() && self.right() >= other.right() &&\n    self.top() <= other.top() && self.bottom() >= other.bottom()\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    self.left() <= other.left() && self.right() >= other.right() && self.top() <= other.top() && self.bottom() >= other.bottom()\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    self.left() <= other.left() &&\n    self.right() >= other.right() &&\n    self.top() <= other.top() &&\n    self.bottom() >= other.bottom()\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    self.left() <= other.left() && self.right() >= other.right() &&\n    self.top() <= other.top() && self.bottom() >= other.bottom()\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    self.left() <= other.left() &&\n    self.right() >= other.right() &&\n    self.top() <= other.top() &&\n    self.bottom() >= other.bottom()\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    self.left() <= other.left() && self.right() >= other.right() && self.top() <= other.top() && self.bottom() >= other.bottom()\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    self.left() <= other.left() &&\n    self.right() >= other.right() &&\n    self.top() <= other.top() &&\n    self.bottom() >= other.bottom()\n}"
    ],
    [
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.get(value)\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.get(value)\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.get(value)\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.get(value)\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.get(value)\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.get(value)\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.get(value)\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.get(value)\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.get(value)\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.get(value)\n}"
    ],
    [
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.get_lftmost().map(|(v, _)| v)\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.get_lftmost().map(|(v, _)| v)\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.get_lftmost().map(|(v, _)| v)\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.get_lftmost().map(|(v, _)| v)\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.get_lftmost().map(|(v, _)| v)\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.get_lftmost().map(|(v, _)| v)\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.get_lftmost().map(|(v, _)| v)\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.get_lftmost().map(|(v, _)| v)\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.get_lftmost().map(|(v, _)| v)\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.get_lftmost().map(|(v, _)| v)\n}"
    ],
    [
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(v, _)| v)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(v, _)| v)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(v, _)| v)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(v, _)| v)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(v, _)| v)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(v, _)| v)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(v, _)| v)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(v, _)| v)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(v, _)| v)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(v, _)| v)\n}"
    ],
    [
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}"
    ],
    [
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\n    self.tree.remove(value)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.remove(value)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.remove(value)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.remove(value)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.remove(value)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.remove(value)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.remove(value)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.remove(value)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.remove(value)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.remove(value)\n}"
    ],
    [
      "pub fn push (&mut self, item: T) {\n    self.tree.push_root(tree_core::Node::new(item, ()));\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.push_root(tree_core::Node::new(item, ()));\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.push_root(tree_core::Node::new(item, ()));\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.push_root(tree_core::Node::new(item));\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.push_root(tree_core::Node::new(item));\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.push_root(tree_core::Node::new(item));\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.push_root(Node::new(item));\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.push_root(Node::new(item));\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.push_root(Node::new(item));\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.push_root(tree_core::Node::new(item));\n}"
    ],
    [
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let size = self.read_u32()?;\n    let mut buf = vec![0; size as usize];\n    self.inner.read_exact(&mut buf)?;\n    Ok(buf)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let size = self.read_u32()?;\n    let mut buf = vec![0; size as usize];\n    if self.offset + size as usize > self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n    buf.copy_from_slice(&self.inner[self.offset..self.offset + size as usize]);\n    self.offset += size as usize;\n    Ok(buf)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let size = self.read_u32()?;\n    let mut buf = vec![0; size as usize];\n    self.read_exact(&mut buf)?;\n    Ok(buf)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let size = self.read_u32()?;\n    let bytes = &self.inner[self.offset..self.offset + size as usize];\n    self.offset += size as usize;\n    Ok(bytes.to_vec())\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let size = self.read_u32()?;\n    let bytes = &self.inner[self.offset..self.offset + size as usize];\n    self.offset += size as usize;\n    Ok(bytes.to_vec())\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let size = self.read_u32()?;\n    let mut buf = vec![0; size as usize];\n    self.read_exact(&mut buf)?;\n    Ok(buf)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let length = self.read_u32()?;\n    let mut bytes = vec![0; length as usize];\n    for i in 0..length {\n        bytes[i as usize] = self.read_u8()?;\n    }\n    Ok(bytes)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let size = self.read_u32()?;\n    let mut bytes = vec![0; size as usize];\n    self.inner.read_exact(&mut bytes)?;\n    Ok(bytes)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let size = self.read_u32()?;\n    let mut bytes = vec![0; size as usize];\n    for i in 0..size as usize {\n        bytes[i] = self.read_u8()?;\n    }\n    Ok(bytes)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let size = self.read_u32()?;\n    let mut buf = vec![0; size as usize];\n    self.inner.read_exact(&mut buf)?;\n    Ok(buf)\n}"
    ],
    [
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let bytes = self.read_bytes()?;\n    let mut result = bytes.to_vec();\n\n    // If the most significant bit of the first byte is set then\n    // the number is negative, otherwise it is positive.\n    // Positive numbers must be preceeded by a leading zero byte\n    // according to RFC 4251, section 5.\n    if result.get(0).unwrap_or(&0) & 0x80 != 0 {\n        result.remove(0);\n    }\n\n    Ok(result)\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let bytes = self.read_bytes()?;\n    let mut result = bytes.to_vec();\n\n    // If most significant bit is set then drop the leading zero byte to\n    // avoid interpretation as a negative number.\n    if result.get(0).unwrap_or(&0) & 0x80 != 0 {\n        result.remove(0);\n    }\n\n    Ok(result)\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let bytes = self.read_bytes()?;\n    let mut result = bytes.to_vec();\n\n    // If most significant bit is set then prepend a zero byte to\n    // avoid interpretation as a negative number.\n    if result.get(0).unwrap_or(&0) & 0x80 != 0 {\n        result.insert(0, 0);\n    }\n\n    Ok(result)\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let mut mpint = self.read_bytes()?;\n\n    // If most significant bit is set then drop the leading zero byte\n    // to avoid interpretation as a negative number.\n    if mpint.get(0).unwrap_or(&0) & 0x80 != 0 {\n        mpint.remove(0);\n    }\n\n    Ok(mpint)\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let mut mpint = self.read_bytes()?;\n    if mpint.len() > 0 && mpint[0] == 0 {\n        mpint.remove(0);\n    }\n    Ok(mpint)\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let mut bytes = self.read_bytes()?;\n\n    // If most significant bit is set then drop the leading zero byte to\n    // avoid interpretation as a negative number.\n    if bytes.get(0).unwrap_or(&0) & 0x80 != 0 {\n        bytes.remove(0);\n    }\n\n    Ok(bytes)\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let mut bytes = self.read_bytes()?;\n    // If the first byte is zero drop it, since it is a leading zero byte.\n    if bytes.get(0).unwrap_or(&0) == &0 {\n        bytes.remove(0);\n    }\n    Ok(bytes)\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let bytes = self.read_bytes()?;\n    let mut result = bytes.to_vec();\n\n    // If most significant bit is set then prepend a zero byte to\n    // avoid interpretation as a negative number.\n    if bytes.get(0).unwrap_or(&0) & 0x80 != 0 {\n        result.insert(0, 0);\n    }\n\n    Ok(result)\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let bytes = self.read_bytes()?;\n    let mut result = bytes.to_vec();\n\n    // If the first byte is zero, drop it, since it's a leading zero byte\n    // that we added according to RFC 4251, section 5.\n    if result.get(0).unwrap_or(&0) == &0 {\n        result.remove(0);\n    }\n\n    Ok(result)\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let mut bytes = self.read_bytes()?;\n\n    // If the most significant bit of the first byte is set then\n    // the number is negative, otherwise it is positive.\n    // Positive numbers must be preceeded by a leading zero byte according to RFC 4251, section 5.\n    if bytes[0] & 0x80 != 0 {\n        bytes.remove(0);\n    }\n\n    Ok(bytes)\n}"
    ],
    [
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    let result = String::from_utf8(bytes)?;\n    Ok(result)\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    String::from_utf8(bytes).map_err(|e| Error::with_kind(ErrorKind::Utf8Error(e)))\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    let result = String::from_utf8(bytes).map_err(|e| Error::with_kind(ErrorKind::Utf8Error(e)))?;\n    Ok(result)\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    String::from_utf8(bytes).map_err(|e| Error::with_kind(ErrorKind::Utf8Error(e)))\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    String::from_utf8(bytes).map_err(|e| Error::with_kind(ErrorKind::Utf8Error(e)))\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    String::from_utf8(bytes).map_err(|e| Error::with_kind(ErrorKind::Utf8Error(e)))\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    let result = String::from_utf8(bytes)?;\n    Ok(result)\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    let result = String::from_utf8(bytes)?;\n    Ok(result)\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    let result = String::from_utf8(bytes)?;\n    Ok(result)\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    let result = String::from_utf8(bytes)?;\n    Ok(result)\n}"
    ],
    [
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 4;\n    let value = BigEndian::read_u32(&slice[..4]);\n\n    Ok(value)\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 4;\n    let value = BigEndian::read_u32(&slice[..4]);\n\n    Ok(value)\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 4;\n    let value = BigEndian::read_u32(&slice[..4]);\n\n    Ok(value)\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 4;\n    let value = BigEndian::read_u32(&slice[..4]);\n\n    Ok(value)\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 4;\n    let value = BigEndian::read_u32(&slice[..4]);\n\n    Ok(value)\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 4;\n    let value = BigEndian::read_u32(&slice[..4]);\n\n    Ok(value)\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 4;\n    let value = BigEndian::read_u32(&slice[..4]);\n\n    Ok(value)\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 4;\n    let value = BigEndian::read_u32(&slice[..4]);\n\n    Ok(value)\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 4;\n    let value = BigEndian::read_u32(&slice[..4]);\n\n    Ok(value)\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 4;\n    let value = BigEndian::read_u32(&slice[..4]);\n\n    Ok(value)\n}"
    ],
    [
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}"
    ],
    [
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    let size = val.len() as u32;\n    self.inner.extend_from_slice(&size.to_be_bytes());\n    self.inner.extend_from_slice(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    self.inner.extend_from_slice(&val.len().to_be_bytes());\n    self.inner.extend_from_slice(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    let size = val.len() as u32;\n    self.inner.extend_from_slice(&size.to_be_bytes());\n    self.inner.extend_from_slice(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    self.inner.extend_from_slice(&(val.len() as u32).to_be_bytes());\n    self.inner.extend_from_slice(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    self.inner.extend_from_slice(&val.len().to_be_bytes());\n    self.inner.extend_from_slice(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    let len = val.len() as u32;\n    let mut bytes = vec![];\n    bytes.extend_from_slice(&len.to_be_bytes());\n    bytes.extend_from_slice(val);\n    self.inner.append(&mut bytes);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    let size = val.len() as u32;\n    let mut bytes = vec![];\n    bytes.extend_from_slice(&size.to_be_bytes());\n    bytes.extend_from_slice(val);\n    self.inner.extend_from_slice(&bytes);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    self.inner.extend_from_slice(&(val.len() as u32).to_be_bytes());\n    self.inner.extend_from_slice(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    let size = val.len() as u32;\n    let mut bytes = Vec::with_capacity(size as usize + 4);\n    bytes.extend_from_slice(&size.to_be_bytes());\n    bytes.extend_from_slice(val);\n    self.inner.append(&mut bytes);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    self.inner.extend_from_slice(&val);\n}"
    ],
    [
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => unsafe { &*(b\"/\" as *const [u8] as *const UnixStr) },\n        Component::CurDir => unsafe { &*(b\".\" as *const [u8] as *const UnixStr) },\n        Component::ParentDir => unsafe { &*(b\"..\" as *const [u8] as *const UnixStr) },\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => unsafe { &*(b\"/\" as *const [u8] as *const UnixStr) },\n        Component::CurDir => unsafe { &*(b\".\" as *const [u8] as *const UnixStr) },\n        Component::ParentDir => unsafe { &*(b\"..\" as *const [u8] as *const UnixStr) },\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => UnixStr::from_inner(&Slice::from_static(b\"/\")),\n        Component::CurDir => UnixStr::from_inner(&Slice::from_static(b\".\")),\n        Component::ParentDir => UnixStr::from_inner(&Slice::from_static(b\"..\")),\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => UnixStr::from_inner(&Slice::from_static(\"/\")),\n        Component::CurDir => UnixStr::from_inner(&Slice::from_static(\".\")),\n        Component::ParentDir => UnixStr::from_inner(&Slice::from_static(\"..\")),\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => unsafe { &*(b\"/\" as *const [u8] as *const UnixStr) },\n        Component::CurDir => unsafe { &*(b\".\" as *const [u8] as *const UnixStr) },\n        Component::ParentDir => unsafe { &*(b\"..\" as *const [u8] as *const UnixStr) },\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => UnixStr::from_inner(&Slice::from_u8_slice(b\"/\"[..].as_ref())),\n        Component::CurDir => UnixStr::from_inner(&Slice::from_u8_slice(b\".\"[..].as_ref())),\n        Component::ParentDir => UnixStr::from_inner(&Slice::from_u8_slice(b\"..\"[..].as_ref())),\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => unsafe { UnixStr::from_u8_slice(b\"\") },\n        Component::CurDir => unsafe { UnixStr::from_u8_slice(b\".\") },\n        Component::ParentDir => unsafe { UnixStr::from_u8_slice(b\"..\") },\n        Component::Normal(s) => s,\n    }\n}\n\nimpl<'a> AsRef<UnixStr> for Component<'a> {\n    fn as_ref(&self) -> &UnixStr {\n        self.as_unix_str()\n    }\n}\n\nimpl<'a> AsRef<Path> for Component<'a> {\n    fn as_ref(&self) -> &Path {\n        self.as_unix_str().as_ref()\n    }\n}\n\nimpl<'a> AsRef<Path> for Iter<'a> {\n    fn as_ref(&self) -> &Path {\n        self.as_path()\n    }\n}\n\nimpl<'a> AsRef<UnixStr> for Iter<'a> {\n    fn as_ref(&self) -> &UnixStr {\n        self.as_path().as_unix_str()\n    }\n}\n\nimpl<'a> Iterator for Iter<'a> {\n    type Item = &'a UnixStr;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.inner.next().map(Component::as_unix_str)\n    }\n}\n\nimpl<'a> AsRef<Path> for IterMut<'a> {\n    fn as_ref(&self) -> &Path {\n        self.as_path()\n    }\n}\n\nimpl<'a> AsRef<UnixStr> for IterMut<'a> {\n    fn as_ref(&self) -> &UnixStr {\n        self.as_path().as_unix_str()\n    }\n}\n\nimpl<'a> Iterator for IterMut<'a> {\n    type Item = &'a UnixStr;\n\n    fn next(&mut self) -> Option<Self::Item> {\n}\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => unsafe { UnixStr::from_u8_slice(b\"/\" as &[u8]) },\n        Component::CurDir => unsafe { UnixStr::from_u8_slice(b\".\" as &[u8]) },\n        Component::ParentDir => unsafe { UnixStr::from_u8_slice(b\"..\" as &[u8]) },\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => UnixStr::new(\"/\"),\n        Component::CurDir => UnixStr::new(\".\"),\n        Component::ParentDir => UnixStr::new(\"..\"),\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => UnixStr::from_inner(&Slice::from_u8_slice(b\"\")),\n        Component::CurDir => UnixStr::from_inner(&Slice::from_u8_slice(b\".\"),),\n        Component::ParentDir => UnixStr::from_inner(&Slice::from_u8_slice(b\"..\")),\n        Component::Normal(s) => s,\n    }\n}\n\nimpl AsRef<Path> for Component<'_> {\n    fn as_ref(&self) -> &Path {\n        self.as_unix_str().as_ref()\n    }\n}\n\nimpl AsRef<UnixStr> for Component<'_> {\n    fn as_ref(&self) -> &UnixStr {\n        self.as_unix_str()\n    }\n}\n\nimpl AsRef<UnixStr> for Iter<'_> {\n    fn as_ref(&self) -> &UnixStr {\n        self.as_path().as_unix_str()\n    }\n}\n\nimpl AsRef<Path> for Iter<'_> {\n    fn as_ref(&self) -> &Path {\n        self.as_path()\n    }\n}\n\nimpl AsRef<Path> for PathBuf {\n    fn as_ref(&self) -> &Path {\n        self\n    }\n}\n\nimpl AsRef<Path> for Path {\n    fn as_ref(&self) -> &Path {\n        self\n    }\n}\n\nimpl AsRef<UnixStr> for PathBuf {\n    fn as_ref(&self) -> &UnixStr {\n        self.as_ref().as_unix_str()\n    }\n}\n\nimpl AsRef<UnixStr> for Path {\n    fn as_ref(&self) -> &UnixStr {\n        self.as_unix_str()\n    }\n}\n\nimpl AsRef<Path> for str {\n    fn as_ref(&self) -> &Path {\n        Path::new(self)\n    }\n}\n\nimpl AsRef<Path> for String {\n    fn as_ref(&self) -> &Path {\n}\n}"
    ],
    [
      "pub fn as_path (&self) -> &'a Path {\n    let mut path = Path::new(\"\");\n    for comp in self.iter() {\n        path = path.join(comp);\n    }\n    path\n}",
      "pub fn as_path (&self) -> &'a Path {\n    let mut components = self.iter();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n    components.next();\n}",
      "pub fn as_path (&self) -> &'a Path {\n    Path::from_u8_slice(self.inner)\n}",
      "pub fn as_path (&self) -> &'a Path {\n    let mut start = 0;\n    let mut end = 0;\n    let mut finished = false;\n    let mut has_root = false;\n    let mut include_cur_dir = false;\n    let mut cur_dir_len = 0;\n    let mut root_len = 0;\n    let mut finished = false;\n    let mut has_root = false;\n    let mut include_cur_dir = false;\n    let mut cur_dir_len = 0;\n    let mut root_len = 0;\n    let mut finished = false;\n    let mut has_root = false;\n    let mut include_cur_dir = false;\n    let mut cur_dir_len = 0;\n    let mut root_len = 0;\n    let mut finished = false;\n    let mut has_root = false;\n    let mut include_cur_dir = false;\n    let mut cur_dir_len = 0;\n    let mut root_len = 0;\n    let mut finished = false;\n    let mut has_root = false;\n    let mut include_cur_dir = false;\n    let mut cur_dir_len = 0;\n    let mut root_len = 0;\n    let mut finished = false;\n    let mut has_root = false;\n    let mut include_cur_dir = false;\n    let mut cur_dir_len = 0;\n    let mut root_len = 0;\n    let mut finished = false;\n    let mut has_root = false;\n    let mut include_cur_dir = false;\n    let mut cur_dir_len = 0;\n    let mut root_len = 0;\n    let mut finished = false;\n    let mut has_root = false;\n    let mut include_cur_dir = false;\n    let mut cur_dir_len = 0;\n    let mut root_len = 0;\n    let mut finished = false;\n    let mut has_root = false;\n    let mut include_cur_dir = false;\n    let mut cur_dir_len = 0;\n    let mut root_len = 0;\n}",
      "pub fn as_path (&self) -> &'a Path {\n    unsafe { Path::from_u8_slice(self.path) }\n}",
      "pub fn as_path (&self) -> &'a Path {\n    let mut components = self.iter();\n    components.next();\n    components.next();\n    components.as_path()\n}",
      "pub fn as_path (&self) -> &'a Path {\n    let mut path = Path::new(\"\");\n    for comp in self.iter() {\n        path = path.join(comp);\n    }\n    path\n}",
      "pub fn as_path (&self) -> &'a Path {\n    unsafe { Path::from_u8_slice(self.inner.as_u8_slice()) }\n}",
      "pub fn as_path (&self) -> &'a Path {\n    unsafe { Path::from_u8_slice(self.inner.as_bytes()) }\n}",
      "pub fn as_path (&self) -> &'a Path {\n    let root = if self.front <= State::StartDir && self.has_physical_root {\n        1\n    } else {\n        0\n    };\n    let cur_dir = if self.front <= State::StartDir && self.include_cur_dir() {\n        1\n    } else {\n        0\n    };\n    let start = self.len_before_body() + root + cur_dir;\n    let end = self.path.len();\n    unsafe { Path::from_u8_slice(&self.path[start..end]) }\n}"
    ],
    [
      "pub fn pop (&mut self) -> bool {\n    if self.parent().is_some() {\n        self.as_mut_vec().truncate(self.parent().unwrap().as_unix_str().len());\n        true\n    } else {\n        false\n    }\n}",
      "pub fn pop (&mut self) -> bool {\n    if self.as_path().parent().is_some() {\n        self.as_mut_vec().truncate(self.as_path().parent().unwrap().as_unix_str().len());\n        true\n    } else {\n        false\n    }\n}",
      "pub fn pop (&mut self) -> bool {\n    let mut components = self.components();\n    if components.next_back().is_some() {\n        components.next_back();\n        self.inner = components.as_unix_str().into();\n        true\n    } else {\n        false\n    }\n}",
      "pub fn pop (&mut self) -> bool {\n    let mut components = self.components();\n    if components.next_back().is_none() {\n        return false;\n    }\n    components.next_back();\n    self.set_components(components);\n    true\n}",
      "pub fn pop (&mut self) -> bool {\n    if self.parent().is_none() {\n        return false;\n    }\n    let mut v = self.as_mut_vec();\n    v.truncate(v.iter().rposition(|&c| c == b'/').unwrap_or(0) + 1);\n    true\n}",
      "pub fn pop (&mut self) -> bool {\n    let mut comps = self.components();\n    let popped = comps.next_back();\n    if popped.is_some() {\n        self.as_mut_vec().truncate(0);\n        for comp in comps {\n            self.inner.push(comp);\n        }\n        true\n    } else {\n        false\n    }\n}",
      "pub fn pop (&mut self) -> bool {\n    if self.parent().is_some() {\n        self.as_mut_vec().truncate(self.parent().unwrap().as_unix_str().len());\n        true\n    } else {\n        false\n    }\n}",
      "pub fn pop (&mut self) -> bool {\n    if let Some(parent) = self.parent() {\n        self.as_mut_vec().truncate(parent.as_unix_str().len());\n        true\n    } else {\n        false\n    }\n}",
      "pub fn pop (&mut self) -> bool {\n    let mut components = self.components();\n    if components.next_back().is_none() {\n        return false;\n    }\n    self.inner = components.as_path().inner;\n    true\n}",
      "pub fn pop (&mut self) -> bool {\n    if let Some(parent) = self.parent() {\n        self.as_mut_vec().truncate(parent.as_unix_str().len());\n        true\n    } else {\n        false\n    }\n}"
    ],
    [
      "pub fn parent (&self) -> Option<&Path> {\n    self.components().next_back().and_then(|p| match p {\n        Component::Normal(_) => Some(self),\n        _ => None,\n    })\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    let mut components = self.components();\n    components.next_back();\n    components.as_path()\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    self.components().next_back().and_then(|p| match p {\n        Component::Normal(_) => Some(self),\n        _ => None,\n    })\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    self.components().next_back().and_then(|p| match p {\n        Component::ParentDir => Some(self),\n        _ => None,\n    })\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    let mut components = self.components();\n    components.next_back();\n    components.as_path()\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    let mut components = self.components();\n    components.next_back();\n    components.as_path()\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    self.components().next_back().and_then(|p| match p {\n        Component::Normal(_) => Some(self),\n        _ => None,\n    })\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    self.components().next_back().and_then(|p| match p {\n        Component::Normal(_) => Some(self),\n        _ => None,\n    })\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    let mut comps = self.components();\n    let comp = comps.next_back();\n    let is_cur_dir = comp.as_ref().map_or(false, |c| c == CurDir);\n    if is_cur_dir {\n        comps.next_back();\n    }\n    let has_no_root = !self.has_root();\n    let is_not_absolute = !self.is_absolute();\n    let has_no_prefix = comps.next_back().is_none();\n    let is_not_ancestor_dir = !(comps.next_back().is_some() && comps.next_back().is_some());\n    if has_no_root && is_not_absolute && has_no_prefix && is_not_ancestor_dir {\n        Some(Path::new(comps.as_path()))\n    } else {\n        None\n    }\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    let mut components = self.components();\n    components.next_back();\n    components.as_path()\n}"
    ],
    [
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    let mut components = self.components();\n    components.next_back()\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    let mut comps = self.components();\n    let comp = comps.next_back();\n    comp.and_then(|p| match p {\n        Component::Normal(s) => Some(s),\n        _ => None,\n    })\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    let mut comps = self.components();\n    comps.next_back()\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    let mut comps = self.components();\n    let comp = comps.next_back();\n    comp.and_then(|p| match p {\n        Component::Normal(s) => Some(s),\n        _ => None,\n    })\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    self.components().next_back().and_then(|c| match c {\n        Component::Normal(s) => Some(s),\n        _ => None,\n    })\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    self.components().next_back().and_then(|comp| match comp {\n        Component::Normal(s) => Some(s),\n        _ => None,\n    })\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    let mut comps = self.components();\n    let comp = comps.next_back();\n    comp.and_then(|p| match p {\n        Component::Normal(s) => Some(s),\n        _ => None,\n    })\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    let mut comps = self.components();\n    comps.next_back()\n        .and_then(|comp| match comp {\n            Component::Normal(name) => Some(name),\n            _ => None,\n        })\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    let mut comps = self.components();\n    let comp = comps.next_back();\n    comp.and_then(|p| match p {\n        Component::Normal(s) => Some(s),\n        _ => None,\n    })\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    let mut comps = self.components();\n    comps.next_back()\n        .and_then(|comp| match comp {\n            Component::Normal(name) => Some(name),\n            _ => None,\n        })\n}"
    ],
    [
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    let cur_len = self.v.len();\n    if len >= cur_len {\n        self.v.reserve_exact(len - cur_len);\n    }\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    let cur_len = self.v.len();\n    if len >= cur_len {\n        self.v.reserve_exact(len - cur_len);\n    }\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    let cur_len = self.v.len();\n    if len >= cur_len {\n        self.v.reserve_exact(len - cur_len);\n    }\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    self.v.reserve_exact(len - self.n);\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    self.v.reserve_exact(len);\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    self.v.reserve_exact(len);\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    let cur_len = self.v.len();\n    if len >= cur_len {\n        self.v.reserve_exact(len - cur_len);\n    }\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    let cur_len = self.v.len();\n    if len >= cur_len {\n        self.v.reserve_exact(len - cur_len);\n    }\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    let cur_len = self.v.len();\n    if len >= cur_len {\n        self.v.reserve_exact(len - cur_len);\n    }\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    let cur_len = self.v.len();\n    if len >= cur_len {\n        self.v.reserve_exact(len - cur_len);\n    }\n}"
    ],
    [
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}"
    ],
    [
      "pub fn append (&mut self, other: &mut Self) {\n    let mut other_iter = other.iter_mut();\n    for (i, e) in self.v.iter_mut().enumerate() {\n        let remove = match *e {\n            Some(ref mut value) => {\n                if let Some((key, value)) = other_iter.next() {\n                    *value = value;\n                    i == key\n                } else {\n                    false\n                }\n            }\n            None => false,\n        };\n        if remove {\n            *e = None;\n            self.n -= 1;\n        }\n    }\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    let other_len = other.len();\n    if other_len == 0 {\n        return;\n    }\n    let self_len = self.len();\n    if self_len == 0 {\n        self.v.extend(other.v.drain(..other_len));\n        self.n = other_len;\n        return;\n    }\n    let mut taken = 0;\n    self.v.extend(other.v.drain(..other_len).map(|el| {\n        let el = el.take();\n        if el.is_some() {\n            taken += 1;\n        }\n        el\n    }));\n    self.n += taken;\n    other.n -= taken;\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    self.v.extend(other.v.iter_mut().map(|el| el.take()));\n    self.n += other.n;\n    other.n = 0;\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    let mut other_iter = other.iter_mut();\n    while let Some((key, value)) = other_iter.next() {\n        self.insert(key, value);\n    }\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    let mut other_iter = other.iter_mut();\n    while let Some((key, value)) = other_iter.next() {\n        self.insert(key, value);\n    }\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    for (k, v) in other.iter_mut() {\n        self.insert(k, v);\n    }\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    self.v.extend(other.v.iter_mut().map(|el| el.take()));\n    self.n += other.n;\n    other.n = 0;\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    let mut other_iter = other.iter_mut();\n    for (key, value) in self.iter_mut() {\n        if let Some(other_value) = other_iter.next() {\n            *value = other_value;\n        } else {\n            break;\n        }\n    }\n    self.n = self.v.len();\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    self.reserve_len_exact(other.len());\n    for (k, v) in other.iter_mut() {\n        self.insert(k, v);\n    }\n    other.clear();\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    for (k, v) in other.iter_mut() {\n        self.insert(k, v.take().unwrap());\n    }\n}"
    ],
    [
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::new();\n    for (k, v) in self.drain() {\n        if k >= at {\n            other.insert(k, v);\n        } else {\n            self.insert(k, v);\n        }\n    }\n    other\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::new();\n    let mut iter = self.iter_mut();\n    while let Some((key, value)) = iter.next() {\n        if key >= at {\n            other.insert(key, value.clone());\n        }\n    }\n    other\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut new_map = Self::with_capacity(self.capacity());\n    let mut new_index = 0;\n    for i in 0..at {\n        if let Some(value) = self.remove(i) {\n            new_map.insert(new_index, value);\n            new_index += 1;\n        }\n    }\n    new_map\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::new();\n    other.extend(self.drain().skip(at));\n    other\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::new();\n    for (key, value) in self.drain() {\n        if key >= at {\n            other.insert(key, value);\n        } else {\n            self.insert(key, value);\n        }\n    }\n    other\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut new_map = Self::new();\n    let mut iter = self.drain();\n    for i in 0..at {\n        if let Some((k, v)) = iter.next() {\n            if k == i {\n                new_map.insert(k, v);\n            }\n        }\n    }\n    new_map\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::new();\n    for (key, value) in self.drain().skip(at) {\n        other.insert(key, value);\n    }\n    other\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut new_map = VecMap::new();\n    let mut i = 0;\n    for (key, value) in self.iter() {\n        if key >= at {\n            new_map.insert(key, value.clone());\n        } else {\n            i += 1;\n        }\n    }\n    new_map.n = self.n - i;\n    self.n = i;\n    new_map\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut new = Self::new();\n    new.v = self.v.split_off(at);\n    new.n = self.n - at;\n    self.n = at;\n    new\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut new_map = Self::new();\n    let mut index = at;\n    while index < self.v.len() {\n        let key = index;\n        let value = self.v[index].take().unwrap();\n        new_map.insert(key, value);\n        index += 1;\n    }\n    new_map\n}"
    ],
    [
      "pub fn get (&self, key: usize) -> Option<&V> {\n    if key >= self.v.len() {\n        return None;\n    }\n    self.v[key].as_ref()\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    if key >= self.v.len() {\n        return None;\n    }\n    let result = &self.v[key];\n    match result {\n        Some(value) => Some(value),\n        None => None,\n    }\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    if key >= self.v.len() {\n        return None;\n    }\n    let result = &self.v[key];\n    match result {\n        Some(value) => Some(value),\n        None => None,\n    }\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    if key >= self.v.len() {\n        return None;\n    }\n    let result = &self.v[key];\n    if result.is_some() {\n        return Some(&result.as_ref().unwrap());\n    }\n    None\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    if key >= self.v.len() {\n        return None;\n    }\n    self.v[key].as_ref()\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    if key >= self.v.len() {\n        return None;\n    }\n    let result = &self.v[key];\n    if result.is_some() {\n        return Some(&result.as_ref().unwrap());\n    }\n    None\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    if key >= self.v.len() {\n        return None;\n    }\n    let result = &self.v[key];\n    if result.is_some() {\n        return Some(result.as_ref().unwrap());\n    }\n    None\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    if key >= self.v.len() {\n        return None;\n    }\n    let result = &self.v[key];\n    if result.is_some() {\n        return Some(result.as_ref().unwrap());\n    }\n    None\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    if key >= self.v.len() {\n        return None;\n    }\n    let result = &self.v[key];\n    if result.is_some() {\n        return Some(result.as_ref().unwrap());\n    }\n    None\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    if key >= self.v.len() {\n        return None;\n    }\n    let result = &self.v[key];\n    if result.is_some() {\n        return Some(result.as_ref().unwrap());\n    }\n    None\n}"
    ],
    [
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key >= self.v.len() {\n        self.v.resize(key + 1, None);\n    }\n    let result = &mut self.v[key];\n    let was = result.take();\n    if was.is_some() {\n        self.n -= 1;\n    }\n    *result = Some(value);\n    self.n += 1;\n    was\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key >= self.v.len() {\n        self.v.resize(key + 1, None);\n    }\n    let result = &mut self.v[key];\n    let was = result.take();\n    if was.is_none() {\n        self.n += 1;\n    }\n    *result = Some(value);\n    was\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key >= self.v.len() {\n        self.v.resize(key + 1, None);\n    }\n    let result = &mut self.v[key];\n    let was = result.take();\n    if was.is_some() {\n        self.n -= 1;\n    }\n    *result = Some(value);\n    self.n += 1;\n    was\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key >= self.v.len() {\n        self.v.resize(key + 1, None);\n    }\n    let result = &mut self.v[key];\n    let was = result.take();\n    if was.is_none() {\n        self.n += 1;\n    }\n    *result = Some(value);\n    was\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key >= self.v.len() {\n        self.v.resize(key + 1, None);\n    }\n    let result = &mut self.v[key];\n    let was = result.take();\n    if was.is_some() {\n        self.n -= 1;\n    }\n    *result = Some(value);\n    self.n += 1;\n    was\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key >= self.v.len() {\n        self.v.resize(key + 1, None);\n    }\n    let result = &mut self.v[key];\n    let was = result.take();\n    if was.is_some() {\n        self.n -= 1;\n    }\n    *result = Some(value);\n    self.n += 1;\n    was\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key >= self.v.len() {\n        self.v.resize(key + 1, None);\n    }\n    let result = &mut self.v[key];\n    let was = result.take();\n    if was.is_some() {\n        self.n -= 1;\n    }\n    *result = Some(value);\n    self.n += 1;\n    was\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key >= self.v.len() {\n        self.v.resize(key + 1, None);\n    }\n    let result = &mut self.v[key];\n    let was = result.take();\n    if was.is_none() {\n        self.n += 1;\n    }\n    *result = Some(value);\n    was\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key >= self.v.len() {\n        self.v.resize(key + 1, None);\n    }\n    let result = &mut self.v[key];\n    let was = result.take();\n    if was.is_none() {\n        self.n += 1;\n    }\n    *result = Some(value);\n    was\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key >= self.v.len() {\n        self.v.resize(key + 1, None);\n    }\n    let result = &mut self.v[key];\n    let was = result.take();\n    if was.is_some() {\n        self.n -= 1;\n    }\n    *result = Some(value);\n    self.n += 1;\n    was\n}"
    ],
    [
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    if key < self.v.len() {\n        let was = replace(&mut self.v[key], None);\n        if was.is_some() {\n            self.n -= 1;\n        }\n        was\n    } else {\n        None\n    }\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    let len = self.v.len();\n    if len <= key {\n        return None;\n    }\n    let was = self.v[key].take();\n    if was.is_some() {\n        self.n -= 1;\n    }\n    was\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    let was = self.v[key].take();\n    if was.is_some() {\n        self.n -= 1;\n    }\n    was\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    let len = self.v.len();\n    if len <= key {\n        return None;\n    }\n    let was = replace(&mut self.v[key], None);\n    if was.is_some() {\n        self.n -= 1;\n    }\n    was\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    let was = replace(&mut self.v[key], None);\n    if was.is_some() {\n        self.n -= 1;\n    }\n    was\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    if key < self.v.len() {\n        let was = self.v[key].take();\n        if was.is_some() {\n            self.n -= 1;\n        }\n        was\n    } else {\n        None\n    }\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    let was = self.v[key].take();\n    if was.is_some() {\n        self.n -= 1;\n    }\n    was\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    if key < self.v.len() {\n        let was = replace(&mut self.v[key], None);\n        if was.is_some() {\n            self.n -= 1;\n        }\n        was\n    } else {\n        None\n    }\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    if key < self.v.len() {\n        let was = replace(&mut self.v[key], None);\n        if was.is_some() {\n            self.n -= 1;\n        }\n        was\n    } else {\n        None\n    }\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    if key < self.v.len() {\n        let was = self.v[key].take();\n        if was.is_some() {\n            self.n -= 1;\n        }\n        was\n    } else {\n        None\n    }\n}"
    ],
    [
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    for i in 0..self.v.len() {\n        if let Some(value) = self.v[i].as_mut() {\n            if !f(i, value) {\n                self.v[i].take();\n            }\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    let mut i = 0;\n    while i < self.v.len() {\n        if let Some(ref mut value) = self.v[i] {\n            if !f(i, value) {\n                self.v[i].take();\n            }\n        }\n        i += 1;\n    }\n    self.v.retain(|x| x.is_some());\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    let mut i = 0;\n    while i < self.v.len() {\n        if !f(i, &mut self.v[i]) {\n            self.remove(i);\n        } else {\n            i += 1;\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    for (index, value) in self.v.iter_mut().enumerate() {\n        if let Some(value) = value.as_mut() {\n            if !f(index, value) {\n                self.remove(index);\n            }\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    for i in 0..self.v.len() {\n        if let Some(ref mut v) = self.v[i] {\n            if !f(i, v) {\n                self.v[i] = None;\n            }\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    let mut i = 0;\n    while i < self.v.len() {\n        if let Some(v) = self.v[i].as_mut() {\n            if f(i, v) {\n                i += 1;\n            } else {\n                self.v[i] = None;\n            }\n        } else {\n            i += 1;\n        }\n    }\n    self.n = self.v.iter().filter(|v| v.is_some()).count();\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    for i in 0..self.v.len() {\n        if let Some(v) = self.v[i].as_mut() {\n            if !f(i, v) {\n                self.v[i].take();\n            }\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    for i in 0..self.v.len() {\n        if let Some(value) = self.v[i].as_mut() {\n            if !f(i, value) {\n                self.remove(i);\n            }\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    for i in 0..self.v.len() {\n        if let Some(ref mut v) = self.v[i] {\n            if !f(i, v) {\n                self.v[i].take();\n            }\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    let mut i = 0;\n    while i < self.v.len() {\n        if let Some(ref mut value) = self.v[i] {\n            if !f(i, value) {\n                self.v[i].take();\n            }\n        }\n        i += 1;\n    }\n}"
    ],
    [
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    // SAFETY:\n    //  * `capacity != len` so this is strictly in bounds. Also, this is behind the\n    //  vector so there can not be any references to it currently.\n    unsafe {\n        ptr::write(self.end_mut_ptr(), val);\n        // SAFETY:\n        //  Just initialized one more element past the end. By the way, this can not\n        //  overflow since the result is at most `self.capacity()`.\n        self.set_len(self.len() + 1);\n    }\n    Ok(())\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    // SAFETY:\n    //  * `self.len()` is strictly less than `self.capacity()`\n    //  * `self.end_mut_ptr()` is strictly in bounds\n    //  * `self.end_mut_ptr()` is behind the vector so there can not be any references to it\n    //    currently.\n    unsafe {\n        ptr::write(self.end_mut_ptr(), val);\n        // SAFETY:\n        //  Just initialized one more element past the end. By the way, this can not overflow since\n        //  the result is at most `self.capacity()`.\n        self.set_len(self.len() + 1);\n    }\n    Ok(())\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    // Check if there is enough space.\n    if self.len() == self.capacity() {\n        return Err(val);\n    }\n    // Get the next slot.\n    let slot = unsafe {\n        // SAFETY:\n        //  * `self.len()` is strictly less than `self.capacity()`\n        //  * `self.capacity()` is strictly less than `self.uninit.capacity()`\n        //  * `self.uninit` is not empty\n        self.uninit.split_at(self.len()).unwrap()\n    };\n    // Initialize the slot.\n    unsafe {\n        // SAFETY:\n        //  * `slot` is not empty\n        //  * `slot` is unused\n        //  * `val` is not used anymore\n        ptr::write(slot.as_mut_ptr(), val);\n    }\n    // Increment the length.\n    unsafe {\n        // SAFETY:\n        //  * `self.len()` is strictly less than `self.capacity()`\n        //  * `self.capacity()` is strictly less than `self.uninit.capacity()`\n        //  * `self.uninit` is not empty\n        self.set_len(self.len() + 1);\n    }\n    Ok(())\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    if self.len() == self.capacity() {\n        Err(val)\n    } else {\n        unsafe {\n            // SAFETY:\n            // * `self.len() < self.capacity()` so this is strictly in bounds. Also, this is behind\n            //   the vector so there can not be any references to it currently.\n            ptr::write(self.end_mut_ptr(), val);\n            // SAFETY:\n            //  Just initialized one more element past the end. By the way, this can not overflow\n            //  since the result is at most `self.capacity()`.\n            self.set_len(self.len() + 1);\n        }\n        Ok(())\n    }\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    // SAFETY:\n    //  * `capacity != len` so this is strictly in bounds. Also, this is behind the\n    //  vector so there can not be any references to it currently.\n    unsafe {\n        ptr::write(self.end_mut_ptr(), val);\n        // SAFETY:\n        //  Just initialized one more element past the end. By the way, this can not\n        //  overflow since the result is at most `self.capacity()`.\n        self.set_len(self.len() + 1);\n    }\n    Ok(())\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    // If the vector is full, there is no space to push another element.\n    if self.len() == self.capacity() {\n        return Err(val);\n    }\n    // Safety:\n    // * The vector is not full.\n    // * The vector is behind the allocation.\n    // * The allocation is uninitialized.\n    unsafe {\n        // SAFETY:\n        // * The vector is not full.\n        // * The vector is behind the allocation.\n        // * The allocation is uninitialized.\n        ptr::write(self.end_mut_ptr(), val);\n        // SAFETY:\n        // * The vector is not full.\n        // * The vector is behind the allocation.\n        // * The allocation is uninitialized.\n        self.set_len(self.len() + 1);\n    }\n    Ok(())\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    if self.len() == self.capacity() {\n        return Err(val);\n    }\n    unsafe {\n        // SAFETY:\n        //  * `self.len() < self.capacity()` so this is strictly in bounds. Also, this is behind the\n        //  vector so there can not be any references to it currently.\n        ptr::write(self.end_mut_ptr(), val);\n        // SAFETY:\n        //  Just initialized one more element past the end. By the way, this can not overflow since\n        //  the result is at most `self.capacity()`.\n        self.set_len(self.len() + 1);\n    }\n    Ok(())\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    if self.len() < self.capacity() {\n        unsafe {\n            // SAFETY:\n            // * `self.len() < self.capacity()` so this is strictly in bounds.\n            // * `self.len() == 0` so this is the first element and we can write to it.\n            ptr::write(self.end_mut_ptr(), val);\n            // SAFETY:\n            // * Just initialized one more element past the end. By the way, this can not\n            // overflow since the result is at most `self.capacity()`.\n            self.set_len(self.len() + 1);\n        }\n        Ok(())\n    } else {\n        Err(val)\n    }\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    // If the vector is full, return the value.\n    if self.len() == self.capacity() {\n        return Err(val);\n    }\n    // SAFETY:\n    // * `self.len()` is strictly less than `self.capacity()`\n    // * `self.as_mut_slice()` is valid for writes\n    // * `self.as_mut_slice()` is behind the vector so there can not be any references to it\n    //   currently.\n    unsafe {\n        ptr::write(self.as_mut_slice().get_unchecked_mut(self.len()), val);\n        // SAFETY:\n        // * Just initialized one more element past the end. By the way, this can not overflow\n        //   since the result is at most `self.capacity()`.\n        self.set_len(self.len() + 1);\n    }\n    Ok(())\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    if self.len() == self.capacity() {\n        return Err(val);\n    }\n    unsafe {\n        // SAFETY:\n        //  * `self.len() < self.capacity()` so this is strictly in bounds.\n        //  * `self.len() == 0` so this is the first element.\n        //  * `self.capacity() > 0` so this is not an empty slice.\n        ptr::write(self.end_mut_ptr(), val);\n        // SAFETY:\n        //  * Just initialized one more element past the end. By the way, this can not overflow\n        //    since the result is at most `self.capacity()`.\n        self.set_len(self.len() + 1);\n    }\n    Ok(())\n}"
    ],
    [
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity(), \"`at` out of bounds\");\n    // `self.length` is always smaller than `split_at`.\n    let new_uninit = self.uninit.split_at(at).unwrap();\n    // The first `at` elements stay in this vec.\n    let new_len = self.length.saturating_sub(at);\n    self.length -= new_len;\n    FixedVec {\n        uninit: new_uninit,\n        length: new_len,\n    }\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity(), \"`at` out of bounds\");\n    // `self.length` is always smaller than `split_at`.\n    let new_uninit = self.uninit.split_at(at).unwrap();\n    // The first `at` elements stay in this vec.\n    let new_len = self.length.saturating_sub(at);\n    self.length -= new_len;\n    FixedVec {\n        uninit: new_uninit,\n        length: new_len,\n    }\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity(), \"`at` out of bounds\");\n    // `self.length` is always smaller than `split_at`.\n    let new_uninit = self.uninit.split_at(at).unwrap();\n    // The first `at` elements stay in this vec.\n    let new_len = self.length.saturating_sub(at);\n    self.length -= new_len;\n    FixedVec {\n        uninit: new_uninit,\n        length: new_len,\n    }\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity(), \"`at` out of bounds\");\n    // `self.length` is always smaller than `split_at`.\n    let new_uninit = self.uninit.split_at(at).unwrap();\n    // The first `at` elements stay in this vec.\n    let new_len = self.length.saturating_sub(at);\n    self.length -= new_len;\n    FixedVec {\n        uninit: new_uninit,\n        length: new_len,\n    }\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity(), \"`at` out of bounds\");\n    // `self.length` is always smaller than `split_at`.\n    let new_uninit = self.uninit.split_at(at).unwrap();\n    // The first `at` elements stay in this vec.\n    let new_len = self.length.saturating_sub(at);\n    self.length -= new_len;\n    FixedVec {\n        uninit: new_uninit,\n        length: new_len,\n    }\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity(), \"`at` out of bounds\");\n    // `self.length` is always smaller than `split_at`.\n    let new_uninit = self.uninit.split_at(at).unwrap();\n    // The first `at` elements stay in this vec.\n    let new_len = self.length.saturating_sub(at);\n    self.length -= new_len;\n    FixedVec {\n        uninit: new_uninit,\n        length: new_len,\n    }\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity(), \"`at` out of bounds\");\n    // `self.length` is always smaller than `split_at`.\n    let new_uninit = self.uninit.split_at(at).unwrap();\n    // The first `at` elements stay in this vec.\n    let new_len = self.length.saturating_sub(at);\n    self.length -= new_len;\n    FixedVec {\n        uninit: new_uninit,\n        length: new_len,\n    }\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity(), \"`at` out of bounds\");\n    // `self.length` is always smaller than `split_at`.\n    let new_uninit = self.uninit.split_at(at).unwrap();\n    // The first `at` elements stay in this vec.\n    let new_len = self.length.saturating_sub(at);\n    self.length -= new_len;\n    FixedVec {\n        uninit: new_uninit,\n        length: new_len,\n    }\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity(), \"`at` out of bounds\");\n    // `self.length` is always smaller than `split_at`.\n    let new_uninit = self.uninit.split_at(at).unwrap();\n    // The first `at` elements stay in this vec.\n    let new_len = self.length.saturating_sub(at);\n    self.length -= new_len;\n    FixedVec {\n        uninit: new_uninit,\n        length: new_len,\n    }\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity(), \"`at` out of bounds\");\n    // `self.length` is always smaller than `split_at`.\n    let new_uninit = self.uninit.split_at(at).unwrap();\n    // The first `at` elements stay in this vec.\n    let new_len = self.length.saturating_sub(at);\n    self.length -= new_len;\n    FixedVec {\n        uninit: new_uninit,\n        length: new_len,\n    }\n}"
    ],
    [
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.strong_count() != 0 {\n        // Note: implicitely increments `strong`\n        let ptr = self.inner.as_non_null();\n        let len = self.inner.size();\n        unsafe {\n            // SAFETY: restored the memory that an rc has originally provided to the `Weak`. We are\n            // the only reference to it, so it is fine to restore the original unqiue allocation\n            // reference.\n            Some(Rc::from_raw(Uninit::from_memory(ptr.cast(), len)))\n        }\n    } else {\n        None\n    }\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.strong_count() != 0 {\n        // Note: implicitely increments `strong`\n        Some(Rc::from_raw(self.inner().clone()))\n    } else {\n        None\n    }\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.strong_count() != 0 {\n        // Note: implicitely increments `strong`\n        Some(Rc::from_raw(self.inner().as_ref().clone()))\n    } else {\n        None\n    }\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.strong_count() == 0 {\n        return None;\n    }\n    let inner = self.inner();\n    let rc = Rc { inner };\n    Some(rc)\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.strong_count() == 0 {\n        return None;\n    }\n    let inner = self.inner();\n    let rc = Rc {\n        inner: UninitView::from_memory(inner.as_non_null().cast(), inner.size()),\n    };\n    rc.inc_strong();\n    Some(rc)\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.strong_count() == 0 {\n        return None;\n    }\n    let inner = self.inner();\n    let ptr = inner.as_non_null();\n    let len = inner.size();\n    unsafe {\n        // SAFETY: restored the memory that an rc has originally provided to the `Weak`. We are\n        // the only reference to it, so it is fine to restore the original unqiue allocation\n        // reference.\n        Some(Rc::from_raw(Uninit::from_memory(ptr.cast(), len)))\n    }\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.strong_count() == 0 {\n        return None;\n    }\n    let inner = self.inner();\n    let inner = unsafe { &mut *inner.as_ptr() };\n    let rc = Rc::from_raw(inner.dec_strong());\n    Some(rc)\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.strong_count() == 0 {\n        return None;\n    }\n    let ptr = self.inner.as_non_null();\n    let len = self.inner.size();\n    unsafe {\n        // SAFETY: restored the memory that an rc has originally provided to the `Weak`. We are\n        // the only reference to it, so it is fine to restore the original unqiue allocation\n        // reference.\n        Some(Rc::from_raw(Uninit::from_memory(ptr.cast(), len)))\n    }\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.strong_count() == 0 {\n        return None;\n    }\n    let ptr = self.inner.as_non_null();\n    let len = self.inner.size();\n    unsafe {\n        // SAFETY: restored the memory that an rc has originally provided to the `Weak`. We are\n        // the only reference to it, so it is fine to restore the original unqiue allocation\n        // reference.\n        Some(Rc::from_raw(Uninit::from_memory(ptr.cast(), len).cast().unwrap()))\n    }\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.strong_count() == 0 {\n        return None;\n    }\n    let inner = self.inner();\n    let rc = Rc {\n        inner: UninitView::decast(inner.clone()),\n    };\n    rc.inc_strong();\n    Some(rc)\n}"
    ]
  ]
}