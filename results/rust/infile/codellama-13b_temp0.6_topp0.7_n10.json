{
  "benchmark": "rusteval_if",
  "lastest_eval": {
    "compile@1": 0.5211111111111111,
    "pass@1": 0.4155555555555556,
    "compile@3": 0.6647222222222221,
    "pass@3": 0.557037037037037,
    "compile@5": 0.709126984126984,
    "pass@5": 0.6159611992945327
  },
  "n": 10,
  "k": [
    1,
    3,
    5
  ],
  "fn_codes": [
    [
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let storage = vec![if bit { !0 } else { 0 }; blocks_for_bits::<B>(nbits)];\n    let nbits = nbits;\n    Self { storage, nbits }\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let storage = vec![bit.into(); blocks_for_bits(nbits)];\n    let nbits = nbits;\n    Self { storage, nbits }\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let nblocks = blocks_for_bits::<B>(nbits);\n    let mut storage = Vec::with_capacity(nblocks);\n    for _ in 0..nblocks {\n        storage.push(if bit { !B::zero() } else { B::zero() });\n    }\n    BitVec {\n        storage: storage,\n        nbits: nbits\n    }\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut storage = Vec::with_capacity(blocks_for_bits::<B>(nbits));\n    let mut nbits = nbits;\n    if nbits % B::bits() == 0 {\n        storage.push(if bit { !0 } else { 0 });\n        nbits -= B::bits();\n    }\n    while nbits >= B::bits() {\n        storage.push(if bit { !0 } else { 0 });\n        nbits -= B::bits();\n    }\n    if nbits > 0 {\n        storage.push(if bit { !0 } else { 0 });\n    }\n    BitVec {\n        storage: storage,\n        nbits: nbits\n    }\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let nblocks = blocks_for_bits::<B>(nbits);\n    let mut storage = Vec::with_capacity(nblocks);\n    let bit_block = if bit { !B::zero() } else { B::zero() };\n    for _ in 0..nblocks {\n        storage.push(bit_block);\n    }\n    BitVec {\n        storage: storage,\n        nbits: nbits\n    }\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let storage = vec![if bit { !0 } else { 0 }; blocks_for_bits::<B>(nbits)];\n    let nbits = nbits;\n    BitVec { storage, nbits }\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let nblocks = blocks_for_bits::<B>(nbits);\n    let mut storage = Vec::with_capacity(nblocks);\n    for _ in 0..nblocks {\n        storage.push(if bit { !B::zero() } else { B::zero() });\n    }\n    let mut bv = BitVec {\n        storage: storage,\n        nbits: nbits\n    };\n    if bit {\n        bv.set_nbits(nbits);\n    }\n    bv\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let nblocks = blocks_for_bits::<B>(nbits);\n    let mut storage = Vec::with_capacity(nblocks);\n    let bit_block = if bit { !B::zero() } else { B::zero() };\n    for _ in 0..nblocks {\n        storage.push(bit_block);\n    }\n    let mask = mask_for_bits::<B>(nbits);\n    BitVec { storage, nbits, mask }\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut storage = Vec::with_capacity(blocks_for_bits::<B>(nbits));\n    if bit {\n        storage.push(B::max_value());\n    }\n    let nbits = nbits % B::bits();\n    if nbits > 0 {\n        storage.push(mask_for_bits::<B>(nbits));\n    }\n    BitVec {\n        storage: storage,\n        nbits: nbits\n    }\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut storage = Vec::with_capacity(blocks_for_bits::<B>(nbits));\n    let nblocks = storage.len();\n    let mut last_block = B::zero();\n    if bit {\n        last_block = !B::zero();\n    }\n    if nblocks > 0 {\n        storage[nblocks - 1] = last_block;\n    }\n    BitVec {\n        storage: storage,\n        nbits: nbits\n    }\n}"
    ],
    [
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bit_vec = BitVec::with_capacity(len);\n    bit_vec.nbits = len;\n    for i in 0..len {\n        bit_vec.push(f(i));\n    }\n    bit_vec\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let nblocks = blocks_for_bits::<B>(len);\n    let mut bit_vec = BitVec {\n        storage: Vec::with_capacity(nblocks),\n        nbits: len,\n    };\n    for i in 0..nblocks {\n        let mut accumulator = B::zero();\n        for j in 0..B::bits() {\n            accumulator |= B::from_bool(f(i * B::bits() + j)) << j;\n        }\n        bit_vec.storage.push(accumulator);\n    }\n    bit_vec\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bit_vec = BitVec::with_capacity(len);\n    bit_vec.nbits = len;\n    for i in 0..len {\n        bit_vec.push(f(i));\n    }\n    bit_vec\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bit_vec = BitVec::with_capacity(len);\n    bit_vec.nbits = len;\n    for i in 0..len {\n        bit_vec.push(f(i));\n    }\n    bit_vec\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let nblocks = blocks_for_bits::<B>(len);\n    let mut bit_vec = BitVec {\n        storage: Vec::with_capacity(nblocks),\n        nbits: len,\n    };\n    for i in 0..nblocks {\n        bit_vec.storage.push(if f(i * B::bits()) { !B::zero() } else { B::zero() });\n    }\n    bit_vec\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bit_vec = BitVec::with_capacity(len);\n    for i in 0..len {\n        bit_vec.push(f(i));\n    }\n    bit_vec\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let nblocks = blocks_for_bits::<B>(len);\n    let mut bit_vec = BitVec {\n        storage: vec![B::zero(); nblocks],\n        nbits: len,\n    };\n    for i in 0..len {\n        if f(i) {\n            bit_vec.set(i, true);\n        }\n    }\n    bit_vec\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let nblocks = blocks_for_bits::<B>(len);\n    let mut bit_vec = BitVec {\n        storage: Vec::with_capacity(nblocks),\n        nbits: len,\n    };\n    for i in 0..nblocks {\n        bit_vec.storage.push(if f(i * B::bits()) { !B::zero() } else { B::zero() });\n    }\n    bit_vec.fix_last_block();\n    bit_vec\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let nblocks = blocks_for_bits::<B>(len);\n    let mut bit_vec = BitVec {\n        storage: Vec::with_capacity(nblocks),\n        nbits: len,\n    };\n    for i in 0..nblocks {\n        let mut block = B::zero();\n        for j in 0..B::bits() {\n            if f(i * B::bits() + j) {\n                block |= B::one() << j;\n            }\n        }\n        bit_vec.storage.push(block);\n    }\n    bit_vec\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bit_vec = BitVec::with_capacity(len);\n    bit_vec.nbits = len;\n    for i in 0..len {\n        bit_vec.storage.push(if f(i) { !B::zero() } else { B::zero() });\n    }\n    bit_vec\n}"
    ],
    [
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i < self.len() {\n        Some(self.storage[i / B::bits()].get_bit(i % B::bits()))\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i < self.len() {\n        Some(self.storage[i / B::bits()].get_bit(i % B::bits()))\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    // (1)\n    if i >= self.len() {\n        return None;\n    }\n    let block_index = i / B::bits();\n    let bit_index = i % B::bits();\n    let block = &self.storage[block_index];\n    let bit_mask = B::one() << bit_index;\n    Some((block & bit_mask) != B::zero())\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i >= self.len() {\n        None\n    } else {\n        let block_index = i / B::bits();\n        let bit_index = i % B::bits();\n        let bit_mask = B::one() << bit_index;\n        let block = &self.storage[block_index];\n        Some((*block & bit_mask) != B::zero())\n    }\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i < self.len() {\n        let block = i / B::bits();\n        let bit = i % B::bits();\n        Some(self.storage[block].get_bit(bit))\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    // (1)\n    if i >= self.len() {\n        None\n    } else {\n        let (block_index, bit_index) = self.block_index(i);\n        let block = self.storage[block_index];\n        Some(block.get_bit(bit_index))\n    }\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i >= self.len() {\n        None\n    } else {\n        let (block_index, bit_index) = self.index_to_bits(i);\n        let block = &self.storage[block_index];\n        let bit_mask = B::one() << bit_index;\n        Some(block & bit_mask != B::zero())\n    }\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i < self.len() {\n        let block = i / B::bits();\n        let bit = i % B::bits();\n        Some((self.storage[block] & (B::one() << bit)) != B::zero())\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i >= self.len() {\n        return None;\n    }\n    let (block_index, bit_index) = self.block_index(i);\n    let block = &self.storage[block_index];\n    let bit = block & (B::one() << bit_index);\n    Some(bit != B::zero())\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i >= self.len() {\n        return None;\n    }\n    let block_index = i / B::bits();\n    let bit_index = i % B::bits();\n    let block = &self.storage[block_index];\n    let bit = block & (B::one() << bit_index);\n    Some(bit != B::zero())\n}"
    ],
    [
      "pub fn set (&mut self, i: usize, x: bool) {\n    self.ensure_invariant();\n    if i >= self.nbits {\n        panic!(\"index out of bounds: the len is {} but the index is {}\", self.nbits, i);\n    }\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let block = self.storage.get_mut(w).expect(\"index out of bounds\");\n    if x {\n        *block |= B::one() << b;\n    } else {\n        *block &= !(B::one() << b);\n    }\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    let extra_bits = self.len() % B::bits();\n    if extra_bits > 0 {\n        let mask = (B::one() << extra_bits) - B::one();\n        let storage_len = self.storage.len();\n        let (last_block, used_bits) = (&mut self.storage[storage_len - 1], mask);\n        *last_block = *last_block & used_bits;\n    }\n    if i >= self.nbits {\n        panic!(\"Index out of bounds\");\n    }\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let block = self.storage.get_mut(w).unwrap();\n    if x {\n        *block = *block | (B::one() << b);\n    } else {\n        *block = *block & !(B::one() << b);\n    }\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    self.ensure_invariant();\n    if i >= self.nbits {\n        panic!(\"index out of bounds\");\n    }\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let mask = B::one() << b;\n    if x {\n        self.storage[w] |= mask;\n    } else {\n        self.storage[w] &= !mask;\n    }\n    self.fix_last_block();\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    let extra_bits = self.len() % B::bits();\n    if extra_bits > 0 {\n        let mask = (B::one() << extra_bits) - B::one();\n        let storage_len = self.storage.len();\n        if i >= self.nbits {\n            panic!(\"index out of bounds\");\n        }\n        let w = i / B::bits();\n        let b = i % B::bits();\n        if w == storage_len - 1 {\n            self.storage[w] = (self.storage[w] & !(B::one() << b)) | ((x as B) << b);\n        } else {\n            self.storage[w] = (self.storage[w] & !(B::one() << b)) | ((x as B) << b);\n            self.storage[w + 1] = self.storage[w + 1] & mask;\n        }\n    } else {\n        if i >= self.nbits {\n            panic!(\"index out of bounds\");\n        }\n        let w = i / B::bits();\n        let b = i % B::bits();\n        self.storage[w] = (self.storage[w] & !(B::one() << b)) | ((x as B) << b);\n    }\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    let extra_bits = self.len() % B::bits();\n    if extra_bits > 0 {\n        let mask = (B::one() << extra_bits) - B::one();\n        let storage_len = self.storage.len();\n        if i >= self.nbits {\n            panic!(\"Index out of bounds\");\n        }\n        let w = i / B::bits();\n        let b = i % B::bits();\n        if w == storage_len - 1 {\n            self.storage[w] = (self.storage[w] & !(B::one() << b)) | (x as B << b);\n        } else {\n            self.storage[w] = (self.storage[w] & !(B::one() << b)) | (x as B << b);\n        }\n    } else {\n        if i >= self.nbits {\n            panic!(\"Index out of bounds\");\n        }\n        let w = i / B::bits();\n        let b = i % B::bits();\n        self.storage[w] = (self.storage[w] & !(B::one() << b)) | (x as B << b);\n    }\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    self.ensure_invariant();\n    assert!(i < self.nbits, \"index out of bounds\");\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let flag = B::one() << b;\n    if x {\n        self.storage[w] |= flag;\n    } else {\n        self.storage[w] &= !flag;\n    }\n    self.fix_last_block();\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    self.ensure_invariant();\n    if i >= self.nbits {\n        panic!(\"index out of bounds: the len is {} but the index is {}\", self.nbits, i);\n    }\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let bit = B::one() << b;\n    let flag = if x { bit } else { B::zero() };\n    let old = self.storage[w];\n    let new = old ^ (old ^ flag);\n    self.storage[w] = new;\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    self.ensure_invariant();\n    if i >= self.nbits {\n        panic!(\"index out of bounds\");\n    }\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let mask = B::one() << b;\n    let flag = if x { mask } else { B::zero() };\n    self.storage[w] = self.storage[w].wrapping_add(flag.wrapping_sub(self.storage[w] & mask));\n    self.fix_last_block();\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    self.ensure_invariant();\n    assert!(i < self.nbits, \"index out of bounds\");\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let mask = B::one() << b;\n    let flag = if x { mask } else { B::zero() };\n    self.storage[w] = self.storage[w] & !mask | flag;\n    self.fix_last_block();\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    self.ensure_invariant();\n    if i >= self.nbits {\n        panic!(\"index out of bounds\");\n    }\n    let w = i / B::bits();\n    let b = i % B::bits();\n    let mask = B::one() << b;\n    if x {\n        self.storage[w] |= mask;\n    } else {\n        self.storage[w] &= !mask;\n    }\n    self.fix_last_block();\n}"
    ],
    [
      "pub fn negate (&mut self) {\n    for w in &mut self.storage { *w = !*w; }\n    self.fix_last_block();\n}",
      "pub fn negate (&mut self) {\n    for w in &mut self.storage {\n        *w = !*w;\n    }\n    self.fix_last_block();\n}",
      "pub fn negate (&mut self) {\n    self.ensure_invariant();\n    for w in &mut self.storage { *w = !*w; }\n    self.fix_last_block();\n}",
      "pub fn negate (&mut self) {\n    self.ensure_invariant();\n    for w in &mut self.storage { *w = !*w; }\n    self.fix_last_block();\n}",
      "pub fn negate (&mut self) {\n    for w in &mut self.storage { *w = !*w; }\n    self.fix_last_block();\n}",
      "pub fn negate (&mut self) {\n    for w in &mut self.storage { *w = !*w; }\n    self.fix_last_block();\n}",
      "pub fn negate (&mut self) {\n    self.ensure_invariant();\n    for w in &mut self.storage {\n        *w = !*w;\n    }\n    self.fix_last_block();\n}",
      "pub fn negate (&mut self) {\n    self.ensure_invariant();\n    for w in &mut self.storage {\n        *w = !*w;\n    }\n    self.fix_last_block();\n}",
      "pub fn negate (&mut self) {\n    self.ensure_invariant();\n    for w in &mut self.storage {\n        *w = !*w;\n    }\n    self.fix_last_block();\n}",
      "pub fn negate (&mut self) {\n    self.ensure_invariant();\n    for w in &mut self.storage {\n        *w = !*w;\n    }\n    self.fix_last_block();\n}"
    ],
    [
      "pub fn all (&self) -> bool {\n    let mut result = true;\n    for i in 0..self.storage.len() {\n        result = result && self.storage[i] == u64::max_value();\n    }\n    result\n}",
      "pub fn all (&self) -> bool {\n    self.blocks.iter().all(|&b| b == !0)\n}",
      "pub fn all (&self) -> bool {\n    self.blocks.iter().all(|b| b.all())\n}",
      "pub fn all (&self) -> bool {\n    let mut all = true;\n    for i in 0..self.len() {\n        if !self.get(i) {\n            all = false;\n            break;\n        }\n    }\n    all\n}",
      "pub fn all (&self) -> bool {\n    self.blocks.iter().all(|b| b.all())\n}",
      "pub fn all (&self) -> bool {\n    self.blocks.iter().all(|b| b.all())\n}",
      "pub fn all (&self) -> bool {\n    self.blocks.iter().all(|&block| block == !0)\n}",
      "pub fn all (&self) -> bool {\n    self.process(0, |w| w == !0)\n}",
      "pub fn all (&self) -> bool {\n    self.blocks.iter().all(|&b| b == u32::max_value())\n}",
      "pub fn all (&self) -> bool {\n    self.blocks.iter().all(|b| b.all())\n}"
    ],
    [
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::with_capacity(self.nbits / 8);\n    let mut i = 0;\n    let mut byte = 0;\n    let mut count = 0;\n    for &block in &self.storage {\n        for j in 0..B::bits() {\n            if self.get(i).unwrap() {\n                byte |= 1 << (B::bits() - j - 1);\n            }\n            count += 1;\n            i += 1;\n            if count == 8 {\n                bytes.push(byte);\n                count = 0;\n                byte = 0;\n            }\n        }\n    }\n    if count > 0 {\n        bytes.push(byte);\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::new();\n    for (i, b) in self.blocks().enumerate() {\n        if i == 0 {\n            bytes.push(b.to_bytes()[0]);\n        } else {\n            bytes.push(b.to_bytes()[1]);\n        }\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::with_capacity(self.len() / 8);\n    for (i, word) in self.storage.iter().enumerate() {\n        let mut byte = 0;\n        for j in 0..8 {\n            if self.get(i * 8 + j) {\n                byte |= 1 << (7 - j);\n            }\n        }\n        bytes.push(byte);\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::new();\n    let mut byte = 0;\n    let mut bit = 0;\n    for b in self.blocks() {\n        for i in 0..B::bits() {\n            if b & (B::one() << (B::bits() - i - 1)) != B::zero() {\n                byte |= 1 << (7 - bit);\n            }\n            bit += 1;\n            if bit == 8 {\n                bytes.push(byte);\n                byte = 0;\n                bit = 0;\n            }\n        }\n    }\n    if bit != 0 {\n        bytes.push(byte);\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::new();\n    for (i, b) in self.blocks().enumerate() {\n        let mut byte = 0;\n        for j in 0..B::bits() {\n            if b.get(j) {\n                byte |= 1 << (B::bits() - j - 1);\n            }\n        }\n        if i == self.storage.len() - 1 && self.nbits % B::bits() != 0 {\n            byte &= (1 << (self.nbits % B::bits())) - 1;\n        }\n        bytes.push(byte);\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut result = Vec::new();\n    let mut current_byte = 0;\n    let mut current_bit = 0;\n    for bit in self.blocks() {\n        for i in 0..B::bits() {\n            if bit & (B::one() << (B::bits() - 1 - i)) != B::zero() {\n                current_byte |= 1 << (7 - current_bit);\n            }\n            current_bit += 1;\n            if current_bit == 8 {\n                result.push(current_byte);\n                current_byte = 0;\n                current_bit = 0;\n            }\n        }\n    }\n    if current_bit > 0 {\n        result.push(current_byte);\n    }\n    result\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::new();\n    let mut byte = 0u8;\n    let mut bit = 0u8;\n    for b in self.blocks() {\n        for i in 0..B::bits() {\n            if b.get(i) {\n                byte |= 1 << (7 - bit);\n            }\n            bit += 1;\n            if bit == 8 {\n                bytes.push(byte);\n                byte = 0;\n                bit = 0;\n            }\n        }\n    }\n    if bit > 0 {\n        bytes.push(byte);\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut result = Vec::with_capacity(self.len() / 8 + 1);\n    let mut byte = 0;\n    let mut bit_count = 0;\n    for (i, bit) in self.iter().enumerate() {\n        if bit {\n            byte |= 1 << (7 - bit_count);\n        }\n        bit_count += 1;\n        if bit_count == 8 {\n            result.push(byte);\n            byte = 0;\n            bit_count = 0;\n        }\n    }\n    if bit_count > 0 {\n        result.push(byte);\n    }\n    result\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut v = Vec::with_capacity(self.nbits / 8);\n    let mut w = 0;\n    for i in 0..self.nbits {\n        if self.get(i).unwrap() {\n            w |= 1 << (7 - i % 8);\n        }\n        if i % 8 == 7 {\n            v.push(w);\n            w = 0;\n        }\n    }\n    if self.nbits % 8 != 0 {\n        v.push(w);\n    }\n    v\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::new();\n    for (i, &b) in self.blocks().enumerate() {\n        let w = i / 8;\n        let b = i % 8;\n        if b == 0 {\n            bytes.push(b);\n        } else {\n            bytes[w] |= b << (8 - b);\n        }\n    }\n    bytes\n}"
    ],
    [
      "pub fn grow (&mut self, n: usize, value: bool) {\n    let new_len = self.len() + n;\n    self.reserve(n);\n    for _ in 0..n {\n        self.push(value);\n    }\n    self.nbits = new_len;\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    let new_len = self.len() + n;\n    if new_len > self.capacity() {\n        let mut new_capacity = self.capacity();\n        new_capacity = new_capacity.checked_mul(2).expect(\"capacity overflow\");\n        if new_capacity < new_len {\n            new_capacity = new_len;\n        }\n        self.reserve_exact(new_capacity - self.capacity());\n    }\n    for _ in 0..n {\n        self.push(value);\n    }\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    self.ensure_invariant();\n    let new_len = self.len().checked_add(n).expect(\"capacity overflow\");\n    if new_len > self.capacity() {\n        self.reserve(new_len - self.len());\n    }\n    for _ in 0..n {\n        self.push(value);\n    }\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    let len = self.len();\n    self.reserve(n);\n    for _ in 0..n {\n        self.push(value);\n    }\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    let len = self.len();\n    self.reserve(n);\n    for _ in 0..n {\n        self.push(value);\n    }\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    self.ensure_invariant();\n    let new_len = self.len().checked_add(n).expect(\"capacity overflow\");\n    self.reserve(n);\n    let mut block = if value { !0 } else { 0 };\n    let mut block_idx = self.nbits / B::bits();\n    let mut nbits_rem = self.nbits % B::bits();\n    for _ in 0..n {\n        if nbits_rem == 0 {\n            self.storage[block_idx] = block;\n            block_idx += 1;\n            block = if value { !0 } else { 0 };\n            nbits_rem = B::bits();\n        } else {\n            let shift = B::bits() - nbits_rem;\n            block <<= shift;\n            nbits_rem = 0;\n        }\n    }\n    self.nbits = new_len;\n    self.fix_last_block();\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    let new_len = self.len() + n;\n    if new_len > self.capacity() {\n        self.reserve(new_len - self.capacity());\n    }\n    for _ in 0..n {\n        self.push(value);\n    }\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    self.reserve(n);\n    let mut i = 0;\n    while i < n {\n        self.push(value);\n        i += 1;\n    }\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    self.reserve(n);\n    for _ in 0..n {\n        self.push(value);\n    }\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    let len = self.len();\n    self.reserve(n);\n    for _ in 0..n {\n        self.push(value);\n    }\n}"
    ],
    [
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.is_empty() {\n        None\n    } else {\n        let new_nbits = self.nbits - 1;\n        let new_nblocks = blocks_for_bits::<B>(new_nbits);\n        let full_value = if self.get(new_nbits).unwrap() { !B::zero() } else { B::zero() };\n        self.nbits = new_nbits;\n        self.storage.truncate(new_nblocks);\n        self.fix_last_block();\n        Some(self.get(new_nbits).unwrap())\n    }\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.is_empty() {\n        None\n    } else {\n        let last_bit = self.nbits - 1;\n        let value = self[last_bit];\n        self.set(last_bit, false);\n        self.nbits -= 1;\n        Some(value)\n    }\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.is_empty() {\n        return None;\n    }\n\n    let new_nbits = self.nbits - 1;\n    let new_nblocks = blocks_for_bits::<B>(new_nbits);\n    let old_nblocks = blocks_for_bits::<B>(self.nbits);\n\n    // Remove the last bit\n    let last_block_idx = new_nblocks - 1;\n    let last_block = &mut self.storage[last_block_idx];\n    let last_bit_idx = self.nbits % B::bits();\n    let last_bit = last_block & (B::one() << last_bit_idx);\n    *last_block = *last_block & !(B::one() << last_bit_idx);\n\n    // Remove any empty words\n    let stop_idx = cmp::min(self.storage.len(), old_nblocks);\n    for idx in last_block_idx + 1..stop_idx {\n        self.storage.pop();\n    }\n\n    // Adjust internal bit count\n    self.nbits = new_nbits;\n\n    self.fix_last_block();\n\n    Some(last_bit != B::zero())\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    self.ensure_invariant();\n    if self.nbits == 0 {\n        return None;\n    }\n    let ret = self.get(self.nbits - 1).unwrap();\n    self.nbits -= 1;\n    self.fix_last_block();\n    Some(ret)\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.is_empty() {\n        return None;\n    }\n\n    let bit_pos = self.nbits - 1;\n    let block_idx = block_idx::<B>(bit_pos);\n    let bit_idx = bit_idx::<B>(bit_pos);\n    let block = &mut self.storage[block_idx];\n    let bit = *block & (B::one() << bit_idx);\n    *block = *block & !(B::one() << bit_idx);\n    self.nbits -= 1;\n    Some(bit != B::zero())\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    self.ensure_invariant();\n    if self.nbits == 0 {\n        return None;\n    }\n    let nbits = self.nbits;\n    let bit = self.get(nbits - 1).unwrap();\n    self.nbits -= 1;\n    Some(bit)\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.is_empty() {\n        return None;\n    }\n    let bit = self.get(self.len() - 1).unwrap();\n    self.set(self.len() - 1, false);\n    self.nbits -= 1;\n    Some(bit)\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.len() == 0 {\n        return None;\n    }\n    let last_bit = self.get(self.len() - 1).unwrap();\n    self.set(self.len() - 1, false);\n    self.nbits -= 1;\n    Some(last_bit)\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.len() == 0 {\n        return None;\n    }\n    let result = self.get(self.len() - 1).unwrap();\n    self.set(self.len() - 1, false);\n    self.nbits -= 1;\n    Some(result)\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.is_empty() {\n        None\n    } else {\n        let bit = self.get(self.len() - 1).unwrap();\n        self.set(self.len() - 1, false);\n        self.nbits -= 1;\n        Some(bit)\n    }\n}"
    ],
    [
      "pub fn push (&mut self, elem: bool) {\n    self.grow(1, elem);\n}",
      "pub fn push (&mut self, elem: bool) {\n    self.grow(1, elem);\n}",
      "pub fn push (&mut self, elem: bool) {\n    self.grow(1, elem);\n}",
      "pub fn push (&mut self, elem: bool) {\n    let len = self.len();\n    self.grow(1, false);\n    self.set(len, elem);\n}",
      "pub fn push (&mut self, elem: bool) {\n    self.grow(1, elem);\n}",
      "pub fn push (&mut self, elem: bool) {\n    self.grow(1, elem);\n}",
      "pub fn push (&mut self, elem: bool) {\n    self.grow(1, elem);\n}",
      "pub fn push (&mut self, elem: bool) {\n    self.grow(1, elem);\n}",
      "pub fn push (&mut self, elem: bool) {\n    self.grow(1, elem);\n}",
      "pub fn push (&mut self, elem: bool) {\n    self.grow(1, elem);\n}"
    ],
    [
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let coefficients = match degree {\n        PolynomialDegree::Infinity => vec![],\n        PolynomialDegree::Finite(degree) => (0..=degree)\n            .map(|_| Scalar::random())\n            .collect(),\n    };\n    Self { coefficients }\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let coefficients = iter::repeat_with(Scalar::random)\n        .take(degree.into() as usize + 1)\n        .collect();\n    Self { coefficients }\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let coefficients = iter::repeat_with(Scalar::random)\n        .take(degree.into())\n        .collect();\n    Self { coefficients }\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let coefficients = match degree {\n        PolynomialDegree::Infinity => vec![],\n        PolynomialDegree::Finite(degree) => {\n            let max_coefficient = Scalar::<E>::random();\n            let mut coefficients = Vec::with_capacity(degree as usize + 1);\n            coefficients.push(max_coefficient);\n            for _ in 0..degree {\n                let coefficient = Scalar::<E>::random();\n                coefficients.push(coefficient);\n            }\n            coefficients\n        }\n    };\n    Self { coefficients }\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let coefficients = iter::repeat_with(Scalar::random)\n        .take(degree.into() as usize + 1)\n        .collect();\n    Self::from_coefficients(coefficients)\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let coefficients = match degree {\n        PolynomialDegree::Infinity => vec![],\n        PolynomialDegree::Finite(degree) => {\n            let mut coefficients = vec![Scalar::random(); degree as usize];\n            coefficients.push(Scalar::zero());\n            coefficients\n        }\n    };\n    Self::from_coefficients(coefficients)\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let coefs = iter::repeat_with(Scalar::random)\n        .take(degree.into() as usize + 1)\n        .collect();\n    Self { coefs }\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let coefficients = iter::repeat_with(Scalar::random)\n        .take(degree.as_usize())\n        .collect();\n    Self { coefficients }\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let coefficients = iter::repeat_with(Scalar::random)\n        .take(degree.as_u16() + 1)\n        .collect();\n    Self::from_coefficients(coefficients)\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let mut coefficients = Vec::with_capacity(degree.to_usize() + 1);\n    for _ in 0..degree.to_usize() + 1 {\n        coefficients.push(Scalar::random());\n    }\n    Self { coefficients }\n}"
    ],
    [
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefs = vec![Scalar::zero(); usize::from(n) + 1];\n    coefs[0] = const_term;\n    for i in 1..usize::from(n) + 1 {\n        coefs[i] = Scalar::random();\n    }\n    Self::from_coefficients(coefs)\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = Vec::with_capacity(n as usize + 1);\n    coefficients.push(const_term);\n    coefficients.extend(iter::repeat_with(Scalar::random).take(n as usize));\n    Self::from_coefficients(coefficients)\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefs = vec![const_term];\n    coefs.extend(iter::repeat_with(Scalar::random).take(usize::from(n)));\n    Self::from_coefficients(coefs)\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = vec![const_term];\n    coefficients.extend(iter::repeat_with(Scalar::random).take(usize::from(n)));\n    Self::from_coefficients(coefficients)\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = Vec::with_capacity(n as usize + 1);\n    coefficients.push(const_term);\n    coefficients.extend(iter::repeat_with(Scalar::random).take(n as usize));\n    Self::from_coefficients(coefficients)\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefs = vec![const_term];\n    coefs.extend(iter::repeat_with(Scalar::random).take(n as usize));\n    Self::from_coefficients(coefs)\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = Vec::with_capacity(n as usize + 1);\n    coefficients.push(const_term);\n    coefficients.extend(iter::repeat_with(Scalar::random).take(n as usize));\n    Self { coefficients }\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefs = vec![const_term];\n    coefs.extend(iter::repeat_with(Scalar::random).take(usize::from(n)));\n    Self::from_coefficients(coefs)\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefs = Vec::with_capacity(n as usize + 1);\n    coefs.push(const_term);\n    coefs.extend(iter::repeat_with(Scalar::random).take(n as usize));\n    Self::from_coefficients(coefs)\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = vec![Scalar::zero(); n as usize + 1];\n    coefficients[0] = const_term;\n    Self::from_coefficients(coefficients)\n}"
    ],
    [
      "pub fn degree (&self) -> PolynomialDegree {\n    match self.coefficients.len() {\n        0 => PolynomialDegree::Infinity,\n        n => PolynomialDegree::Finite(n as u16 - 1),\n    }\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    match self.coefficients.len() {\n        0 => PolynomialDegree::Infinity,\n        n => PolynomialDegree::Finite(n as u16 - 1),\n    }\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    if self.coefficients.is_empty() {\n        PolynomialDegree::Infinity\n    } else {\n        PolynomialDegree::Finite(self.coefficients.len() - 1)\n    }\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    if self.coefficients.is_empty() {\n        PolynomialDegree::Infinity\n    } else {\n        PolynomialDegree::Finite(self.coefficients.len() - 1)\n    }\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    self.coefficients.iter().rposition(|&x| x != Scalar::zero()).map_or(PolynomialDegree::Infinity, |i| PolynomialDegree::Finite(i as u16))\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    match self.coefficients.len() {\n        0 => PolynomialDegree::Infinity,\n        len => PolynomialDegree::Finite(len as u16 - 1),\n    }\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    self.coefficients.iter().rposition(|x| x != &Scalar::zero()).map_or(PolynomialDegree::Infinity, |i| (i as u16).into())\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    match self.coefficients.len() {\n        0 => PolynomialDegree::Infinity,\n        len => PolynomialDegree::Finite(len - 1),\n    }\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    match self.coefficients.iter().rposition(|x| x != &Scalar::zero()) {\n        Some(degree) => PolynomialDegree::Finite(degree as u16),\n        None => PolynomialDegree::Infinity,\n    }\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    self.coefficients.iter().rposition(|x| *x != Scalar::zero()).map_or(PolynomialDegree::Infinity, |x| x.into())\n}"
    ],
    [
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = Scalar::zero();\n    for (i, coef) in self.coefficients().iter().enumerate() {\n        result += coef * point_x.pow(i as u32);\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = Scalar::zero();\n    for (i, a) in self.coefficients().iter().enumerate() {\n        result += a * &point_x.pow(i as u32);\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut res = Scalar::zero();\n    for (i, a) in self.coefficients().iter().enumerate() {\n        res += a * &point_x.pow(i as u32);\n    }\n    res\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut res = Scalar::zero();\n    for (i, coef) in self.coefficients().iter().enumerate() {\n        res += coef * &point_x.pow(i as u32);\n    }\n    res\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut res = Scalar::zero();\n    for (i, a) in self.coefficients().iter().enumerate() {\n        let mut x = point_x.clone();\n        for _ in 0..i {\n            x *= point_x;\n        }\n        res += a * x;\n    }\n    res\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = Scalar::zero();\n    for (i, coef) in self.coefficients().iter().enumerate() {\n        let mut tmp = coef.clone();\n        for _ in 0..i {\n            tmp *= point_x;\n        }\n        result += tmp;\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = Scalar::zero();\n    for (i, coefficient) in self.coefficients().iter().enumerate() {\n        result += coefficient * point_x.pow(i as u32);\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = Scalar::zero();\n    for (i, coefficient) in self.coefficients().iter().enumerate() {\n        let mut term = coefficient.clone();\n        for _ in 0..i {\n            term = &term * point_x;\n        }\n        result = &result + &term;\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = Scalar::zero();\n    for (i, coef) in self.coefficients().iter().enumerate() {\n        let mut tmp = Scalar::one();\n        for j in 0..i {\n            tmp *= point_x;\n        }\n        result += coef * tmp;\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut res = Scalar::zero();\n    for (i, coef) in self.coefficients().iter().enumerate() {\n        res += coef * point_x.pow(i as u32);\n    }\n    res\n}"
    ],
    [
      "pub fn back (&self) -> Option<&T> {\n    self.tail.map(|tail| &self.entries[tail.get()].value)\n}",
      "pub fn back (&self) -> Option<&T> {\n    self.tail.map(|tail| &self.entries[tail.get()].value)\n}",
      "pub fn back (&self) -> Option<&T> {\n    self.tail.map(|i| &self.entries[i.get()].value)\n}",
      "pub fn back (&self) -> Option<&T> {\n  self.tail.map(|tail| &self.entries[tail.get()].value)\n}",
      "pub fn back (&self) -> Option<&T> {\n    self.tail.map(|tail| &self.entries[tail.get()].value)\n}",
      "pub fn back (&self) -> Option<&T> {\n    self.tail.map(|i| &self.entries[i.get()].value)\n}",
      "pub fn back (&self) -> Option<&T> {\n  self.tail.map(|tail| &self.entries[tail.get()].value)\n}",
      "pub fn back (&self) -> Option<&T> {\n  self.tail.map(|tail| &self.entries[tail.get()].value)\n}",
      "pub fn back (&self) -> Option<&T> {\n    self.tail.map(|tail| &self.entries[tail.get()].value)\n}",
      "pub fn back (&self) -> Option<&T> {\n  self.tail.map(|tail| &self.entries[tail.get()].value)\n}"
    ],
    [
      "pub fn back_index (&self) -> Option<Index<T>> {\n  let index = self.tail?.get();\n  match &self.entries[index] {\n    Entry::Occupied(entry) => Some(Index {\n      generation: self.generation,\n      index,\n      _marker: PhantomData,\n    }),\n    _ => None,\n  }\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    self.tail.map(|tail| Index {\n        index: tail.get(),\n        generation: self.generation,\n    })\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    self.tail.map(|tail| Index {\n        index: tail.get(),\n        generation: self.generation,\n    })\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    self.tail.map(|tail| Index {\n        generation: self.generation,\n        index: tail.get(),\n    })\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    let index = self.tail?.get();\n    match &self.entries[index] {\n        Entry::Occupied(entry) => Some(Index {\n            generation: self.generation,\n            index,\n            value: &entry.value,\n        }),\n        _ => None,\n    }\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n  self.tail.map(|index| Index {\n    generation: self.generation,\n    index: index.get(),\n  })\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    let index = self.tail?.get();\n    match &self.entries[index] {\n        Entry::Occupied(entry) => Some(Index {\n            generation: self.generation,\n            index,\n            value: &entry.value,\n        }),\n        _ => None,\n    }\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    self.tail.map(|index| Index {\n        generation: self.generation,\n        index: index.get(),\n    })\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    self.tail.map(|index| Index {\n        generation: self.generation,\n        index: index.get(),\n    })\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n  let index = self.tail?.get();\n  Some(Index {\n    generation: self.generation,\n    index,\n  })\n}"
    ],
    [
      "pub fn clear (&mut self) {\n    self.entries.clear();\n    self.head = None;\n    self.tail = None;\n}",
      "pub fn clear (&mut self) {\n    self.entries.clear();\n    self.head = None;\n    self.tail = None;\n}",
      "pub fn clear (&mut self) {\n    self.entries.clear();\n    self.head = None;\n    self.tail = None;\n}",
      "pub fn clear (&mut self) {\n    self.entries.clear();\n    self.head = None;\n    self.tail = None;\n}",
      "pub fn clear (&mut self) {\n    self.entries.clear();\n    self.head = None;\n    self.tail = None;\n}",
      "pub fn clear (&mut self) {\n    self.entries.clear();\n    self.head = None;\n    self.tail = None;\n}",
      "pub fn clear (&mut self) {\n    self.entries.clear();\n    self.head = None;\n    self.tail = None;\n}",
      "pub fn clear (&mut self) {\n    self.entries.clear();\n    self.head = None;\n    self.tail = None;\n}",
      "pub fn clear (&mut self) {\n    self.entries.clear();\n    self.head = None;\n    self.tail = None;\n}",
      "pub fn clear (&mut self) {\n    self.entries.clear();\n    self.head = None;\n    self.tail = None;\n}"
    ],
    [
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?.get();\n    match &mut self.entries[index] {\n        Entry::Occupied(entry) => Some(&mut entry.value),\n        _ => None,\n    }\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?.get();\n    match &mut self.entries[index] {\n        Entry::Occupied(entry) => Some(&mut entry.value),\n        _ => None,\n    }\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?.get();\n\n    match &mut self.entries[index] {\n        Entry::Occupied(entry) => Some(&mut entry.value),\n        _ => None,\n    }\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?.get();\n    let entry = self.entries[index].occupied_mut();\n    Some(&mut entry.value)\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?.get();\n\n    match &mut self.entries[index] {\n        Entry::Occupied(entry) => Some(&mut entry.value),\n        _ => None,\n    }\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?.get();\n    let entry = self.entries[index].occupied_mut();\n    Some(&mut entry.value)\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?.get();\n    match &mut self.entries[index] {\n        Entry::Occupied(entry) => Some(&mut entry.value),\n        _ => None,\n    }\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?.get();\n\n    match &mut self.entries[index] {\n        Entry::Occupied(entry) => Some(&mut entry.value),\n        _ => None,\n    }\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?.get();\n    match &mut self.entries[index] {\n        Entry::Occupied(entry) => Some(&mut entry.value),\n        _ => None,\n    }\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    let index = self.head?.get();\n\n    match &mut self.entries[index] {\n        Entry::Occupied(entry) => Some(&mut entry.value),\n        _ => None,\n    }\n}"
    ],
    [
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let entry = self.entries[index.index.get()].occupied_ref();\n    if entry.generation == index.generation {\n        Some(&entry.value)\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let index = index.get();\n    let entry = self.entries[index].occupied_ref();\n    if entry.generation == index.generation {\n        Some(&entry.value)\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let index = index.get();\n    let entry = self.entries[index].occupied_ref();\n    if entry.generation == index.generation {\n        Some(&entry.value)\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let entry = self.entries[index.get()].occupied_ref();\n    if entry.generation == index.generation {\n        Some(&entry.value)\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let index = index.get();\n    let entry = self.entries[index].occupied_ref();\n    if entry.generation == index.generation {\n        Some(&entry.value)\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let entry = self.entries.get(index.get())?;\n    if entry.generation == index.generation {\n        Some(&entry.value)\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let entry = self.entries[index.get()].occupied_ref();\n    if entry.generation == index.generation {\n        Some(&entry.value)\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let entry = self.entries[index.get()].occupied_ref();\n    if entry.generation == index.generation {\n        Some(&entry.value)\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let index = index.get();\n    let entry = self.entries[index].occupied_ref();\n    if entry.generation == index.generation {\n        Some(&entry.value)\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let index = index.get();\n    let entry = self.entries[index].occupied_ref();\n    if entry.generation == index.generation {\n        Some(&entry.value)\n    } else {\n        None\n    }\n}"
    ],
    [
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    match self.entries.get(index.index())? {\n        Entry::Occupied(entry) if entry.generation == index.generation => Some(Index { index: entry.next, generation: entry.generation }),\n        _ => None,\n    }\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    let index = index.index();\n    let generation = index.generation();\n    let next_index = index + 1;\n    if next_index < self.entries.len() {\n        match self.entries.get(next_index)? {\n            Entry::Occupied(entry) => {\n                if entry.generation == generation {\n                    return Some(Index::new(next_index, generation));\n                }\n            }\n            _ => {}\n        }\n    }\n    None\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    match self.entries.get(index.index())? {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            match entry.next {\n                Some(next) => Some(Index { index: next, generation: entry.generation }),\n                None => None,\n            }\n        }\n        _ => None,\n    }\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    match self.entries.get(index.index())? {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            let next_index = index.index() + 1;\n            if next_index < self.entries.len() {\n                Some(Index::new(next_index, entry.generation))\n            } else {\n                None\n            }\n        }\n        _ => None,\n    }\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    let next_index = index.index() + 1;\n    if next_index < self.entries.len() {\n        let entry = self.entries.get(next_index)?;\n        match entry {\n            Entry::Occupied(entry) if entry.generation == index.generation => Some(Index::new(next_index, entry.generation)),\n            _ => None,\n        }\n    } else {\n        None\n    }\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    match self.entries.get(index.index())? {\n        Entry::Occupied(entry) if entry.generation == index.generation => {\n            match entry.next {\n                Some(next) => Some(Index::new(next, entry.generation)),\n                None => None,\n            }\n        },\n        _ => None,\n    }\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    match self.entries.get(index.index())? {\n        Entry::Occupied(entry) if entry.generation == index.generation => Some(Index {\n            index: entry.next,\n            generation: entry.generation,\n        }),\n        _ => None,\n    }\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    let index = index.index();\n    if index >= self.entries.len() {\n        return None;\n    }\n    let entry = self.entries.get(index)?;\n    match entry {\n        Entry::Occupied(entry) => {\n            if entry.generation != index.generation() {\n                return None;\n            }\n            let next_index = index + 1;\n            if next_index >= self.entries.len() {\n                return None;\n            }\n            let next_entry = self.entries.get(next_index)?;\n            match next_entry {\n                Entry::Occupied(next_entry) => {\n                    if next_entry.generation != index.generation() {\n                        return None;\n                    }\n                    Some(Index::new(next_index, index.generation()))\n                }\n                Entry::Vacant(_) => None,\n            }\n        }\n        Entry::Vacant(_) => None,\n    }\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    let next_index = index.index() + 1;\n    if next_index < self.entries.len() {\n        let entry = self.entries.get(next_index)?;\n        if let Entry::Occupied(entry) = entry {\n            return Some(Index { index: next_index, generation: entry.generation });\n        }\n    }\n    None\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    let index = index.index();\n    let next_index = index + 1;\n    if next_index < self.entries.len() {\n        Some(Index::new(next_index, self.entries[next_index].generation))\n    } else {\n        None\n    }\n}"
    ],
    [
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n  let index = index.index();\n  let target = target.index();\n  let entry = self.entries[index].occupied_mut();\n  let next = entry.next;\n  let previous = entry.previous;\n  self.update_link(previous, Some(target));\n  self.update_link(Some(index), next);\n  self.update_link(Some(target), Some(index));\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    let index = index.index();\n    let target = target.index();\n    if index == target {\n        panic!(\"index and target are the same\");\n    }\n    let index_entry = self.entries.get_mut(index).unwrap().occupied_mut();\n    let target_entry = self.entries.get_mut(target).unwrap().occupied_mut();\n    let next = index_entry.next;\n    let previous = index_entry.previous;\n    let next_next = target_entry.next;\n    let previous_previous = target_entry.previous;\n    index_entry.next = next_next;\n    index_entry.previous = Some(target);\n    target_entry.next = Some(index);\n    target_entry.previous = previous;\n    self.update_link(previous_previous, Some(index));\n    self.update_link(next, Some(target));\n    self.update_link(Some(index), next_next);\n    self.update_link(Some(target), previous_previous);\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n  if index == target {\n    panic!(\"Cannot move a node to be after itself\");\n  }\n  let index = self.entries[index.index()].occupied_mut();\n  let target = self.entries[target.index()].occupied_mut();\n  let next = target.next;\n  let previous = target.previous;\n  let next_index = next.map(|next| next.get());\n  let previous_index = previous.map(|previous| previous.get());\n  self.update_link(previous_index, Some(index.index()));\n  self.update_link(next_index, Some(index.index()));\n  self.update_link(Some(index.index()), next);\n  self.update_link(Some(index.index()), previous);\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    let index = index.index();\n    let target = target.index();\n    let entry = self.entries[index].occupied_mut();\n    let previous = entry.previous;\n    let next = entry.next;\n    let target_entry = self.entries[target].occupied_mut();\n    let target_previous = target_entry.previous;\n    let target_next = target_entry.next;\n    self.update_link(previous, Some(target));\n    self.update_link(Some(index), target_next);\n    self.update_link(target_previous, Some(index));\n    self.update_link(Some(target), next);\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n  if index == target {\n    return;\n  }\n  let index_entry = self.entries[index.index()].occupied_mut();\n  let target_entry = self.entries[target.index()].occupied_mut();\n  let next = target_entry.next;\n  let previous = target_entry.previous;\n  if let Some(next) = next {\n    let next_entry = self.entries[next.get()].occupied_mut();\n    next_entry.previous = Some(index);\n  } else {\n    self.tail = Some(index);\n  }\n  if let Some(previous) = previous {\n    let previous_entry = self.entries[previous.get()].occupied_mut();\n    previous_entry.next = Some(index);\n  } else {\n    self.head = Some(index);\n  }\n  index_entry.previous = Some(target);\n  index_entry.next = next;\n  target_entry.next = Some(index);\n  target_entry.previous = previous;\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    let index = index.index();\n    let target = target.index();\n    if index == target {\n        panic!(\"`index` and `target` cannot be the same\");\n    }\n    if index == self.head {\n        self.head = Some(NonMaxUsize::new(index));\n    }\n    if target == self.tail {\n        self.tail = Some(NonMaxUsize::new(index));\n    }\n    let entry = self.entries[index].occupied_mut();\n    let previous = entry.previous;\n    let next = entry.next;\n    if let Some(previous) = previous {\n        let previous_entry = self.entries[previous.get()].occupied_mut();\n        previous_entry.next = next;\n    }\n    if let Some(next) = next {\n        let next_entry = self.entries[next.get()].occupied_mut();\n        next_entry.previous = previous;\n    }\n    entry.previous = Some(NonMaxUsize::new(target));\n    entry.next = self.entries[target].occupied_ref().next;\n    if let Some(next) = entry.next {\n        let next_entry = self.entries[next.get()].occupied_mut();\n        next_entry.previous = Some(NonMaxUsize::new(index));\n    }\n    self.entries[target].occupied_mut().next = Some(NonMaxUsize::new(index));\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    let index = index.index();\n    let target = target.index();\n    let entry = self.entries.get_mut(index).unwrap().occupied_mut();\n    let target_entry = self.entries.get_mut(target).unwrap().occupied_mut();\n    if entry.generation != index.generation || target_entry.generation != target.generation {\n        panic!(\"Invalidated index\");\n    }\n    if index == target {\n        panic!(\"Cannot move index to itself\");\n    }\n    self.update_link(Some(NonMaxUsize::new(index)), target_entry.next);\n    self.update_link(target_entry.next, Some(NonMaxUsize::new(index)));\n    target_entry.next = Some(NonMaxUsize::new(index));\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n  let index = index.index();\n  let target = target.index();\n  if index == target {\n    panic!(\"Cannot move a node after itself.\");\n  }\n  let entry = self.entries.get_mut(index).expect(\"Invalid index.\");\n  let target_entry = self.entries.get_mut(target).expect(\"Invalid index.\");\n  let next = entry.next;\n  let previous = entry.previous;\n  let next_entry = self.entries.get_mut(next.unwrap().get()).expect(\"Invalid index.\");\n  let previous_entry = self.entries.get_mut(previous.unwrap().get()).expect(\"Invalid index.\");\n  next_entry.previous = Some(target);\n  previous_entry.next = Some(target);\n  target_entry.next = next;\n  target_entry.previous = Some(index);\n  entry.next = Some(target);\n  entry.previous = Some(previous);\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    let index = index.index();\n    let target = target.index();\n    if index == target {\n        panic!(\"Cannot move index to after itself.\");\n    }\n    let entry = self.entries.get_mut(index).unwrap().occupied_mut();\n    let target_entry = self.entries.get_mut(target).unwrap().occupied_mut();\n    let next = entry.next;\n    let previous = entry.previous;\n    let next_next = target_entry.next;\n    let previous_previous = target_entry.previous;\n    self.update_link(previous, Some(target));\n    self.update_link(Some(index), next_next);\n    self.update_link(previous_previous, Some(index));\n    self.update_link(Some(target), next);\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    if index == target {\n        return;\n    }\n    let index_entry = self.entries[index.index()].occupied_mut();\n    let target_entry = self.entries[target.index()].occupied_mut();\n    let index_next = index_entry.next;\n    let index_previous = index_entry.previous;\n    let target_next = target_entry.next;\n    let target_previous = target_entry.previous;\n    self.update_link(index_previous, Some(target));\n    self.update_link(target_next, Some(index));\n    self.update_link(target_previous, Some(index_next));\n    self.update_link(index_next, Some(target_next));\n}"
    ],
    [
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let previous_index = match &mut self.entries[index.index()] {\n        Entry::Occupied(entry) if entry.generation == index.generation => entry.previous,\n        _ => panic!(\"expected occupied entry with correct generation\"),\n    };\n    let new_index = self.insert_new(value, previous_index, Some(index.index()));\n    let entry = self.entries[index.index()].occupied_mut();\n    entry.previous = Some(new_index);\n\n    if Some(index.index) == self.head {\n        self.head = Some(new_index);\n    }\n\n    if let Some(previous_index) = previous_index {\n        self.entries[previous_index.get()].occupied_mut().next = Some(new_index);\n    }\n\n    Index::new(new_index, self.generation)\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let previous_index = match &mut self.entries[index.index()] {\n        Entry::Occupied(entry) if entry.generation == index.generation => entry.previous,\n        _ => panic!(\"expected occupied entry with correct generation\"),\n    };\n    let new_index = self.insert_new(value, previous_index, Some(index.index()));\n    let entry = self.entries[index.index()].occupied_mut();\n    entry.previous = Some(new_index);\n\n    if Some(index.index) == self.head {\n        self.head = Some(new_index);\n    }\n\n    if let Some(previous_index) = previous_index {\n        self.entries[previous_index.get()].occupied_mut().next = Some(new_index);\n    }\n\n    Index::new(new_index, self.generation)\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let previous_index = match &mut self.entries[index.index()] {\n        Entry::Occupied(entry) if entry.generation == index.generation => entry.previous,\n        _ => panic!(\"expected occupied entry with correct generation\"),\n    };\n    let new_index = self.insert_new(value, previous_index, Some(index.index()));\n    let entry = self.entries[index.index()].occupied_mut();\n    entry.previous = Some(new_index);\n\n    if Some(index.index) == self.head {\n        self.head = Some(new_index);\n    }\n\n    if let Some(previous_index) = previous_index {\n        self.entries[previous_index.get()].occupied_mut().next = Some(new_index);\n    }\n\n    Index::new(new_index, self.generation)\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let previous_index = match &mut self.entries[index.index()] {\n        Entry::Occupied(entry) if entry.generation == index.generation => entry.previous,\n        _ => panic!(\"expected occupied entry with correct generation\"),\n    };\n    let new_index = self.insert_new(value, previous_index, Some(index.index()));\n    let entry = self.entries[index.index()].occupied_mut();\n    entry.previous = Some(new_index);\n\n    if Some(index.index) == self.head {\n        self.head = Some(new_index);\n    }\n\n    if let Some(previous_index) = previous_index {\n        self.entries[previous_index.get()].occupied_mut().next = Some(new_index);\n    }\n\n    Index::new(new_index, self.generation)\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let previous_index = match &mut self.entries[index.index()] {\n        Entry::Occupied(entry) if entry.generation == index.generation => entry.previous,\n        _ => panic!(\"expected occupied entry with correct generation\"),\n    };\n    let new_index = self.insert_new(value, previous_index, Some(index.index()));\n    let entry = self.entries[index.index()].occupied_mut();\n    entry.previous = Some(new_index);\n\n    if Some(index.index) == self.head {\n        self.head = Some(new_index);\n    }\n\n    if let Some(previous_index) = previous_index {\n        self.entries[previous_index.get()].occupied_mut().next = Some(new_index);\n    }\n\n    Index::new(new_index, self.generation)\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let previous_index = match &mut self.entries[index.index()] {\n        Entry::Occupied(entry) if entry.generation == index.generation => entry.previous,\n        _ => panic!(\"expected occupied entry with correct generation\"),\n    };\n    let new_index = self.insert_new(value, previous_index, Some(index.index()));\n    let entry = self.entries[index.index()].occupied_mut();\n    entry.previous = Some(new_index);\n\n    if Some(index.index) == self.head {\n        self.head = Some(new_index);\n    }\n\n    if let Some(previous_index) = previous_index {\n        self.entries[previous_index.get()].occupied_mut().next = Some(new_index);\n    }\n\n    Index::new(new_index, self.generation)\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let previous_index = match &mut self.entries[index.index()] {\n        Entry::Occupied(entry) if entry.generation == index.generation => entry.previous,\n        _ => panic!(\"expected occupied entry with correct generation\"),\n    };\n    let new_index = self.insert_new(value, previous_index, Some(index.index()));\n    let entry = self.entries[index.index()].occupied_mut();\n    entry.previous = Some(new_index);\n\n    if Some(index.index) == self.head {\n        self.head = Some(new_index);\n    }\n\n    if let Some(previous_index) = previous_index {\n        self.entries[previous_index.get()].occupied_mut().next = Some(new_index);\n    }\n\n    Index::new(new_index, self.generation)\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let previous_index = match &mut self.entries[index.index()] {\n        Entry::Occupied(entry) if entry.generation == index.generation => entry.previous,\n        _ => panic!(\"expected occupied entry with correct generation\"),\n    };\n    let new_index = self.insert_new(value, previous_index, Some(index.index()));\n    let entry = self.entries[index.index()].occupied_mut();\n    entry.previous = Some(new_index);\n\n    if Some(index.index) == self.head {\n        self.head = Some(new_index);\n    }\n\n    if let Some(previous_index) = previous_index {\n        self.entries[previous_index.get()].occupied_mut().next = Some(new_index);\n    }\n\n    Index::new(new_index, self.generation)\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let previous_index = match &mut self.entries[index.index()] {\n        Entry::Occupied(entry) if entry.generation == index.generation => entry.previous,\n        _ => panic!(\"expected occupied entry with correct generation\"),\n    };\n    let new_index = self.insert_new(value, previous_index, Some(index.index()));\n    let entry = self.entries[index.index()].occupied_mut();\n    entry.previous = Some(new_index);\n\n    if Some(index.index) == self.head {\n        self.head = Some(new_index);\n    }\n\n    if let Some(previous_index) = previous_index {\n        self.entries[previous_index.get()].occupied_mut().next = Some(new_index);\n    }\n\n    Index::new(new_index, self.generation)\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let previous_index = match &mut self.entries[index.index()] {\n        Entry::Occupied(entry) if entry.generation == index.generation => entry.previous,\n        _ => panic!(\"expected occupied entry with correct generation\"),\n    };\n    let new_index = self.insert_new(value, previous_index, Some(index.index()));\n    let entry = self.entries[index.index()].occupied_mut();\n    entry.previous = Some(new_index);\n\n    if Some(index.index) == self.head {\n        self.head = Some(new_index);\n    }\n\n    if let Some(previous_index) = previous_index {\n        self.entries[previous_index.get()].occupied_mut().next = Some(new_index);\n    }\n\n    Index::new(new_index, self.generation)\n}"
    ],
    [
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    if minimum_capacity < self.length {\n        panic!(\"minimum capacity is less than the current length of the list\");\n    }\n    let mut map = HashMap::new();\n    let mut index = self.head;\n    let mut remaining = self.length;\n    let mut tail = self.tail;\n    let mut entries = self.entries.clone();\n    let mut head = self.head;\n    while remaining > 0 {\n        let next = entries[index].next;\n        entries[index].next = tail;\n        entries[tail].prev = index;\n        map.insert(Index(index), Index(tail));\n        tail = index;\n        index = next;\n        remaining -= 1;\n    }\n    self.entries = entries;\n    self.head = head;\n    self.tail = tail;\n    self.length = self.entries.len();\n    self.capacity = self.entries.capacity();\n    map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    if minimum_capacity < self.length {\n        panic!(\"minimum capacity must be at least the current length\");\n    }\n    let mut map = HashMap::new();\n    let mut new_tail = self.tail;\n    let mut new_head = self.head;\n    let mut new_entries = Vec::with_capacity(minimum_capacity);\n    let mut new_length = 0;\n    for index in self.iter() {\n        let value = self.remove(index).unwrap();\n        let new_index = new_length;\n        new_length += 1;\n        new_entries.push(value);\n        map.insert(index, new_index);\n        if new_tail == index {\n            new_tail = new_index;\n        }\n        if new_head == index {\n            new_head = new_index;\n        }\n    }\n    self.entries = new_entries;\n    self.head = new_head;\n    self.tail = new_tail;\n    self.length = new_length;\n    map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    if minimum_capacity < self.length {\n        panic!(\"minimum capacity must be at least the current length\");\n    }\n    let mut map = HashMap::new();\n    let mut head = self.head;\n    let mut tail = self.tail;\n    let mut entries = self.entries.clone();\n    for i in 0..self.length {\n        let index = Index::new(i);\n        let value = entries.remove(&index).unwrap();\n        if i == 0 {\n            head = index;\n        } else {\n            entries.insert(tail, value);\n            tail = index;\n        }\n        map.insert(index, index);\n    }\n    self.head = head;\n    self.tail = tail;\n    self.entries = entries;\n    self.capacity = minimum_capacity;\n    map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    if minimum_capacity < self.length {\n        panic!(\"minimum capacity must be at least the current length\");\n    }\n    let mut map = HashMap::new();\n    let mut head = self.head;\n    let mut tail = self.tail;\n    let mut entries = self.entries.clone();\n    let mut length = self.length;\n    for i in 0..self.length {\n        let index = Index::new(i);\n        let value = entries[index.get()];\n        if head.get() == index.get() {\n            head = index;\n        }\n        if tail.get() == index.get() {\n            tail = index;\n        }\n        map.insert(index, Index::new(i));\n        entries[i] = value;\n    }\n    self.head = head;\n    self.tail = tail;\n    self.entries = entries;\n    self.length = length;\n    map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    let mut map = HashMap::new();\n    if self.length == 0 {\n        self.entries.clear();\n        self.entries.resize(minimum_capacity, None);\n        self.head = 0;\n        self.tail = minimum_capacity;\n        return map;\n    }\n    let mut head = self.head;\n    let mut tail = self.tail;\n    let mut index = 0;\n    while index < self.length {\n        if let Some(entry) = self.entries[head].take() {\n            self.entries[tail] = Some(entry);\n            map.insert(Index::new(head), Index::new(tail));\n            tail = (tail + 1) % self.entries.len();\n            index += 1;\n        }\n        head = (head + 1) % self.entries.len();\n    }\n    self.head = 0;\n    self.tail = self.length;\n    self.entries.truncate(minimum_capacity);\n    self.entries.resize(minimum_capacity, None);\n    map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    if minimum_capacity < self.length {\n        panic!(\"minimum capacity must be greater than or equal to the current length of the list\");\n    }\n    let mut map = HashMap::new();\n    let mut new_head = self.head;\n    let mut new_tail = self.tail;\n    let mut new_length = self.length;\n    let mut new_entries = self.entries.clone();\n    for i in 0..self.length {\n        let index = self.index(i);\n        let value = self.entries[index].value.clone();\n        let new_index = new_length;\n        new_entries[new_index] = Entry {\n            value,\n            prev: new_head,\n            next: new_tail,\n        };\n        if new_head != Index::none() {\n            new_entries[new_head].next = new_index;\n        }\n        if new_tail != Index::none() {\n            new_entries[new_tail].prev = new_index;\n        }\n        new_head = new_index;\n        new_tail = Index::none();\n        new_length += 1;\n        map.insert(index, new_index);\n    }\n    self.head = new_head;\n    self.tail = new_tail;\n    self.length = new_length;\n    self.entries = new_entries;\n    map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    if minimum_capacity < self.length {\n        panic!(\"minimum capacity is less than the current length of the list\");\n    }\n    let mut map = HashMap::new();\n    let mut index = self.head;\n    let mut next = self.entries[index].next;\n    while next != self.tail {\n        let new_index = self.entries.len();\n        self.entries.push(Entry {\n            next: self.tail,\n            prev: self.tail,\n            value: None,\n        });\n        self.entries[new_index].value = Some(self.entries[next].value.take().unwrap());\n        self.entries[self.entries[next].prev].next = new_index;\n        self.entries[self.entries[next].next].prev = new_index;\n        map.insert(Index(next), Index(new_index));\n        next = self.entries[next].next;\n    }\n    self.head = self.entries.len();\n    self.tail = self.entries.len();\n    self.entries.push(Entry {\n        next: self.tail,\n        prev: self.tail,\n        value: None,\n    });\n    self.entries[self.head].value = Some(self.entries[index].value.take().unwrap());\n    self.entries[self.tail].prev = self.head;\n    self.entries[self.head].next = self.tail;\n    self.entries[self.tail].next = self.tail;\n    self.entries[self.tail].prev = self.tail;\n    self.entries.truncate(minimum_capacity);\n    map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    let mut map = HashMap::new();\n    if self.length == 0 {\n        self.entries.clear();\n        self.entries.resize(minimum_capacity, None);\n        self.head = 0;\n        self.tail = 0;\n        return map;\n    }\n    if minimum_capacity < self.length {\n        panic!(\"The given minimum capacity is less than the current length of the list.\");\n    }\n    let mut new_entries = Vec::with_capacity(minimum_capacity);\n    let mut new_head = 0;\n    let mut new_tail = 0;\n    let mut new_length = 0;\n    let mut index = self.head;\n    while index != self.tail {\n        if let Some(Some(value)) = self.entries.get(index) {\n            new_entries.push(Some(value));\n            new_length += 1;\n            map.insert(Index { index }, Index { index: new_tail });\n            new_tail += 1;\n        }\n        index = (index + 1) % self.entries.capacity();\n    }\n    self.entries = new_entries;\n    self.head = new_head;\n    self.tail = new_tail;\n    self.length = new_length;\n    map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    if minimum_capacity < self.length {\n        panic!(\"The given minimum capacity is less than the current length of the list.\");\n    }\n    let mut map = HashMap::new();\n    let mut index = self.head;\n    let mut remaining = self.length;\n    while remaining > 0 {\n        let entry = &mut self.entries[index];\n        if entry.is_removed() {\n            map.insert(entry.index, index);\n            entry.index = index;\n            entry.set_removed(false);\n        }\n        index = entry.next;\n        remaining -= 1;\n    }\n    self.tail = index;\n    self.entries.truncate(minimum_capacity);\n    map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    if minimum_capacity < self.length {\n        panic!(\"minimum capacity must be greater than or equal to length\");\n    }\n    let mut map = HashMap::new();\n    let mut new_head = self.head;\n    let mut new_tail = self.tail;\n    let mut new_length = 0;\n    let mut index = self.head;\n    while index != self.tail {\n        let entry = &self.entries[index];\n        if entry.is_removed() {\n            map.insert(index, index);\n            index = entry.next;\n            continue;\n        }\n        let new_index = if new_length == 0 {\n            new_head\n        } else {\n            self.entries[new_tail].next\n        };\n        self.entries[new_index] = entry.clone();\n        self.entries[new_index].next = new_index + 1;\n        self.entries[new_index].prev = new_tail;\n        self.entries[new_tail].next = new_index;\n        self.entries[new_tail].prev = new_index - 1;\n        new_tail = new_index;\n        new_length += 1;\n        map.insert(index, new_index);\n        index = entry.next;\n    }\n    self.head = new_head;\n    self.tail = new_tail;\n    self.length = new_length;\n    map\n}"
    ],
    [
      "pub fn pop_back (&mut self) -> Option<T> {\n    let index = self.tail?;\n    let entry = self.remove_entry(index).expect(\"expected occupied entry\");\n    let value = entry.value;\n    self.tail = entry.previous;\n    if let Some(previous) = entry.previous {\n        self.entries[previous.get()].next = None;\n    } else {\n        self.head = None;\n    }\n    self.length -= 1;\n    Some(value)\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    let mut entries = self.entries.as_mut_slice();\n    let mut next_index = self.tail;\n    let mut previous_index = None;\n    while let Some(index) = next_index {\n        let mut entry = entries.remove(index.get() as usize).expect(\"expected occupied entry\");\n        next_index = entry.next;\n        if let Some(previous) = previous_index {\n            entry.previous = Some(previous);\n        } else {\n            entry.previous = None;\n        }\n        entries.insert(index.get() as usize, entry);\n        previous_index = Some(index);\n    }\n    let mut entry = entries.remove(previous_index.expect(\"expected occupied entry\").get() as usize).expect(\"expected occupied entry\");\n    entry.next = None;\n    entries.insert(previous_index.expect(\"expected occupied entry\").get() as usize, entry);\n    self.tail = previous_index;\n    self.length = self.length.checked_sub(1).expect(\"overflow\");\n    if self.length == 0 {\n        self.head = None;\n        self.tail = None;\n    }\n    self.entries = entries.into();\n    self.vacant_head = None;\n    self.generation = self.generation.checked_add(1).expect(\"overflow\");\n    self.entries.last().map(|entry| match entry {\n        Entry::Occupied(entry) => entry.value,\n        Entry::Vacant(_) => unreachable!(),\n    })\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    let tail = self.tail?;\n    let index = Index::new(tail, self.generation);\n    self.remove(index)\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    let tail = self.tail?;\n    let entry = self.remove_entry(tail.get())?;\n    self.tail = entry.previous;\n    self.length -= 1;\n    Some(entry.into_value())\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    let mut index = self.tail;\n    let mut entry = self.remove_entry(index.unwrap());\n    if entry.is_none() {\n        return None;\n    }\n    entry = entry.unwrap();\n    let value = entry.value;\n    self.tail = entry.previous;\n    if self.tail.is_some() {\n        self.get_mut(self.tail.unwrap()).unwrap().next = None;\n    } else {\n        self.head = None;\n    }\n    self.length -= 1;\n    Some(value)\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    if self.tail.is_none() {\n        return None;\n    }\n    let tail = self.tail.unwrap();\n    let index = tail.get();\n    let entry = self.remove_entry(index).expect(\"expected occupied entry\");\n    self.tail = entry.previous;\n    if let Some(previous) = entry.previous {\n        let previous_index = previous.get();\n        let previous_entry = self.entries[previous_index].as_occupied_mut().expect(\"expected occupied entry\");\n        previous_entry.next = None;\n    } else {\n        self.head = None;\n    }\n    self.length -= 1;\n    Some(entry.value)\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    if self.tail.is_none() {\n        return None;\n    }\n    let tail = self.tail.unwrap();\n    let entry = self.remove_entry(tail).unwrap();\n    self.tail = entry.previous;\n    if self.tail.is_none() {\n        self.head = None;\n    }\n    self.length -= 1;\n    Some(entry.value)\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    let tail = self.tail?;\n    let entry = self.entries.get_mut(tail.get() as usize)?;\n    let value = entry.get_mut()?;\n    self.tail = entry.previous;\n    self.length -= 1;\n    Some(value)\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    let tail = self.tail?;\n    let entry = self.entries.get_mut(tail.get() as usize)?;\n    let value = entry.value();\n    if let Entry::Occupied(entry) = entry {\n        if entry.previous.is_none() {\n            self.head = entry.next;\n        } else {\n            let previous = entry.previous?;\n            self.entries[previous.get() as usize].next = entry.next;\n        }\n        if entry.next.is_none() {\n            self.tail = entry.previous;\n        } else {\n            let next = entry.next?;\n            self.entries[next.get() as usize].previous = entry.previous;\n        }\n    }\n    self.length -= 1;\n    Some(value)\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    let mut tail = self.tail;\n    if tail.is_none() {\n        return None;\n    }\n    let mut entry = self.remove_entry(tail.unwrap()).unwrap();\n    let value = entry.value;\n    if entry.previous.is_none() {\n        self.head = None;\n    } else {\n        self.get_mut(entry.previous.unwrap()).unwrap().next = None;\n    }\n    self.tail = entry.previous;\n    self.length -= 1;\n    self.vacant_head = Some(tail.unwrap());\n    Some(value)\n}"
    ],
    [
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let index = self.insert_entry(None, value);\n    self.tail = Some(index);\n    index\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    self.insert_entry(self.tail, value).index\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let index = self.allocate();\n    self.insert_entry(index, Entry::new(value));\n    index\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let index = self.insert_entry(self.tail, value);\n    self.tail = Some(index);\n    index\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let index = self.insert_entry(None, value);\n    self.tail = Some(index);\n    index\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let index = self.length;\n    self.length += 1;\n    self.insert_entry(index, value)\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    self.insert_entry(self.tail, value).index\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    self.insert_entry(self.tail, value).index\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let index = self.insert_entry(None, value);\n    self.tail = Some(index);\n    index\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let index = self.length;\n    self.insert_entry(index, value);\n    index\n}"
    ],
    [
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut index = self.head;\n    while let Some(index) = index {\n        let next_index = self.entries[index.get()].occupied().next;\n        if !predicate(&mut self.entries[index.get()].occupied_mut().value) {\n            self.remove_entry(index);\n        }\n        index = next_index;\n    }\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut index = self.head;\n    while let Some(current_index) = index {\n        let next_index = self.entries[current_index.get()].occupied().next;\n        if !predicate(&mut self.entries[current_index.get()].occupied_mut().value) {\n            self.remove_helper(self.entries[current_index.get()].occupied().previous, current_index, next_index);\n        }\n        index = next_index;\n    }\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n  let mut index = self.head;\n  while let Some(index) = index {\n    let next_index = self.entries[index.get()].next();\n    if let Entry::Occupied(entry) = &mut self.entries[index.get()] {\n      if !predicate(entry.get_mut()) {\n        self.remove_entry(index);\n      }\n    }\n    index = next_index;\n  }\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut index = self.head;\n    while let Some(index) = index {\n        let entry = &mut self.entries[index.get()];\n        let entry = match entry {\n            Entry::Occupied(entry) => entry,\n            Entry::Vacant(_) => unreachable!(),\n        };\n        let value = entry.get_mut();\n        if predicate(value) {\n            index = entry.next;\n        } else {\n            let next_index = entry.next;\n            self.remove_helper(entry.previous, index, next_index);\n            index = next_index;\n        }\n    }\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut index = self.head;\n    while let Some(index) = index {\n        let next_index = self.entries[index.get()].next();\n        if !predicate(self.entries[index.get()].get_mut()) {\n            self.remove_entry(index);\n        }\n        index = next_index;\n    }\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n  let mut index = self.head;\n  while let Some(entry_index) = index {\n    let next_index = self.entries[entry_index.get()].occupied().next;\n    if !predicate(self.entries[entry_index.get()].occupied_mut().get_mut()) {\n      self.remove_entry(entry_index);\n    }\n    index = next_index;\n  }\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut index = self.head;\n    while let Some(index) = index {\n        let entry = &mut self.entries[index.get()];\n        let next_index = entry.next;\n        if let Entry::Occupied(ref mut occupied_entry) = entry {\n            if !predicate(occupied_entry.get_mut()) {\n                self.remove_entry(index);\n            }\n        }\n        index = next_index;\n    }\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut index = self.head;\n    while let Some(index) = index {\n        let entry = &mut self.entries[index.get()];\n        if let Entry::Occupied(occupied_entry) = entry {\n            if predicate(&mut occupied_entry.value) {\n                index = occupied_entry.next;\n            } else {\n                let next_index = occupied_entry.next;\n                self.remove_helper(occupied_entry.previous, index, next_index);\n                index = next_index;\n            }\n        } else {\n            unreachable!(\"expected occupied entry\");\n        }\n    }\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut previous_index = self.head;\n    let mut index = previous_index.map(|index| index.get());\n    while let Some(index) = index {\n        let next_index = self.entries[index].next();\n        if predicate(&mut self.entries[index].value) {\n            previous_index = next_index;\n            index = next_index.map(|index| index.get());\n        } else {\n            self.remove_helper(previous_index, NonMaxUsize::new(index).unwrap(), next_index);\n            index = next_index.map(|index| index.get());\n        }\n    }\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut index = self.head;\n    while let Some(current_index) = index {\n        let next_index = self.entries[current_index.get()].occupied().next;\n        if !predicate(&mut self.entries[current_index.get()].occupied_mut().value) {\n            self.remove_entry(current_index);\n        }\n        index = next_index;\n    }\n}"
    ],
    [
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors: Vec<(u64, u64)> = Vec::new();\n    let mut last_lba = self.header.first_usable_lba;\n    for partition in self.iter() {\n        if partition.1.is_used() {\n            let partition_start = partition.1.starting_lba;\n            let partition_end = partition.1.ending_lba;\n            if partition_start > last_lba {\n                free_sectors.push((last_lba, partition_start - last_lba));\n            }\n            last_lba = partition_end + 1;\n        }\n    }\n    if self.header.last_usable_lba + 1 > last_lba {\n        free_sectors.push((last_lba, self.header.last_usable_lba + 1 - last_lba));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors: Vec<(u64, u64)> = Vec::new();\n    let mut last_free_sector = self.header.first_usable_lba;\n    for partition in self.iter() {\n        if partition.is_used() {\n            if last_free_sector < partition.starting_lba {\n                free_sectors.push((last_free_sector, partition.starting_lba - last_free_sector));\n            }\n            last_free_sector = partition.ending_lba + 1;\n        }\n    }\n    if last_free_sector < self.header.last_usable_lba {\n        free_sectors.push((last_free_sector, self.header.last_usable_lba - last_free_sector + 1));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors: Vec<(u64, u64)> = Vec::new();\n    let mut start_sector = self.header.first_usable_lba;\n    let mut end_sector = self.header.last_usable_lba;\n    let mut last_sector = self.header.last_usable_lba;\n    for partition in self.iter() {\n        if partition.1.is_used() {\n            if start_sector < partition.1.starting_lba {\n                free_sectors.push((start_sector, partition.1.starting_lba - start_sector));\n            }\n            start_sector = partition.1.ending_lba + 1;\n        }\n        if start_sector > end_sector {\n            break;\n        }\n    }\n    if start_sector <= end_sector {\n        free_sectors.push((start_sector, last_sector - start_sector + 1));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut partitions: Vec<&GPTPartitionEntry> =\n        self.partitions.iter().filter(|x| x.is_used()).collect();\n    partitions.sort_unstable_by_key(|x| x.starting_lba);\n    let mut free_sectors: Vec<(u64, u64)> = Vec::new();\n    let mut first_available = self.header.first_usable_lba;\n    for partition in partitions {\n        if first_available < partition.starting_lba {\n            free_sectors.push((first_available, partition.starting_lba - first_available));\n        }\n        first_available = partition.ending_lba + 1;\n    }\n    if first_available <= self.header.last_usable_lba {\n        free_sectors.push((first_available, self.header.last_usable_lba - first_available + 1));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut last_lba = self.header.first_usable_lba;\n    for partition in self.iter().filter(|(_, p)| p.is_used()) {\n        let partition_start = partition.1.starting_lba;\n        let partition_end = partition.1.ending_lba;\n        if partition_start > last_lba {\n            free_sectors.push((last_lba, partition_start - last_lba));\n        }\n        last_lba = partition_end + 1;\n    }\n    if last_lba < self.header.last_usable_lba {\n        free_sectors.push((last_lba, self.header.last_usable_lba - last_lba + 1));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut partitions: Vec<&GPTPartitionEntry> = self.partitions.iter().filter(|x| x.is_used()).collect();\n    partitions.sort_unstable_by_key(|x| x.starting_lba);\n    let mut free_sectors: Vec<(u64, u64)> = Vec::new();\n    let mut first_available = self.header.first_usable_lba;\n    for partition in partitions {\n        if partition.starting_lba > first_available {\n            free_sectors.push((first_available, partition.starting_lba - first_available));\n        }\n        first_available = partition.ending_lba + 1;\n    }\n    if first_available < self.header.last_usable_lba + 1 {\n        free_sectors.push((first_available, self.header.last_usable_lba + 1 - first_available));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors: Vec<(u64, u64)> = Vec::new();\n    let mut last_free_sector = self.header.first_usable_lba;\n    for partition in self.iter() {\n        if partition.is_used() {\n            if last_free_sector < partition.starting_lba {\n                free_sectors.push((last_free_sector, partition.starting_lba - last_free_sector));\n            }\n            last_free_sector = partition.ending_lba + 1;\n        }\n    }\n    if last_free_sector < self.header.last_usable_lba {\n        free_sectors.push((last_free_sector, self.header.last_usable_lba - last_free_sector + 1));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut partitions: Vec<&GPTPartitionEntry> = self.partitions.iter().filter(|x| x.is_used()).collect();\n    partitions.sort_unstable_by_key(|x| x.starting_lba);\n    let mut free_sectors: Vec<(u64, u64)> = Vec::new();\n    let mut first_available = self.header.first_usable_lba;\n    for partition in partitions {\n        if partition.starting_lba > first_available {\n            free_sectors.push((first_available, partition.starting_lba - first_available));\n        }\n        first_available = partition.ending_lba + 1;\n    }\n    if first_available < self.header.last_usable_lba + 1 {\n        free_sectors.push((first_available, self.header.last_usable_lba + 1 - first_available));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors: Vec<(u64, u64)> = Vec::new();\n    let mut last_free_sector = self.header.first_usable_lba;\n    for partition in self.iter() {\n        if partition.1.is_used() {\n            if last_free_sector < partition.1.starting_lba {\n                free_sectors.push((last_free_sector, partition.1.starting_lba - last_free_sector));\n            }\n            last_free_sector = partition.1.ending_lba + 1;\n        }\n    }\n    if last_free_sector < self.header.last_usable_lba {\n        free_sectors.push((last_free_sector, self.header.last_usable_lba - last_free_sector + 1));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors: Vec<(u64, u64)> = Vec::new();\n    let mut current_start = self.header.first_usable_lba;\n    let mut current_end = self.header.first_usable_lba;\n    for partition in self.iter() {\n        if partition.1.is_used() {\n            if current_start < partition.1.starting_lba {\n                free_sectors.push((current_start, partition.1.starting_lba - current_start));\n            }\n            current_start = partition.1.ending_lba + 1;\n            current_end = partition.1.ending_lba + 1;\n        }\n    }\n    if current_start < self.header.last_usable_lba {\n        free_sectors.push((current_start, self.header.last_usable_lba - current_start + 1));\n    }\n    free_sectors\n}"
    ],
    [
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    self.find_free_sectors()\n        .iter()\n        .filter(|(_, l)| *l >= size)\n        .min_by_key(|(_, l)| *l)\n        .map(|(i, _)| (i + size - 1) / self.align * self.align)\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    self.find_free_sectors()\n        .iter()\n        .filter(|(_, l)| *l >= size)\n        .min_by_key(|(_, l)| *l)\n        .map(|(i, _)| *i)\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    self.find_free_sectors()\n        .iter()\n        .filter(|(_, l)| *l >= size)\n        .min_by_key(|(_, l)| *l)\n        .map(|(i, _)| (i + size - 1) / self.align * self.align)\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    self.find_free_sectors()\n        .iter()\n        .filter(|(_, l)| *l >= size)\n        .min_by_key(|(_, l)| *l)\n        .map(|(i, l)| (i + l - size) / self.align * self.align)\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    self.find_free_sectors()\n        .iter()\n        .filter(|(_, l)| *l >= size)\n        .min_by_key(|(_, l)| *l)\n        .map(|(i, _)| (i + size - 1) / self.align * self.align)\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    self.find_free_sectors()\n        .iter()\n        .filter(|(_, l)| *l >= size)\n        .min_by_key(|(_, l)| *l)\n        .map(|(i, _)| (i + size - 1) / self.align * self.align)\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    self.find_free_sectors()\n        .iter()\n        .filter(|(_, l)| *l >= size)\n        .min_by_key(|(_, l)| *l)\n        .map(|(i, _)| (i + size - 1) / self.align * self.align)\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    self.find_free_sectors()\n        .iter()\n        .filter(|(_, l)| *l >= size)\n        .min_by_key(|(_, l)| *l)\n        .map(|(i, _)| (i + size - 1) / self.align * self.align)\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    self.find_free_sectors()\n        .iter()\n        .filter(|(_, l)| *l >= size)\n        .min_by_key(|(_, l)| *l)\n        .map(|(i, l)| (i + l - size) / self.align * self.align)\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    self.find_free_sectors()\n        .iter()\n        .filter(|(_, l)| *l >= size)\n        .min_by_key(|(_, l)| *l)\n        .map(|(i, _)| (i + size - 1) / self.align * self.align)\n}"
    ],
    [
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let mut max_size = 0;\n    for (_, l) in self.find_free_sectors() {\n        if l > max_size {\n            max_size = l;\n        }\n    }\n    Ok(max_size)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let mut max_size = 0;\n    for (_, size) in self.find_free_sectors() {\n        if size > max_size {\n            max_size = size;\n        }\n    }\n    Ok(max_size)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let mut size = 0;\n    for (_, l) in self.find_free_sectors() {\n        size = size.max(l);\n    }\n    Ok(size)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let mut free_sectors = self.find_free_sectors();\n    free_sectors.sort_by(|(_, l1), (_, l2)| l1.cmp(l2));\n    let max_size = free_sectors.last().map(|&(_, l)| l).unwrap_or(0);\n    Ok(max_size)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let mut max_size = 0;\n    for (i, l) in self.find_free_sectors() {\n        if l > max_size {\n            max_size = l;\n        }\n    }\n    Ok(max_size)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let mut max_size = 0;\n    for (_, l) in self.find_free_sectors() {\n        if l > max_size {\n            max_size = l;\n        }\n    }\n    Ok(max_size)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let mut max_size = 0;\n    for (_, size) in self.find_free_sectors() {\n        if size > max_size {\n            max_size = size;\n        }\n    }\n    Ok(max_size)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let mut free_sectors = self.find_free_sectors();\n    free_sectors.sort_by(|(_, l1), (_, l2)| l1.cmp(l2));\n    let mut max_size = 0;\n    for (_, l) in free_sectors {\n        if l > max_size {\n            max_size = l;\n        }\n    }\n    Ok(max_size)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let mut size = self.header.last_usable_lba + 1 - self.header.first_usable_lba;\n    size -= self.header.first_usable_lba;\n    size -= self.header.last_usable_lba;\n    size -= self.header.backup_lba;\n    size -= 2;\n    size /= self.align;\n    size *= self.align;\n    Ok(size)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let mut free_sectors = self.find_free_sectors();\n    free_sectors.sort_by(|(_, l1), (_, l2)| l1.cmp(l2));\n    free_sectors.first().map(|&(_, l)| l).ok_or(Error::NoFreeSpace)\n}"
    ],
    [
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let entry = self.get_partition_entry(partition_number)?;\n    let starting_byte = self.header.first_usable_lba * self.header.logical_block_size;\n    let ending_byte = entry.ending_lba * self.header.logical_block_size;\n    Ok(starting_byte..=ending_byte)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let partition = self.get_partition(partition_number)?;\n    let start = partition.starting_lba * self.header.logical_sector_size;\n    let end = partition.ending_lba * self.header.logical_sector_size;\n    Ok(start..=end)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let partition = self.get_partition(partition_number)?;\n    let start = self.header.first_usable_lba + partition.starting_lba;\n    let end = self.header.first_usable_lba + partition.ending_lba;\n    Ok(start..=end)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let partition = self.get_partition(partition_number)?;\n    let start = partition.starting_lba * self.sector_size;\n    let end = partition.ending_lba * self.sector_size;\n    Ok(start..=end)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let partition = self.get_partition(partition_number)?;\n    let starting_byte = self.header.lba_size * u64::from(partition.starting_lba);\n    let ending_byte = self.header.lba_size * u64::from(partition.ending_lba);\n    Ok(starting_byte..=ending_byte)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let partition = self.get_partition(partition_number)?;\n    let start = partition.starting_lba * self.header.sector_size;\n    let end = partition.ending_lba * self.header.sector_size;\n    Ok(start..=end)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let partition = self.get_partition(partition_number)?;\n    let starting_lba = partition.starting_lba;\n    let ending_lba = partition.ending_lba;\n    let first_lba = self.header.first_usable_lba;\n    let last_lba = self.header.last_usable_lba;\n    let sector_size = self.header.sector_size;\n    if ending_lba < starting_lba {\n        return Err(Error::InvalidPartition {\n            partition_number,\n            message: \"ending_lba is less than starting_lba\".into(),\n        });\n    }\n    let starting_byte = (starting_lba - first_lba) * sector_size;\n    let ending_byte = (ending_lba - first_lba + 1) * sector_size - 1;\n    Ok(starting_byte..=ending_byte)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let partition = self.get_partition(partition_number)?;\n    let start = self.header.first_usable_lba * self.header.logical_block_size;\n    let end = self.header.last_usable_lba * self.header.logical_block_size;\n    let start = partition.starting_lba * self.header.logical_block_size;\n    let end = partition.ending_lba * self.header.logical_block_size;\n    Ok(start..=end)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let entry = self.get_partition(partition_number)?;\n    let starting_byte = self.get_starting_byte(entry.starting_lba)?;\n    let ending_byte = self.get_ending_byte(entry.ending_lba)?;\n    Ok(starting_byte..=ending_byte)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let entry = self.get_partition_entry(partition_number)?;\n    let start = entry.starting_lba * self.header.sector_size;\n    let end = entry.ending_lba * self.header.sector_size;\n    Ok(start..=end)\n}"
    ],
    [
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}"
    ],
    [
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\n    assert_eq!(self.m, self.n);\n    let mut tr: T = T::zero();\n    for i in 0..self.m {\n        tr = tr + self.data[i * self.n + i];\n    }\n    tr\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\n    if self.m != self.n\n    {\n        panic!(\"Matrix must be square\");\n    }\n    let mut sum: T = T::zero();\n    for i in 0..self.m\n    {\n        sum = sum + self.data[i * self.m + i];\n    }\n    sum\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\n    if self.m != self.n\n    {\n        panic!(\"Matrix is not square\");\n    }\n    let mut sum: T = T::zero();\n    for i in 0..self.m\n    {\n        sum += self.data[i * self.n + i];\n    }\n    sum\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\n    if self.m != self.n\n    {\n        panic!(\"Matrix must be square\");\n    }\n    let mut tr: T = T::zero();\n    for i in 0..self.m\n    {\n        tr = tr + self.data[i * self.m + i];\n    }\n    tr\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\n    if self.m != self.n\n    {\n        panic!(\"The matrix is not a square matrix.\");\n    }\n    let mut tr: T = T::zero();\n    for i in 0..self.m\n    {\n        tr = tr + self.data[i * self.m + i];\n    }\n    tr\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\n    if self.m != self.n\n    {\n        panic!(\"The matrix is not square\");\n    }\n    let mut tr: T = T::zero();\n    for i in 0..self.m\n    {\n        tr += self.data[i * self.n + i];\n    }\n    tr\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\n    assert!(self.m == self.n, \"Matrix must be square\");\n    let mut tr: T = T::zero();\n    for i in 0..self.m\n    {\n        tr += self.data[i * self.m + i];\n    }\n    tr\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\n    assert!(self.m == self.n, \"The matrix must be square\");\n    let mut tr: T = T::zero();\n    for i in 0..self.m\n    {\n        tr += self.data[i * self.n + i];\n    }\n    tr\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\n    if self.m != self.n\n    {\n        panic!(\"Matrix must be square\");\n    }\n    let mut tr: T = T::zero();\n    for i in 0..self.m\n    {\n        tr = tr + self.data[i * self.m + i];\n    }\n    tr\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\n    if self.m != self.n\n    {\n        panic!(\"The matrix must be square\");\n    }\n    let mut tr: T = T::zero();\n    for i in 0..self.m\n    {\n        tr += self.data[i * self.n + i];\n    }\n    tr\n}"
    ],
    [
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\n    let (m, n): (usize, usize) = self.dim();\n\n    debug_assert!(row_s < m);\n    debug_assert!(row_e < m);\n    debug_assert!(column_s < n);\n    debug_assert!(column_e <= n);\n\n    let mut data: Vec<T> = Vec::with_capacity((row_e - row_s) * (column_e - column_s));\n\n    for i in row_s..row_e\n    {\n        for j in column_s..column_e\n        {\n            data.push(self.get(i, j));\n        }\n    }\n\n    General::new(row_e - row_s, column_e - column_s, data)\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\n    let (m, n): (usize, usize) = self.dim();\n\n    assert!(row_s < m);\n    assert!(row_e < m);\n    assert!(column_s < n);\n    assert!(column_e <= n);\n\n    let mut data: Vec<T> = Vec::with_capacity((row_e - row_s) * (column_e - column_s));\n\n    for i in row_s..row_e\n    {\n        for j in column_s..column_e\n        {\n            data.push(self.get(i, j));\n        }\n    }\n\n    General::new(row_e - row_s, column_e - column_s, data)\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\nlet (m, n): (usize, usize) = self.dim();\ndebug_assert!(row_s < m);\ndebug_assert!(row_e < m);\ndebug_assert!(column_s < n);\ndebug_assert!(column_e <= n);\n\nlet mut slice: Vec<T> = Vec::with_capacity(\n(row_e - row_s) * (column_e - column_s)\n);\n\nfor i in row_s..row_e\n{\nfor j in column_s..column_e\n{\nslice.push(self.get(i, j));\n}\n}\n\nGeneral::new(row_e - row_s, column_e - column_s, slice)\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\n    let (m, n): (usize, usize) = self.dim();\n\n    assert!(row_s < m);\n    assert!(row_e < m);\n    assert!(column_s < n);\n    assert!(column_e <= n);\n\n    let mut data: Vec<T> = Vec::with_capacity((row_e - row_s + 1) * (column_e - column_s + 1));\n\n    for i in row_s..=row_e\n    {\n        for j in column_s..=column_e\n        {\n            data.push(self.get((i, j)));\n        }\n    }\n\n    General::new(row_e - row_s + 1, column_e - column_s + 1, data)\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\nlet (m, n): (usize, usize) = self.dim();\n\ndebug_assert!(row_s < m);\ndebug_assert!(row_e < m);\ndebug_assert!(column_s < n);\ndebug_assert!(column_e <= n);\n\nlet mut slice: Vec<T> = Vec::with_capacity((row_e - row_s) * (column_e - column_s));\n\nfor i in row_s..row_e\n{\nfor j in column_s..column_e\n{\nslice.push(self.get(i, j));\n}\n}\n\nGeneral::new(row_e - row_s, column_e - column_s, slice)\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\nlet (m, n): (usize, usize) = self.dim();\n\ndebug_assert!(row_s < m);\ndebug_assert!(row_e < m);\ndebug_assert!(column_s < n);\ndebug_assert!(column_e <= n);\n\nlet mut data: Vec<T> = Vec::with_capacity((row_e - row_s) * (column_e - column_s));\n\nfor i in row_s..row_e\n{\nfor j in column_s..column_e\n{\ndata.push(self.get((i, j)));\n}\n}\n\nGeneral::new(row_e - row_s, column_e - column_s, data)\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\nlet (m, n): (usize, usize) = self.dim();\n\ndebug_assert!(row_s < m);\ndebug_assert!(row_e < m);\ndebug_assert!(column_s < n);\ndebug_assert!(column_e <= n);\n\nlet mut v: Vec<T> = Vec::with_capacity(row_e - row_s + 1);\n\nfor i in row_s..=row_e\n{\nlet mut row: Vec<T> = Vec::with_capacity(column_e - column_s + 1);\n\nfor j in column_s..=column_e\n{\nrow.push(self.get(i, j));\n}\n\nv.push(row.into_iter().product());\n}\n\nGeneral::new(row_e - row_s + 1, column_e - column_s + 1, v)\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\nlet (m, n): (usize, usize) = self.dim();\ndebug_assert!(row_s < m);\ndebug_assert!(row_e < m);\ndebug_assert!(column_s < n);\ndebug_assert!(column_e <= n);\n\nlet mut slice: Vec<T> = Vec::with_capacity((row_e - row_s + 1) * (column_e - column_s + 1));\n\nfor i in row_s..=row_e\n{\nfor j in column_s..=column_e\n{\nslice.push(self.get((i, j)));\n}\n}\n\nGeneral::new(row_e - row_s + 1, column_e - column_s + 1, slice)\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\n    let (m, n): (usize, usize) = self.dim();\n\n    debug_assert!(row_s < m);\n    debug_assert!(row_e < m);\n    debug_assert!(column_s < n);\n    debug_assert!(column_e <= n);\n\n    let mut slice: Vec<T> = Vec::with_capacity((row_e - row_s + 1) * (column_e - column_s + 1));\n\n    for i in row_s..row_e + 1\n    {\n        for j in column_s..column_e + 1\n        {\n            slice.push(self.get(i, j));\n        }\n    }\n\n    General::new(row_e - row_s + 1, column_e - column_s + 1, slice)\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\nlet (m, n): (usize, usize) = self.dim();\n\ndebug_assert!(row_s < m);\ndebug_assert!(row_e < m);\ndebug_assert!(column_s < n);\ndebug_assert!(column_e <= n);\n\nlet mut slice: Vec<T> = Vec::with_capacity((row_e - row_s + 1) * (column_e - column_s + 1));\n\nfor i in row_s..=row_e\n{\nfor j in column_s..=column_e\n{\nslice.push(self.get(i, j));\n}\n}\n\nGeneral::new(row_e - row_s + 1, column_e - column_s + 1, slice)\n}"
    ],
    [
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    debug_assert!(row < self.m);\n    debug_assert!(column < self.n);\n\n    for r in 0..slice.m {\n        for c in 0..slice.n {\n            self[[row + r, column + c]] = slice[[r, c]];\n        }\n    }\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    debug_assert!(row < self.m);\n    debug_assert!(column < self.n);\n    debug_assert!(row + slice.m <= self.m);\n    debug_assert!(column + slice.n <= self.n);\n\n    for r in 0..slice.m {\n        for c in 0..slice.n {\n            self[[row + r, column + c]] = slice[[r, c]];\n        }\n    }\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    debug_assert!(row < self.m);\n    debug_assert!(column < self.n);\n    debug_assert!(slice.m == self.m - row);\n    debug_assert!(slice.n == self.n - column);\n\n    for r in 0..slice.m {\n        for c in 0..slice.n {\n            self[[row + r, column + c]] = slice[[r, c]];\n        }\n    }\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    debug_assert!(row < self.m);\n    debug_assert!(column < self.n);\n\n    for r in 0..slice.m\n    {\n        for c in 0..slice.n\n        {\n            self[[row + r, column + c]] = slice[[r, c]];\n        }\n    }\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    let (slice_m, slice_n): (usize, usize) = slice.dim();\n    let (m, n): (usize, usize) = self.dim();\n\n    for r in 0..slice_m\n    {\n        for c in 0..slice_n\n        {\n            self[[row + r, column + c]] = slice[[r, c]];\n        }\n    }\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    debug_assert!(row < self.m);\n    debug_assert!(column < self.n);\n\n    for r in 0..slice.m {\n        for c in 0..slice.n {\n            self[[row + r, column + c]] = slice[[r, c]];\n        }\n    }\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    debug_assert!(row < self.m);\n    debug_assert!(column < self.n);\n\n    for r in 0..slice.m\n    {\n        for c in 0..slice.n\n        {\n            self[[row + r, column + c]] = slice[[r, c]];\n        }\n    }\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    debug_assert!(row < self.m);\n    debug_assert!(column < self.n);\n    debug_assert!(slice.m == self.m - row);\n    debug_assert!(slice.n == self.n - column);\n\n    for r in 0..slice.m {\n        for c in 0..slice.n {\n            self[[row + r, column + c]] = slice[[r, c]];\n        }\n    }\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    debug_assert!(row < self.m);\n    debug_assert!(column < self.n);\n\n    for r in 0..slice.m {\n        for c in 0..slice.n {\n            self[[row + r, column + c]] = slice[[r, c]];\n        }\n    }\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    debug_assert!(row < self.m);\n    debug_assert!(column < self.n);\n    debug_assert!(slice.m == self.m - row);\n    debug_assert!(slice.n == self.n - column);\n\n    for r in 0..slice.m {\n        for c in 0..slice.n {\n            self[[row + r, column + c]] = slice[[r, c]];\n        }\n    }\n    self\n}"
    ],
    [
      "pub fn dotp (&self, rhs: &Self) -> T {\n    self.data.dotp(&rhs.data)\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    let mut result: T = T::zero();\n    for i in 0..self.data.dim()\n    {\n        result += self.data[i] * rhs.data[i];\n    }\n    result\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    self.data.dotp(&rhs.data)\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    self.data.dotp(&rhs.data)\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    self.data.dotp(&rhs.data)\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    self.data.dotp(&rhs.data)\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    self.data.dotp(&rhs.data)\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    self.data.dotp(&rhs.data)\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    let mut result: T = T::zero();\n    for i in 0..self.data.ncols() {\n        result += self.data.get(0, i) * rhs.data.get(0, i);\n    }\n    result\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    self.data.dotp(&rhs.data)\n}"
    ],
    [
      "pub fn argmax (&self) -> usize {\n    let (m, n) = self.dim();\n    debug_assert_eq!(m, n);\n    debug_assert_eq!(n, 1);\n\n    let mut max_idx: usize = 0;\n    let mut max_val: T = self.data[[0, 0]];\n\n    for i in 1..m\n    {\n        let val: T = self.data[[i, 0]];\n        if val > max_val\n        {\n            max_idx = i;\n            max_val = val;\n        }\n    }\n\n    max_idx\n}",
      "pub fn argmax (&self) -> usize {\n    let mut max_value = self.data[[0, 0]];\n    let mut max_index = 0;\n\n    for i in 1..self.data.dim().0 {\n        if self.data[[i, 0]] > max_value {\n            max_value = self.data[[i, 0]];\n            max_index = i;\n        }\n    }\n\n    max_index\n}",
      "pub fn argmax (&self) -> usize {\n    let (m, n) = self.dim();\n    debug_assert_eq!(m, n);\n    let mut idx: usize = 0;\n    let mut max: T = self[[0, 0]];\n    for i in 1..m\n    {\n        let temp: T = self[[i, 0]];\n        if temp > max\n        {\n            max = temp;\n            idx = i;\n        }\n    }\n    idx\n}",
      "pub fn argmax (&self) -> usize {\n    let mut max = self.data[[0, 0]];\n    let mut idx = 0;\n    for i in 1..self.data.m {\n        if self.data[[i, 0]] > max {\n            max = self.data[[i, 0]];\n            idx = i;\n        }\n    }\n    idx\n}",
      "pub fn argmax (&self) -> usize {\n    let mut max_value = self.data[[0, 0]];\n    let mut max_index = 0;\n    for i in 1..self.data.m {\n        if self.data[[i, 0]] > max_value {\n            max_value = self.data[[i, 0]];\n            max_index = i;\n        }\n    }\n    max_index\n}",
      "pub fn argmax (&self) -> usize {\n    let (m, n) = self.dim();\n    debug_assert_ne!(m, 0);\n    debug_assert_eq!(n, 1);\n\n    let mut idx: usize = 0;\n    let mut max: T = self[[0, 0]];\n\n    for i in 0..m {\n        let value: T = self[[i, 0]];\n        if value > max {\n            max = value;\n            idx = i;\n        }\n    }\n\n    idx\n}",
      "pub fn argmax (&self) -> usize {\n    let (m, n) = self.dim();\n    debug_assert_eq!(m, 1);\n    debug_assert_eq!(n, 1);\n    let mut max_index = 0;\n    let mut max_value = self.data[[0, 0]];\n    for i in 1..m {\n        let value = self.data[[i, 0]];\n        if value > max_value {\n            max_value = value;\n            max_index = i;\n        }\n    }\n    max_index\n}",
      "pub fn argmax (&self) -> usize {\n    let (m, n) = self.dim();\n    debug_assert_eq!(m, 1);\n    debug_assert_eq!(n, 1);\n    let mut idx: usize = 0;\n    let mut max: T = self.data[[0, 0]];\n    for i in 0..m {\n        if self.data[[i, 0]] > max {\n            idx = i;\n            max = self.data[[i, 0]];\n        }\n    }\n    idx\n}",
      "pub fn argmax (&self) -> usize {\n    let (m, n) = self.dim();\n    debug_assert_eq!(m, 1);\n    debug_assert_eq!(n, 1);\n    let mut max_idx: usize = 0;\n    let mut max_val: T = self.data[[0, 0]];\n    for i in 0..m {\n        let val: T = self.data[[i, 0]];\n        if val > max_val {\n            max_idx = i;\n            max_val = val;\n        }\n    }\n    max_idx\n}",
      "pub fn argmax (&self) -> usize {\n    let (m, n) = self.dim();\n    debug_assert_eq!(m, 1);\n    debug_assert_eq!(n, 1);\n\n    let mut max_idx: usize = 0;\n    let mut max_val: T = self.data[[0, 0]];\n\n    for i in 1..m\n    {\n        let val: T = self.data[[i, 0]];\n\n        if val > max_val\n        {\n            max_val = val;\n            max_idx = i;\n        }\n    }\n\n    max_idx\n}"
    ],
    [
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    Vector {\n        data: self.data.get_slice(s, e),\n    }\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    let (m, n): (usize, usize) = self.dim();\n    assert!(s < m && e < m);\n\n    let mut vec: Vec<T> = Vec::with_capacity(e - s + 1);\n\n    for i in s..=e {\n        vec.push(self[i]);\n    }\n\n    Vector::new_column(vec)\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    Vector::new_column(self.data.get_slice(s, e))\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    Vector::new_column(self.data.get_slice(s, e))\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    Vector { data: self.data.get_slice(s, e, 0, 0) }\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    let (m, _n): (usize, usize) = self.dim();\n    assert!(s < m);\n    assert!(e < m);\n    assert!(s <= e);\n\n    let mut vec: Vec<T> = Vec::with_capacity(e - s + 1);\n\n    for i in s..e + 1\n    {\n        vec.push(self[i]);\n    }\n\n    Vector::new_column(vec)\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    Vector { data: self.data.get_slice(s, e) }\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    Vector::new_column(self.data.get_slice(s, e))\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    Vector {\n        data: self.data.get_slice(s, e, 0),\n    }\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    Vector::new_column(self.data.get_slice(s, e))\n}"
    ],
    [
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, n): (usize, usize) = self.dim();\n    if m == 1 {\n        debug_assert!(s < n);\n    } else {\n        debug_assert!(s < m);\n    }\n\n    for r in s..(s + rhs.len()) {\n        self[r] = rhs[r - s]\n    }\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, n): (usize, usize) = self.dim();\n    if m == 1 {\n        debug_assert!(s < n);\n    } else {\n        debug_assert!(s < m);\n    }\n\n    let (rhs_m, rhs_n): (usize, usize) = rhs.dim();\n    debug_assert!(rhs_m == rhs_n);\n    debug_assert!(rhs_m == (e - s + 1));\n\n    for r in s..(e + 1) {\n        self[r] = rhs[r - s]\n    }\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, n): (usize, usize) = self.dim();\n    debug_assert!(s < m);\n    debug_assert!(rhs.dim() == (m - s, 1));\n\n    for r in s..(m) {\n        self[r] = rhs[r - s];\n    }\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, n): (usize, usize) = self.dim();\n    if m == 1 {\n        debug_assert!(s < n);\n    } else {\n        debug_assert!(s < m);\n    }\n\n    for r in s..(s + rhs.dim().0) {\n        self[r] = rhs[r - s]\n    }\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, n): (usize, usize) = self.dim();\n    if m == 1 {\n        debug_assert!(s < n);\n    } else {\n        debug_assert!(s < m);\n    }\n\n    let (m, n): (usize, usize) = rhs.dim();\n    debug_assert!(m == n);\n\n    for r in s..(s + m) {\n        self[r] = rhs[r - s]\n    }\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, n): (usize, usize) = self.dim();\n    if m == 1 {\n        debug_assert!(s < n);\n    } else {\n        debug_assert!(s < m);\n    }\n\n    let rhs_dim: (usize, usize) = rhs.dim();\n    let rhs_m: usize = rhs_dim.0;\n    let rhs_n: usize = rhs_dim.1;\n\n    debug_assert!(rhs_m == rhs_n);\n    debug_assert!(rhs_m == (e - s + 1));\n\n    for r in s..(e + 1) {\n        self[r] = rhs[r - s]\n    }\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, n): (usize, usize) = self.dim();\n    if m == 1 {\n        debug_assert!(s < n);\n    } else {\n        debug_assert!(s < m);\n    }\n\n    let mut slice: Vector<T> = self.get_slice(s, s + rhs.dim().0 - 1);\n\n    for r in 0..rhs.dim().0 {\n        slice[r] = rhs[r];\n    }\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, n): (usize, usize) = self.dim();\n    debug_assert!(s < m);\n    debug_assert!(rhs.dim() == (m - s, 1));\n\n    for r in s..(m) {\n        self[r] = rhs[r - s]\n    }\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, n): (usize, usize) = self.dim();\n    if m == 1 {\n        debug_assert!(s < n);\n    } else {\n        debug_assert!(s < m);\n    }\n\n    for r in s..(s + rhs.dim().0) {\n        self[r] = rhs[r - s];\n    }\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, n): (usize, usize) = self.dim();\n    if m == 1 {\n        debug_assert!(s < n);\n    } else {\n        debug_assert!(s < m);\n    }\n\n    for r in s..(s + rhs.dim().0) {\n        self[r] = rhs[r - s];\n    }\n}"
    ],
    [
      "fn abs (&self) -> Self {\n    Complex {\n        re: (self.re * self.re + self.im * self.im).sqrt(),\n        im: T::zero(),\n    }\n}",
      "fn abs (&self) -> Self {\n    let re = self.re.abs();\n    let im = self.im.abs();\n    Complex::new(re.max(im), re.min(im))\n}",
      "fn abs (&self) -> Self {\n    let re: Self = self.re.powi(2);\n    let im: Self = self.im.powi(2);\n    re + im\n}",
      "fn abs (&self) -> Self {\n    Complex {\n        re: (self.re * self.re + self.im * self.im).sqrt(),\n        im: T::zero(),\n    }\n}",
      "fn abs (&self) -> Self {\n    self.clone()\n}",
      "fn abs (&self) -> Self {\n    Complex {\n        re: (self.re * self.re + self.im * self.im).sqrt(),\n        im: T::zero(),\n    }\n}",
      "fn abs (&self) -> Self {\n    let re_abs: T = self.re.abs();\n    let im_abs: T = self.im.abs();\n    let abs: T = (re_abs * re_abs + im_abs * im_abs).sqrt();\n    Complex { re: abs, im: T::zero() }\n}",
      "fn abs (&self) -> Self {\n    self.re.hypot(self.im)\n}",
      "fn abs (&self) -> Self {\n    Complex {\n        re: (self.re.powi(2) + self.im.powi(2)).sqrt(),\n        im: T::zero(),\n    }\n}",
      "fn abs (&self) -> Self {\n    let re: T = self.re.clone();\n    let im: T = self.im.clone();\n    let mut result: T = re.powi(2) + im.powi(2);\n    result = result.sqrt();\n    Complex {\n        re: result,\n        im: T::zero(),\n    }\n}"
    ],
    [
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty() {\n        panic!()\n    }\n    let mut coef: Vec<T> = Vec::new();\n    let n = root.len();\n    let mut k = n - 1;\n    let mut sum = T::zero();\n    while k >= 0 {\n        sum = sum + root[k];\n        coef.push(sum);\n        k = k - 1;\n    }\n    coef.reverse();\n    Polynomial { coef }\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty() {\n        panic!()\n    }\n    let n = root.len();\n    let mut coef = vec![T::zero(); n + 1];\n    coef[0] = T::one();\n    for i in 0..n {\n        let mut coef_i = T::one();\n        for j in 0..n {\n            if i != j {\n                coef_i *= -root[j] / (root[i] - root[j]);\n            }\n        }\n        coef[n - i] = coef_i;\n    }\n    Polynomial::from_coef(coef)\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty() {\n        panic!()\n    }\n    let mut coef: Vec<T> = Vec::new();\n    let n = root.len();\n    for i in 0..n {\n        let mut c: T = T::zero();\n        for j in 0..n {\n            if i == j {\n                continue;\n            }\n            c = c - root[j] * T::one();\n        }\n        coef.push(c);\n    }\n    Polynomial { coef }\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty() {\n        panic!()\n    }\n    let n: usize = root.len();\n    let mut coef: Vec<T> = vec![T::zero(); n + 1];\n    for i in 0..n {\n        for j in 0..n {\n            if i == j {\n                coef[i] = T::zero();\n            } else {\n                coef[i] = -root[j] * root[i];\n            }\n        }\n    }\n    coef[n] = T::one();\n    Polynomial::from_coef(coef)\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty() {\n        panic!()\n    }\n    let n = root.len();\n    let mut coef = Vec::with_capacity(n);\n    coef.push(T::one());\n    for i in 0..n {\n        let mut coef_i = T::zero();\n        for j in 0..n {\n            if i == j {\n                continue;\n            }\n            coef_i -= root[j] * coef[i - j - 1];\n        }\n        coef.push(coef_i);\n    }\n    coef.reverse();\n    Polynomial { coef }\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty() {\n        panic!()\n    }\n    let n: usize = root.len();\n    let mut coef: Vec<T> = Vec::with_capacity(n + 1);\n    coef.push(T::one());\n    for i in 0..n {\n        let mut term: T = T::zero();\n        for j in 0..n {\n            if i != j {\n                term = term - root[i] * root[j];\n            }\n        }\n        coef.push(term);\n    }\n    Polynomial { coef }\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty() {\n        panic!()\n    }\n    let mut coef: Vec<T> = Vec::new();\n    let mut coef_len = root.len() - 1;\n    for i in 0..root.len() {\n        let mut sum = T::zero();\n        for j in 0..root.len() {\n            if i != j {\n                sum = sum + root[j];\n            }\n        }\n        coef.push(sum);\n    }\n    Polynomial { coef }\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty() {\n        panic!()\n    }\n    let mut coef: Vec<T> = Vec::with_capacity(root.len() + 1);\n    let mut root_i = root.len() - 1;\n    let mut root_j = root.len() - 2;\n    let mut root_k = root.len() - 3;\n    coef.push(root[root_k] * root[root_j] * root[root_i]);\n    while root_i > 0\n    {\n        root_k -= 1;\n        root_j -= 1;\n        root_i -= 1;\n        coef.push(root[root_k] * root[root_j] * root[root_i]\n            + root[root_k] * root[root_i] * root[root_j]\n            + root[root_j] * root[root_i] * root[root_k]);\n    }\n    while root_j > 0\n    {\n        root_k -= 1;\n        root_j -= 1;\n        coef.push(root[root_k] * root[root_j] * root[root_j]\n            + root[root_k] * root[root_j] * root[root_j]\n            + root[root_j] * root[root_j] * root[root_k]);\n    }\n    while root_k > 0\n    {\n        root_k -= 1;\n        coef.push(root[root_k] * root[root_k] * root[root_k]);\n    }\n    coef.push(T::one());\n    coef.reverse();\n    Polynomial { coef }\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty() {\n        panic!()\n    }\n    let mut coef: Vec<T> = Vec::with_capacity(root.len() + 1);\n    coef.push(T::one());\n    for i in 0..root.len() {\n        coef.push(-root[i]);\n    }\n    Polynomial::from_coef(coef)\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty() {\n        panic!()\n    }\n    let mut coef: Vec<T> = Vec::new();\n    let n = root.len();\n    for i in 0..n {\n        let mut term: T = T::zero();\n        for j in 0..n {\n            if i == j {\n                term = term - root[j];\n            } else {\n                term = term - root[j] * root[i];\n            }\n        }\n        coef.push(term);\n    }\n    Polynomial::from_coef(coef)\n}"
    ],
    [
      "pub fn eval (&self, x: T) -> T {\n    let mut result: T = T::zero();\n    for (i, a_i) in self.coef.iter().enumerate() {\n        result = result * x + a_i;\n    }\n    result\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut result: T = T::zero();\n\n    for (i, a_i) in self.coef.iter().enumerate() {\n        result = result * x + a_i;\n    }\n\n    result\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut result: T = T::zero();\n\n    for (i, a_i) in self.coef.iter().enumerate() {\n        result = result * x + a_i;\n    }\n\n    result\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut result: T = T::zero();\n    for a_i in self.coef.iter().rev() {\n        result = result * x + a_i;\n    }\n    result\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut result: T = T::zero();\n    for a_i in &self.coef {\n        result = result * x + a_i;\n    }\n    result\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut result: T = T::zero();\n\n    for (i, a_i) in self.coef.iter().enumerate() {\n        result = result * x + a_i;\n    }\n\n    result\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut y: T = T::zero();\n\n    for (i, a_i) in self.coef.iter().enumerate() {\n        y = y * x + a_i;\n    }\n\n    y\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut result: T = T::zero();\n    for (i, a_i) in self.coef.iter().enumerate()\n    {\n        result = result * x + a_i;\n    }\n    result\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut result: T = T::zero();\n\n    for (i, a_i) in self.coef.iter().enumerate()\n    {\n        result = result * x + a_i;\n    }\n\n    result\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut result: T = T::zero();\n\n    for (i, a_i) in self.coef.iter().enumerate() {\n        result = result * x + a_i;\n    }\n\n    result\n}"
    ],
    [
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut coef: Vec<T> = Vec::new();\n    for i in 1..self.coef.len() {\n        coef.push(self.coef[i] * (i as T));\n    }\n    Polynomial { coef }\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut coef: Vec<T> = Vec::with_capacity(self.degree());\n    for i in 0..self.degree() {\n        coef.push(self.coef[i] * (self.degree() - i) as T);\n    }\n    Polynomial { coef }\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut coef: Vec<T> = Vec::new();\n    for i in 1..self.coef.len() {\n        coef.push(self.coef[i] * (i as f64));\n    }\n    Polynomial { coef }\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut new_coef: Vec<T> = Vec::new();\n    for i in 1..self.coef.len()\n    {\n        new_coef.push(self.coef[i] * (i as f64));\n    }\n\n    Polynomial::new(new_coef)\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut new_coef: Vec<T> = Vec::new();\n    for i in 1..self.coef.len()\n    {\n        new_coef.push(self.coef[i] * T::from(i as u32).unwrap());\n    }\n    Polynomial::new(new_coef)\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut coef: Vec<T> = Vec::with_capacity(self.degree());\n    for i in 0..self.degree() {\n        coef.push(self.coef[i] * (i as f64 + 1) as T);\n    }\n    Polynomial { coef }\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut coef: Vec<T> = Vec::with_capacity(self.degree());\n    for i in 0..self.degree() {\n        coef.push(self.coef[i] * (self.degree() - i) as T);\n    }\n    Polynomial { coef }\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut coef: Vec<T> = Vec::with_capacity(self.degree());\n    for i in 0..self.degree() {\n        coef.push(self.coef[i] * (self.degree() - i) as T);\n    }\n    Polynomial { coef }\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut coef: Vec<T> = Vec::with_capacity(self.degree());\n    for i in 0..self.degree() {\n        coef.push(self.coef[i] * (i as f64 + 1.0));\n    }\n\n    Polynomial { coef }\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut coef: Vec<T> = Vec::new();\n    for i in 1..self.coef.len() {\n        coef.push(self.coef[i] * T::from(i as u32).unwrap());\n    }\n    Polynomial { coef }\n}"
    ],
    [
      "pub fn integrate (&self) -> Polynomial<T> {\n    let mut coef_int = Vec::with_capacity(self.degree() + 1);\n    for (i, a_i) in self.coef.iter().enumerate() {\n        coef_int.push(T::from_f64((i as f64) * *a_i));\n    }\n\n    Polynomial {\n        coef: Polynomial::reduce_coef(coef_int),\n    }\n}",
      "pub fn integrate (&self) -> Polynomial<T> {\n    if self.degree() == 0 {\n        return Polynomial::from_coef(vec![T::zero()]);\n    }\n\n    let mut coef_integral = Vec::with_capacity(self.degree() + 1);\n    for (i, a_i) in self.coef.iter().enumerate() {\n        coef_integral.push(T::from_f64((i + 1) as f64) * *a_i);\n    }\n\n    Polynomial {\n        coef: Polynomial::reduce_coef(coef_integral),\n    }\n}",
      "pub fn integrate (&self) -> Polynomial<T> {\n    if self.degree() == 0 {\n        return Polynomial::from_coef(vec![T::zero()]);\n    }\n\n    let mut coef_integrate = Vec::with_capacity(self.degree() + 1);\n    for (i, a_i) in self.coef.iter().enumerate() {\n        coef_integrate.push(T::from_f64((i as f64) * *a_i));\n    }\n\n    Polynomial {\n        coef: Polynomial::reduce_coef(coef_integrate),\n    }\n}",
      "pub fn integrate (&self) -> Polynomial<T> {\n    if self.degree() == 0 {\n        return Polynomial::from_coef(vec![T::zero()]);\n    }\n\n    let mut coef_integrate = Vec::with_capacity(self.degree() + 1);\n    for (i, a_i) in self.coef.iter().enumerate() {\n        coef_integrate.push(T::from_f64((i + 1) as f64) * *a_i);\n    }\n\n    Polynomial {\n        coef: Polynomial::reduce_coef(coef_integrate),\n    }\n}",
      "pub fn integrate (&self) -> Polynomial<T> {\n    if self.degree() == 0 {\n        return Polynomial::from_coef(vec![T::zero()]);\n    }\n\n    let mut coef_integrate = Vec::with_capacity(self.degree() + 1);\n    for (i, a_i) in self.coef.iter().enumerate() {\n        coef_integrate.push(T::from_f64((i as f64) / (i as f64 + 1.0)) * *a_i);\n    }\n\n    Polynomial {\n        coef: Polynomial::reduce_coef(coef_integrate),\n    }\n}",
      "pub fn integrate (&self) -> Polynomial<T> {\n    if self.degree() == 0 {\n        return Polynomial::from_coef(vec![T::zero()]);\n    }\n\n    let mut coef_int = Vec::with_capacity(self.degree() + 1);\n    for (i, a_i) in self.coef.iter().enumerate() {\n        coef_int.push(T::from_f64((i + 1) as f64) * *a_i);\n    }\n\n    Polynomial {\n        coef: Polynomial::reduce_coef(coef_int),\n    }\n}",
      "pub fn integrate (&self) -> Polynomial<T> {\n    if self.degree() == 0 {\n        return Polynomial::from_coef(vec![T::zero()]);\n    }\n\n    let mut coef_int = Vec::with_capacity(self.degree() + 1);\n    for (i, a_i) in self.coef.iter().enumerate() {\n        coef_int.push(T::from_f64((i as f64) / (i as f64 + 1.0)) * *a_i);\n    }\n\n    Polynomial {\n        coef: Polynomial::reduce_coef(coef_int),\n    }\n}",
      "pub fn integrate (&self) -> Polynomial<T> {\n    if self.degree() == 0 {\n        return Polynomial::from_coef(vec![T::zero()]);\n    }\n\n    let mut coef_int = Vec::with_capacity(self.degree() + 1);\n    for (i, a_i) in self.coef.iter().enumerate() {\n        coef_int.push(T::from_f64((i + 1) as f64) * *a_i);\n    }\n\n    Polynomial {\n        coef: Polynomial::reduce_coef(coef_int),\n    }\n}",
      "pub fn integrate (&self) -> Polynomial<T> {\n    let mut coef_integral = Vec::with_capacity(self.degree() + 1);\n    for (i, a_i) in self.coef.iter().enumerate() {\n        coef_integral.push(T::from_f64((i + 1) as f64) * *a_i);\n    }\n\n    Polynomial {\n        coef: Polynomial::reduce_coef(coef_integral),\n    }\n}",
      "pub fn integrate (&self) -> Polynomial<T> {\n    if self.degree() == 0 {\n        return Polynomial::from_coef(vec![T::zero()]);\n    }\n\n    let mut coef_int = Vec::with_capacity(self.degree() + 1);\n    for (i, a_i) in self.coef.iter().enumerate() {\n        coef_int.push(T::from_f64((i + 1) as f64) * *a_i);\n    }\n\n    Polynomial {\n        coef: Polynomial::reduce_coef(coef_int),\n    }\n}"
    ],
    [
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    match self.elem_counts.entry(val) {\n        Entry::Occupied(mut entry) => {\n            *entry.get_mut() += n;\n        }\n        Entry::Vacant(entry) => {\n            entry.insert(n);\n        }\n    }\n    self.size += n;\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    self.size += n;\n    self.elem_counts.insert(val, n);\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    if n == 0 {\n        return;\n    }\n    match self.elem_counts.entry(val) {\n        Entry::Occupied(mut e) => {\n            *e.get_mut() += n;\n        }\n        Entry::Vacant(e) => {\n            e.insert(n);\n        }\n    }\n    self.size += n;\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    self.size += n;\n    *self.elem_counts.entry(val).or_insert(0) += n;\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    if self.elem_counts.contains_key(&val) {\n        self.elem_counts.insert(val, self.elem_counts[&val] + n);\n    } else {\n        self.elem_counts.insert(val, n);\n    }\n    self.size += n;\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    if n == 0 {\n        return;\n    }\n    let count = self.elem_counts.entry(val).or_insert(0);\n    *count += n;\n    self.size += n;\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    match self.elem_counts.entry(val) {\n        Entry::Occupied(mut e) => {\n            *e.get_mut() += n;\n        }\n        Entry::Vacant(e) => {\n            e.insert(n);\n        }\n    }\n    self.size += n;\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    if n == 0 {\n        return;\n    }\n    match self.elem_counts.entry(val) {\n        Entry::Vacant(e) => {\n            e.insert(n);\n            self.size += n;\n        }\n        Entry::Occupied(mut e) => {\n            let count = e.get_mut();\n            *count += n;\n            self.size += n;\n        }\n    }\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    if n == 0 {\n        return;\n    }\n    match self.elem_counts.entry(val) {\n        Entry::Occupied(mut e) => {\n            *e.get_mut() += n;\n        }\n        Entry::Vacant(e) => {\n            e.insert(n);\n        }\n    }\n    self.size += n;\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    match self.elem_counts.entry(val) {\n        Entry::Vacant(e) => {\n            e.insert(n);\n            self.size += n;\n        },\n        Entry::Occupied(mut e) => {\n            let count = e.get_mut();\n            *count += n;\n            self.size += n;\n        }\n    }\n}"
    ],
    [
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    match self.elem_counts.entry(val.clone()) {\n        Entry::Vacant(_) => {\n            0\n        },\n        Entry::Occupied(mut view) => {\n            let v = view.get_mut();\n            let n = *v;\n            if n > times {\n                *v -= times;\n                self.size -= times;\n                times\n            } else {\n                self.size -= n;\n                view.remove();\n                n\n            }\n        }\n    }\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    let old_count = match self.elem_counts.get_mut(val) {\n        Some(count) => {\n            if *count >= times {\n                *count -= times;\n                times\n            } else {\n                let old_count = *count;\n                self.elem_counts.remove(val);\n                old_count\n            }\n        },\n        None => 0\n    };\n    self.size -= old_count;\n    old_count\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    match self.elem_counts.entry(val) {\n        Entry::Vacant(_) => {\n            return 0;\n        },\n        Entry::Occupied(mut view) => {\n            let v = view.get_mut();\n            if *v < times {\n                return 0;\n            }\n            else {\n                *v -= times;\n                self.size -= times;\n                if *v == 0 {\n                    view.remove();\n                }\n                return times;\n            }\n        },\n    }\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    match self.elem_counts.entry(val.clone()) {\n        Entry::Vacant(_) => 0,\n        Entry::Occupied(mut view) => {\n            let count = view.get_mut();\n            if *count < times {\n                return 0;\n            }\n            *count -= times;\n            self.size -= times;\n            if *count == 0 {\n                view.remove();\n            }\n            times\n        }\n    }\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    match self.elem_counts.entry(val) {\n        Entry::Vacant(_) => 0,\n        Entry::Occupied(mut view) => {\n            let v = view.get_mut();\n            let to_remove = if times > *v {\n                *v\n            } else {\n                *v -= times;\n                times\n            };\n            self.size -= to_remove;\n            if *v == 0 {\n                view.remove();\n            }\n            to_remove\n        }\n    }\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    let mut count = 0;\n    if let Some(n) = self.elem_counts.get_mut(val) {\n        if *n >= times {\n            *n -= times;\n            count = times;\n        } else {\n            count = *n;\n            self.elem_counts.remove(val);\n        }\n        self.size -= count;\n    }\n    count\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    match self.elem_counts.entry(val.clone()) {\n        Entry::Vacant(_) => 0,\n        Entry::Occupied(mut view) => {\n            let count = view.get_mut();\n            if *count >= times {\n                *count -= times;\n                self.size -= times;\n                times\n            } else {\n                self.size -= *count;\n                *count = 0;\n                *count\n            }\n        }\n    }\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    let mut removed = 0;\n    if let Some(count) = self.elem_counts.get_mut(val) {\n        if *count >= times {\n            removed = times;\n            *count -= times;\n        } else {\n            removed = *count;\n            self.elem_counts.remove(val);\n        }\n        self.size -= removed;\n    }\n    removed\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    match self.elem_counts.entry(val.clone()) {\n        Entry::Vacant(_) => {\n            return 0;\n        },\n        Entry::Occupied(mut view) => {\n            let v = view.get_mut();\n            if *v >= times {\n                *v -= times;\n                self.size -= times;\n                return times;\n            } else {\n                self.size -= *v;\n                let removed = *v;\n                view.remove();\n                return removed;\n            }\n        },\n    }\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    let old_count = self.elem_counts.get(val).unwrap_or(&0);\n    let new_count = old_count - times;\n    if new_count == 0 {\n        self.elem_counts.remove(val);\n    } else {\n        self.elem_counts.insert(val.clone(), new_count);\n    }\n    self.size -= times;\n    old_count\n}"
    ],
    [
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut result = HashMultiSet::new();\n    for (key, count) in self.elem_counts.into_iter() {\n        result.insert_times(&key, count);\n    }\n    for (key, count) in rhs.elem_counts.into_iter() {\n        result.insert_times(&key, count);\n    }\n    result\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut new_set = HashMultiSet::new();\n    for (k, v) in self.elem_counts {\n        new_set.insert_times(k, v);\n    }\n    for (k, v) in rhs.elem_counts {\n        new_set.insert_times(k, v);\n    }\n    new_set\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut combined = HashMultiSet::new();\n    for (k, v) in self.elem_counts {\n        combined.insert_times(k, v);\n    }\n    for (k, v) in rhs.elem_counts {\n        combined.insert_times(k, v);\n    }\n    combined\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut combined = HashMultiSet::new();\n    for (key, count) in self.elem_counts.into_iter() {\n        combined.insert_times(&key, count);\n    }\n    for (key, count) in rhs.elem_counts.into_iter() {\n        combined.insert_times(&key, count);\n    }\n    combined\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut combined = HashMultiSet::new();\n    for (key, count) in self.elem_counts {\n        combined.insert_times(key, count);\n    }\n    for (key, count) in rhs.elem_counts {\n        combined.insert_times(key, count);\n    }\n    combined\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut result = HashMultiSet::new();\n    for (key, count) in self.elem_counts.into_iter() {\n        result.insert_times(&key, count);\n    }\n    for (key, count) in rhs.elem_counts.into_iter() {\n        result.insert_times(&key, count);\n    }\n    result\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut combined = HashMultiSet::new();\n    for (key, count) in self.elem_counts.into_iter() {\n        combined.insert_times(key, count);\n    }\n    for (key, count) in rhs.elem_counts.into_iter() {\n        combined.insert_times(key, count);\n    }\n    combined\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut result = HashMultiSet::new();\n    for (key, count) in self.elem_counts {\n        result.insert_times(key, count);\n    }\n    for (key, count) in rhs.elem_counts {\n        result.insert_times(key, count);\n    }\n    result\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut result = HashMultiSet::new();\n    for (k, v) in self.elem_counts.into_iter() {\n        result.insert_times(&k, v);\n    }\n    for (k, v) in rhs.elem_counts.into_iter() {\n        result.insert_times(&k, v);\n    }\n    result\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut result = HashMultiSet::new();\n    for (key, count) in self.elem_counts.into_iter() {\n        result.insert_times(key, count);\n    }\n    for (key, count) in rhs.elem_counts.into_iter() {\n        result.insert_times(key, count);\n    }\n    result\n}"
    ],
    [
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        let rhs_count = rhs.count_of(val);\n        let min = if count < rhs_count {count} else {rhs_count};\n        ret.insert_times((*val).clone(), min);\n    }\n    ret\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        let rhs_count = rhs.count_of(val);\n        if count > rhs_count {\n            ret.insert_times((*val).clone(), count - rhs_count);\n        }\n    }\n    ret\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        let rhs_count = rhs.count_of(val);\n        if count > rhs_count {\n            ret.insert_times((*val).clone(), count - rhs_count);\n        }\n    }\n    ret\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        let mut remove = 0;\n        if let Some(rhs_count) = rhs.count_of(val) {\n            remove = cmp::min(count, rhs_count);\n        }\n        if remove < count {\n            ret.insert_times((*val).clone(), count - remove);\n        }\n    }\n    ret\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        let rhs_count = rhs.count_of(val);\n        if count > rhs_count {\n            ret.insert_times((*val).clone(), count - rhs_count);\n        }\n    }\n    ret\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        ret.insert_times((*val).clone(), count);\n    }\n    for val in rhs.distinct_elements() {\n        let count = rhs.count_of(val);\n        ret.remove_times((*val).clone(), count);\n    }\n    ret\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        let rhs_count = rhs.count_of(val);\n        if count > rhs_count {\n            ret.insert_times((*val).clone(), count - rhs_count);\n        }\n    }\n    ret\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        ret.insert_times((*val).clone(), count);\n    }\n    for val in rhs.distinct_elements() {\n        let count = rhs.count_of(val);\n        ret.remove_times((*val).clone(), count);\n    }\n    ret\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        ret.insert_times((*val).clone(), count);\n    }\n    for val in rhs.distinct_elements() {\n        let count = rhs.count_of(val);\n        ret.remove_times((*val).clone(), count);\n    }\n    ret\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut ret: HashMultiSet<T> = HashMultiSet::new();\n    for val in self.distinct_elements() {\n        let count = self.count_of(val);\n        let rhs_count = rhs.count_of(val);\n        if count > rhs_count {\n            ret.insert_times((*val).clone(), count - rhs_count);\n        }\n    }\n    ret\n}"
    ],
    [
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(s) => Cow::Borrowed(RawStr::new(s)),\n        Cow::Owned(s) => Cow::Owned(RawStrBuf::from(s)),\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(s) => Cow::Borrowed(RawStr::new(s)),\n        Cow::Owned(s) => Cow::Owned(RawStrBuf::from(s)),\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(s) => Cow::Borrowed(RawStr::new(s)),\n        Cow::Owned(s) => Cow::Owned(RawStrBuf::from(s).into_raw()),\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(s) => Cow::Borrowed(RawStr::new(s)),\n        Cow::Owned(s) => Cow::Owned(RawStrBuf::from(s)),\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(s) => Cow::Borrowed(RawStr::new(s)),\n        Cow::Owned(s) => Cow::Owned(RawStrBuf(s)),\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(s) => Cow::Borrowed(RawStr::new(s)),\n        Cow::Owned(s) => Cow::Owned(RawStrBuf::from(s).into()),\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(s) => Cow::Borrowed(RawStr::new(s)),\n        Cow::Owned(s) => Cow::Owned(RawStrBuf::from(s)),\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(s) => Cow::Borrowed(RawStr::new(s)),\n        Cow::Owned(s) => Cow::Owned(RawStrBuf(s).into_raw()),\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(s) => Cow::Borrowed(RawStr::new(s)),\n        Cow::Owned(s) => Cow::Owned(RawStrBuf(s).into_raw_str()),\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(s) => Cow::Borrowed(RawStr::new(s)),\n        Cow::Owned(s) => Cow::Owned(RawStrBuf(s).into_raw()),\n    }\n}"
    ],
    [
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let string = self.as_str();\n    let mut output = String::new();\n    for c in string.chars() {\n        match c {\n            '<' => output.push_str(\"&lt;\"),\n            '>' => output.push_str(\"&gt;\"),\n            '\"' => output.push_str(\"&quot;\"),\n            '\\'' => output.push_str(\"&#x27;\"),\n            '/' => output.push_str(\"&#x2F;\"),\n            '`' => output.push_str(\"&#x60;\"),\n            '&' => output.push_str(\"&amp;\"),\n            _ => output.push(c),\n        }\n    }\n    Cow::Owned(output)\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let mut result = String::new();\n    for c in self.chars() {\n        match c {\n            '<' => result.push_str(\"&lt;\"),\n            '>' => result.push_str(\"&gt;\"),\n            '\"' => result.push_str(\"&quot;\"),\n            '\\'' => result.push_str(\"&#x27;\"),\n            '/' => result.push_str(\"&#x2F;\"),\n            '`' => result.push_str(\"&#x60;\"),\n            '&' => result.push_str(\"&amp;\"),\n            c => result.push(c),\n        }\n    }\n    Cow::Owned(result)\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let mut string = String::with_capacity(self.len());\n    let mut bytes = self.as_bytes();\n    while let Some(byte) = bytes.get(0) {\n        match byte {\n            b'&' => string.push_str(\"&amp;\"),\n            b'<' => string.push_str(\"&lt;\"),\n            b'>' => string.push_str(\"&gt;\"),\n            b'\"' => string.push_str(\"&quot;\"),\n            b'\\'' => string.push_str(\"&#x27;\"),\n            b'/' => string.push_str(\"&#x2F;\"),\n            b'`' => string.push_str(\"&#x60;\"),\n            _ => string.push(*byte as char),\n        }\n        bytes = &bytes[1..];\n    }\n    Cow::Owned(string)\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let mut string = self.to_string();\n    string.replace_range(.., &html_escape::encode_text(&string));\n    Cow::Owned(string)\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let mut string = String::with_capacity(self.len());\n    let mut iter = self.chars();\n    while let Some(c) = iter.next() {\n        match c {\n            '<' => string.push_str(\"&lt;\"),\n            '>' => string.push_str(\"&gt;\"),\n            '&' => string.push_str(\"&amp;\"),\n            '\"' => string.push_str(\"&quot;\"),\n            '\\'' => string.push_str(\"&#x27;\"),\n            '/' => string.push_str(\"&#x2F;\"),\n            '`' => string.push_str(\"&#x60;\"),\n            _ => string.push(c),\n        }\n    }\n    Cow::Owned(string)\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let mut string = String::new();\n    for c in self.chars() {\n        match c {\n            '&' => string.push_str(\"&amp;\"),\n            '<' => string.push_str(\"&lt;\"),\n            '>' => string.push_str(\"&gt;\"),\n            '\"' => string.push_str(\"&quot;\"),\n            '\\'' => string.push_str(\"&#x27;\"),\n            '/' => string.push_str(\"&#x2F;\"),\n            '`' => string.push_str(\"&#x60;\"),\n            _ => string.push(c),\n        }\n    }\n    Cow::Owned(string)\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let mut string = self.to_string();\n    let mut bytes = string.as_bytes_mut();\n    let mut i = 0;\n    while i < bytes.len() {\n        let ch = bytes[i];\n        if ch == b'&' || ch == b'<' || ch == b'>' || ch == b'\"' || ch == b'\\'' || ch == b'/' || ch == b'`' {\n            let replacement = match ch {\n                b'&' => \"&amp;\",\n                b'<' => \"&lt;\",\n                b'>' => \"&gt;\",\n                b'\"' => \"&quot;\",\n                b'\\'' => \"&#x27;\",\n                b'/' => \"&#x2F;\",\n                b'`' => \"&#x60;\",\n                _ => unreachable!()\n            };\n            bytes.splice(i..i+1, replacement.bytes());\n            i += replacement.len();\n        } else {\n            i += 1;\n        }\n    }\n    Cow::Owned(string)\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let string = self._replace_plus();\n    match percent_encoding::percent_decode(string.as_bytes()).decode_utf8() {\n        Ok(s) => Cow::Owned(html_escape::encode_safe(s.into_owned())),\n        Err(_) => Cow::Borrowed(string)\n    }\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let mut string = self.as_str();\n    let mut escape = false;\n    for c in string.chars() {\n        if c == '&' || c == '<' || c == '>' || c == '\"' || c == '\\'' || c == '/' || c == '`' {\n            escape = true;\n            break;\n        }\n    }\n    if !escape {\n        return string.into();\n    }\n    let mut escaped = String::with_capacity(string.len() + 20);\n    for c in string.chars() {\n        match c {\n            '&' => escaped.push_str(\"&amp;\"),\n            '<' => escaped.push_str(\"&lt;\"),\n            '>' => escaped.push_str(\"&gt;\"),\n            '\"' => escaped.push_str(\"&quot;\"),\n            '\\'' => escaped.push_str(\"&#x27;\"),\n            '/' => escaped.push_str(\"&#x2F;\"),\n            '`' => escaped.push_str(\"&#x60;\"),\n            _ => escaped.push(c),\n        }\n    }\n    escaped.into()\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let string = self._replace_plus();\n    match percent_encoding::percent_decode(string.as_bytes()).decode_utf8() {\n        Ok(s) => Cow::Owned(s.to_string()),\n        Err(e) => Cow::Owned(e.to_string())\n    }\n}"
    ],
    [
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let mut before = 0;\n    let mut after = self.len();\n    for (i, c) in self.as_str().char_indices() {\n        if c as u8 == b {\n            before = i;\n            after = i + c.len_utf8();\n            break;\n        }\n    }\n    (&self[..before], &self[after..])\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let mut i = 0;\n    while i < self.len() {\n        if self.as_bytes()[i] == b {\n            return (self.slice(0, i), self.slice(i + 1, self.len()));\n        }\n        i += 1;\n    }\n    (self, RawStr::new(\"\"))\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let mut iter = self.as_str().bytes();\n    let mut before = 0;\n    let mut after = 0;\n    while let Some(c) = iter.next() {\n        if c == b {\n            break;\n        }\n        before += 1;\n        after += 1;\n    }\n    (&self[..before], &self[before..])\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let mut index = 0;\n    for (i, c) in self.as_str().bytes().enumerate() {\n        if c == b {\n            index = i;\n            break;\n        }\n    }\n    (self.slice(0, index), self.slice(index + 1, self.len()))\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let mut iter = self.as_str().bytes();\n    let mut index = 0;\n    while let Some(c) = iter.next() {\n        if c == b {\n            break;\n        }\n        index += 1;\n    }\n    (self.slice(0, index), self.slice(index + 1, self.len()))\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let mut iter = self.as_str().bytes();\n    let mut index = 0;\n    let mut found = false;\n    while let Some(c) = iter.next() {\n        if c == b {\n            found = true;\n            break;\n        }\n        index += 1;\n    }\n    if found {\n        let (before, after) = self.as_str().split_at(index);\n        (RawStr::new(before), RawStr::new(after))\n    } else {\n        (self, RawStr::new(\"\"))\n    }\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let mut before = 0;\n    let mut after = self.len();\n    for (i, c) in self.as_str().bytes().enumerate() {\n        if c == b {\n            before = i;\n            after = i + 1;\n            break;\n        }\n    }\n    (&self[..before], &self[after..])\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let mut i = 0;\n    let mut found = false;\n    while i < self.len() {\n        if self.as_bytes()[i] == b {\n            found = true;\n            break;\n        }\n        i += 1;\n    }\n    if found {\n        (&self[..i], &self[i + 1..])\n    } else {\n        (&self[..], &self[self.len()..])\n    }\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let mut i = 0;\n    let mut found = false;\n    let mut found_index = 0;\n    let mut found_index_byte = 0;\n    while i < self.len() {\n        let byte = self.as_bytes()[i];\n        if byte == b {\n            found = true;\n            found_index = i;\n            found_index_byte = i + 1;\n        }\n        i += 1;\n    }\n    if found {\n        (&self[0..found_index], &self[found_index_byte..])\n    } else {\n        (&self[0..self.len()], &self[self.len()..])\n    }\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let mut iter = self.as_str().bytes();\n    let mut before = 0;\n    while let Some(c) = iter.next() {\n        if c == b {\n            break;\n        }\n        before += 1;\n    }\n    let after = self.len() - before;\n    (&self[..before], &self[before..])\n}"
    ],
    [
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Get | Head | Connect | Trace | Options => false,\n        Put | Post | Delete | Patch => true\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Get | Head | Connect | Trace | Options => false,\n        Put | Post | Delete | Patch => true,\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Put | Method::Post | Method::Delete | Method::Patch => true,\n        _ => false,\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Get | Head | Connect | Trace | Options => false,\n        Put | Post | Delete | Patch => true\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Get | Head | Connect | Trace | Options => false,\n        Put | Post | Delete | Patch => true,\n    }\n}\n\nimpl FromStr for Method {\n    type Err = ();\n\n    fn from_str(method: &str) -> Result<Self, Self::Err> {\n        match method {\n            \"GET\" => Ok(Get),\n            \"PUT\" => Ok(Put),\n            \"POST\" => Ok(Post),\n            \"DELETE\" => Ok(Delete),\n            \"OPTIONS\" => Ok(Options),\n            \"HEAD\" => Ok(Head),\n            \"TRACE\" => Ok(Trace),\n            \"CONNECT\" => Ok(Connect),\n            \"PATCH\" => Ok(Patch),\n            _ => Err(()),\n        }\n    }\n}\n\nimpl fmt::Display for Method {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Get => write!(f, \"GET\"),\n            Put => write!(f, \"PUT\"),\n            Post => write!(f, \"POST\"),\n            Delete => write!(f, \"DELETE\"),\n            Options => write!(f, \"OPTIONS\"),\n            Head => write!(f, \"HEAD\"),\n            Trace => write!(f, \"TRACE\"),\n            Connect => write!(f, \"CONNECT\"),\n            Patch => write!(f, \"PATCH\"),\n        }\n    }\n}\n\n#[cfg(feature = \"serde\")]\nmod serde {\n    use super::*;\n    use serde_ as serde;\n\n    #[derive(Deserialize, Serialize)]\n    #[serde(crate = \"serde_\")]\n    struct MethodVisitor;\n\n    impl<'de> serde::de::Visitor<'de> for MethodVisitor {\n        type Value = Method;\n\n        fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n            formatter.write_str(\"an HTTP method\")\n        }\n\n        fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n}\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Get | Method::Head | Method::Connect | Method::Trace | Method::Options => false,\n        Method::Put | Method::Post | Method::Delete | Method::Patch => true,\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Get | Head | Connect | Trace | Options => false,\n        Put | Post | Delete | Patch => true,\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Get | Head | Connect | Trace | Options => false,\n        Put | Post | Delete | Patch => true,\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Get | Method::Head | Method::Connect | Method::Trace | Method::Options => false,\n        Method::Put | Method::Post | Method::Delete | Method::Patch => true,\n    }\n}\n\nimpl FromStr for Method {\n    type Err = ();\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        match uncased(s) {\n            \"GET\" => Ok(Get),\n            \"PUT\" => Ok(Put),\n            \"POST\" => Ok(Post),\n            \"DELETE\" => Ok(Delete),\n            \"OPTIONS\" => Ok(Options),\n            \"HEAD\" => Ok(Head),\n            \"TRACE\" => Ok(Trace),\n            \"CONNECT\" => Ok(Connect),\n            \"PATCH\" => Ok(Patch),\n            _ => Err(()),\n        }\n    }\n}\n\nimpl fmt::Display for Method {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match *self {\n            Get => write!(f, \"GET\"),\n            Put => write!(f, \"PUT\"),\n            Post => write!(f, \"POST\"),\n            Delete => write!(f, \"DELETE\"),\n            Options => write!(f, \"OPTIONS\"),\n            Head => write!(f, \"HEAD\"),\n            Trace => write!(f, \"TRACE\"),\n            Connect => write!(f, \"CONNECT\"),\n            Patch => write!(f, \"PATCH\"),\n        }\n    }\n}\n\n#[cfg(feature = \"serde\")]\nmod serde {\n    use super::*;\n    use serde_ as serde;\n\n    #[derive(Deserialize, Serialize)]\n    #[serde(crate = \"serde_\")]\n    struct MethodString(String);\n\n    impl From<Method> for MethodString {\n        fn from(method: Method) -> Self {\n            MethodString(method.to_string())\n        }\n    }\n\n    impl From<MethodString> for Method {\n        fn from(method: MethodString) -> Self {\n}\n}\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Put | Method::Post | Method::Delete | Method::Patch => true,\n        _ => false\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_supports_payload() {\n        assert_eq!(Method::Get.supports_payload(), false);\n        assert_eq!(Method::Post.supports_payload(), true);\n        assert_eq!(Method::Put.supports_payload(), true);\n        assert_eq!(Method::Delete.supports_payload(), true);\n        assert_eq!(Method::Patch.supports_payload(), true);\n        assert_eq!(Method::Head.supports_payload(), false);\n        assert_eq!(Method::Connect.supports_payload(), false);\n        assert_eq!(Method::Trace.supports_payload(), false);\n        assert_eq!(Method::Options.supports_payload(), false);\n    }\n}"
    ],
    [
      "pub const fn is_valid_name (name: &str) -> bool {\n    !name.is_empty() && name.chars().all(|c| c.is_ascii_alphanumeric() || c == '-' || c == '_' || c == '~')\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    !name.is_empty() && name.chars().all(|c| {\n        matches!(c, '!' | '#' | '$' | '%' | '&' | '\\'' | '*' | '+' | '-' | '.' | '^' | '_' | '`' | '|' | '~' | DIGIT | ALPHA)\n    })\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    name.chars().all(|c| c.is_ascii_alphanumeric() || c == '!' || c == '#' || c == '$' || c == '%' || c == '&' || c == '\\'' || c == '*' || c == '+' || c == '-' || c == '.' || c == '^' || c == '_' || c == '`' || c == '|' || c == '~')\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    name.chars().all(|c| {\n        matches!(c, '!' | '#' | '$' | '%' | '&' | '\\'' | '*' | '+' | '-' | '.' | '^' | '_' | '`' | '|' | '~' | '0'..='9' | 'A'..='Z' | 'a'..='z')\n    })\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    let mut chars = name.chars();\n    match chars.next() {\n        Some(c) if c.is_ascii_alphabetic() || c == '!' | c == '#' | c == '$' | c == '%' | c == '&' | c == '\\'' | c == '*' | c == '+' | c == '-' | c == '.' | c == '^' | c == '_' | c == '`' | c == '|' | c == '~' => (),\n        _ => return false,\n    }\n\n    for c in chars {\n        if c.is_ascii_alphanumeric() || c == '!' | c == '#' | c == '$' | c == '%' | c == '&' | c == '\\'' | c == '*' | c == '+' | c == '-' | c == '.' | c == '^' | c == '_' | c == '`' | c == '|' | c == '~' {\n            continue;\n        }\n\n        return false;\n    }\n\n    true\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    let mut chars = name.chars();\n    if let Some(first) = chars.next() {\n        if !first.is_ascii_alphanumeric() {\n            return false;\n        }\n\n        for c in chars {\n            if !c.is_ascii_alphanumeric() && !c.is_ascii_punctuation() {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    false\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    name.bytes().all(|b| {\n        b.is_ascii_alphanumeric()\n        || b == b'!'\n        || b == b'#'\n        || b == b'$'\n        || b == b'%'\n        || b == b'&'\n        || b == b'\\''\n        || b == b'*'\n        || b == b'+'\n        || b == b'-'\n        || b == b'.'\n        || b == b'^'\n        || b == b'_'\n        || b == b'`'\n        || b == b'|'\n        || b == b'~'\n    })\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    let mut chars = name.chars();\n    let first = match chars.next() {\n        Some(c) => c,\n        None => return false,\n    };\n\n    if !first.is_ascii_alphabetic() && first != '!' && first != '#' && first != '$' && first != '%' && first != '&' && first != '\\'' && first != '*' && first != '+' && first != '-' && first != '.' && first != '^' && first != '_' && first != '`' && first != '|' && first != '~' && !first.is_ascii_digit() {\n        return false;\n    }\n\n    for c in chars {\n        if !c.is_ascii_alphanumeric() && c != '!' && c != '#' && c != '$' && c != '%' && c != '&' && c != '\\'' && c != '*' && c != '+' && c != '-' && c != '.' && c != '^' && c != '_' && c != '`' && c != '|' && c != '~' && !c.is_ascii_digit() {\n            return false;\n        }\n    }\n\n    true\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    !name.is_empty() && name.chars().all(|c| c.is_ascii_alphanumeric() || c == '-' || c == '_' || c == '~')\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    name.chars().all(|c| c.is_ascii_alphanumeric() || c == '!' || c == '#' || c == '$' || c == '%' || c == '&' || c == '\\'' || c == '*' || c == '+' || c == '-' || c == '.' || c == '^' || c == '_' || c == '`' || c == '|' || c == '~')\n}"
    ],
    [
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    self.headers.entry(Uncased::new(name)).or_insert(vec![]).append(values);\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    self.headers.entry(Uncased::new(name)).or_insert(vec![]).append(values);\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    self.headers.entry(Uncased::new(name)).or_insert(vec![]).append(values);\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    let name = Uncased::new(name);\n    let values = self.headers.entry(name).or_insert(vec![]);\n    values.append(values);\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    let name = Uncased::new(name);\n    self.headers.entry(name).or_insert(vec![]).append(values);\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    let name = name.into();\n    let mut new_values = vec![];\n    if let Some(existing_values) = self.headers.get_mut(&name) {\n        existing_values.append(values);\n    } else {\n        new_values.append(values);\n    }\n    self.headers.insert(name, new_values);\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    let name = Uncased::new(name);\n    let entry = self.headers.entry(name);\n    match entry {\n        Entry::Vacant(entry) => {\n            entry.insert(values);\n        },\n        Entry::Occupied(mut entry) => {\n            entry.get_mut().append(values);\n        }\n    }\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    self.headers.entry(Uncased::new(name)).or_insert(vec![]).append(values);\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    self.headers.entry(Uncased::new(name)).or_insert(vec![]).append(values);\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    self.headers.entry(Uncased::new(name)).or_insert(vec![]).append(values);\n}"
    ],
    [
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(ref inner) => Some(inner),\n        _ => None\n    }\n}"
    ],
    [
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}"
    ],
    [
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}"
    ],
    [
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    self.iter().nth(n)\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    self.0.get(n).map(|s| {\n        let mut parts = s.splitn(2, '=');\n        let key = parts.next().unwrap();\n        let val = parts.next().unwrap_or(\"\");\n        (key, val)\n    })\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    self.iter().nth(n)\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    self.0.get(n).map(|(k, v)| (k.as_str(), v.as_str()))\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    self.clone().nth(n)\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    if n < self.len() {\n        let mut i = 0;\n        for (key, value) in self.clone() {\n            if i == n {\n                return Some((key, value));\n            }\n            i += 1;\n        }\n    }\n    None\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    self.0.get(n).map(|&(ref k, ref v)| (k, v))\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    if n < self.len() {\n        let mut i = 0;\n        for (key, value) in self.clone() {\n            if i == n {\n                return Some((key, value));\n            }\n            i += 1;\n        }\n    }\n    None\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    if n < self.len() {\n        let (key, value) = self.as_slice()[n];\n        Some((key, value))\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    if n < self.len() {\n        let (key, value) = self.as_slice()[n];\n        Some((key, value))\n    } else {\n        None\n    }\n}"
    ],
    [
      "pub fn is_normalized (&self) -> bool {\n    // TODO: Implement\n    true\n}",
      "pub fn is_normalized (&self) -> bool {\n    self.scheme.is_normalized() &&\n    self.authority.is_normalized() &&\n    self.path.is_normalized() &&\n    self.query.is_normalized()\n}",
      "pub fn is_normalized (&self) -> bool {\n    self.scheme.is_normalized() && self.authority.is_normalized() && self.path.is_normalized() && self.query.is_normalized()\n}",
      "pub fn is_normalized (&self) -> bool {\n    self.scheme.is_normalized() && self.authority.is_normalized() && self.path.is_normalized() && self.query.is_normalized()\n}",
      "pub fn is_normalized (&self) -> bool {\n    self.scheme.is_normalized() && self.authority.is_normalized() && self.path.is_normalized() && self.query.is_normalized()\n}",
      "pub fn is_normalized (&self) -> bool {\n    // Check if the scheme is normalized.\n    if !self.scheme.is_normalized() {\n        return false;\n    }\n\n    // Check if the authority is normalized.\n    if let Some(authority) = self.authority.as_ref() {\n        if !authority.is_normalized() {\n            return false;\n        }\n    }\n\n    // Check if the path is normalized.\n    if !self.path.is_normalized() {\n        return false;\n    }\n\n    // Check if the query is normalized.\n    if let Some(query) = self.query.as_ref() {\n        if !query.is_normalized() {\n            return false;\n        }\n    }\n\n    true\n}",
      "pub fn is_normalized (&self) -> bool {\n    self.scheme.is_normalized() &&\n    self.authority.as_ref().map_or(true, |a| a.is_normalized()) &&\n    self.path.is_normalized() &&\n    self.query.as_ref().map_or(true, |q| q.is_normalized())\n}",
      "pub fn is_normalized (&self) -> bool {\n    // The scheme is always normalized.\n    if !self.scheme.is_normalized() {\n        return false;\n    }\n\n    // The authority is always normalized.\n    if !self.authority.is_normalized() {\n        return false;\n    }\n\n    // The path is always normalized.\n    if !self.path.is_normalized() {\n        return false;\n    }\n\n    // The query is always normalized.\n    if !self.query.is_normalized() {\n        return false;\n    }\n\n    true\n}",
      "pub fn is_normalized (&self) -> bool {\n    // TODO:\n    // 1. Check if the scheme is normalized.\n    // 2. Check if the authority is normalized.\n    // 3. Check if the path is normalized.\n    // 4. Check if the query is normalized.\n    // 5. Return `true` if all are normalized.\n    // 6. Return `false` otherwise.\n    //\n    // Hint:\n    // 1. Check the `Scheme::is_normalized()` method.\n    // 2. Check the `Authority::is_normalized()` method.\n    // 3. Check the `Path::is_normalized()` method.\n    // 4. Check the `Query::is_normalized()` method.\n    // 5. If any of the above return `false`, return `false`.\n    // 6. Otherwise, return `true`.\n    true\n}",
      "pub fn is_normalized (&self) -> bool {\n    // The scheme is normalized if it is not empty and it does not contain any\n    // illegal characters.\n    let scheme_is_normalized = !self.scheme.is_empty() && self.scheme.is_normalized();\n\n    // The authority is normalized if it is not present or if it is present and\n    // it is normalized.\n    let authority_is_normalized = self.authority.as_ref().map_or(true, |a| a.is_normalized());\n\n    // The path is normalized if it is not empty and it does not contain any\n    // illegal characters.\n    let path_is_normalized = !self.path.is_empty() && self.path.is_normalized();\n\n    // The query is normalized if it is not present or if it is present and it\n    // is normalized.\n    let query_is_normalized = self.query.as_ref().map_or(true, |q| q.is_normalized());\n\n    scheme_is_normalized && authority_is_normalized && path_is_normalized && query_is_normalized\n}"
    ],
    [
      "pub fn top_left (&self) -> Point {\n    Point::new(self.raw.x, self.raw.y)\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.raw.x, self.raw.y)\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.raw.x, self.raw.y)\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.raw.x, self.raw.y)\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.raw.x, self.raw.y)\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.raw.x, self.raw.y)\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.raw.x, self.raw.y)\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.raw.x, self.raw.y)\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.raw.x, self.raw.y)\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.raw.x, self.raw.y)\n}"
    ],
    [
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}"
    ],
    [
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\n    let (x, y) = point.into();\n    x >= self.left() && x < self.right() && y >= self.top() && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nself.left() <= x && x < self.right() && self.top() <= y && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nself.left() <= x && x < self.right() && self.top() <= y && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\n    let (x, y) = point.into();\n    self.left() <= x && x < self.right() && self.top() <= y && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nself.left() <= x && x < self.right() && self.top() <= y && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nx >= self.left() && x < self.right() && y >= self.top() && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nself.left() <= x && x < self.right() && self.top() <= y && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nself.left() <= x && x < self.right() && self.top() <= y && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nx >= self.left() && x < self.right() && y >= self.top() && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\n    let (x, y) = point.into();\n    x >= self.left() && x < self.right() && y >= self.top() && y < self.bottom()\n}"
    ],
    [
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    self.left() <= other.left() && self.right() >= other.right() &&\n    self.top() <= other.top() && self.bottom() >= other.bottom()\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    self.left() <= other.left() &&\n    self.right() >= other.right() &&\n    self.top() <= other.top() &&\n    self.bottom() >= other.bottom()\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    self.left() <= other.left() &&\n    self.right() >= other.right() &&\n    self.top() <= other.top() &&\n    self.bottom() >= other.bottom()\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    self.left() <= other.left() &&\n    self.top() <= other.top() &&\n    self.right() >= other.right() &&\n    self.bottom() >= other.bottom()\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    self.left() <= other.left() && self.right() >= other.right() &&\n    self.top() <= other.top() && self.bottom() >= other.bottom()\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    let left = self.left();\n    let right = self.right();\n    let top = self.top();\n    let bottom = self.bottom();\n    let other_left = other.left();\n    let other_right = other.right();\n    let other_top = other.top();\n    let other_bottom = other.bottom();\n    other_left >= left && other_right <= right && other_top >= top && other_bottom <= bottom\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    self.left() <= other.left() &&\n    self.top() <= other.top() &&\n    self.right() >= other.right() &&\n    self.bottom() >= other.bottom()\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    self.left() <= other.left() &&\n    self.top() <= other.top() &&\n    self.right() >= other.right() &&\n    self.bottom() >= other.bottom()\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    self.left() <= other.left() && self.right() >= other.right() &&\n    self.top() <= other.top() && self.bottom() >= other.bottom()\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    let other_left = other.left();\n    let other_right = other.right();\n    let other_top = other.top();\n    let other_bottom = other.bottom();\n    let self_left = self.left();\n    let self_right = self.right();\n    let self_top = self.top();\n    let self_bottom = self.bottom();\n    other_left >= self_left && other_right <= self_right && other_top >= self_top && other_bottom <= self_bottom\n}"
    ],
    [
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\n    self.tree.get_key(value)\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.get_key(value)\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.get(value).map(|(v, _)| v)\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.get(value)\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\n    self.tree.get_key(value)\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\n    self.tree.get_key(value)\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.get(value).map(|(v, _)| v)\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\n    self.tree.get_key(value)\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.get_key(value)\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\n    self.tree.get_key(value)\n}"
    ],
    [
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.smallest()\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.smallest()\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.smallest()\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.smallest()\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.smallest()\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.smallest()\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.smallest()\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.smallest()\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.smallest()\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.smallest()\n}"
    ],
    [
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(v, _)| v)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(v, _)| v)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost().map(|(v, _)| v)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost().map(|(v, _)| v)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(v, _)| v)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(v, _)| v)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost().map(|(v, _)| v)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost().map(|(v, _)| v)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(v, _)| v)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(v, _)| v)\n}"
    ],
    [
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(v, _)| v)\n}"
    ],
    [
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\n    self.tree.remove(value).map(|(v, _)| v)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.remove(value).map(|(v, _)| v)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.remove(value).map(|(v, _)| v)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.remove(value).map(|(v, _)| v)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.remove(value).map(|(v, _)| v)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.remove(value).map(|(v, _)| v)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.remove(value).map(|(v, _)| v)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.remove(value).map(|(v, _)| v)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.remove(value).map(|(v, _)| v)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\n    self.tree.remove(value).map(|(v, _)| v)\n}"
    ],
    [
      "pub fn push (&mut self, item: T) {\n    self.tree.push(Item(item, self.seq));\n    self.seq += 1;\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.push(Item(item, self.seq));\n    self.seq += 1;\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.push(Item(item, self.seq));\n    self.seq += 1;\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.insert(Item(item, self.seq));\n    self.seq += 1;\n}",
      "pub fn push (&mut self, item: T) {\n    self.seq += 1;\n    self.tree.insert(Item(item, self.seq));\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.insert(Item(item, self.seq));\n    self.seq += 1;\n}",
      "pub fn push (&mut self, item: T) {\n    self.seq += 1;\n    self.tree.insert(Item(item, self.seq));\n}",
      "pub fn push (&mut self, item: T) {\n    self.seq += 1;\n    self.tree.insert(Item(item, self.seq));\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.insert(Item(item, self.seq));\n    self.seq += 1;\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.push(Item(item, self.seq));\n    self.seq += 1;\n}"
    ],
    [
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let len = self.read_u32()?;\n    let mut bytes = vec![0; len as usize];\n    self.read_exact(&mut bytes)?;\n    Ok(bytes)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let len = self.read_u32()?;\n    let bytes = self.read_bytes_len(len as usize)?;\n    Ok(bytes)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let len = self.read_u32()?;\n    let bytes = self.read_bytes_len(len as usize)?;\n    Ok(bytes)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let length = self.read_u32()?;\n    let bytes = self.read_bytes_len(length as usize)?;\n    Ok(bytes)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let len = self.read_u32()?;\n    let mut bytes = vec![0; len as usize];\n    self.read_exact(&mut bytes)?;\n\n    Ok(bytes)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let len = self.read_u32()?;\n    let mut bytes = vec![0; len as usize];\n    self.read_exact(&mut bytes)?;\n    Ok(bytes)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let len = self.read_u32()?;\n    let mut buf = vec![0; len as usize];\n    self.read_exact(&mut buf)?;\n    Ok(buf)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let len = self.read_u32()?;\n    let bytes = self.read_bytes_len(len as usize)?;\n    Ok(bytes)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let length = self.read_u32()?;\n    let mut bytes = Vec::with_capacity(length as usize);\n    for _ in 0..length {\n        bytes.push(self.read_u8()?);\n    }\n    Ok(bytes)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let length = self.read_u32()?;\n    let mut bytes = vec![0; length as usize];\n    self.read_exact(&mut bytes)?;\n\n    Ok(bytes)\n}"
    ],
    [
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let bytes = self.read_bytes()?;\n    let mut result = Vec::new();\n    if bytes.len() > 0 && bytes[0] == 0 {\n        result.extend_from_slice(&bytes[1..]);\n    } else {\n        result.extend_from_slice(&bytes);\n    }\n    Ok(result)\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let bytes = self.read_bytes()?;\n    if bytes.is_empty() {\n        return Ok(bytes);\n    }\n    if bytes[0] == 0 {\n        Ok(bytes[1..].to_vec())\n    } else {\n        Ok(bytes)\n    }\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let mut mpint = self.read_bytes()?;\n    if mpint.len() > 0 && mpint[0] == 0 {\n        mpint = mpint[1..].to_vec();\n    }\n    Ok(mpint)\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let bytes = self.read_bytes()?;\n    if bytes[0] == 0 {\n        Ok(bytes[1..].to_vec())\n    } else {\n        Ok(bytes)\n    }\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let bytes = self.read_bytes()?;\n    if bytes.len() > 0 && bytes[0] == 0 {\n        Ok(bytes[1..].to_vec())\n    } else {\n        Ok(bytes)\n    }\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let bytes = self.read_bytes()?;\n    if bytes.len() > 0 && bytes[0] == 0 {\n        Ok(bytes[1..].to_vec())\n    } else {\n        Ok(bytes)\n    }\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let bytes = self.read_bytes()?;\n    if bytes.is_empty() {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n    if bytes[0] == 0 {\n        Ok(bytes[1..].to_vec())\n    } else {\n        Ok(bytes)\n    }\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let bytes = self.read_bytes()?;\n    if bytes[0] == 0 {\n        Ok(bytes[1..].to_vec())\n    } else {\n        Ok(bytes)\n    }\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let mut mpint = self.read_bytes()?;\n\n    if mpint.len() > 0 && mpint[0] == 0 {\n        mpint.remove(0);\n    }\n\n    Ok(mpint)\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let mut mpint = self.read_bytes()?;\n    if mpint.len() > 0 && mpint[0] == 0 {\n        mpint.remove(0);\n    }\n    Ok(mpint)\n}"
    ],
    [
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    let result = String::from_utf8(bytes)?;\n    Ok(result)\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n\n    String::from_utf8(bytes).map_err(|_| Error::with_kind(ErrorKind::InvalidFormat))\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    String::from_utf8(bytes).map_err(|_| Error::with_kind(ErrorKind::InvalidFormat))\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    String::from_utf8(bytes).map_err(|_| Error::with_kind(ErrorKind::InvalidFormat))\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    String::from_utf8(bytes).map_err(|_| Error::with_kind(ErrorKind::InvalidFormat))\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n\n    String::from_utf8(bytes).map_err(|_| Error::with_kind(ErrorKind::InvalidFormat))\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    String::from_utf8(bytes).map_err(|_| Error::with_kind(ErrorKind::InvalidFormat))\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    let result = String::from_utf8(bytes)?;\n    Ok(result)\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    String::from_utf8(bytes).map_err(|_| Error::with_kind(ErrorKind::InvalidFormat))\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n\n    String::from_utf8(bytes).map_err(|_| Error::with_kind(ErrorKind::InvalidFormat))\n}"
    ],
    [
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 4;\n    let result = BigEndian::read_u32(&slice[..4]);\n\n    Ok(result)\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    let result = BigEndian::read_u32(&slice[..4]);\n    self.offset += 4;\n\n    Ok(result)\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 4;\n    let result = BigEndian::read_u32(&slice[..4]);\n\n    Ok(result)\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    let result = BigEndian::read_u32(&slice[..4]);\n    self.offset += 4;\n\n    Ok(result)\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    let result = BigEndian::read_u32(&slice[..4]);\n\n    self.offset += 4;\n\n    Ok(result)\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    let result = BigEndian::read_u32(&slice[..4]);\n\n    self.offset += 4;\n\n    Ok(result)\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 4;\n    let result = BigEndian::read_u32(&slice[..4]);\n\n    Ok(result)\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 4;\n    let result = BigEndian::read_u32(&slice[..4]);\n\n    Ok(result)\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    let result = BigEndian::read_u32(&slice[..4]);\n\n    self.offset += 4;\n\n    Ok(result)\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n\n    if slice.len() < 4 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 4;\n    let result = BigEndian::read_u32(&slice[..4]);\n\n    Ok(result)\n}"
    ],
    [
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    if self.offset >= self.inner.len() {\n        return Err(Error::with_kind(ErrorKind::UnexpectedEof));\n    }\n\n    let slice = &self.inner[self.offset..];\n    if slice.len() < 8 {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n\n    self.offset += 8;\n    let value = BigEndian::read_u64(&slice[..8]);\n\n    Ok(value)\n}"
    ],
    [
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    let len = val.len();\n    self.inner.extend_from_slice(&len.to_be_bytes());\n    self.inner.extend_from_slice(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    let len = val.len();\n    self.inner.write_u32::<BigEndian>(len as u32).unwrap();\n    self.inner.write_all(val).unwrap();\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    let mut buf = [0; 4];\n    BigEndian::write_u32(&mut buf, val.len() as u32);\n    self.inner.extend_from_slice(&buf);\n    self.inner.extend_from_slice(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    let len = val.len() as u32;\n    self.inner.extend_from_slice(&len.to_be_bytes());\n    self.inner.extend_from_slice(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    self.inner.extend_from_slice(&(val.len() as u32).to_be_bytes());\n    self.inner.extend_from_slice(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    let mut buf = [0; 4];\n    BigEndian::write_u32(&mut buf, val.len() as u32);\n    self.inner.extend_from_slice(&buf);\n    self.inner.extend_from_slice(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    let len = val.len();\n    let mut buf = [0u8; 4];\n    BigEndian::write_u32(&mut buf, len as u32);\n    self.inner.extend_from_slice(&buf);\n    self.inner.extend_from_slice(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    let len = val.len();\n    self.inner.extend_from_slice(&(len as u32).to_be_bytes());\n    self.inner.extend_from_slice(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    let len = val.len();\n    let mut buf = vec![0; 4];\n    BigEndian::write_u32(&mut buf, len as u32);\n    self.inner.extend_from_slice(&buf);\n    self.inner.extend_from_slice(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    let len = val.len();\n    self.inner.extend_from_slice(&(len as u32).to_be_bytes());\n    self.inner.extend_from_slice(val);\n}"
    ],
    [
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => b\"/\",\n        Component::CurDir => b\".\",\n        Component::ParentDir => b\"..\",\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => b\"/\" as &'a UnixStr,\n        Component::CurDir => b\".\" as &'a UnixStr,\n        Component::ParentDir => b\"..\" as &'a UnixStr,\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => UnixStr::from_slice(b\"\"),\n        Component::CurDir => UnixStr::from_slice(b\".\"),\n        Component::ParentDir => UnixStr::from_slice(b\"..\"),\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => UnixStr::from_str(\"/\"),\n        Component::CurDir => UnixStr::from_str(\".\"),\n        Component::ParentDir => UnixStr::from_str(\"..\"),\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => UnixStr::from_str(\"/\"),\n        Component::CurDir => UnixStr::from_str(\".\"),\n        Component::ParentDir => UnixStr::from_str(\"..\"),\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => &UnixStr::new(b\"\"),\n        Component::CurDir => &UnixStr::new(b\".\"),\n        Component::ParentDir => &UnixStr::new(b\"..\"),\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => b\"/\" as &'a UnixStr,\n        Component::CurDir => b\".\" as &'a UnixStr,\n        Component::ParentDir => b\"..\" as &'a UnixStr,\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => UnixStr::from_bytes(b\"/\"),\n        Component::CurDir => UnixStr::from_bytes(b\".\"),\n        Component::ParentDir => UnixStr::from_bytes(b\"..\"),\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => &UnixStr::from_bytes(b\"/\"),\n        Component::CurDir => &UnixStr::from_bytes(b\".\"),\n        Component::ParentDir => &UnixStr::from_bytes(b\"..\"),\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => UnixStr::from_bytes(b\"/\"),\n        Component::CurDir => UnixStr::from_bytes(b\".\"),\n        Component::ParentDir => UnixStr::from_bytes(b\"..\"),\n        Component::Normal(s) => s,\n    }\n}"
    ],
    [
      "pub fn as_path (&self) -> &'a Path {\n    Path::new(self.as_unix_str())\n}",
      "pub fn as_path (&self) -> &'a Path {\n    let mut comps = self.path.iter();\n    if self.has_physical_root {\n        comps.next();\n    }\n    if self.include_cur_dir() {\n        comps.next();\n    }\n    Path::new(self.path)\n}",
      "pub fn as_path (&self) -> &'a Path {\n    let mut comps = self.path.iter();\n    if self.has_physical_root {\n        comps.next();\n    }\n    if self.include_cur_dir() {\n        comps.next();\n    }\n    Path::new(self.path)\n}",
      "pub fn as_path (&self) -> &'a Path {\n    let mut comps = self.path.iter();\n    if self.has_physical_root {\n        comps.next();\n    }\n    if self.include_cur_dir() {\n        comps.next();\n    }\n    Path::new(comps.as_slice())\n}",
      "pub fn as_path (&self) -> &'a Path {\n    Path::new(self.as_os_str())\n}",
      "pub fn as_path (&self) -> &'a Path {\n    Path::new(self.path)\n}",
      "pub fn as_path (&self) -> &'a Path {\n    let mut comps = self.path.iter();\n    if self.has_physical_root {\n        comps.next();\n    }\n    if self.include_cur_dir() {\n        comps.next();\n    }\n    Path::new(self.path)\n}",
      "pub fn as_path (&self) -> &'a Path {\n    Path::new(self.as_os_str())\n}",
      "pub fn as_path (&self) -> &'a Path {\n    let mut comps = self.path.iter();\n    if self.has_physical_root {\n        comps.next();\n    }\n    if self.include_cur_dir() {\n        comps.next();\n    }\n    Path::new(comps.as_slice())\n}",
      "pub fn as_path (&self) -> &'a Path {\n    let mut comps = self.path.iter();\n    if self.has_physical_root {\n        comps.next();\n    }\n    if self.include_cur_dir() {\n        comps.next();\n    }\n    Path::new(comps.as_slice())\n}"
    ],
    [
      "pub fn pop (&mut self) -> bool {\n    if let Some(parent) = self.parent() {\n        self.as_mut_vec().truncate(parent.as_unix_str().len());\n        true\n    } else {\n        false\n    }\n}",
      "pub fn pop (&mut self) -> bool {\n    if let Some(parent) = self.parent() {\n        self.as_mut_vec().truncate(parent.as_unix_str().len());\n        true\n    } else {\n        false\n    }\n}",
      "pub fn pop (&mut self) -> bool {\n    let mut parent = self.parent();\n    if parent.is_none() {\n        return false;\n    }\n    let parent = parent.unwrap();\n    self.as_mut_vec().truncate(parent.as_unix_str().len());\n    true\n}",
      "pub fn pop (&mut self) -> bool {\n    let mut components = self.components();\n    if components.next_back().is_none() {\n        return false;\n    }\n    components.next_back();\n    self.inner = UnixString::from(components.as_path());\n    true\n}",
      "pub fn pop (&mut self) -> bool {\n    let mut components = self.components();\n    match components.next_back() {\n        Some(Component::ParentDir) => {\n            components.next_back();\n            for component in components.rev() {\n                self.pop();\n            }\n            true\n        }\n        Some(Component::Normal(_)) | Some(Component::Prefix(_)) | None => false,\n    }\n}",
      "pub fn pop (&mut self) -> bool {\n    let mut comps = self.components();\n    if comps.next_back().is_none() {\n        return false;\n    }\n    let mut new = PathBuf::new();\n    for comp in comps {\n        match comp {\n            Component::ParentDir => {\n                new.pop();\n            }\n            _ => {\n                new.push(comp);\n            }\n        }\n    }\n    *self = new;\n    true\n}",
      "pub fn pop (&mut self) -> bool {\n    if let Some(parent) = self.parent() {\n        self.as_mut_vec().truncate(parent.as_unix_str().len());\n        true\n    } else {\n        false\n    }\n}",
      "pub fn pop (&mut self) -> bool {\n    if self.inner.pop() {\n        if self.inner.is_empty() {\n            self.inner.push(\"/\");\n        }\n        true\n    } else {\n        false\n    }\n}",
      "pub fn pop (&mut self) -> bool {\n    if let Some(parent) = self.parent() {\n        self.as_mut_vec().truncate(parent.as_unix_str().len());\n        true\n    } else {\n        false\n    }\n}",
      "pub fn pop (&mut self) -> bool {\n    if self.parent().is_none() {\n        false\n    } else {\n        self.as_mut_vec().truncate(self.parent().unwrap().as_unix_str().len());\n        true\n    }\n}"
    ],
    [
      "pub fn parent (&self) -> Option<&Path> {\n    let mut components = self.components();\n    components.next_back();\n    components.as_path()\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    let mut components = self.components();\n    components.next_back();\n    components.as_path()\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    let mut components = self.components();\n    components.next_back();\n    components.as_path()\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    let mut components = self.components();\n    components.next_back();\n    components.as_path()\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    let mut components = self.components();\n    components.next_back();\n    components.as_path()\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    self.components().next().and_then(|c| c.as_path())\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    self.components().next().map(Path::from)\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    self.components().next().and_then(|c| c.as_path())\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    let mut components = self.components();\n    components.next_back();\n    components.as_path()\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    let mut components = self.components();\n    components.next_back();\n    components.as_path()\n}"
    ],
    [
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    let mut comps = self.components();\n    let comp = comps.next_back();\n    comp.and_then(|p| match p {\n        Component::Normal(s) => Some(s),\n        Component::CurDir | Component::ParentDir => None,\n    })\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    let mut comps = self.components();\n    let comp = comps.next_back();\n    comp.and_then(|p| match p {\n        Component::Normal(s) => Some(s),\n        Component::CurDir | Component::ParentDir => None,\n    })\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    let mut comps = self.components();\n    let comp = comps.next_back();\n    comp.and_then(|p| match p {\n        Component::Normal(s) => Some(s),\n        _ => None,\n    })\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    let mut comps = self.components();\n    let comp = comps.next_back();\n    comp.and_then(|p| match p {\n        Component::Normal(s) => Some(s),\n        Component::CurDir | Component::ParentDir => None,\n    })\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    let mut comps = self.components();\n    let comp = comps.next_back();\n    comp.and_then(|p| match p {\n        Component::Normal(s) => Some(s),\n        Component::CurDir | Component::ParentDir => None,\n    })\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    let mut comps = self.components();\n    let comp = comps.next_back();\n    comp.and_then(|p| match p {\n        Component::Normal(s) => Some(s),\n        _ => None,\n    })\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    let mut comps = self.components();\n    let comp = comps.next_back();\n    comp.and_then(|p| match p {\n        Component::Normal(s) => Some(s),\n        _ => None,\n    })\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    self.components().next_back().and_then(|c| match c {\n        Component::Normal(s) => Some(s),\n        _ => None,\n    })\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    self.components().next_back().and_then(|c| match c {\n        Component::Normal(s) => Some(s),\n        _ => None,\n    })\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    let mut comps = self.components();\n    let comp = comps.next_back();\n    comp.and_then(|p| match p {\n        Component::Normal(s) => Some(s),\n        Component::CurDir | Component::ParentDir => None,\n    })\n}"
    ],
    [
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    let cur_len = self.v.len();\n    if len >= cur_len {\n        self.v.reserve_exact(len - cur_len);\n    }\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    let cur_len = self.v.len();\n    if len >= cur_len {\n        self.v.reserve_exact(len - cur_len);\n    }\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    let cur_len = self.v.len();\n    if len >= cur_len {\n        self.v.reserve_exact(len - cur_len);\n    }\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    let cur_len = self.v.len();\n    if len >= cur_len {\n        self.v.reserve_exact(len - cur_len);\n    }\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    let cur_len = self.v.len();\n    if len >= cur_len {\n        self.v.reserve_exact(len - cur_len);\n    }\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    let cur_len = self.v.len();\n    if len >= cur_len {\n        self.v.reserve_exact(len - cur_len);\n    }\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    let cur_len = self.v.len();\n    if len >= cur_len {\n        self.v.reserve_exact(len - cur_len);\n    }\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    let cur_len = self.v.len();\n    if len >= cur_len {\n        self.v.reserve_exact(len - cur_len);\n    }\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    let cur_len = self.v.len();\n    if len >= cur_len {\n        self.v.reserve_exact(len - cur_len);\n    }\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    let cur_len = self.v.len();\n    if len >= cur_len {\n        self.v.reserve_exact(len - cur_len);\n    }\n}"
    ],
    [
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}"
    ],
    [
      "pub fn append (&mut self, other: &mut Self) {\n    for (k, v) in other.iter_mut() {\n        self.insert(k, v);\n    }\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    for (k, v) in other.iter_mut() {\n        self.insert(k, v);\n    }\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    let mut other_iter = other.iter_mut();\n    while let Some((key, value)) = other_iter.next() {\n        self.insert(key, value);\n    }\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    let mut i = 0;\n    let mut j = 0;\n    while i < self.v.len() && j < other.v.len() {\n        if let Some(k) = self.v[i] {\n            i += 1;\n        } else {\n            self.v[i] = other.v[j].take();\n            j += 1;\n        }\n    }\n    if j < other.v.len() {\n        self.v.extend(other.v.drain(j..));\n    }\n    self.n = self.v.len();\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    for (k, v) in other.iter_mut() {\n        self.insert(k, v);\n    }\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    for (k, v) in other.drain() {\n        self.insert(k, v);\n    }\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    for (key, value) in other.drain() {\n        self.insert(key, value);\n    }\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    for (k, v) in other.iter_mut() {\n        self.insert(k, v);\n    }\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    for (key, value) in other.iter_mut() {\n        self.insert(key, value);\n    }\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    let mut other_iter = other.iter_mut();\n    while let Some((key, value)) = other_iter.next() {\n        self.insert(key, value);\n    }\n}"
    ],
    [
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::new();\n    other.v = self.v.split_off(at);\n    other.n = self.n;\n    self.n = at;\n    other\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::new();\n    other.v = self.v.split_off(at);\n    other.n = self.n - at;\n    self.n = at;\n    other\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::new();\n    for (k, v) in self.drain().skip(at) {\n        other.insert(k, v);\n    }\n    other\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::new();\n    other.n = self.n;\n    other.v = self.v.split_off(at);\n    self.n -= other.n;\n    other\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::new();\n    other.v = self.v.split_off(at);\n    other.n = self.n - at;\n    self.n = at;\n    other\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::new();\n    for (key, value) in self.drain() {\n        if key < at {\n            self.insert(key, value);\n        } else {\n            other.insert(key, value);\n        }\n    }\n    other\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::new();\n    for i in at..self.n {\n        other.insert(i, self.v[i].take().unwrap());\n    }\n    other\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::new();\n    let mut i = 0;\n    let mut j = 0;\n    while i < self.v.len() {\n        if j == at {\n            other.v.push(self.v.remove(i));\n            other.n += 1;\n        } else {\n            i += 1;\n        }\n        j += 1;\n    }\n    other\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::new();\n    for (k, v) in self.drain() {\n        if k < at {\n            self.insert(k, v);\n        } else {\n            other.insert(k, v);\n        }\n    }\n    other\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::new();\n    other.n = self.n - at;\n    other.v.extend(self.v.drain(at..));\n    self.n = at;\n    other\n}"
    ],
    [
      "pub fn get (&self, key: usize) -> Option<&V> {\n    let idx = self.v.iter().position(|x| x.as_ref().map_or(false, |(k, _)| k == &key));\n    idx.and_then(|i| self.v[i].as_ref())\n        .map(|(_, v)| v)\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    if key < self.v.len() {\n        self.v[key].as_ref()\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    self.v.get(key).and_then(|v| v.as_ref())\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    self.v.get(key).and_then(|e| e.as_ref())\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    let i = self.v.get(key)?;\n    i.as_ref()\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    self.v.get(key).and_then(|v| v.as_ref())\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    self.v.get(key).and_then(|v| v.as_ref())\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    let idx = self.find_idx(key)?;\n    self.v[idx].as_ref()\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    if key < self.v.len() {\n        self.v[key].as_ref()\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    self.v.get(key).and_then(|x| x.as_ref())\n}"
    ],
    [
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key < self.v.len() {\n        self.v[key].replace(value)\n    } else {\n        self.v.push(Some(value));\n        self.n += 1;\n        None\n    }\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key < self.v.len() {\n        self.v[key].replace(value)\n    } else {\n        self.v.push(Some(value));\n        self.n += 1;\n        None\n    }\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key < self.v.len() {\n        self.v[key].replace(value)\n    } else {\n        self.v.push(Some(value));\n        self.n += 1;\n        None\n    }\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key >= self.v.len() {\n        self.v.resize(key + 1, None);\n    }\n    self.n += 1;\n    self.v[key].replace(value)\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key < self.v.len() {\n        let old_value = self.v[key].take();\n        self.v[key] = Some(value);\n        old_value\n    } else {\n        self.v.resize(key + 1, None);\n        self.v[key] = Some(value);\n        self.n += 1;\n        None\n    }\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key < self.v.len() {\n        self.v[key].replace(value)\n    } else {\n        self.v.resize(key + 1, None);\n        self.v[key].replace(value);\n        self.n += 1;\n        None\n    }\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key < self.v.len() {\n        self.v[key].replace(value)\n    } else {\n        self.v.resize_with(key + 1, Default::default);\n        self.v[key].replace(value);\n        self.n += 1;\n        None\n    }\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key < self.v.len() {\n        self.v[key].replace(value)\n    } else {\n        self.v.resize(key + 1, None);\n        self.v[key].replace(value);\n        self.n += 1;\n        None\n    }\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key < self.v.len() {\n        self.v[key].replace(value)\n    } else {\n        self.v.push(Some(value));\n        None\n    }\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key < self.v.len() {\n        self.v[key].replace(value)\n    } else {\n        self.v.resize(key + 1, None);\n        self.v[key].replace(value);\n        self.n += 1;\n        None\n    }\n}"
    ],
    [
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    if key < self.v.len() {\n        let was = replace(&mut self.v[key], None);\n        if was.is_some() {\n            self.n -= 1;\n        }\n        was\n    } else {\n        None\n    }\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    if key < self.v.len() {\n        let was = replace(&mut self.v[key], None);\n        if was.is_some() {\n            self.n -= 1;\n        }\n        was\n    } else {\n        None\n    }\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    if key < self.v.len() {\n        let was = replace(&mut self.v[key], None);\n        if was.is_some() {\n            self.n -= 1;\n        }\n        was\n    } else {\n        None\n    }\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    if key < self.v.len() {\n        let was = replace(&mut self.v[key], None);\n        if was.is_some() {\n            self.n -= 1;\n        }\n        was\n    } else {\n        None\n    }\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    if key < self.v.len() {\n        let was = replace(&mut self.v[key], None);\n        if was.is_some() {\n            self.n -= 1;\n        }\n        was\n    } else {\n        None\n    }\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    if key < self.v.len() {\n        let was = replace(&mut self.v[key], None);\n        if was.is_some() {\n            self.n -= 1;\n        }\n        was\n    } else {\n        None\n    }\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    if key < self.v.len() {\n        let was = replace(&mut self.v[key], None);\n        if was.is_some() {\n            self.n -= 1;\n        }\n        was\n    } else {\n        None\n    }\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    if key < self.v.len() {\n        let was = replace(&mut self.v[key], None);\n        if was.is_some() {\n            self.n -= 1;\n        }\n        was\n    } else {\n        None\n    }\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    if key < self.v.len() {\n        let was = replace(&mut self.v[key], None);\n        if was.is_some() {\n            self.n -= 1;\n        }\n        was\n    } else {\n        None\n    }\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    if key < self.v.len() {\n        let was = replace(&mut self.v[key], None);\n        if was.is_some() {\n            self.n -= 1;\n        }\n        was\n    } else {\n        None\n    }\n}"
    ],
    [
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    for i in 0..self.v.len() {\n        if let Some(ref mut v) = self.v[i] {\n            if !f(i, v) {\n                self.remove(i);\n            }\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    for i in 0..self.v.len() {\n        let v = self.v.get_mut(i);\n        if v.is_some() && !f(i, v.unwrap()) {\n            self.remove(i);\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    for i in 0..self.v.len() {\n        if let Some(value) = self.v[i].as_mut() {\n            if !f(i, value) {\n                self.v[i].take();\n                self.n -= 1;\n            }\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    for i in 0..self.v.len() {\n        let value = self.v[i].as_mut();\n        if value.is_some() && !f(i, value.as_mut().unwrap()) {\n            self.v[i] = None;\n            self.n -= 1;\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    for i in 0..self.v.len() {\n        let val = self.v[i].as_mut();\n        if val.is_some() && !f(i, val.unwrap()) {\n            self.v[i] = None;\n            self.n -= 1;\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    for i in 0..self.v.len() {\n        if let Some(ref mut v) = self.v[i] {\n            if !f(i, v) {\n                self.v[i] = None;\n                self.n -= 1;\n            }\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    for i in 0..self.v.len() {\n        if let Some(value) = self.v.get_mut(i) {\n            if !f(i, value) {\n                self.v[i] = None;\n                self.n -= 1;\n            }\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    for i in 0..self.v.len() {\n        let value = self.v[i].as_mut();\n        if value.is_none() || !f(i, value.as_mut().unwrap()) {\n            self.v[i] = None;\n            self.n -= 1;\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    for i in 0..self.v.len() {\n        if let Some(value) = self.v[i].as_mut() {\n            if !f(i, value) {\n                self.remove(i);\n            }\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    for i in 0..self.v.len() {\n        if let Some(value) = self.v[i].as_mut() {\n            if !f(i, value) {\n                self.v[i] = None;\n                self.n -= 1;\n            }\n        }\n    }\n}"
    ],
    [
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    if self.length < self.capacity() {\n        unsafe {\n            let ptr = self.end_mut_ptr();\n            ptr::write(ptr, val);\n            self.length += 1;\n        }\n        Ok(())\n    } else {\n        Err(val)\n    }\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    if self.length == self.capacity() {\n        return Err(val);\n    }\n    unsafe {\n        self.uninit.as_begin_ptr().add(self.length).write(val);\n        self.length += 1;\n    }\n    Ok(())\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    if self.length == self.capacity() {\n        return Err(val);\n    }\n    unsafe {\n        self.uninit.as_mut_ptr().add(self.length).write(val);\n        self.length += 1;\n    }\n    Ok(())\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    if self.length == self.capacity() {\n        return Err(val);\n    }\n    unsafe {\n        let end_ptr = self.end_mut_ptr();\n        end_ptr.write(val);\n        self.length += 1;\n    }\n    Ok(())\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    if self.length < self.capacity() {\n        unsafe {\n            let end_ptr = self.end_mut_ptr();\n            end_ptr.write(val);\n            self.length += 1;\n        }\n        Ok(())\n    } else {\n        Err(val)\n    }\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    if self.length == self.capacity() {\n        return Err(val);\n    }\n    unsafe {\n        self.as_mut_slice().push(val);\n    }\n    Ok(())\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    if self.length == self.capacity() {\n        Err(val)\n    } else {\n        unsafe {\n            let ptr = self.end_mut_ptr();\n            ptr::write(ptr, val);\n            self.length += 1;\n        }\n        Ok(())\n    }\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    if self.length < self.capacity() {\n        unsafe {\n            self.uninit.as_mut_ptr().add(self.length).write(val);\n            self.length += 1;\n        }\n        Ok(())\n    } else {\n        Err(val)\n    }\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    if self.length == self.capacity() {\n        return Err(val);\n    }\n    unsafe {\n        self.uninit.as_mut_ptr().add(self.length).write(val);\n        self.length += 1;\n    }\n    Ok(())\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    if self.length == self.capacity() {\n        Err(val)\n    } else {\n        unsafe {\n            self.uninit.as_mut_ptr().add(self.length).write(val);\n            self.length += 1;\n            Ok(())\n        }\n    }\n}"
    ],
    [
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity());\n    let (head, tail) = self.uninit.split_at(at);\n    FixedVec {\n        uninit: tail,\n        length: self.length - at,\n    }\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity());\n    let (head, tail) = self.uninit.split_at(at);\n    FixedVec {\n        uninit: tail,\n        length: self.length - at,\n    }\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity());\n    let (head, tail) = self.head_tail_mut();\n    let (head, tail) = (head.split_to(at), tail.split_to(self.capacity() - at));\n    FixedVec {\n        uninit: Uninit::from(head.chain(tail)),\n        length: self.length,\n    }\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity());\n    let (head, tail) = self.head_tail_mut();\n    let (head, tail) = (head.split_to(at), tail.split_to(at));\n    FixedVec {\n        uninit: Uninit::from(head),\n        length: at,\n        _marker: PhantomData,\n    }\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity());\n    let (head, tail) = self.head_tail_mut();\n    let (head, tail) = (&mut head[..at], &mut tail[..(self.capacity() - at)]);\n    let mut other = FixedVec::new(Uninit::from(tail));\n    other.length = self.length - at;\n    self.length = at;\n    unsafe {\n        // SAFETY: `other` is a valid `FixedVec` and `self` is a valid `FixedVec`\n        // `self` is the head of the split, `other` is the tail.\n        // The tail is not used in `self` and the head is not used in `other`.\n        // This is safe because `self` and `other` are disjoint and `self` is a valid `FixedVec`.\n        ptr::copy_nonoverlapping(other.uninit.as_ptr(), head.as_mut_ptr(), other.capacity());\n    }\n    other\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity());\n    let (head, tail) = self.uninit.split_at(at);\n    let mut other = FixedVec::new(tail);\n    other.length = self.length - at;\n    self.length = at;\n    other\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity());\n    let (uninit, capacity) = self.uninit.split_at(at);\n    FixedVec {\n        uninit,\n        length: self.length,\n        capacity,\n    }\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity());\n    let mut other = FixedVec::new(self.uninit.split_borrowed(at));\n    other.length = self.length - at;\n    self.length = at;\n    other\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity());\n    let (head, tail) = self.uninit.split_at(at);\n    let mut other = FixedVec::new(tail);\n    self.uninit = head;\n    other.length = self.length - at;\n    self.length = at;\n    other\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity());\n    let (head, tail) = self.head_tail_mut();\n    let (_, tail) = tail.split_at(at);\n    let mut new_vec = FixedVec::new(tail);\n    new_vec.length = at;\n    self.length -= at;\n    new_vec\n}"
    ],
    [
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.strong_count() == 0 {\n        return None;\n    }\n\n    let rc = Rc::from_inner(self.inner.clone());\n    rc.inc_strong();\n    Some(rc)\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.is_unique_to_rc_memory() {\n        let ptr = self.inner.as_non_null();\n        let len = self.inner.size();\n        unsafe {\n            // SAFETY: restored the memory that an rc has originally provided to the `Weak`. We are\n            // the only reference to it, so it is fine to restore the original unqiue allocation\n            // reference.\n            Some(Rc::from_memory(ptr.cast(), len))\n        }\n    } else {\n        None\n    }\n}\n\nfn is_unique_to_rc_memory(&self) -> bool {\n    Rc::strong_count(self) == 1 && Rc::weak_count(self) == 1\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.strong_count() == 0 {\n        return None;\n    }\n\n    let inner = self.inner();\n    let strong = inner.strong.get();\n    let weak = inner.weak.get();\n\n    if strong == 0 {\n        return None;\n    }\n\n    inner.strong.set(strong + 1);\n    inner.weak.set(weak - 1);\n\n    Some(Rc {\n        inner: NonNull::new_unchecked(self.inner.as_ptr() as *mut RcBox<T>),\n        phantom: PhantomData,\n    })\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.strong_count() == 0 {\n        return None;\n    }\n    let rc = Rc {\n        inner: self.inner,\n        phantom: PhantomData,\n    };\n    rc.inc_strong();\n    Some(rc)\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.strong_count() == 0 {\n        return None;\n    }\n    let inner = self.inner();\n    let new_inner = unsafe {\n        RcBox::from_raw(inner.as_ptr())\n    };\n    let rc = Rc {\n        inner: new_inner,\n        phantom: PhantomData,\n    };\n    rc.inc_strong();\n    Some(rc)\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.strong_count() == 0 {\n        None\n    } else {\n        let inner = self.inner().clone();\n        inner.inc_strong();\n        Some(Rc { inner })\n    }\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.strong_count() == 0 {\n        None\n    } else {\n        Some(Rc::from_inner(self.inner.clone()))\n    }\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.strong_count() == 0 {\n        return None;\n    }\n    let rc = Rc::new_with_memory(self.inner.as_non_null(), self.inner.size());\n    rc.inc_strong();\n    Some(rc)\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.is_unique_to_rc_memory() {\n        let ptr = self.inner.as_non_null();\n        let len = self.inner.size();\n        unsafe {\n            // SAFETY: restored the memory that an rc has originally provided to the `Weak`. We are\n            // the only reference to it, so it is fine to restore the original unqiue allocation\n            // reference.\n            Some(Rc::from_memory(ptr.cast(), len))\n        }\n    } else {\n        None\n    }\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.is_unique_to_rc_memory() {\n        let ptr = self.inner.as_non_null();\n        let len = self.inner.size();\n        unsafe {\n            // SAFETY: restored the memory that an rc has originally provided to the `Weak`. We are\n            // the only reference to it, so it is fine to restore the original unqiue allocation\n            // reference.\n            Some(Rc::from_memory(ptr.cast(), len))\n        }\n    } else {\n        None\n    }\n}\n\nfn is_unique_to_rc_memory(&self) -> bool {\n    Rc::strong_count(self) == 1 && Rc::weak_count(self) == 1\n}"
    ]
  ]
}