{
  "benchmark": "rusteval-cr",
  "lastest_eval": {
    "compile@1": 0.35000000000000003,
    "pass@1": 0.23333333333333336,
    "compile@3": 0.5072222222222224,
    "pass@3": 0.35398148148148145,
    "compile@5": 0.5628306878306877,
    "pass@5": 0.4104056437389771
  },
  "n": 10,
  "k": [
    1,
    3,
    5
  ],
  "fn_codes": [
    [
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut bv = BitVec::with_capacity(nbits);\n    bv.set_all();\n    bv.negate();\n    bv\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut storage = Vec::<B>::with_capacity(nbits);\n    let nblocks = nbits / B::BITS + (nbits % B::BITS > 0) as usize;\n    for _ in 0..nblocks {\n        storage.push(B::from_bool(bit));\n    }\n    Self {\n        storage,\n        nbits,\n    }\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut storage = Vec::with_capacity(nbits);\n    let mut nbits_left = nbits;\n    while nbits_left > 0 {\n        let mut block = 0;\n        for _ in 0..std::mem::size_of::<B>() * 8 {\n            if nbits_left == 0 {\n                break;\n            }\n            block <<= 1;\n            if bit {\n                block |= 1;\n            }\n            nbits_left -= 1;\n        }\n        storage.push(block);\n    }\n    BitVec {\n        storage,\n        nbits,\n    }\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut storage = Vec::<B, Global>::new();\n    let mut nblocks = nbits / B::BITS;\n    if nbits % B::BITS != 0 {\n        nblocks += 1;\n    }\n    for _ in 0..nblocks {\n        storage.push(B::from_elem(B::BITS, bit));\n    }\n    BitVec {\n        storage: storage,\n        nbits: nbits,\n    }\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut storage = Vec::<B>::with_capacity(nbits);\n    let mut nbits = nbits;\n    while nbits > 0 {\n        storage.push(if bit { !0 } else { 0 });\n        nbits -= B::BITS as usize;\n    }\n    Self {\n        storage,\n        nbits,\n    }\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut storage = Vec::<B>::with_capacity(nbits);\n    let mut nbits = nbits;\n    while nbits > 0 {\n        let block = if bit { !0 } else { 0 };\n        storage.push(block);\n        nbits -= B::BITS as usize;\n    }\n    Self { storage, nbits }\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut storage = Vec::with_capacity(nbits);\n    let mut nblocks = nbits / B::BITS;\n    if nbits % B::BITS != 0 {\n        nblocks += 1;\n    }\n    for _ in 0..nblocks {\n        storage.push(if bit { !0 } else { 0 });\n    }\n    Self {\n        storage,\n        nbits,\n    }\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut storage = Vec::with_capacity(nbits);\n    let mut nbits = nbits;\n    while nbits > 0 {\n        let n = cmp::min(nbits, B::BITS as usize);\n        storage.push(if bit { !0 } else { 0 });\n        nbits -= n;\n    }\n    Self { storage, nbits }\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut storage = Vec::with_capacity(nbits);\n    let nblocks = nbits / B::BITS + (nbits % B::BITS > 0) as usize;\n    for _ in 0..nblocks {\n        storage.push(B::from_bool(bit));\n    }\n    Self {\n        storage,\n        nbits,\n    }\n}",
      "pub fn from_elem (nbits: usize, bit: bool) -> Self {\n    let mut storage = Vec::<B>::with_capacity(nbits);\n    let mut nbits_remaining = nbits;\n    let mut last_block_mask = !0;\n    while nbits_remaining > 0 {\n        let block = if bit {\n            last_block_mask\n        } else {\n            0\n        };\n        storage.push(block);\n        nbits_remaining -= B::BITS as usize;\n        last_block_mask = !0 >> (B::BITS as usize - nbits_remaining);\n    }\n    BitVec {\n        storage,\n        nbits,\n    }\n}"
    ],
    [
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bv = Self::with_capacity(len);\n    bv.storage.resize(len, false);\n    for i in 0..len {\n        bv.storage[i] = f(i);\n    }\n    bv\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut storage = Vec::with_capacity(len / B::BITS + 1);\n    let mut nbits = len;\n    for i in 0..len {\n        let bit = f(i);\n        if i % B::BITS == 0 {\n            storage.push(0);\n        }\n        if bit {\n            storage[i / B::BITS] |= 1 << (i % B::BITS);\n        }\n    }\n    BitVec { storage, nbits }\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut storage = Vec::with_capacity(len);\n    let mut nbits = 0;\n    let mut block = 0;\n    for i in 0..len {\n        let bit = f(i);\n        if nbits == B::BITS {\n            storage.push(block);\n            nbits = 0;\n            block = 0;\n        }\n        block |= (bit as B) << (B::BITS - 1 - nbits);\n        nbits += 1;\n    }\n    if nbits > 0 {\n        storage.push(block);\n    }\n    Self {\n        storage,\n        nbits,\n    }\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bv = Self::with_capacity(len);\n    bv.set_len(len);\n    for i in 0..len {\n        bv.set(i, f(i));\n    }\n    bv\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bv = Self::with_capacity(len);\n    bv.set_len(len);\n    for i in 0..len {\n        bv.set(i, f(i));\n    }\n    bv\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut storage = Vec::with_capacity(len / B::BITS + 1);\n    let mut nbits = len;\n    let mut last_block = 0;\n    let mut last_block_mask = 0;\n    for i in 0..len {\n        let bit = f(i);\n        if bit {\n            last_block |= last_block_mask;\n        }\n        last_block_mask <<= 1;\n        if last_block_mask == 0 {\n            storage.push(last_block);\n            last_block = 0;\n            last_block_mask = 1;\n        }\n    }\n    if last_block != 0 {\n        storage.push(last_block);\n    }\n    Self { storage, nbits }\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut storage = Vec::with_capacity(len);\n    let mut nbits = 0;\n    let mut block = 0;\n    for i in 0..len {\n        let bit = f(i);\n        block |= bit << (nbits % BITS);\n        nbits += 1;\n        if nbits % BITS == 0 {\n            storage.push(block);\n            block = 0;\n        }\n    }\n    if nbits % BITS != 0 {\n        storage.push(block);\n    }\n    Self {\n        storage,\n        nbits,\n    }\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut storage = Vec::with_capacity(len / B::BITS + 1);\n    let mut nbits = len;\n    let mut i = 0;\n    while i < len {\n        let block = f(i);\n        storage.push(block);\n        i += 1;\n    }\n    BitVec {\n        storage: storage,\n        nbits: nbits,\n    }\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut bv = Self::with_capacity(len);\n    for i in 0..len {\n        bv.push(f(i));\n    }\n    bv\n}",
      "pub fn from_fn <F> (len: usize, mut f: F) -> Self where F: FnMut(usize) -> bool {\n    let mut storage = Vec::<B>::with_capacity(len);\n    let mut nbits = 0;\n    let mut block = B::default();\n    let mut mask = B::default();\n    for i in 0..len {\n        if nbits == B::BITS {\n            storage.push(block);\n            nbits = 0;\n            block = B::default();\n            mask = B::default();\n        }\n        if f(i) {\n            block |= mask;\n        }\n        mask <<= 1;\n        nbits += 1;\n    }\n    if nbits > 0 {\n        storage.push(block);\n    }\n    Self { storage, nbits }\n}"
    ],
    [
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i >= self.nbits {\n        return None;\n    }\n    let (block_index, bit_index) = self.block_index(i);\n    let block = self.storage[block_index];\n    let mask = 1 << bit_index;\n    Some((block & mask) != 0)\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i >= self.nbits {\n        None\n    } else {\n        let block = i / B::nbits();\n        let bit = i % B::nbits();\n        Some(self.storage[block].get_bit(bit))\n    }\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i >= self.nbits {\n        None\n    } else {\n        let (block_idx, bit_idx) = (i / B::BITS, i % B::BITS);\n        let block = self.storage.get(block_idx)?;\n        Some(block & (B::one() << bit_idx) != B::zero())\n    }\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i < self.nbits {\n        let block = i / B::nbits();\n        let bit = i % B::nbits();\n        let mask = B::one() << bit;\n        let storage = self.storage();\n        let block = storage.get(block)?;\n        let block = block & mask;\n        Some(block != B::zero())\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i >= self.nbits {\n        return None;\n    }\n    let (block_index, bit_index) = self.block_index(i);\n    let block = self.storage[block_index];\n    let bit_mask = 1 << bit_index;\n    Some(block & bit_mask != 0)\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i >= self.nbits {\n        return None;\n    }\n    let block = i / B::nbits();\n    let bit = i % B::nbits();\n    let mask = B::one() << bit;\n    Some(self.storage[block] & mask != B::zero())\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i >= self.nbits {\n        return None;\n    }\n    let block = i / B::BITS;\n    let bit = i % B::BITS;\n    let mask = B::one() << bit;\n    let block = &self.storage[block];\n    Some((*block & mask) != B::zero())\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i < self.nbits {\n        let block_index = i / B::BITS as usize;\n        let bit_index = i % B::BITS as usize;\n        let block = self.storage.get(block_index)?;\n        Some((block & (B::ONE << bit_index)) != B::ZERO)\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i < self.nbits {\n        let block = i / B::BITS;\n        let bit = i % B::BITS;\n        let block = self.storage.get(block)?;\n        Some(block & (B::ONE << bit) != B::ZERO)\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, i: usize) -> Option<bool> {\n    if i < self.nbits {\n        let (block_index, bit_index) = (i / B::BITS, i % B::BITS);\n        let block = self.storage.get(block_index)?;\n        Some((block & (B::one() << bit_index)) != B::zero())\n    } else {\n        None\n    }\n}"
    ],
    [
      "pub fn set (&mut self, i: usize, x: bool) {\n    let (block, mask) = self.get_block_and_mask(i);\n    if x {\n        *block |= mask;\n    } else {\n        *block &= !mask;\n    }\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    if i >= self.nbits {\n        panic!(\"index out of bounds\");\n    }\n    let block = i / B::BITS;\n    let bit = i % B::BITS;\n    let mask = B::one() << bit;\n    if x {\n        self.storage[block] |= mask;\n    } else {\n        self.storage[block] &= !mask;\n    }\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    let (block_index, bit_index) = self.index_to_bit_index(i);\n    let block = &mut self.storage[block_index];\n    let mask = 1 << bit_index;\n    if x {\n        *block |= mask;\n    } else {\n        *block &= !mask;\n    }\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    let (block, bit) = self.index_to_block_bit(i);\n    let mask = 1 << bit;\n    let block = self.storage_mut()[block];\n    if x {\n        self.storage_mut()[block] |= mask;\n    } else {\n        self.storage_mut()[block] &= !mask;\n    }\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    let (block, bit) = self.get_block_and_bit(i);\n    let mask = 1 << bit;\n    if x {\n        self.storage[block] |= mask;\n    } else {\n        self.storage[block] &= !mask;\n    }\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    let (block, bit) = self.block_bit(i);\n    let mask = 1 << bit;\n    let mut block = self.storage[block];\n    if x {\n        block |= mask;\n    } else {\n        block &= !mask;\n    }\n    self.storage[block] = block;\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    let (block_index, bit_index) = self.get_indices(i);\n    let block = &mut self.storage[block_index];\n    let mask = 1 << bit_index;\n    if x {\n        *block |= mask;\n    } else {\n        *block &= !mask;\n    }\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    if i >= self.nbits {\n        panic!(\"Index out of bounds: the len is {} but the index is {}\", self.nbits, i);\n    }\n    let (block_index, bit_index) = (i / B::BITS, i % B::BITS);\n    let block = &mut self.storage[block_index];\n    let mask = B::one() << bit_index;\n    if x {\n        *block |= mask;\n    } else {\n        *block &= !mask;\n    }\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    let (block_index, bit_index) = self.block_indices(i);\n    let block = self.storage_mut().get_mut(block_index).unwrap();\n    let mask = 1 << bit_index;\n    if x {\n        *block |= mask;\n    } else {\n        *block &= !mask;\n    }\n}",
      "pub fn set (&mut self, i: usize, x: bool) {\n    let (block_index, bit_index) = self.index_to_bit_index(i);\n    let block = &mut self.storage[block_index];\n    let mask = 1 << bit_index;\n    if x {\n        *block |= mask;\n    } else {\n        *block &= !mask;\n    }\n}"
    ],
    [
      "pub fn negate (&mut self) {\n    for i in 0..self.storage.len() {\n        self.storage[i] = !self.storage[i];\n    }\n}",
      "pub fn negate (&mut self) {\n    for block in self.blocks_mut() {\n        *block = !*block;\n    }\n    self.fix_last_block_with_ones();\n}",
      "pub fn negate (&mut self) {\n    for block in self.blocks_mut() {\n        *block = !*block;\n    }\n    self.fix_last_block_with_ones();\n}",
      "pub fn negate (&mut self) {\n    for i in 0..self.nbits {\n        self.set(i, !self.get(i).unwrap());\n    }\n}",
      "pub fn negate (&mut self) {\n    for b in self.storage.iter_mut() {\n        *b = !*b;\n    }\n}",
      "pub fn negate (&mut self) {\n    for b in self.storage_mut().iter_mut() {\n        *b = !*b;\n    }\n}",
      "pub fn negate (&mut self) {\n    for b in self.storage.iter_mut() {\n        *b = !*b;\n    }\n}",
      "pub fn negate (&mut self) {\n    for block in self.storage_mut().iter_mut() {\n        *block = !*block;\n    }\n}",
      "pub fn negate (&mut self) {\n    for block in self.storage_mut().iter_mut() {\n        *block = !*block;\n    }\n    self.fix_last_block_with_ones();\n}",
      "pub fn negate (&mut self) {\n    for i in 0..self.nbits {\n        self.set(i, !self.get(i).unwrap());\n    }\n}"
    ],
    [
      "pub fn all (&self) -> bool {\n    self.blocks().all()\n}",
      "pub fn all (&self) -> bool {\n    let mut blocks = self.blocks();\n    let mut all = true;\n    while let Some(block) = blocks.next() {\n        all = all && block.all();\n    }\n    all\n}",
      "pub fn all (&self) -> bool {\n    self.storage.iter().all(|x| x == &Self::mask(self.nbits))\n}",
      "pub fn all (&self) -> bool {\n    let mut all = true;\n    for (i, bit) in self.iter().enumerate() {\n        if !bit {\n            all = false;\n            break;\n        }\n    }\n    all\n}",
      "pub fn all (&self) -> bool {\n    for i in 0..self.nbits {\n        if self.get(i).unwrap() == false {\n            return false;\n        }\n    }\n    true\n}",
      "pub fn all (&self) -> bool {\n    for i in 0..self.nbits {\n        if self.get(i).unwrap() == false {\n            return false;\n        }\n    }\n    true\n}",
      "pub fn all (&self) -> bool {\n    self.iter().all(|&b| b)\n}",
      "pub fn all (&self) -> bool {\n    self.storage().iter().all(|&b| b == B::max_value())\n}",
      "pub fn all (&self) -> bool {\n    self.storage().iter().all(|&b| b == !0)\n}",
      "pub fn all (&self) -> bool {\n    let mut i = 0;\n    while i < self.nbits {\n        if !self.get(i).unwrap() {\n            return false;\n        }\n        i += 1;\n    }\n    true\n}"
    ],
    [
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::with_capacity(self.nbits / 8 + 1);\n    let mut block = 0;\n    let mut bit = 0;\n    for &b in self.storage.iter() {\n        let mut byte = 0;\n        for i in 0..8 {\n            if bit == 0 {\n                byte = (b >> (7 - i)) & 1;\n            } else {\n                byte |= (b >> (15 - i)) & 1;\n            }\n            if bit == 7 {\n                bytes.push(byte);\n                block += 1;\n                bit = 0;\n            } else {\n                bit += 1;\n            }\n        }\n    }\n    if bit != 0 {\n        bytes.push(0);\n        for i in 0..bit {\n            bytes[bytes.len() - 1] |= 1 << (7 - i);\n        }\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::with_capacity(self.nbits / 8);\n    let mut byte = 0;\n    let mut cnt = 0;\n    for bit in self.storage.iter() {\n        byte <<= 1;\n        if *bit {\n            byte |= 1;\n        }\n        cnt += 1;\n        if cnt == 8 {\n            bytes.push(byte);\n            byte = 0;\n            cnt = 0;\n        }\n    }\n    if cnt > 0 {\n        bytes.push(byte << (8 - cnt));\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::new();\n    let mut byte = 0;\n    let mut byte_pos = 0;\n    for bit in self.iter() {\n        if bit {\n            byte |= 1 << byte_pos;\n        }\n        byte_pos += 1;\n        if byte_pos == 8 {\n            bytes.push(byte);\n            byte = 0;\n            byte_pos = 0;\n        }\n    }\n    if byte_pos > 0 {\n        bytes.push(byte);\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::new();\n    let mut byte = 0;\n    let mut i = 0;\n    while i < self.nbits {\n        if self.get(i).unwrap() {\n            byte |= 1 << (7 - i % 8);\n        }\n        if i % 8 == 7 {\n            bytes.push(byte);\n            byte = 0;\n        }\n        i += 1;\n    }\n    if i % 8 != 0 {\n        bytes.push(byte);\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::new();\n    let mut byte = 0;\n    let mut byte_idx = 0;\n    for (i, bit) in self.iter().enumerate() {\n        if bit {\n            byte |= 1 << (7 - i % 8);\n        }\n        if i % 8 == 7 {\n            bytes.push(byte);\n            byte = 0;\n            byte_idx += 1;\n        }\n    }\n    if byte != 0 {\n        bytes.push(byte);\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut v = Vec::new();\n    let mut i = 0;\n    let mut j = 0;\n    while i < self.nbits {\n        let mut byte = 0;\n        for _ in 0..8 {\n            if self.get(i).unwrap() {\n                byte |= 1 << (7 - j);\n            }\n            i += 1;\n            j += 1;\n            if i == self.nbits {\n                break;\n            }\n        }\n        v.push(byte);\n        j = 0;\n    }\n    v\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut result = Vec::new();\n    let mut i = 0;\n    while i < self.nbits {\n        let mut byte = 0;\n        for j in 0..8 {\n            if i < self.nbits && self.get(i).unwrap() {\n                byte |= 1 << (7 - j);\n            }\n            i += 1;\n        }\n        result.push(byte);\n    }\n    result\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::with_capacity(self.nbits / 8);\n    let mut block = 0;\n    let mut mask = 1 << 7;\n    for bit in self.storage.iter() {\n        for _ in 0..8 {\n            if block == 0 {\n                block = *bit;\n            }\n            if block & mask != 0 {\n                bytes.push(1);\n            } else {\n                bytes.push(0);\n            }\n            block <<= 1;\n            mask >>= 1;\n        }\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::with_capacity(self.nbits / 8 + 1);\n    let mut i = 0;\n    let mut byte = 0;\n    let mut bit = 0;\n    for &b in &self.storage {\n        for _ in 0..8 {\n            if i < self.nbits {\n                if b & (1 << bit) != 0 {\n                    byte |= 1 << (7 - bit);\n                }\n                bit += 1;\n                if bit == 8 {\n                    bytes.push(byte);\n                    byte = 0;\n                    bit = 0;\n                }\n                i += 1;\n            }\n        }\n    }\n    if bit != 0 {\n        bytes.push(byte);\n    }\n    bytes\n}",
      "pub fn to_bytes (&self) -> Vec<u8> {\n    let mut bytes = Vec::with_capacity(self.nbits / 8);\n    let mut byte = 0;\n    let mut bit = 0;\n    for i in 0..self.nbits {\n        if self.get(i).unwrap() {\n            byte |= 1 << (7 - bit);\n        }\n        bit += 1;\n        if bit == 8 {\n            bytes.push(byte);\n            byte = 0;\n            bit = 0;\n        }\n    }\n    if bit != 0 {\n        bytes.push(byte);\n    }\n    bytes\n}"
    ],
    [
      "pub fn grow (&mut self, n: usize, value: bool) {\n    self.nbits += n;\n    let nblocks = n / B::BITS;\n    let nbits_in_last_block = n % B::BITS;\n    let mut new_storage = Vec::with_capacity(self.storage.len() + nblocks + 1);\n    new_storage.extend_from_slice(&self.storage);\n    if nbits_in_last_block > 0 {\n        let last_block = self.storage.last().unwrap();\n        let mask = B::max_value() >> (B::BITS - nbits_in_last_block);\n        let new_last_block = if value {\n            *last_block | mask\n        } else {\n            *last_block & !mask\n        };\n        new_storage.push(new_last_block);\n    }\n    self.storage = new_storage;\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    self.storage.grow(n, value);\n    self.nbits += n * B::BITS;\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    let mut nbits = self.nbits;\n    let mut storage = self.storage.clone();\n    let mut last_block_with_mask = self.last_block_with_mask();\n    let mut last_block_mut_with_mask = self.last_block_mut_with_mask();\n    let mut fix_last_block = self.fix_last_block();\n    let mut fix_last_block_with_ones = self.fix_last_block_with_ones();\n    let mut is_last_block_fixed = self.is_last_block_fixed();\n    let mut ensure_invariant = self.ensure_invariant();\n    let mut get = self.get();\n    let mut set = self.set();\n    let mut set_all = self.set_all();\n    let mut negate = self.negate();\n    let mut union = self.union();\n    let mut intersect = self.intersect();\n    let mut or = self.or();\n    let mut and = self.and();\n    let mut difference = self.difference();\n    let mut xor = self.xor();\n    let mut nand = self.nand();\n    let mut nor = self.nor();\n    let mut xnor = self.xnor();\n    let mut all = self.all();\n    let mut iter = self.iter();\n    let mut append = self.append();\n    let mut split_off = self.split_off();\n    let mut none = self.none();\n    let mut any = self.any();\n    let mut to_bytes = self.to_bytes();\n    let mut eq_vec = self.eq_vec();\n    let mut truncate = self.truncate();\n    let mut reserve = self.reserve();\n    let mut reserve_exact = self.reserve_exact();\n    let mut capacity = self.capacity();\n    let mut pop = self.pop();\n    let mut push = self.push();\n    let mut len = self.len();\n    let mut set_len = self.set_len();\n    let mut is_empty = self.is_empty();\n    let mut clear = self.clear();\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    let nbits = self.nbits;\n    let nblocks = self.storage.len();\n    let nbits_new = nbits + n;\n    let nblocks_new = nbits_new / B::BITS + (nbits_new % B::BITS != 0) as usize;\n    if nblocks_new > nblocks {\n        self.storage.grow(nblocks_new - nblocks, value);\n    }\n    self.nbits = nbits_new;\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    self.nbits += n;\n    let old_len = self.storage.len();\n    self.storage.grow(n, value);\n    if self.nbits % B::BITS == 0 {\n        self.storage[old_len] = B::zero();\n    }\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    let nbits = self.nbits;\n    let nbits_new = nbits + n;\n    let storage_len = self.storage.len();\n    let storage_len_new = storage_len + (nbits_new + B::BITS - 1) / B::BITS;\n    self.storage.reserve(storage_len_new - storage_len);\n    let last_block_with_mask = self.last_block_with_mask();\n    let mut last_block = last_block_with_mask.map(|(b, m)| b).unwrap_or(B::ZERO);\n    let mut last_block_mask = last_block_with_mask.map(|(b, m)| m).unwrap_or(B::ALL);\n    for _ in 0..n {\n        if value {\n            last_block |= last_block_mask;\n        } else {\n            last_block &= !last_block_mask;\n        }\n        self.storage.push(last_block);\n        last_block_mask = B::ALL;\n        nbits_new += B::BITS;\n        if nbits_new % B::BITS == 0 {\n            last_block = B::ZERO;\n        }\n    }\n    self.nbits = nbits_new;\n    self.fix_last_block();\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    let old_len = self.len();\n    self.reserve(n);\n    for _ in 0..n {\n        self.push(value);\n    }\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    self.nbits += n;\n    let nblocks = n / B::BITS;\n    let nbits_in_last_block = n % B::BITS;\n    if nbits_in_last_block > 0 {\n        let last_block = self.storage.last_mut().unwrap();\n        let mask = !0 >> (B::BITS - nbits_in_last_block);\n        *last_block &= mask;\n        if value {\n            *last_block |= !mask;\n        }\n    }\n    self.storage.reserve(nblocks);\n    for _ in 0..nblocks {\n        self.storage.push(if value { !0 } else { 0 });\n    }\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    let nbits = n * 8;\n    let old_len = self.len();\n    self.nbits += nbits;\n    let new_len = self.len();\n    let mut block = 0;\n    if value {\n        block = !0;\n    }\n    if old_len % 8 == 0 {\n        self.storage.push(block);\n    } else {\n        self.storage[self.storage.len() - 1] |= block << (old_len % 8);\n    }\n}",
      "pub fn grow (&mut self, n: usize, value: bool) {\n    let new_len = self.len() + n;\n    if new_len > self.capacity() {\n        self.reserve_exact(new_len - self.len());\n    }\n    self.nbits = new_len;\n    if value {\n        self.storage.set_all();\n    } else {\n        self.storage.clear();\n    }\n}"
    ],
    [
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.len() == 0 {\n        None\n    } else {\n        let bit = self.get(self.len() - 1).unwrap();\n        self.set(self.len() - 1, false);\n        Some(bit)\n    }\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.len() == 0 {\n        None\n    } else {\n        let last_bit = self.get(self.len() - 1).unwrap();\n        self.set(self.len() - 1, false);\n        Some(last_bit)\n    }\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.len() == 0 {\n        return None;\n    }\n    let mut last_block = self.last_block_mut_with_mask().unwrap();\n    let last_block_mask = last_block.1;\n    let bit = last_block.0 & last_block_mask != 0;\n    last_block.0 &= !last_block_mask;\n    if last_block.0 == 0 {\n        self.storage.pop();\n    }\n    self.nbits -= 1;\n    Some(bit)\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.len() == 0 {\n        return None;\n    }\n    let (block_index, bit_index) = self.index_to_block_bit(self.len() - 1);\n    let mut block = self.storage[block_index];\n    let bit = (block >> bit_index) & 1 == 1;\n    block &= !(1 << bit_index);\n    self.storage[block_index] = block;\n    self.nbits -= 1;\n    Some(bit)\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.len() == 0 {\n        return None;\n    }\n    let bit = self.get(self.len() - 1).unwrap();\n    self.set(self.len() - 1, false);\n    self.fix_last_block();\n    Some(bit)\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.len() == 0 {\n        return None;\n    }\n    let (block, mask) = self.last_block_mut_with_mask().unwrap();\n    let bit = mask & *block != 0;\n    *block &= !mask;\n    self.nbits -= 1;\n    Some(bit)\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.is_empty() {\n        return None;\n    }\n    let last_bit = self.get(self.len() - 1).unwrap();\n    self.set_len(self.len() - 1);\n    Some(last_bit)\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.len() == 0 {\n        None\n    } else {\n        let last_block = self.storage.len() - 1;\n        let last_bit = self.len() - 1;\n        let last_bit_mask = 1 << (last_bit % B::BITS as usize);\n        let last_bit_value = (self.storage[last_block] & last_bit_mask) != 0;\n        self.storage[last_block] &= !last_bit_mask;\n        self.nbits -= 1;\n        Some(last_bit_value)\n    }\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.len() == 0 {\n        return None;\n    }\n    let last_block = self.storage.len() - 1;\n    let last_bit = self.nbits - 1;\n    let (block, mask) = self.last_block_mut_with_mask().unwrap();\n    let bit = (mask & *block) != 0;\n    *block &= !mask;\n    self.nbits -= 1;\n    if last_bit == 0 {\n        self.storage.pop();\n    }\n    Some(bit)\n}",
      "pub fn pop (&mut self) -> Option<bool> {\n    if self.len() == 0 {\n        return None;\n    }\n    let last_bit = self.get(self.len() - 1).unwrap();\n    self.set(self.len() - 1, false);\n    self.nbits -= 1;\n    Some(last_bit)\n}"
    ],
    [
      "pub fn push (&mut self, elem: bool) {\n    let len = self.len();\n    if len == self.nbits {\n        self.storage.push(elem as B);\n        self.nbits += B::BITS as usize;\n    } else {\n        let idx = len / B::BITS as usize;\n        let shift = len % B::BITS as usize;\n        let mask = B::one() << shift;\n        if elem {\n            self.storage[idx] |= mask;\n        } else {\n            self.storage[idx] &= !mask;\n        }\n    }\n}",
      "pub fn push (&mut self, elem: bool) {\n    if self.nbits % B::BITS == 0 {\n        self.storage.push(0);\n    }\n    let i = self.nbits / B::BITS;\n    let j = self.nbits % B::BITS;\n    if elem {\n        self.storage[i] |= 1 << j;\n    } else {\n        self.storage[i] &= !(1 << j);\n    }\n    self.nbits += 1;\n}",
      "pub fn push (&mut self, elem: bool) {\n    if self.nbits % 32 == 0 {\n        self.storage.push(0);\n    }\n    let last_block = self.storage.last_mut().unwrap();\n    let last_block_mask = 1 << (self.nbits % 32);\n    *last_block |= last_block_mask;\n    self.nbits += 1;\n}",
      "pub fn push (&mut self, elem: bool) {\n    let nbits = self.nbits;\n    let nblocks = nbits / B::BITS;\n    if nbits % B::BITS != 0 {\n        nblocks += 1;\n    }\n    if nblocks == self.storage.len() {\n        self.storage.push(0);\n    }\n    let i = nbits % B::BITS;\n    if elem {\n        self.storage[nblocks - 1] |= 1 << i;\n    } else {\n        self.storage[nblocks - 1] &= !(1 << i);\n    }\n    self.nbits += 1;\n}",
      "pub fn push (&mut self, elem: bool) {\n    let nbits = self.nbits;\n    if nbits % B::BITS == 0 {\n        self.storage.push(0);\n    }\n    let (block, mask) = self.last_block_mut_with_mask().unwrap();\n    *block |= (elem as B) << (nbits % B::BITS);\n    self.nbits += 1;\n}",
      "pub fn push (&mut self, elem: bool) {\n    let nbits = self.nbits;\n    if nbits % B::BITS == 0 {\n        self.storage.push(0);\n    }\n    self.nbits += 1;\n    self.set(nbits - 1, elem);\n}",
      "pub fn push (&mut self, elem: bool) {\n    if self.len() == self.capacity() {\n        self.grow(self.len() + 1, false);\n    }\n    let bit_index = self.len();\n    self.set(bit_index, elem);\n    self.set_len(bit_index + 1);\n}",
      "pub fn push (&mut self, elem: bool) {\n    if self.nbits % B::BITS == 0 {\n        self.storage.push(0);\n    }\n    let i = self.nbits / B::BITS;\n    let j = self.nbits % B::BITS;\n    if elem {\n        self.storage[i] |= B::one() << j;\n    } else {\n        self.storage[i] &= !(B::one() << j);\n    }\n    self.nbits += 1;\n}",
      "pub fn push (&mut self, elem: bool) {\n    if self.nbits == 0 {\n        self.storage.push(0);\n    }\n    let (block, mask) = self.last_block_mut_with_mask().unwrap();\n    *block |= mask & (elem as B);\n    self.nbits += 1;\n}",
      "pub fn push (&mut self, elem: bool) {\n    if self.nbits == 0 {\n        self.storage.push(elem as B);\n        self.nbits += 1;\n    } else if self.nbits % B::BITS == 0 {\n        self.storage.push(elem as B);\n        self.nbits += 1;\n    } else {\n        let last = self.storage.last_mut().unwrap();\n        let mask = B::MAX >> (B::BITS - self.nbits % B::BITS);\n        if elem {\n            *last |= mask;\n        } else {\n            *last &= !mask;\n        }\n        self.nbits += 1;\n    }\n}"
    ],
    [
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let mut coefficients = vec![];\n    match degree {\n        PolynomialDegree::Infinity => {\n            coefficients.push(Scalar::<E>::zero());\n        }\n        PolynomialDegree::Finite(n) => {\n            for _ in 0..=n {\n                coefficients.push(Scalar::<E>::random());\n            }\n        }\n    }\n    Polynomial { coefficients }\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let coefficients = match degree {\n        PolynomialDegree::Infinity => vec![],\n        PolynomialDegree::Finite(degree) => {\n            let mut coefficients = vec![];\n            for _ in 0..degree + 1 {\n                coefficients.push(Scalar::random());\n            }\n            coefficients\n        }\n    };\n    Self { coefficients }\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let coefficients = match degree {\n        PolynomialDegree::Infinity => vec![],\n        PolynomialDegree::Finite(degree) => {\n            let mut coefficients = vec![Scalar::<E>::zero(); degree as usize];\n            for i in 0..degree {\n                coefficients[i as usize] = Scalar::<E>::random();\n            }\n            coefficients\n        }\n    };\n    Polynomial { coefficients }\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let coefficients = match degree {\n        PolynomialDegree::Infinity => vec![],\n        PolynomialDegree::Finite(degree) => {\n            let mut coefficients = Vec::with_capacity(degree as usize + 1);\n            for _ in 0..degree + 1 {\n                coefficients.push(Scalar::random());\n            }\n            coefficients\n        }\n    };\n    Polynomial { coefficients }\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let mut coefficients = vec![];\n    match degree {\n        PolynomialDegree::Infinity => {\n            coefficients.push(Scalar::<E>::zero());\n        }\n        PolynomialDegree::Finite(degree) => {\n            for _ in 0..degree {\n                coefficients.push(Scalar::<E>::random());\n            }\n        }\n    }\n    Polynomial { coefficients }\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let coefficients = match degree {\n        PolynomialDegree::Infinity => vec![],\n        PolynomialDegree::Finite(degree) => (0..degree + 1)\n            .map(|_| Scalar::<E>::random())\n            .collect(),\n    };\n    Polynomial { coefficients }\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let coefficients = match degree {\n        PolynomialDegree::Infinity => vec![],\n        PolynomialDegree::Finite(degree) => {\n            let mut coefficients = vec![];\n            for _ in 0..degree {\n                coefficients.push(Scalar::<E>::random());\n            }\n            coefficients\n        }\n    };\n    Self { coefficients }\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let coefficients = match degree {\n        PolynomialDegree::Infinity => vec![],\n        PolynomialDegree::Finite(degree) => {\n            let mut coefficients = Vec::with_capacity(degree as usize);\n            for _ in 0..degree {\n                coefficients.push(Scalar::<E>::random());\n            }\n            coefficients\n        }\n    };\n    Self { coefficients }\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let mut coefficients = Vec::with_capacity(degree.as_finite().unwrap_or(0) as usize + 1);\n    coefficients.push(Scalar::<E>::random());\n    for _ in 1..degree.as_finite().unwrap_or(0) as usize + 1 {\n        coefficients.push(Scalar::<E>::random());\n    }\n    Self { coefficients }\n}",
      "pub fn sample_exact (degree: impl Into<PolynomialDegree>) -> Self {\n    let degree = degree.into();\n    let coefficients = match degree {\n        PolynomialDegree::Infinity => vec![],\n        PolynomialDegree::Finite(degree) => (0..=degree)\n            .map(|_| Scalar::<E>::random())\n            .collect(),\n    };\n    Self { coefficients }\n}"
    ],
    [
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = Vec::with_capacity(n as usize + 1);\n    coefficients.push(const_term);\n    for i in 1..=n {\n        coefficients.push(Scalar::random());\n    }\n    Polynomial { coefficients }\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = Vec::with_capacity(n as usize);\n    for i in 0..n {\n        let mut lagrange_basis = Scalar::<E>::zero();\n        for j in 0..n {\n            if i != j {\n                let x = Scalar::<E>::random();\n                lagrange_basis = lagrange_basis + Polynomial::<E>::lagrange_basis(&x, i, &[x.clone(), x.clone()]);\n            }\n        }\n        coefficients.push(const_term.clone() + lagrange_basis);\n    }\n    Polynomial { coefficients }\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = Vec::with_capacity(n as usize + 1);\n    coefficients.push(const_term);\n    for i in 1..=n {\n        let mut coeff = Scalar::zero();\n        while coeff.is_zero() {\n            coeff = Scalar::random();\n        }\n        coefficients.push(coeff);\n    }\n    Polynomial { coefficients }\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = Vec::with_capacity(n as usize + 1);\n    coefficients.push(const_term);\n    for i in 1..=n {\n        coefficients.push(Scalar::random());\n    }\n    Self { coefficients }\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = vec![];\n    for i in 0..n {\n        coefficients.push(Scalar::random());\n    }\n    coefficients[0] = const_term;\n    Self { coefficients }\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = Vec::with_capacity(n as usize);\n    for i in 0..n {\n        let x = Scalar::<E>::random();\n        coefficients.push(x);\n    }\n    coefficients.push(const_term);\n    Self { coefficients }\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = Vec::with_capacity(n as usize);\n    coefficients.push(const_term);\n    for i in 1..n as usize {\n        coefficients.push(Scalar::random());\n    }\n    Self { coefficients }\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = vec![];\n    for i in 0..n {\n        let mut x = Scalar::zero();\n        for j in 0..i {\n            x += lagrange_basis(&Scalar::zero(), j, &coefficients);\n        }\n        x += const_term.clone();\n        coefficients.push(x);\n    }\n    Self { coefficients }\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = Vec::with_capacity(n as usize + 1);\n    coefficients.push(const_term);\n    for i in 1..=n {\n        let mut rand_scalar = Scalar::<E>::random();\n        while rand_scalar.is_zero() {\n            rand_scalar = Scalar::<E>::random();\n        }\n        coefficients.push(rand_scalar);\n    }\n    Polynomial { coefficients }\n}",
      "pub fn sample_exact_with_fixed_const_term (n: u16, const_term: Scalar<E>) -> Self {\n    let mut coefficients = vec![];\n    coefficients.push(const_term);\n    for i in 1..n {\n        coefficients.push(Scalar::random());\n    }\n    Polynomial { coefficients }\n}"
    ],
    [
      "pub fn degree (&self) -> PolynomialDegree {\n    let mut degree = 0;\n    for c in self.coefficients.iter() {\n        if !c.is_zero() {\n            degree += 1;\n        }\n    }\n    degree.into()\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    if self.coefficients.is_empty() {\n        PolynomialDegree::Infinity\n    } else {\n        self.coefficients.len() - 1\n    }\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    if self.coefficients.iter().any(|c| !c.is_zero()) {\n        PolynomialDegree::Finite(self.coefficients.len() as u16 - 1)\n    } else {\n        PolynomialDegree::Infinity\n    }\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    if self.coefficients.is_empty() {\n        PolynomialDegree::Infinity\n    } else {\n        self.coefficients.len() - 1\n    }\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    if self.coefficients.is_empty() {\n        PolynomialDegree::Infinity\n    } else {\n        self.coefficients.len().into()\n    }\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    match self.coefficients.len() {\n        0 => PolynomialDegree::Infinity,\n        n => PolynomialDegree::Finite(n as u16 - 1),\n    }\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    let mut degree = 0;\n    for i in 0..self.coefficients.len() {\n        if !self.coefficients[i].is_zero() {\n            degree = i;\n        }\n    }\n    if degree == 0 {\n        PolynomialDegree::Infinity\n    } else {\n        degree.into()\n    }\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    let degree = self.coefficients.len() - 1;\n    if degree == 0 {\n        PolynomialDegree::Infinity\n    } else {\n        PolynomialDegree::Finite(degree as u16)\n    }\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    let degree = self.coefficients.len() - 1;\n    if degree == 0 {\n        PolynomialDegree::Infinity\n    } else {\n        degree.into()\n    }\n}",
      "pub fn degree (&self) -> PolynomialDegree {\n    let degree = self.coefficients.len() - 1;\n    if degree == 0 {\n        PolynomialDegree::Infinity\n    } else {\n        PolynomialDegree::Finite(degree as u16)\n    }\n}"
    ],
    [
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut y = Scalar::zero();\n    for (i, coeff) in self.coefficients.iter().enumerate() {\n        let mut term = Scalar::zero();\n        for j in 0..i {\n            term += &self.coefficients[j] * &lagrange_basis(point_x, j as u16, &self.coefficients);\n        }\n        term += coeff;\n        y += &term;\n    }\n    y\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = Scalar::zero();\n    for (i, coeff) in self.coefficients.iter().enumerate() {\n        let mut term = Scalar::zero();\n        for j in 0..i {\n            term = term + &self.coefficients[j] * &self.lagrange_basis(point_x, j as u16, &self.coefficients);\n        }\n        result = result + &coeff * &term;\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = Scalar::zero();\n    for (i, coefficient) in self.coefficients.iter().enumerate() {\n        let mut term = coefficient.clone();\n        for j in 0..i {\n            term *= &point_x;\n        }\n        result += &term;\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = Scalar::zero();\n    for (i, coeff) in self.coefficients.iter().enumerate() {\n        let mut term = coeff.clone();\n        for j in 0..i {\n            term = &term * &point_x;\n        }\n        result = &result + &term;\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut y = Scalar::zero();\n    for (i, c) in self.coefficients.iter().enumerate() {\n        let mut term = c.clone();\n        for j in 0..i {\n            term *= &point_x;\n        }\n        y += &term;\n    }\n    y\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = Scalar::zero();\n    for (i, coefficient) in self.coefficients.iter().enumerate() {\n        let mut term = Scalar::zero();\n        for j in 0..i {\n            term += &self.coefficients[j] * &Polynomial::<E>::lagrange_basis(point_x, j as u16, &self.coefficients);\n        }\n        result += &coefficient * &term;\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut y = Scalar::zero();\n    for (i, a) in self.coefficients.iter().enumerate() {\n        let mut term = a.clone();\n        for j in 0..i {\n            term *= &point_x.clone();\n        }\n        y += term;\n    }\n    y\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = Scalar::zero();\n    let mut x = Scalar::one();\n    for i in 0..self.coefficients.len() {\n        result = &result + &self.coefficients[i] * &x;\n        x = &x * point_x;\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = Scalar::zero();\n    for (i, coefficient) in self.coefficients.iter().enumerate() {\n        let mut term = coefficient.clone();\n        for j in 0..i {\n            term = term * point_x.clone();\n        }\n        result = result + term;\n    }\n    result\n}",
      "pub fn evaluate (&self, point_x: &Scalar<E>) -> Scalar<E> {\n    let mut result = Scalar::zero();\n    for (i, coeff) in self.coefficients.iter().enumerate() {\n        let mut term = Scalar::zero();\n        for j in 0..i {\n            term = term + &self.coefficients[j] * &lagrange_basis(point_x, j as u16, &self.coefficients);\n        }\n        result = result + &coeff * &term;\n    }\n    result\n}"
    ],
    [
      "pub fn back (&self) -> Option<&T> {\n    self.tail.and_then(|tail| self.entries.get(tail).map(|entry| entry.get()))\n}",
      "pub fn back (&self) -> Option<&T> {\n    self.tail.map(|tail| unsafe { self.entries.get_unchecked(tail.get()) }.value())\n}",
      "pub fn back (&self) -> Option<&T> {\n    self.tail.and_then(|tail| self.entries.get(tail).and_then(|entry| entry.occupied_ref().get()))\n}",
      "pub fn back (&self) -> Option<&T> {\n    self.tail.map(|index| unsafe { self.entries.get_unchecked(index.get()).value() })\n}",
      "pub fn back (&self) -> Option<&T> {\n    self.tail.map(|tail| unsafe { self.entries.get_unchecked(tail).value() })\n}",
      "pub fn back (&self) -> Option<&T> {\n    self.tail.map(|tail| unsafe { self.entries.get_unchecked(tail.get()) }.as_ref().unwrap())\n}",
      "pub fn back (&self) -> Option<&T> {\n    self.tail.map(|tail| unsafe { self.entries.get_unchecked(tail.get()).value() })\n}",
      "pub fn back (&self) -> Option<&T> {\n    self.tail.map(|tail| unsafe { self.entries.get_unchecked(tail).value() })\n}",
      "pub fn back (&self) -> Option<&T> {\n    self.tail.map(|tail| unsafe { self.entries.get_unchecked(tail.get()) }.value())\n}",
      "pub fn back (&self) -> Option<&T> {\n    self.tail.map(|index| &self.entries[index.get()].value)\n}"
    ],
    [
      "pub fn back_index (&self) -> Option<Index<T>> {\n    self.tail.map(|index| Index::new(index.get(), self.generation))\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    self.tail.map(|tail| Index::new(tail.get(), self.generation))\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    self.tail.map(|index| Index::new(index.get(), self.generation))\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    self.tail.map(|index| Index::new(index.get(), self.generation))\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    self.tail.map(|tail| Index::new(tail.get(), self.generation))\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    self.tail.map(|index| Index::new(index.get(), self.generation))\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    self.tail.map(|tail| Index::new(tail.get(), self.generation))\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    self.tail.map(|tail| Index::new(tail.get(), self.generation))\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    self.tail.map(|index| Index::new(index.get(), self.generation))\n}",
      "pub fn back_index (&self) -> Option<Index<T>> {\n    self.tail.map(|tail| Index::new(tail.get(), self.generation))\n}"
    ],
    [
      "pub fn clear (&mut self) {\n    self.entries.clear();\n    self.head = None;\n    self.tail = None;\n    self.vacant_head = None;\n    self.length = 0;\n}",
      "pub fn clear (&mut self) {\n    self.entries.clear();\n    self.head = None;\n    self.tail = None;\n    self.vacant_head = None;\n    self.length = 0;\n    self.generation += 1;\n}",
      "pub fn clear (&mut self) {\n    self.entries.clear();\n    self.head = None;\n    self.tail = None;\n    self.vacant_head = None;\n    self.length = 0;\n}",
      "pub fn clear (&mut self) {\n    self.entries.clear();\n    self.head = None;\n    self.tail = None;\n    self.vacant_head = None;\n    self.length = 0;\n    self.generation = 0;\n}",
      "pub fn clear (&mut self) {\n    self.entries.clear();\n    self.head = None;\n    self.tail = None;\n    self.vacant_head = None;\n    self.length = 0;\n    self.generation += 1;\n}",
      "pub fn clear (&mut self) {\n    self.entries.clear();\n    self.head = None;\n    self.tail = None;\n    self.vacant_head = None;\n    self.length = 0;\n}",
      "pub fn clear (&mut self) {\n    self.entries.clear();\n    self.generation = 0;\n    self.head = None;\n    self.length = 0;\n    self.tail = None;\n    self.vacant_head = None;\n}",
      "pub fn clear (&mut self) {\n    self.entries.clear();\n    self.head = None;\n    self.tail = None;\n    self.vacant_head = None;\n    self.length = 0;\n}",
      "pub fn clear (&mut self) {\n    self.entries.clear();\n    self.head = None;\n    self.tail = None;\n    self.vacant_head = None;\n    self.length = 0;\n}",
      "pub fn clear (&mut self) {\n    self.entries.clear();\n    self.generation = 0;\n    self.head = None;\n    self.length = 0;\n    self.tail = None;\n    self.vacant_head = None;\n}"
    ],
    [
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    self.head.map(|head| unsafe { self.entries.get_unchecked_mut(head.get()) }.value.as_mut().unwrap())\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    self.head.map(|head| unsafe { self.entries.get_unchecked_mut(head.get()) }.as_mut())\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    self.head.map(|index| unsafe {\n        self.entries.get_unchecked_mut(index.get()).value.as_mut().unwrap()\n    })\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    self.head.map(|head| unsafe {\n        &mut *self.entries.get_unchecked_mut(head.get())\n    })\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    self.head.map(|index| unsafe { self.entries.get_unchecked_mut(index.get()) }.value.as_mut().unwrap())\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    self.head.map(|index| {\n        let entry = self.entries.get_unchecked_mut(index.get());\n        unsafe { entry.value_mut() }\n    })\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    self.head.map(|index| unsafe { self.entries.get_unchecked_mut(index.get()) }.value())\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    self.head.map(|head| unsafe { self.entries.get_unchecked_mut(head.get()) }.value.as_mut())\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    self.head.map(|head| unsafe {\n        self.entries.get_unchecked_mut(head.get())\n    })\n}",
      "pub fn front_mut (&mut self) -> Option<&mut T> {\n    self.head.map(|head| unsafe {\n        self.entries.get_unchecked_mut(head.get()).value.as_mut().unwrap()\n    })\n}"
    ],
    [
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let index = index.index();\n    if index >= self.entries.len() {\n        return None;\n    }\n    let entry = &self.entries[index];\n    if entry.generation() != index.generation() {\n        return None;\n    }\n    match entry {\n        Entry::Occupied(occupied) => Some(occupied.value()),\n        Entry::Vacant(_) => None,\n    }\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let index = index.index();\n    if index >= self.length {\n        return None;\n    }\n    let entry = &self.entries[index];\n    if entry.generation == index.generation {\n        return Some(&entry.value);\n    }\n    None\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let index = index.index();\n    if index >= self.length {\n        return None;\n    }\n    let entry = self.entries.get(index)?;\n    if entry.generation != index.generation {\n        return None;\n    }\n    Some(&entry.value)\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let entry = self.entries.get(index.index)?;\n    if entry.generation == index.generation {\n        Some(&entry.value)\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let entry = self.entries.get(index.index)?;\n    if entry.generation() != index.generation {\n        return None;\n    }\n    match entry {\n        Entry::Occupied(entry) => Some(entry.value()),\n        Entry::Vacant(_) => None,\n    }\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    if index.generation == self.generation {\n        let index = index.index.get();\n        if index < self.length {\n            let entry = &self.entries[index];\n            if entry.generation == index.generation {\n                return Some(&entry.value);\n            }\n        }\n    }\n    None\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    if index.generation == self.generation {\n        let index = index.index.get();\n        if index < self.length {\n            let entry = &self.entries[index];\n            if entry.generation == index.generation {\n                return Some(&entry.value);\n            }\n        }\n    }\n    None\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    if index.generation == self.generation && index.index.get() < self.length {\n        Some(&self.entries[index.index.get()].value)\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let entry = self.entries.get(index.index)?;\n    if entry.generation() != index.generation {\n        return None;\n    }\n    Some(entry.value())\n}",
      "pub fn get (&self, index: Index<T>) -> Option<&T> {\n    let entry = self.entries.get(index.index)?;\n    if entry.generation() == index.generation {\n        Some(entry.value())\n    } else {\n        None\n    }\n}"
    ],
    [
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    let index = index.index();\n    if index >= self.length {\n        return None;\n    }\n    let entry = &self.entries[index];\n    if entry.generation != index.generation {\n        return None;\n    }\n    let next = entry.next;\n    if next.is_none() {\n        return None;\n    }\n    Some(Index::new(next.unwrap().get(), index.generation))\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    let index = index.index();\n    if index >= self.length {\n        return None;\n    }\n    let entry = self.entries.get(index)?;\n    let next = entry.next();\n    if next.is_none() {\n        return None;\n    }\n    let next = next.unwrap().get();\n    if next >= self.length {\n        return None;\n    }\n    Some(Index::new(next, self.generation))\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    let entry = self.entries.get(index.index)?;\n    if entry.generation == index.generation {\n        Some(Index::new(entry.next, entry.generation))\n    } else {\n        None\n    }\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    let index = index.index();\n    if index >= self.length {\n        return None;\n    }\n    let entry = &self.entries[index];\n    if entry.generation != index.generation {\n        return None;\n    }\n    let next = entry.next;\n    if next.is_none() {\n        return None;\n    }\n    Some(Index::new(next.unwrap().get(), index.generation))\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    self.entries.get(index.index.get()).map(|entry| match entry {\n        Entry::Occupied(entry) => entry.next,\n        Entry::Vacant(entry) => entry.next,\n    })\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    let index = index.index().get();\n    if index < self.entries.len() {\n        let entry = &self.entries[index];\n        if entry.generation == index.generation() {\n            return Some(Index::new(entry.next.get(), index.generation()));\n        }\n    }\n    None\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    let index = index.index();\n    if index < self.entries.len() {\n        let entry = &self.entries[index];\n        if entry.generation == index.generation() {\n            return Some(Index::new(entry.next.get(), index.generation()));\n        }\n    }\n    None\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    let index = index.index();\n    if index >= self.entries.len() {\n        return None;\n    }\n    let entry = self.entries[index].as_ref();\n    match entry {\n        Some(entry) => {\n            let next = entry.next();\n            if next.is_some() {\n                return Some(Index::new(next.unwrap(), self.generation));\n            }\n        }\n        None => return None,\n    }\n    None\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    self.entries.get(index.index).and_then(|entry| match entry {\n        Entry::Occupied(occupied_entry) => occupied_entry.next,\n        Entry::Vacant(_) => None,\n    })\n}",
      "pub fn get_next_index (&self, index: Index<T>) -> Option<Index<T>> {\n    let index = index.index();\n    if index >= self.length {\n        return None;\n    }\n    let entry = &self.entries[index];\n    if entry.generation != index.generation() {\n        return None;\n    }\n    let next = entry.next;\n    if next == None {\n        return None;\n    }\n    let next = next.unwrap();\n    if next.get() >= self.length {\n        return None;\n    }\n    Some(Index::new(next.get(), index.generation()))\n}"
    ],
    [
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    if index.index() == target.index() {\n        panic!(\"Cannot move node after itself\");\n    }\n    let index = index.index();\n    let target = target.index();\n    let next = self.entries[index].next();\n    let previous = self.entries[index].previous();\n    let target_next = self.entries[target].next();\n    let target_previous = self.entries[target].previous();\n    self.update_link(previous, next);\n    self.update_link(Some(index), target_next);\n    self.update_link(target_previous, Some(index));\n    self.update_link(Some(target), next);\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    if index.index == target.index {\n        panic!(\"index and target cannot be the same\");\n    }\n    let index = index.index;\n    let target = target.index;\n    if index == target + 1 {\n        return;\n    }\n    let entry = self.get_unchecked_mut(index);\n    let previous = entry.previous();\n    let next = entry.next();\n    let entry = self.remove_helper(previous, index, next);\n    self.update_link(previous, next);\n    let next = self.get_unchecked(target).next();\n    let entry = self.insert_new(entry.value(), target, next);\n    self.update_link(Some(target), Some(entry.index()));\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    let index = index.index();\n    let target = target.index();\n    let next = self.entries[index].next;\n    let previous = self.entries[index].previous;\n    let target_next = self.entries[target].next;\n    let target_previous = self.entries[target].previous;\n    self.update_link(previous, next);\n    self.update_link(Some(index), target_next);\n    self.update_link(target_previous, Some(index));\n    self.update_link(Some(target), next);\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    let index = index.index();\n    let target = target.index();\n    if index == target {\n        return;\n    }\n    let (previous_index, next_index) = self.get_link(index);\n    let (target_previous_index, target_next_index) = self.get_link(target);\n    self.update_link(previous_index, next_index);\n    self.update_link(target_previous_index, Some(index));\n    self.update_link(Some(index), target_next_index);\n    self.update_link(Some(target), next_index);\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    let index = index.index();\n    let target = target.index();\n    if index == target {\n        panic!(\"index and target are the same\");\n    }\n    if index >= self.length || target >= self.length {\n        panic!(\"index or target is invalidated\");\n    }\n    let (previous, next) = self.get_link(index);\n    self.update_link(previous, next);\n    let (previous, next) = self.get_link(target);\n    self.update_link(previous, Some(index));\n    self.update_link(Some(index), next);\n    self.update_link(Some(target), Some(index));\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    let index = index.index();\n    let target = target.index();\n    let next = self.entries[index].next;\n    let previous = self.entries[index].previous;\n    let target_next = self.entries[target].next;\n    let target_previous = self.entries[target].previous;\n    self.update_link(previous, next);\n    self.update_link(Some(index), target_next);\n    self.update_link(target_previous, Some(index));\n    self.update_link(Some(target), Some(index));\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    let index = index.index();\n    let target = target.index();\n    if index == target {\n        panic!(\"Cannot move node after itself.\");\n    }\n    let (previous, next) = self.update_link(Some(index), Some(target));\n    self.update_link(previous, next);\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    let index = index.index();\n    let target = target.index();\n    let next = self.entries[index].next;\n    let previous = self.entries[index].previous;\n    let target_next = self.entries[target].next;\n    let target_previous = self.entries[target].previous;\n    self.update_link(previous, Some(target));\n    self.update_link(next, Some(target_next));\n    self.update_link(Some(index), Some(target_next));\n    self.update_link(target_next, Some(index));\n    self.update_link(target_previous, Some(next));\n    self.update_link(Some(target), previous);\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    let index = index.index();\n    let target = target.index();\n    let next = self.entries[index].next;\n    let previous = self.entries[index].previous;\n    let target_next = self.entries[target].next;\n    let target_previous = self.entries[target].previous;\n    self.update_link(Some(index), next);\n    self.update_link(previous, Some(target));\n    self.update_link(Some(target), next);\n    self.update_link(target_previous, Some(index));\n}",
      "pub fn move_after (&mut self, index: Index<T>, target: Index<T>) {\n    let index = index.index();\n    let target = target.index();\n    let next = self.entries[index].next;\n    let previous = self.entries[index].previous;\n    let target_next = self.entries[target].next;\n    let target_previous = self.entries[target].previous;\n    self.update_link(previous, Some(target));\n    self.update_link(Some(index), target_next);\n    self.update_link(target_previous, Some(index));\n    self.update_link(target, next);\n}"
    ],
    [
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let index = index.index();\n    if index == 0 {\n        return self.push_front(value);\n    }\n    let previous_index = index - 1;\n    let next_index = index;\n    let index = self.insert_new(value, Some(previous_index), Some(next_index));\n    self.update_link(Some(previous_index), Some(index));\n    self.update_link(Some(index), Some(next_index));\n    index\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let previous_index = self.get_previous_index(index);\n    let next_index = self.get_next_index(index);\n    self.insert_new(value, previous_index, next_index)\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let mut index = index.index();\n    if index == 0 {\n        return self.insert_front(value);\n    }\n    index -= 1;\n    let entry = self.get_entry(index);\n    let entry = match entry {\n        Some(entry) => entry,\n        None => return self.insert_empty(value),\n    };\n    let next_index = entry.next();\n    let next_index = next_index.index();\n    let next_entry = self.get_entry(next_index);\n    let next_entry = match next_entry {\n        Some(next_entry) => next_entry,\n        None => return self.insert_empty(value),\n    };\n    let previous_index = entry.index();\n    let next_index = next_entry.index();\n    self.insert_new(value, Some(previous_index), Some(next_index))\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let index = index.index();\n    let previous_index = self.get_previous_index(index);\n    let next_index = self.get_next_index(index);\n    let new_index = self.insert_new(value, previous_index, next_index);\n    self.update_link(previous_index, Some(new_index));\n    self.update_link(Some(new_index), next_index);\n    new_index\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let mut index = index.index();\n    let mut previous_index = self.get_previous_index(index);\n    if index == 0 {\n        return self.insert_front(value);\n    }\n    if index == self.length {\n        return self.insert_back(value);\n    }\n    if self.is_empty() {\n        return self.insert_empty(value);\n    }\n    if index >= self.length {\n        panic!(\"index out of bounds\");\n    }\n    if self.entries[index].generation != index.generation() {\n        panic!(\"index invalidated\");\n    }\n    let mut next_index = self.get_next_index(index);\n    let new_index = self.insert_new(value, previous_index, next_index);\n    self.update_link(previous_index, Some(new_index));\n    self.update_link(next_index, Some(new_index));\n    self.update_link(Some(new_index), next_index);\n    new_index\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let index = index.index();\n    let new_index = self.insert_new(value, self.get_previous_index(index), Some(index));\n    self.move_before(new_index, index);\n    new_index\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let index = index.index();\n    if index == 0 {\n        return self.insert_front(value);\n    }\n    let index = index - 1;\n    let previous_index = self.get_previous_index(index);\n    let next_index = self.get_next_index(index);\n    self.insert_new(value, previous_index, next_index)\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    // TODO: Implement this function\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let mut previous_index = self.get_previous_index(index);\n    let next_index = Some(index.index);\n    let index = self.insert_new(value, previous_index, next_index);\n    self.update_link(previous_index, Some(index.index));\n    self.update_link(Some(index.index), next_index);\n    index\n}",
      "pub fn insert_before (&mut self, index: Index<T>, value: T) -> Index<T> {\n    let mut index = index.index();\n    let mut previous_index = self.get_previous_index(index);\n    if previous_index.is_none() {\n        return self.insert_front(value);\n    }\n    let previous_index = previous_index.unwrap();\n    let next_index = self.get_next_index(index);\n    let new_index = self.insert_new(value, Some(previous_index), next_index);\n    self.update_link(Some(previous_index), Some(new_index));\n    self.update_link(Some(new_index), next_index);\n    self.update_link(Some(index), Some(new_index));\n    new_index\n}"
    ],
    [
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    let mut map = HashMap::new();\n    if minimum_capacity > self.length {\n        panic!(\"minimum capacity must be greater than or equal to the current length of the list\");\n    }\n    if self.capacity() <= minimum_capacity {\n        return map;\n    }\n    let mut vacant_head = self.vacant_head;\n    let mut vacant_tail = self.vacant_head;\n    let mut vacant_length = 0;\n    let mut index = self.head;\n    while let Some(non_max_index) = index {\n        let index = Index::new(non_max_index.get(), self.generation);\n        let entry = self.entries.get_unchecked(non_max_index.get());\n        if let Entry::Vacant(entry) = entry {\n            vacant_length += 1;\n            if vacant_head.is_none() {\n                vacant_head = Some(non_max_index);\n            }\n            vacant_tail = Some(non_max_index);\n            map.insert(index, entry.index);\n        } else {\n            if vacant_head.is_some() {\n                self.vacant_head = vacant_head;\n                self.vacant_tail = vacant_tail;\n                self.length -= vacant_length;\n                return map;\n            }\n        }\n        index = entry.next;\n    }\n    if vacant_head.is_some() {\n        self.vacant_head = vacant_head;\n        self.vacant_tail = vacant_tail;\n        self.length -= vacant_length;\n    }\n    map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    let mut map = HashMap::new();\n    if minimum_capacity < self.length {\n        panic!(\"Minimum capacity is less than the current length of the list.\");\n    }\n    let mut previous_index = self.head;\n    let mut next_index = self.head;\n    while let Some(index) = previous_index {\n        let index = index.get();\n        let next_index = self.entries[index].next;\n        if let Some(next_index) = next_index {\n            let next_index = next_index.get();\n            if next_index > index {\n                let mut next_previous_index = self.entries[next_index].previous;\n                while let Some(next_previous_index) = next_previous_index {\n                    let next_previous_index = next_previous_index.get();\n                    if next_previous_index < index {\n                        break;\n                    }\n                    next_previous_index = self.entries[next_previous_index].previous;\n                }\n                if let Some(next_previous_index) = next_previous_index {\n                    let next_previous_index = next_previous_index.get();\n                    if next_previous_index < index {\n                        self.update_link(Some(index), next_previous_index);\n                        self.update_link(Some(next_previous_index), Some(index));\n                        self.update_link(Some(next_index), next_previous_index);\n                        self.update_link(Some(next_previous_index), next_index);\n                        previous_index = Some(index);\n                        next_index = Some(next_index);\n                        continue;\n                    }\n                }\n            }\n        }\n        previous_index = next_index;\n        next_index = self.entries[index].next;\n    }\n    let mut index = self.head;\n    while let Some(index) = index {\n        let index = index.get();\n        let next_index = self.entries[index].next;\n        if let Some(next_index) = next_index {\n}\n}\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    if minimum_capacity < self.length {\n        panic!(\"minimum capacity must be at least the length of the list\");\n    }\n    let mut map = HashMap::new();\n    let mut index = self.head;\n    while let Some(non_max_index) = index {\n        let index = Index::new(non_max_index.get(), self.generation);\n        let value = self.entries[non_max_index.get()].get();\n        let new_index = self.push_back(value);\n        map.insert(index, new_index);\n        index = self.entries[non_max_index.get()].get_next_index();\n    }\n    self.clear();\n    self.reserve(minimum_capacity);\n    map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    if minimum_capacity < self.length {\n        panic!(\"Minimum capacity must be greater than or equal to the current length of the list\");\n    }\n    let mut map = HashMap::new();\n    let mut index = self.head;\n    while let Some(non_max_index) = index {\n        let index = Index::new(non_max_index.get(), self.generation);\n        let entry = self.entries.get_unchecked(non_max_index.get());\n        if let Entry::Occupied(occupied_entry) = entry {\n            let new_index = self.push_back(occupied_entry.get_unchecked());\n            map.insert(index, new_index);\n        }\n        index = self.entries.get_unchecked(non_max_index.get()).next();\n    }\n    self.head = None;\n    self.tail = None;\n    self.length = 0;\n    self.entries.clear();\n    self.entries.reserve(minimum_capacity);\n    self.generation += 1;\n    map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    if minimum_capacity < self.length {\n        panic!(\"The given minimum capacity is less than the current length of the list.\");\n    }\n    let mut map = HashMap::new();\n    let mut new_index = 0;\n    for index in self.indices() {\n        let value = self.remove_entry(index.index()).unwrap().into_value();\n        self.insert_new(value, None, Some(new_index));\n        map.insert(index, Index::new(new_index, self.generation));\n        new_index += 1;\n    }\n    self.capacity = minimum_capacity;\n    self.entries.resize(minimum_capacity, Entry::Vacant(VacantEntry));\n    map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    if self.length == 0 {\n        return HashMap::new();\n    }\n    if minimum_capacity < self.length {\n        panic!(\"The given minimum capacity is less than the current length of the list.\");\n    }\n    let mut map = HashMap::new();\n    let mut index = self.head.unwrap();\n    let mut previous_index = None;\n    while let Some(entry) = self.entries.get_mut(index) {\n        if let Entry::Occupied(occupied_entry) = entry {\n            if occupied_entry.previous_index.is_some() {\n                occupied_entry.previous_index = previous_index;\n            }\n            if occupied_entry.next_index.is_some() {\n                occupied_entry.next_index = None;\n            }\n            map.insert(occupied_entry.index, occupied_entry.index);\n        }\n        previous_index = Some(index);\n        index = self.entries.get(index).unwrap().next_index.unwrap();\n    }\n    self.head = previous_index;\n    self.tail = Some(index);\n    self.vacant_head = None;\n    self.length = self.length.min(minimum_capacity);\n    map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    if minimum_capacity < self.length {\n        panic!(\"The given minimum capacity is less than the current length of the list.\");\n    }\n    let mut map = HashMap::new();\n    let mut previous_index = None;\n    let mut next_index = self.head;\n    while let Some(index) = next_index {\n        let entry = self.entries.get_unchecked(index.get());\n        if let Entry::Occupied(occupied_entry) = entry {\n            let new_index = self.insert_new(occupied_entry.value.clone(), previous_index, next_index);\n            map.insert(index, new_index);\n        }\n        previous_index = Some(index);\n        next_index = entry.next();\n    }\n    self.head = map.get(&self.head.unwrap()).cloned();\n    self.tail = map.get(&self.tail.unwrap()).cloned();\n    self.vacant_head = map.get(&self.vacant_head.unwrap()).cloned();\n    self.entries.shrink_to(minimum_capacity);\n    map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    if minimum_capacity < self.length {\n        panic!(\"The given minimum capacity is less than the current length of the list.\");\n    }\n    let mut map = HashMap::new();\n    let mut vacant_head = None;\n    let mut vacant_tail = None;\n    let mut vacant_count = 0;\n    let mut entry = self.head;\n    while let Some(index) = entry {\n        if let Entry::Vacant(entry) = self.entries.get_mut(index.get()) {\n            if vacant_head.is_none() {\n                vacant_head = Some(index);\n            }\n            vacant_tail = Some(index);\n            vacant_count += 1;\n            entry.next = vacant_tail;\n            entry.previous = vacant_head;\n        }\n        entry = self.entries.get(index.get()).unwrap().next;\n    }\n    let mut vacant_head = vacant_head;\n    let mut vacant_tail = vacant_tail;\n    let mut vacant_count = vacant_count;\n    let mut index = self.head;\n    while let Some(index) = index {\n        if let Entry::Occupied(entry) = self.entries.get_mut(index.get()) {\n            if vacant_head.is_none() {\n                break;\n            }\n            let vacant_index = vacant_head.unwrap();\n            let vacant_entry = self.entries.get_mut(vacant_index.get()).unwrap();\n            vacant_entry.index = entry.index;\n            vacant_entry.generation = entry.generation;\n            vacant_entry.value = entry.value;\n            vacant_entry.previous = entry.previous;\n            vacant_entry.next = entry.next;\n            entry.index = vacant_index.get();\n            entry.generation = vacant_entry.generation;\n            entry.value = vacant_entry.value;\n            entry.previous = vacant_entry.previous;\n            entry.next = vacant_entry.next;\n}\n}\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    let mut map = HashMap::new();\n    if self.length == 0 {\n        return map;\n    }\n    if minimum_capacity < self.length {\n        panic!(\"The given minimum capacity is less than the current length of the list.\");\n    }\n    let mut previous_index = self.head;\n    let mut next_index = self.get_next_index(previous_index.unwrap());\n    let mut new_index = 0;\n    while let Some(index) = previous_index {\n        let value = self.entries[index.get()].take();\n        if let Some(value) = value {\n            let new_index = NonMaxUsize::new(new_index).unwrap();\n            let new_index = Index::new(new_index, self.generation);\n            self.entries[new_index.index()] = Entry::Occupied(OccupiedEntry::new(new_index, value));\n            map.insert(Index::new(index.index(), index.generation), new_index);\n            self.update_link(previous_index, Some(new_index));\n            self.update_link(next_index, Some(new_index));\n            self.update_link(Some(new_index), next_index);\n            previous_index = next_index;\n            next_index = self.get_next_index(previous_index.unwrap());\n            new_index += 1;\n        } else {\n            self.update_link(previous_index, next_index);\n            self.update_link(next_index, None);\n            previous_index = next_index;\n            next_index = self.get_next_index(previous_index.unwrap());\n        }\n    }\n    self.head = Some(NonMaxUsize::new(0).unwrap());\n    self.tail = Some(NonMaxUsize::new(new_index - 1).unwrap());\n    self.length = new_index;\n    self.generation += 1;\n    map\n}",
      "pub fn pack_to (&mut self, minimum_capacity: usize) -> HashMap<Index<T>, Index<T>> {\n    if self.capacity() < minimum_capacity {\n        self.reserve(minimum_capacity - self.capacity());\n    }\n    let mut map = HashMap::new();\n    let mut previous = None;\n    let mut next = self.head;\n    while let Some(index) = next {\n        let entry = self.entries.get_unchecked(index.get());\n        let next = entry.next;\n        let previous = previous;\n        if let Some(previous) = previous {\n            let previous_entry = self.entries.get_unchecked(previous.get());\n            previous_entry.next = next;\n        } else {\n            self.head = next;\n        }\n        if let Some(next) = next {\n            let next_entry = self.entries.get_unchecked(next.get());\n            next_entry.previous = previous;\n        } else {\n            self.tail = previous;\n        }\n        let new_index = self.insert_new(entry.value, previous, next, );\n        map.insert(index, new_index);\n        previous = Some(new_index);\n        next = next;\n    }\n    map\n}"
    ],
    [
      "pub fn pop_back (&mut self) -> Option<T> {\n    if let Some(index) = self.tail {\n        let entry = self.entries.get_mut(index.get()).unwrap();\n        let value = entry.value();\n        self.remove_helper(self.head, index.get(), None);\n        return Some(value);\n    }\n    None\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    if let Some(index) = self.tail {\n        let entry = self.entries.get_mut(index).unwrap();\n        let value = entry.value.take();\n        self.length -= 1;\n        if let Some(next) = entry.next {\n            self.entries.get_mut(next).unwrap().previous = entry.previous;\n        } else {\n            self.head = entry.previous;\n        }\n        if let Some(previous) = entry.previous {\n            self.entries.get_mut(previous).unwrap().next = entry.next;\n        } else {\n            self.tail = entry.next;\n        }\n        self.update_link(Some(index), entry.next);\n        return Some(value.unwrap());\n    }\n    None\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    if let Some(index) = self.tail {\n        let entry = self.entries.get_unchecked_mut(index.get());\n        let value = entry.value.take();\n        if let Some(previous) = entry.previous {\n            self.entries.get_unchecked_mut(previous.get()).next = entry.next;\n        } else {\n            self.head = entry.next;\n        }\n        if let Some(next) = entry.next {\n            self.entries.get_unchecked_mut(next.get()).previous = entry.previous;\n        } else {\n            self.tail = entry.previous;\n        }\n        self.length -= 1;\n        return Some(value);\n    }\n    None\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    let index = self.tail?;\n    let entry = self.entries.get_unchecked_mut(index.get());\n    let value = entry.value.take();\n    self.update_link(self.tail, None);\n    self.length -= 1;\n    value\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    let tail = self.tail?;\n    let vacant_head = self.vacant_head?;\n    let entry = self.entries.get_mut(tail)?;\n    let value = entry.value.take();\n    if tail == vacant_head {\n        self.vacant_head = None;\n    }\n    self.tail = entry.previous;\n    self.length -= 1;\n    value\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    self.remove(self.back_index()?)\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    let mut tail = self.tail;\n    let mut prev = None;\n    while let Some(index) = tail {\n        let entry = self.entries.get_unchecked(index);\n        if let Entry::Occupied(entry) = entry {\n            let next = entry.next;\n            if let Some(next) = next {\n                tail = Some(next);\n                prev = Some(index);\n            } else {\n                break;\n            }\n        } else {\n            break;\n        }\n    }\n    if let Some(tail) = tail {\n        let entry = self.entries.get_unchecked(tail);\n        if let Entry::Occupied(entry) = entry {\n            let value = entry.value;\n            let next = entry.next;\n            if let Some(prev) = prev {\n                self.update_link(Some(prev), next);\n            } else {\n                self.head = next;\n            }\n            self.length -= 1;\n            return Some(value);\n        }\n    }\n    None\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    let index = self.tail?;\n    let entry = self.entries.get_mut(index)?;\n    let value = entry.remove()?;\n    self.length -= 1;\n    if self.length == 0 {\n        self.head = None;\n        self.tail = None;\n    } else {\n        self.tail = entry.previous;\n        self.update_link(self.tail, None);\n    }\n    Some(value)\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    let tail = self.tail?;\n    let vacant_head = self.vacant_head?;\n    let index = tail.get();\n    let entry = self.entries.get_mut(index)?;\n    let next = entry.next;\n    if next == vacant_head {\n        self.tail = None;\n    } else {\n        self.entries.get_mut(next.get())?.previous = None;\n    }\n    self.entries.get_mut(index)?.next = None;\n    self.vacant_head = Some(index);\n    self.length -= 1;\n    Some(entry.value)\n}",
      "pub fn pop_back (&mut self) -> Option<T> {\n    let mut tail = self.tail;\n    if let Some(tail) = tail {\n        let entry = self.entries.get_unchecked_mut(tail.get());\n        let value = entry.remove();\n        if let Some(previous) = entry.previous {\n            self.entries.get_unchecked_mut(previous.get()).next = entry.next;\n        } else {\n            self.head = entry.next;\n        }\n        if let Some(next) = entry.next {\n            self.entries.get_unchecked_mut(next.get()).previous = entry.previous;\n        } else {\n            self.tail = entry.previous;\n        }\n        self.length -= 1;\n        Some(value)\n    } else {\n        None\n    }\n}"
    ],
    [
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let index = self.length;\n    let next = self.tail;\n    let vacant = self.vacant_head;\n    let entry = Entry::Vacant(VacantEntry {\n        next,\n        vacant,\n        generation: self.generation,\n        index,\n        value,\n    });\n    self.entries.push(entry);\n    self.length += 1;\n    if self.length == 1 {\n        self.head = Some(NonMaxUsize::new_unchecked(0));\n    }\n    if let Some(vacant) = vacant {\n        self.update_link(Some(vacant), Some(index));\n    }\n    self.tail = Some(NonMaxUsize::new_unchecked(index));\n    Index::new(index, self.generation)\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    // TODO: Implement this function\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let index = self.length;\n    self.length += 1;\n    self.entries.push(Entry::Occupied(OccupiedEntry::new(index, value)));\n    Index::new(index, self.generation)\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    // Implement the body of the function here.\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let index = self.vacant_head.map_or(self.length, |v| v.get());\n    let entry = self.entries.get_mut(index).unwrap();\n    if let Some(next) = entry.next() {\n        self.entries.get_mut(next).unwrap().set_previous(index);\n    } else {\n        self.tail = Some(index);\n    }\n    entry.set_value(value);\n    self.length += 1;\n    self.vacant_head = entry.next();\n    Index::new(index, self.generation)\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let index = self.vacant_head.take().map_or_else(\n        || {\n            let index = self.entries.len();\n            self.entries.push(Entry::Vacant(VacantEntry { index }));\n            index\n        },\n        |index| {\n            self.entries.insert(index, Entry::Vacant(VacantEntry { index }));\n            index\n        }\n    );\n    self.entries[index] = Entry::Occupied(OccupiedEntry {\n        index,\n        generation: self.generation,\n        value,\n    });\n    self.length += 1;\n    if self.tail.is_none() {\n        self.tail = Some(index);\n    }\n    if self.head.is_none() {\n        self.head = Some(index);\n    }\n    Index::new(index, self.generation)\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let index = self.entries.len();\n    self.entries.push(Entry::Occupied(OccupiedEntry::new(index, value)));\n    self.length += 1;\n    Index::new(index, self.generation)\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let index = self.entries.len();\n    self.entries.push(Entry::Occupied(OccupiedEntry {\n        index: NonMaxUsize::new(index).unwrap(),\n        generation: self.generation,\n        value,\n    }));\n    self.length += 1;\n    if self.tail.is_none() {\n        self.tail = Some(NonMaxUsize::new(index).unwrap());\n    }\n    if self.head.is_none() {\n        self.head = Some(NonMaxUsize::new(index).unwrap());\n    }\n    Index::new(index, self.generation)\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let index = self.vacant_head.unwrap_or_else(|| {\n        let index = NonMaxUsize::new(self.length).unwrap();\n        self.entries.push(Entry::Vacant(VacantEntry { index }));\n        index\n    });\n    self.insert_new(value, self.vacant_head, self.tail);\n    Index::new(index.get(), self.generation)\n}",
      "pub fn push_back (&mut self, value: T) -> Index<T> {\n    let index = self.length;\n    self.length += 1;\n    self.entries.push(Entry::Occupied(OccupiedEntry::new(value, index)));\n    Index::new(index, self.generation)\n}"
    ],
    [
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut previous = self.head;\n    let mut current = self.head;\n    while let Some(index) = current {\n        let next = self.entries[index.get()].next;\n        if predicate(&mut self.entries[index.get()].value) {\n            self.update_link(previous, Some(index));\n            previous = Some(index);\n        } else {\n            self.remove_helper(previous, index.get(), next);\n        }\n        current = next;\n    }\n    self.update_link(previous, None);\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut previous = None;\n    let mut index = self.head;\n    while let Some(next) = index {\n        let entry = self.entries.get_mut(next.get()).unwrap();\n        if predicate(entry) {\n            previous = Some(next);\n            index = entry.next;\n        } else {\n            self.remove_helper(previous, next.get(), entry.next);\n        }\n    }\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut previous = self.head;\n    let mut current = self.head;\n    let mut next = self.get_next_index(current);\n    while let Some(index) = current {\n        let value = self.get_unchecked_mut(index);\n        if predicate(value) {\n            previous = Some(index);\n            current = next;\n            next = self.get_next_index(current);\n        } else {\n            self.remove_helper(previous, index, next);\n            next = self.get_next_index(current);\n        }\n    }\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut previous = self.vacant_head;\n    let mut index = self.vacant_head;\n    while let Some(next) = index.and_then(|index| self.entries.get(index).and_then(|entry| entry.next())) {\n        if let Entry::Occupied(OccupiedEntry { value, .. }) = &mut self.entries[index] {\n            if predicate(value) {\n                previous = Some(index);\n                index = next;\n                continue;\n            }\n        }\n        self.remove_helper(previous, index, next);\n    }\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\nlet mut previous = self.head;\nlet mut index = self.head;\nwhile let Some(current) = index {\nlet next = self.entries[current].next;\nif predicate(&mut self.entries[current].value) {\nself.update_link(previous, Some(current));\nprevious = Some(current);\n} else {\nself.remove_helper(previous, current, next);\n}\nindex = next;\n}\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut current = self.head;\n    let mut previous = None;\n    while let Some(index) = current {\n        let index = index.get();\n        let next = self.entries[index].next;\n        if predicate(&mut self.entries[index].value) {\n            previous = Some(index);\n            current = next;\n        } else {\n            self.remove_helper(previous, index, next, );\n            current = next;\n        }\n    }\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut previous_index = None;\n    let mut index = self.head;\n    while let Some(index) = index {\n        let next_index = self.entries[index.get()].next;\n        if predicate(&mut self.entries[index.get()].value) {\n            previous_index = Some(index);\n        } else {\n            self.remove_helper(previous_index, index.get(), next_index);\n        }\n        index = next_index;\n    }\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut index = self.head;\n    while let Some(non_max_usize) = index {\n        let index = non_max_usize.get();\n        let entry = self.entries.get_mut(index);\n        let occupied_entry = entry.occupied_mut();\n        let value = occupied_entry.get_mut();\n        if predicate(value) {\n            index = self.get_next_index(index);\n        } else {\n            self.remove_entry(index);\n        }\n    }\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\n    let mut previous_index = None;\n    let mut index = self.head;\n    while let Some(current_index) = index {\n        let next_index = self.entries[current_index.get()].next;\n        if predicate(&mut self.entries[current_index.get()].value) {\n            previous_index = Some(current_index);\n            index = next_index;\n        } else {\n            self.remove_helper(previous_index, current_index.get(), next_index);\n        }\n    }\n}",
      "pub fn retain <Predicate> (&mut self, mut predicate: Predicate) where\nPredicate: FnMut(&mut T) -> bool, {\nlet mut index = self.head;\nwhile let Some(index) = index {\nlet entry = self.entries.get_unchecked_mut(index.get());\nif !predicate(&mut entry.value) {\nself.remove_helper(index.get(), index.get(), index.get());\n} else {\nindex = entry.next;\n}\n}\n}"
    ],
    [
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut last_lba = self.header.first_usable_lba;\n    for (_, partition) in self.iter() {\n        if last_lba < partition.starting_lba {\n            free_sectors.push((last_lba, partition.starting_lba - last_lba));\n        }\n        last_lba = partition.ending_lba + 1;\n    }\n    if last_lba < self.header.last_usable_lba {\n        free_sectors.push((last_lba, self.header.last_usable_lba - last_lba + 1));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut last_lba = self.header.first_usable_lba;\n    for partition in self.partitions.iter() {\n        if !partition.is_used() {\n            continue;\n        }\n        let range = partition.range().unwrap();\n        let start = range.start();\n        let end = range.end();\n        if last_lba < start {\n            free_sectors.push((last_lba, start - last_lba));\n        }\n        last_lba = end + 1;\n    }\n    if last_lba < self.header.last_usable_lba {\n        free_sectors.push((last_lba, self.header.last_usable_lba - last_lba + 1));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut current_free_start = self.header.first_usable_lba;\n    let mut current_free_size = 0;\n    for partition in &self.partitions {\n        if partition.is_unused() {\n            continue;\n        }\n        if current_free_size > 0 {\n            free_sectors.push((current_free_start, current_free_size));\n        }\n        current_free_start = partition.ending_lba + 1;\n        current_free_size = 0;\n    }\n    if current_free_size > 0 {\n        free_sectors.push((current_free_start, current_free_size));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut result = Vec::new();\n    let mut last_end = self.header.first_usable_lba;\n    for partition in &self.partitions {\n        if partition.is_unused() {\n            continue;\n        }\n        let start = partition.starting_lba;\n        let end = partition.ending_lba;\n        if start > last_end {\n            result.push((last_end, start - last_end));\n        }\n        last_end = end + 1;\n    }\n    if self.header.last_usable_lba > last_end {\n        result.push((last_end, self.header.last_usable_lba - last_end));\n    }\n    result\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut last_lba = self.header.first_usable_lba;\n    for partition in self.partitions.iter() {\n        if partition.is_used() {\n            let range = partition.range().unwrap();\n            if last_lba < range.start() {\n                free_sectors.push((last_lba, range.start() - last_lba));\n            }\n            last_lba = range.end() + 1;\n        }\n    }\n    if last_lba < self.header.last_usable_lba {\n        free_sectors.push((last_lba, self.header.last_usable_lba - last_lba + 1));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut current_start = self.header.first_usable_lba;\n    let mut current_end = self.header.first_usable_lba;\n    for partition in self.partitions.iter() {\n        if current_start < partition.starting_lba {\n            free_sectors.push((current_start, partition.starting_lba - current_start));\n        }\n        current_start = partition.ending_lba + 1;\n        current_end = current_start;\n    }\n    if current_start < self.header.last_usable_lba {\n        free_sectors.push((current_start, self.header.last_usable_lba - current_start + 1));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut last_free_sector = self.header.first_usable_lba;\n    for partition in self.iter() {\n        let start = partition.1.starting_lba;\n        let end = partition.1.ending_lba;\n        if start > last_free_sector {\n            free_sectors.push((last_free_sector, start - last_free_sector));\n        }\n        last_free_sector = end + 1;\n    }\n    if last_free_sector < self.header.last_usable_lba {\n        free_sectors.push((last_free_sector, self.header.last_usable_lba - last_free_sector + 1));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut last_lba = self.header.first_usable_lba;\n    for (i, partition) in self.partitions.iter().enumerate() {\n        if partition.is_unused() {\n            continue;\n        }\n        let start = partition.starting_lba;\n        let end = partition.ending_lba;\n        if start > last_lba {\n            free_sectors.push((last_lba, start - last_lba));\n        }\n        last_lba = end + 1;\n    }\n    if last_lba < self.header.last_usable_lba {\n        free_sectors.push((last_lba, self.header.last_usable_lba - last_lba + 1));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut start = self.header.first_usable_lba;\n    let mut end = self.header.last_usable_lba;\n    let mut current_partition = 0;\n    let mut last_partition = 0;\n    let mut last_lba = self.header.first_usable_lba;\n    for partition in self.iter() {\n        if partition.1.starting_lba != last_lba {\n            free_sectors.push((start, partition.1.starting_lba - start));\n            start = partition.1.starting_lba;\n        }\n        last_lba = partition.1.ending_lba + 1;\n        last_partition = current_partition;\n        current_partition += 1;\n    }\n    if last_lba != self.header.last_usable_lba {\n        free_sectors.push((start, end - start));\n    }\n    free_sectors\n}",
      "pub fn find_free_sectors (&self) -> Vec<(u64, u64)> {\n    let mut free_sectors = Vec::new();\n    let mut current_free_start = self.header.first_usable_lba;\n    let mut current_free_size = 0;\n    for partition in &self.partitions {\n        if partition.is_unused() {\n            continue;\n        }\n        let partition_range = partition.range().unwrap();\n        if current_free_start < partition_range.start() {\n            free_sectors.push((current_free_start, current_free_size));\n        }\n        current_free_start = partition_range.end() + 1;\n        current_free_size = 0;\n    }\n    if current_free_start < self.header.last_usable_lba {\n        free_sectors.push((current_free_start, current_free_size));\n    }\n    free_sectors\n}"
    ],
    [
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    // NOTE: this is only for the demonstration purpose, this is not recommended\n    //       the optimal place is not always the first one\n    //       you should use the find_first_place function instead\n    //       this is only for the demonstration purpose\n    let mut optimal_place = None;\n    let mut optimal_size = u64::MAX;\n    for free_space in self.find_free_sectors() {\n        let space_size = free_space.1 - free_space.0;\n        if space_size < optimal_size {\n            optimal_place = Some(free_space.0);\n            optimal_size = space_size;\n        }\n    }\n    optimal_place\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    // NOTE: this is a simplified version of the `find_first_place` function,\n    //       which is optimized for the most optimal place\n    // NOTE: we need to find the first place where the size fits\n    // NOTE: we need to find the last place where the size fits\n    // NOTE: we need to find the place where the size fits the most\n    // NOTE: we need to return the first place if the size fits\n    // NOTE: we need to return the last place if the size fits\n    // NOTE: we need to return the place where the size fits the most\n    // NOTE: we need to return `None` if the size does not fit\n    // NOTE: we need to return `None` if the size is zero\n    // NOTE: we need to return `None` if the size is bigger than the disk\n    // NOTE: we need to return `None` if the size is bigger than the free space\n    // NOTE: we need to return `None` if the size is bigger than the maximum partition size\n    // NOTE: we need to return `None` if the size is bigger than the minimum partition size\n    // NOTE: we need to return `None` if the size is bigger than the maximum partition size\n    // NOTE: we need to return `None` if the size is bigger than the minimum partition size\n    // NOTE: we need to return `None` if the size is bigger than the maximum partition size\n    // NOTE: we need to return `None` if the size is bigger than the minimum partition size\n    // NOTE: we need to return `None` if the size is bigger than the maximum partition size\n    // NOTE: we need to return `None` if the size is bigger than the minimum partition size\n    // NOTE: we need to return `None` if the size is bigger than the maximum partition size\n    // NOTE: we need to return `None` if the size is bigger than the minimum partition size\n    // NOTE: we need to return `None` if the size is bigger than the maximum partition size\n    // NOTE: we need to return `None` if the size is bigger than the minimum partition size\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    let mut free_sectors = self.find_free_sectors();\n    free_sectors.sort_by_key(|(start, end)| *start);\n    free_sectors.retain(|(start, end)| *end - *start >= size);\n    free_sectors.into_iter().find_map(|(start, end)| {\n        let mut optimal_place = start;\n        for (_, end) in free_sectors.iter() {\n            if *end <= optimal_place {\n                break;\n            }\n            if *end - optimal_place < end - start {\n                optimal_place = *end;\n            }\n        }\n        if optimal_place - start >= size {\n            Some(optimal_place)\n        } else {\n            None\n        }\n    })\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    // NOTE: we want to find the biggest free space\n    let mut free_spaces = self.find_free_sectors();\n    free_spaces.sort_by(|a, b| b.1.cmp(&a.1));\n\n    // NOTE: we want to find the first free space that is bigger than the size given in parameter\n    for (start, len) in free_spaces {\n        if len >= size {\n            // NOTE: we want to align the partition with the alignment defined in the `GPT`\n            let aligned_start = start - (start % self.align);\n            return Some(aligned_start);\n        }\n    }\n\n    None\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    let mut optimal_place = None;\n    let mut optimal_size = None;\n    for (start, end) in self.find_free_sectors() {\n        let size = end - start;\n        if optimal_size.is_none() || size < optimal_size.unwrap() {\n            optimal_place = Some(start);\n            optimal_size = Some(size);\n        }\n    }\n    optimal_place\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    let mut free_sectors = self.find_free_sectors();\n    free_sectors.sort_by(|a, b| a.0.cmp(&b.0));\n    for (start, end) in free_sectors {\n        if start + size <= end {\n            return Some(start);\n        }\n    }\n    None\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    let mut free_sectors = self.find_free_sectors();\n    free_sectors.sort_by_key(|(start, end)| *start);\n    for (start, end) in free_sectors {\n        if end - start >= size {\n            return Some(start);\n        }\n    }\n    None\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    // NOTE: find the first place where we can insert the partition\n    // NOTE: this is the most optimal place because it will allow us to still be able to\n    //       insert a bigger partition later\n    self.find_last_place(size)\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    let mut free_sectors = self.find_free_sectors();\n    free_sectors.sort_by_key(|(start, end)| *start);\n    for (start, end) in free_sectors {\n        if end - start >= size {\n            return Some(start);\n        }\n    }\n    None\n}",
      "pub fn find_optimal_place (&self, size: u64) -> Option<u64> {\n    // NOTE: we need to find the first place where we can start the partition\n    //       and where the partition will end\n    // NOTE: we need to make sure that the partition is aligned\n    //       and that the partition will not overlap with other partitions\n    // NOTE: we need to make sure that the partition will not overlap with the\n    //       header and the backup header\n    // NOTE: we need to make sure that the partition will not overlap with the\n    //       protective MBR\n    // NOTE: we need to make sure that the partition will not overlap with the\n    //       protective MBR\n    // NOTE: we need to make sure that the partition will not overlap with the\n    //       protective MBR\n    // NOTE: we need to make sure that the partition will not overlap with the\n    //       protective MBR\n    // NOTE: we need to make sure that the partition will not overlap with the\n    //       protective MBR\n    // NOTE: we need to make sure that the partition will not overlap with the\n    //       protective MBR\n    // NOTE: we need to make sure that the partition will not overlap with the\n    //       protective MBR\n    // NOTE: we need to make sure that the partition will not overlap with the\n    //       protective MBR\n    // NOTE: we need to make sure that the partition will not overlap with the\n    //       protective MBR\n    // NOTE: we need to make sure that the partition will not overlap with the\n    //       protective MBR\n    // NOTE: we need to make sure that the partition will not overlap with the\n    //       protective MBR\n    // NOTE: we need to make sure that the partition will not overlap with the\n    //       protective MBR\n    // NOTE: we need to make sure that the partition will not overlap with the\n    //       protective MBR\n    // NOTE: we need to make sure that the partition will not overlap with the\n    //       protective MBR\n    // NOTE: we need to make sure that the partition will not overlap with the\n    //       protective MBR\n}"
    ],
    [
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let mut last_lba = self.header.last_usable_lba;\n    for partition in self.partitions.iter() {\n        if partition.is_used() {\n            last_lba = partition.ending_lba;\n            break;\n        }\n    }\n    Ok(last_lba - self.header.first_usable_lba)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let mut max_size = self.header.last_usable_lba + 1 - self.header.first_usable_lba;\n    let align = self.align;\n    if align > 0 {\n        max_size -= max_size % align;\n    }\n    Ok(max_size)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let mut max_size = self.header.last_usable_lba + 1 - self.header.first_usable_lba;\n    if max_size < self.align {\n        return Err(Error::NoSpaceLeft);\n    }\n    max_size -= self.align;\n    Ok(max_size)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let mut total_size = self.header.last_usable_lba + 1 - self.header.first_usable_lba;\n    total_size -= self.header.first_usable_lba;\n    total_size -= self.header.last_usable_lba;\n    total_size -= self.header.first_usable_lba;\n    total_size -= self.header.last_usable_lba;\n    total_size -= self.header.first_usable_lba;\n    total_size -= self.header.last_usable_lba;\n    total_size -= self.header.first_usable_lba;\n    total_size -= self.header.last_usable_lba;\n    total_size -= self.header.first_usable_lba;\n    total_size -= self.header.last_usable_lba;\n    total_size -= self.header.first_usable_lba;\n    total_size -= self.header.last_usable_lba;\n    total_size -= self.header.first_usable_lba;\n    total_size -= self.header.last_usable_lba;\n    total_size -= self.header.first_usable_lba;\n    total_size -= self.header.last_usable_lba;\n    total_size -= self.header.first_usable_lba;\n    total_size -= self.header.last_usable_lba;\n    total_size -= self.header.first_usable_lba;\n    total_size -= self.header.last_usable_lba;\n    total_size -= self.header.first_usable_lba;\n    total_size -= self.header.last_usable_lba;\n    total_size -= self.header.first_usable_lba;\n    total_size -= self.header.last_usable_lba;\n    total_size -= self.header.first_usable_lba;\n    total_size -= self.header.last_usable_lba;\n    total_size -= self.header.first_usable_lba;\n    total_size -= self.header.last_usable_lba;\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let mut max_size = self.header.last_usable_lba + 1 - self.header.first_usable_lba;\n    if self.align > 0 {\n        max_size -= max_size % self.align;\n    }\n    Ok(max_size)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let align = self.align;\n    let mut last_usable_lba = self.header.last_usable_lba;\n    let mut first_usable_lba = self.header.first_usable_lba;\n    let mut partition_entry_lba = self.header.partition_entry_lba;\n    let mut number_of_partition_entries = self.header.number_of_partition_entries;\n    let mut size_of_partition_entry = self.header.size_of_partition_entry;\n    let mut partitions = self.partitions.clone();\n    let mut align_lba = 0;\n    let mut align_size = 0;\n    for i in 0..number_of_partition_entries {\n        let partition = partitions[i as usize].clone();\n        let partition_size = partition.ending_lba - partition.starting_lba;\n        let partition_lba = partition.starting_lba;\n        if partition_lba > align_lba {\n            align_lba = partition_lba;\n            align_size = partition_size;\n        }\n        if partition_lba + partition_size > last_usable_lba {\n            last_usable_lba = partition_lba + partition_size;\n        }\n        if partition_lba < first_usable_lba {\n            first_usable_lba = partition_lba;\n        }\n        if partition_lba < partition_entry_lba {\n            partition_entry_lba = partition_lba;\n        }\n    }\n    let mut align_lba = align_lba;\n    let mut align_size = align_size;\n    let mut partition_entry_lba = partition_entry_lba;\n    let mut number_of_partition_entries = number_of_partition_entries;\n    let mut size_of_partition_entry = size_of_partition_entry;\n    let mut partitions = partitions.clone();\n    let mut last_usable_lba = last_usable_lba;\n    let mut first_usable_lba = first_usable_lba;\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let mut max_size = self.header.last_usable_lba + 1 - self.header.first_usable_lba;\n    let align = self.align;\n    if align > 1 {\n        max_size = max_size - max_size % align;\n    }\n    Ok(max_size)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let mut size = self.header.last_usable_lba + 1 - self.header.first_usable_lba;\n    if self.align > 0 {\n        size -= size % self.align;\n    }\n    Ok(size)\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let mut size = self.header.last_usable_lba + 1 - self.header.first_usable_lba;\n    size -= self.header.first_usable_lba;\n    size -= self.header.last_usable_lba;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n    size -= 1;\n}",
      "pub fn get_maximum_partition_size (&self) -> Result<u64> {\n    let mut total_sectors = self.header.last_usable_lba + 1 - self.header.first_usable_lba;\n    let mut free_sectors = total_sectors;\n    for partition in self.partitions.iter() {\n        if partition.is_unused() {\n            continue;\n        }\n        let size = partition.ending_lba - partition.starting_lba + 1;\n        free_sectors -= size;\n    }\n    Ok(free_sectors)\n}"
    ],
    [
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let partition = self.partitions.get(partition_number as usize).ok_or(Error::InvalidPartitionNumber)?;\n    if partition.is_unused() {\n        return Err(Error::UnusedPartition);\n    }\n    let start = partition.starting_lba * self.sector_size;\n    let end = partition.ending_lba * self.sector_size;\n    if end < start {\n        return Err(Error::InvalidPartition);\n    }\n    Ok(start..=end)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let entry = self.get_partition_entry(partition_number)?;\n    let start = entry.starting_lba * self.sector_size;\n    let end = entry.ending_lba * self.sector_size;\n    Ok(start..=end)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let entry = self.get_partition(partition_number)?;\n    let start = entry.starting_lba * self.sector_size;\n    let end = entry.ending_lba * self.sector_size;\n    Ok(start..=end)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let partition = self.partitions.get(partition_number as usize).ok_or(Error::InvalidPartitionNumber)?;\n    if partition.is_unused() {\n        return Err(Error::UnusedPartition);\n    }\n    let start = partition.starting_lba * self.sector_size;\n    let end = partition.ending_lba * self.sector_size;\n    if start > end {\n        return Err(Error::InvalidPartition);\n    }\n    Ok(start..=end)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let entry = self.get_partition_entry(partition_number)?;\n    let start = entry.starting_lba * self.sector_size;\n    let end = entry.ending_lba * self.sector_size;\n    Ok(start..=end)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let entry = self.get_partition_entry(partition_number)?;\n    let start = entry.starting_lba * self.sector_size;\n    let end = entry.ending_lba * self.sector_size;\n    Ok(start..=end)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let partition = self.partitions.get(partition_number as usize)?;\n    partition.range()\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let entry = self.get_partition_entry(partition_number)?;\n    let start = entry.starting_lba * self.sector_size;\n    let end = entry.ending_lba * self.sector_size;\n    Ok(start..=end)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let entry = self.partitions.get(partition_number as usize)?;\n    let start = entry.starting_lba * self.sector_size;\n    let end = entry.ending_lba * self.sector_size;\n    Ok(start..=end)\n}",
      "pub fn get_partition_byte_range (&self, partition_number: u32) -> Result<RangeInclusive<u64>> {\n    let entry = self.get_partition(partition_number)?;\n    let start = entry.starting_lba * self.sector_size;\n    let end = entry.ending_lba * self.sector_size;\n    Ok(start..=end)\n}"
    ],
    [
      "fn entropy (&self) -> T {\n\t(self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n    (self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n\t(self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T {\n(self.b - self.a).ln()\n}",
      "fn entropy (&self) -> T where T: Float\n{\n    (self.b - self.a).ln()\n}"
    ],
    [
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\n    assert!(self.nrows() == self.ncols(), \"Matrix must be square\");\n    let mut sum: T = T::zero();\n    for i in 0..self.nrows()\n    {\n        sum += self.get(i, i);\n    }\n    sum\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\n    assert!(self.nrows() == self.ncols(), \"Matrix must be square\");\n    let mut tr: T = T::zero();\n    for i in 0..self.nrows()\n    {\n        tr += self.get_element(i, i);\n    }\n    tr\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\n    assert!(self.m == self.n, \"Matrix must be square\");\n    let mut sum: T = T::zero();\n    for i in 0..self.m {\n        sum += self.data[i * self.m + i];\n    }\n    sum\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\n    assert!(self.m == self.n, \"The matrix must be square\");\n    let mut tr: T = T::zero();\n    for i in 0..self.m {\n        tr += self.data[i * self.m + i];\n    }\n    tr\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\n    assert!(self.m == self.n, \"Matrix must be square\");\n    let mut sum: T = T::zero();\n    for i in 0..self.m {\n        sum += self.data[i * self.n + i];\n    }\n    sum\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\n    assert_eq!(self.m, self.n, \"Matrix must be square\");\n    let mut tr: T = T::zero();\n    for i in 0..self.m {\n        tr += self.data[i * self.n + i];\n    }\n    tr\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\n    assert!(self.m == self.n, \"Matrix must be square\");\n    let mut tr: T = T::zero();\n    for i in 0..self.m {\n        tr += self.data[i * self.n + i];\n    }\n    tr\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\n    assert!(self.m == self.n, \"Matrix must be square\");\n    let mut tr: T = T::zero();\n    for i in 0..self.m {\n        tr += self.data[i * self.n + i];\n    }\n    tr\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\n    assert!(self.m == self.n, \"Matrix must be square\");\n    let mut tr: T = T::zero();\n    for i in 0..self.m {\n        tr += self.data[i * self.m + i];\n    }\n    tr\n}",
      "pub fn trace (&self) -> T where\nT: Field + Scalar, {\n    assert_eq!(self.m, self.n);\n    let mut sum: T = T::zero();\n    for i in 0..self.m {\n        sum += self.data[i * self.m + i];\n    }\n    sum\n}"
    ],
    [
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\nlet m: usize = self.m;\nlet n: usize = self.n;\nlet data: Vec<T> = self.data.clone();\nlet mut slice_data: Vec<T> = Vec::with_capacity(m * n);\n\nfor i in row_s..row_e\n{\nfor j in column_s..column_e\n{\nslice_data.push(data[i * n + j]);\n}\n}\n\nGeneral::new(row_e - row_s, column_e - column_s, slice_data)\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\nlet m: usize = self.m;\nlet n: usize = self.n;\n\nassert!(row_s < m, \"row_s must be less than m\");\nassert!(row_e < m, \"row_e must be less than m\");\nassert!(column_s < n, \"column_s must be less than n\");\nassert!(column_e <= n, \"column_e must be less than or equal to n\");\n\nlet mut slice: Vec<T> = Vec::with_capacity((row_e - row_s + 1) * (column_e - column_s + 1));\n\nfor i in row_s..row_e + 1\n{\nfor j in column_s..column_e + 1\n{\nslice.push(self.data[i * n + j]);\n}\n}\n\nGeneral::new(row_e - row_s + 1, column_e - column_s + 1, slice)\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\nlet m = self.m;\nlet n = self.n;\n\nassert!(row_s < m);\nassert!(row_e < m);\nassert!(column_s < n);\nassert!(column_e <= n);\n\nlet mut data: Vec<T, Global> = Vec::new();\n\nfor i in row_s..row_e\n{\nfor j in column_s..column_e\n{\ndata.push(self.data[i * n + j]);\n}\n}\n\nGeneral::new(row_e - row_s, column_e - column_s, data)\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\n    let m: usize = self.m;\n    let n: usize = self.n;\n    let data: Vec<T> = self.data.clone();\n\n    if row_s >= m || row_e >= m || column_s >= n || column_e >= n\n    {\n        panic!(\"Index out of bounds\");\n    }\n\n    let mut slice_data: Vec<T> = Vec::new();\n\n    for i in row_s..row_e\n    {\n        for j in column_s..column_e\n        {\n            slice_data.push(data[i * n + j]);\n        }\n    }\n\n    General::new(row_e - row_s, column_e - column_s, slice_data)\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\n    let mut slice: Vec<T> = Vec::new();\n    let (m, n): (usize, usize) = self.dim();\n\n    assert!(row_s < m);\n    assert!(row_e < m);\n    assert!(column_s < n);\n    assert!(column_e <= n);\n\n    for i in row_s..row_e\n    {\n        for j in column_s..column_e\n        {\n            slice.push(self.data[i * n + j]);\n        }\n    }\n\n    General::new(row_e - row_s, column_e - column_s, slice)\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\n    let (m, n) = self.dim();\n    let mut data: Vec<T> = Vec::with_capacity(m * n);\n    for i in row_s..row_e\n    {\n        for j in column_s..column_e\n        {\n            data.push(self.data[i * n + j]);\n        }\n    }\n    General::new(row_e - row_s, column_e - column_s, data)\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\nlet m: usize = self.m;\nlet n: usize = self.n;\nlet data: Vec<T> = self.data.clone();\nlet mut slice: Vec<T> = Vec::new();\n\nif row_s >= m || row_e >= m || column_s >= n || column_e >= n\n{\nreturn Err(());\n}\n\nfor i in row_s..row_e + 1\n{\nfor j in column_s..column_e + 1\n{\nslice.push(data[i * n + j]);\n}\n}\n\nOk(General::new(row_e - row_s + 1, column_e - column_s + 1, slice))\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\n    assert!(row_s < self.m);\n    assert!(row_e < self.m);\n    assert!(column_s < self.n);\n    assert!(column_e <= self.n);\n    let mut slice: Vec<T> = Vec::with_capacity((row_e - row_s) * (column_e - column_s));\n    for i in row_s..row_e\n    {\n        for j in column_s..column_e\n        {\n            slice.push(self.data[i * self.n + j]);\n        }\n    }\n    General::new(row_e - row_s, column_e - column_s, slice)\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\n    assert!(row_s < self.m);\n    assert!(row_e < self.m);\n    assert!(column_s < self.n);\n    assert!(column_e <= self.n);\n\n    let mut slice: Vec<T> = Vec::new();\n\n    for i in row_s..row_e\n    {\n        for j in column_s..column_e\n        {\n            slice.push(self.data[i * self.n + j]);\n        }\n    }\n\n    General::new(row_e - row_s, column_e - column_s, slice)\n}",
      "pub fn get_slice (\n&self,\nrow_s: usize,\nrow_e: usize,\ncolumn_s: usize,\ncolumn_e: usize,\n) -> General<T> {\n    assert!(row_s < self.m);\n    assert!(row_e < self.m);\n    assert!(column_s < self.n);\n    assert!(column_e <= self.n);\n\n    let mut slice: Vec<T> = Vec::with_capacity(self.m * self.n);\n\n    for i in row_s..row_e\n    {\n        for j in column_s..column_e\n        {\n            slice.push(self.data[i * self.n + j]);\n        }\n    }\n\n    General::new(row_e - row_s, column_e - column_s, slice)\n}"
    ],
    [
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    let (m, n) = self.dim();\n    let (m_slice, n_slice) = slice.dim();\n\n    assert!(row + m_slice <= m, \"The row index is out of bounds\");\n    assert!(column + n_slice <= n, \"The column index is out of bounds\");\n\n    for i in 0..m_slice\n    {\n        for j in 0..n_slice\n        {\n            self.data[row + i][column + j] = slice.data[i][j];\n        }\n    }\n\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    let (m, n) = self.dim();\n    assert!(row < m, \"Row index out of bounds\");\n    assert!(column < n, \"Column index out of bounds\");\n    assert_eq!(slice.dim(), (m - row, n - column), \"Dimension mismatch\");\n\n    for i in 0..(m - row)\n    {\n        for j in 0..(n - column)\n        {\n            self.data[row + i][column + j] = slice.data[i][j];\n        }\n    }\n\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    for i in 0..slice.nrows()\n    {\n        for j in 0..slice.ncols()\n        {\n            self.data[row * self.n + column + j] = slice.data[i * self.n + j];\n        }\n    }\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    let (m, n) = self.dim();\n    let (s_m, s_n) = slice.dim();\n\n    if row + s_m > m || column + s_n > n\n    {\n        panic!(\"Index out of bounds.\");\n    }\n\n    for i in 0..s_m\n    {\n        for j in 0..s_n\n        {\n            self.data[i * n + j] = slice.data[i * s_n + j];\n        }\n    }\n\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    for i in 0..slice.nrows()\n    {\n        for j in 0..slice.ncols()\n        {\n            self.data[row + i][column + j] = slice.data[i][j];\n        }\n    }\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    let (m, n) = self.dim();\n    let (slice_m, slice_n) = slice.dim();\n    assert!(row + slice_m <= m, \"Row index out of bounds\");\n    assert!(column + slice_n <= n, \"Column index out of bounds\");\n\n    for i in 0..slice_m\n    {\n        for j in 0..slice_n\n        {\n            self.data[row * n + column + j] = slice.data[i * n + j];\n        }\n    }\n\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    for i in 0..slice.nrows()\n    {\n        for j in 0..slice.ncols()\n        {\n            self.data[row + i][column + j] = slice.data[i][j];\n        }\n    }\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    for i in 0..slice.nrows()\n    {\n        for j in 0..slice.ncols()\n        {\n            self.data[row + i][column + j] = slice.data[i][j];\n        }\n    }\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    let (m, n) = self.dim();\n    let (s_m, s_n) = slice.dim();\n\n    if row + s_m > m || column + s_n > n\n    {\n        panic!(\"The slice is out of bounds\");\n    }\n\n    for i in 0..s_m\n    {\n        for j in 0..s_n\n        {\n            self.data[row + i + (column + j) * m] = slice.data[i + j * s_m];\n        }\n    }\n\n    self\n}",
      "pub fn set_slice (mut self, slice: &Self, row: usize, column: usize) -> General<T> {\n    let (m, n) = self.dim();\n    let (slice_m, slice_n) = slice.dim();\n    assert!(row + slice_m <= m);\n    assert!(column + slice_n <= n);\n\n    for i in 0..slice_m\n    {\n        for j in 0..slice_n\n        {\n            self.data[row + i + (column + j) * m] = slice.data[i + j * slice_m];\n        }\n    }\n    self\n}"
    ],
    [
      "pub fn dotp (&self, rhs: &Self) -> T {\n    let mut dotp: T = T::zero();\n    for i in 0..self.data.len()\n    {\n        dotp += self.data[i] * rhs.data[i];\n    }\n    dotp\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    let mut dotp: T = T::zero();\n    for i in 0..self.dim()\n    {\n        dotp += self.data[i] * rhs.data[i];\n    }\n    dotp\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    let mut result: T = T::zero();\n    for (i, v) in self.data.iter().enumerate()\n    {\n        result += v * rhs.data[i];\n    }\n    result\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    let mut sum: T = T::zero();\n    for i in 0..self.data.len()\n    {\n        sum = sum + self.data[i] * rhs.data[i];\n    }\n    sum\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    let mut sum: T = T::zero();\n    for i in 0..self.data.len()\n    {\n        sum += self.data[i] * rhs.data[i];\n    }\n    sum\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    let mut result: T = T::zero();\n    for i in 0..self.data.len()\n    {\n        result += self.data[i] * rhs.data[i];\n    }\n    result\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    let mut result: T = T::zero();\n    for i in 0..self.data.len()\n    {\n        result += self.data[i] * rhs.data[i];\n    }\n    result\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    let mut dotp: T = T::zero();\n    for (i, a) in self.data.iter().enumerate()\n    {\n        dotp += a * rhs.data[i];\n    }\n    dotp\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    let mut result: T = T::zero();\n    for (i, &x) in self.data.iter().enumerate()\n    {\n        result += x * rhs.data[i];\n    }\n    result\n}",
      "pub fn dotp (&self, rhs: &Self) -> T {\n    let mut result: T = T::zero();\n    for i in 0..self.dim()\n    {\n        result += self.data[i] * rhs.data[i];\n    }\n    result\n}"
    ],
    [
      "pub fn argmax (&self) -> usize {\n    let mut max_value = self.data[0];\n    let mut max_index = 0;\n    for (i, value) in self.data.iter().enumerate()\n    {\n        if *value > max_value\n        {\n            max_value = *value;\n            max_index = i;\n        }\n    }\n    max_index\n}",
      "pub fn argmax (&self) -> usize {\n    let mut max_val: T = self.data[0];\n    let mut max_idx: usize = 0;\n    for (i, &val) in self.data.iter().enumerate().skip(1)\n    {\n        if val > max_val\n        {\n            max_val = val;\n            max_idx = i;\n        }\n    }\n    max_idx\n}",
      "pub fn argmax (&self) -> usize {\n    let mut max_idx: usize = 0;\n    let mut max_val: T = self.data[0];\n    for i in 0..self.data.len()\n    {\n        if self.data[i] > max_val\n        {\n            max_val = self.data[i];\n            max_idx = i;\n        }\n    }\n    max_idx\n}",
      "pub fn argmax (&self) -> usize {\n    let mut max: T = self.data[0];\n    let mut idx: usize = 0;\n    for i in 0..self.data.len()\n    {\n        if self.data[i] > max\n        {\n            max = self.data[i];\n            idx = i;\n        }\n    }\n    idx\n}",
      "pub fn argmax (&self) -> usize {\n    let mut max: T = self.data[0];\n    let mut idx: usize = 0;\n    for i in 1..self.data.len()\n    {\n        if self.data[i] > max\n        {\n            max = self.data[i];\n            idx = i;\n        }\n    }\n    idx\n}",
      "pub fn argmax (&self) -> usize {\n    let mut max: T = self.data[0];\n    let mut idx: usize = 0;\n    for i in 1..self.data.len()\n    {\n        if self.data[i] > max\n        {\n            max = self.data[i];\n            idx = i;\n        }\n    }\n    idx\n}",
      "pub fn argmax (&self) -> usize {\n    let mut max: T = self.data[0];\n    let mut idx: usize = 0;\n    for i in 0..self.data.len()\n    {\n        if self.data[i] > max\n        {\n            max = self.data[i];\n            idx = i;\n        }\n    }\n    idx\n}",
      "pub fn argmax (&self) -> usize {\n    let mut max_idx: usize = 0;\n    let mut max_val: T = self.data[0];\n\n    for i in 0..self.data.len()\n    {\n        if self.data[i] > max_val\n        {\n            max_val = self.data[i];\n            max_idx = i;\n        }\n    }\n\n    max_idx\n}",
      "pub fn argmax (&self) -> usize {\n    let mut max_val = self.data[0];\n    let mut max_idx = 0;\n    for i in 1..self.data.len()\n    {\n        if self.data[i] > max_val\n        {\n            max_val = self.data[i];\n            max_idx = i;\n        }\n    }\n    max_idx\n}",
      "pub fn argmax (&self) -> usize {\n    let mut max: T = self.data[0];\n    let mut idx: usize = 0;\n    for i in 1..self.data.len()\n    {\n        if self.data[i] > max\n        {\n            max = self.data[i];\n            idx = i;\n        }\n    }\n    idx\n}"
    ],
    [
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    let m: usize = self.dim().0;\n    assert!(s < m && e < m, \"Slice out of bounds\");\n    let data: Vec<T> = self.data[s..e].to_vec();\n    Vector { data }\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    assert!(s < self.m);\n    assert!(e < self.m);\n    assert!(s <= e);\n    let mut data: Vec<T> = Vec::with_capacity(e - s + 1);\n    for i in s..=e\n    {\n        data.push(self.data[i]);\n    }\n    Vector{ data: data, m: e - s + 1 }\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    assert!(s < self.m);\n    assert!(e < self.m);\n    assert!(s <= e);\n    let mut slice: Vec<T> = Vec::with_capacity(e - s);\n    for i in s..e\n    {\n        slice.push(self.data[i]);\n    }\n    Vector::new_column(slice)\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    let mut v: Vector<T> = Vector::new_column(Vec::new());\n    v.data = self.data[s..e].to_vec();\n    v\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    let m: usize = self.data.len();\n    assert!(s < m && e < m, \"Out of bounds\");\n    let mut slice: Vec<T> = Vec::with_capacity(e - s + 1);\n    for i in s..=e\n    {\n        slice.push(self.data[i]);\n    }\n    Vector::new_column(slice)\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    let mut v: Vector<T> = Vector::new_column(Vec::new());\n    for i in s..e\n    {\n        v.data.push(self.data[i].clone());\n    }\n    v\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    let m: usize = self.data.len();\n    assert!(s < m);\n    assert!(e < m);\n    let mut v: Vector<T> = Vector::new_column(Vec::with_capacity(e - s + 1));\n    for i in s..=e\n    {\n        v.data.push(self.data[i].clone());\n    }\n    v\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    assert!(s < self.m);\n    assert!(e < self.m);\n\n    let mut data: Vec<T> = Vec::new();\n    for i in s..e\n    {\n        data.push(self.data[i]);\n    }\n    Vector{data: data, m: e - s}\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    assert!(s < self.m);\n    assert!(e < self.m);\n    let mut data: Vec<T> = Vec::with_capacity(e - s + 1);\n    for i in s..=e\n    {\n        data.push(self.data[i]);\n    }\n    Vector{m: e - s + 1, n: 1, data}\n}",
      "pub fn get_slice (&self, s: usize, e: usize) -> Vector<T> {\n    assert!(s < self.m, \"Slice start out of bounds\");\n    assert!(e < self.m, \"Slice end out of bounds\");\n    assert!(s <= e, \"Slice start must be less or equal to slice end\");\n\n    let mut data: Vec<T> = Vec::with_capacity(e - s + 1);\n\n    for i in s..=e\n    {\n        data.push(self.data[i]);\n    }\n\n    Vector{data: data, m: e - s + 1}\n}"
    ],
    [
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, n): (usize, usize) = self.dim();\n    let (m_rhs, n_rhs): (usize, usize) = rhs.dim();\n    assert!(m_rhs == m && n_rhs == n);\n    assert!(s < m);\n    for i in 0..n\n    {\n        self.data[s + i * m] = rhs.data[i];\n    }\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let m: usize = self.data.len();\n    let n: usize = rhs.data.len();\n    let mut k: usize = 0;\n    let mut i: usize = s;\n    while i < s + n\n    {\n        self.data[i] = rhs.data[k];\n        k += 1;\n        i += 1;\n    }\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let m: usize = self.data.len();\n    let n: usize = rhs.data.len();\n    assert!(s < m, \"Index out of bounds\");\n    assert!(s + n <= m, \"Index out of bounds\");\n    for i in 0..n\n    {\n        self.data[s + i] = rhs.data[i];\n    }\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, n) = self.dim();\n    let (m_rhs, n_rhs) = rhs.dim();\n\n    assert!(s < m, \"Slice start out of bounds\");\n    assert!(m_rhs == n, \"Slice size mismatch\");\n\n    for i in 0..n_rhs\n    {\n        self.data[s + i] = rhs.data[i];\n    }\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let m: usize = self.data.len();\n    let n: usize = rhs.data.len();\n    let k: usize = s + n;\n\n    if k > m\n    {\n        panic!(\"Out of bounds\")\n    }\n\n    for i in 0..n\n    {\n        self.data[s + i] = rhs.data[i];\n    }\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, n) = self.dim();\n    assert!(s < m, \"The start index is out of bounds\");\n    assert_eq!(n, rhs.dim().1, \"The vectors must have the same dimension\");\n    let mut k: usize = 0;\n    for i in s..m\n    {\n        self.data[i] = rhs.data[k];\n        k += 1;\n    }\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, n) = self.dim();\n    let (m_rhs, n_rhs) = rhs.dim();\n\n    assert!(s < m, \"Start index out of bounds\");\n    assert!(m_rhs == n, \"Dimension mismatch\");\n\n    for i in 0..m_rhs\n    {\n        self.data[s + i] = rhs.data[i];\n    }\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, n): (usize, usize) = self.dim();\n    let (rhs_m, rhs_n): (usize, usize) = rhs.dim();\n    assert!(s < m, \"The slice must be within the vector\");\n    assert!(rhs_m == m - s, \"The slice must be within the vector\");\n    assert!(rhs_n == n, \"The slice must be within the vector\");\n\n    for i in 0..rhs_m\n    {\n        self.data[s + i] = rhs.data[i];\n    }\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, n) = self.dim();\n    let (rhs_m, rhs_n) = rhs.dim();\n    assert!(rhs_m == rhs_n && rhs_n == 1);\n    assert!(s < m);\n    let mut k: usize = 0;\n    while k < rhs_m\n    {\n        self.data[s + k * m] = rhs.data[k];\n        k += 1;\n    }\n}",
      "pub fn set_slice (&mut self, rhs: &Self, s: usize) {\n    let (m, _) = self.dim();\n    let (rhs_m, _) = rhs.dim();\n\n    assert!(s < m);\n    assert_eq!(rhs_m, m - s);\n\n    for i in 0..rhs_m\n    {\n        self.data[s + i] = rhs.data[i];\n    }\n}"
    ],
    [
      "fn abs (&self) -> Self {\n    self.conj().sqrt()\n}",
      "fn abs (&self) -> Self {\n    self.conj().sqrt()\n}",
      "fn abs (&self) -> Self {\n    self.conj().sqrt()\n}",
      "fn abs (&self) -> Self {\n    let re: Self = self.re.clone();\n    let im: Self = self.im.clone();\n    let re_sqr: Self = re.powi(2);\n    let im_sqr: Self = im.powi(2);\n    let sum: Self = re_sqr + im_sqr;\n    sum.sqrt()\n}",
      "fn abs (&self) -> Self {\n    let re: Self = self.re.clone();\n    let im: Self = self.im.clone();\n    let mut sum: Self = re.pow(2) + im.pow(2);\n    sum = sum.sqrt();\n    sum\n}",
      "fn abs (&self) -> Self {\n    let re = self.re.abs();\n    let im = self.im.abs();\n    let max = if re > im { re } else { im };\n    let min = if re < im { re } else { im };\n    let res = max * (1.0 + (min / max).sqrt());\n    Self { re: res, im: 0.0 }\n}",
      "fn abs (&self) -> Self {\n    self.clone()\n}",
      "fn abs (&self) -> Self {\n    let re = self.re.to_f64().unwrap();\n    let im = self.im.to_f64().unwrap();\n    let abs = (re * re + im * im).sqrt();\n    Complex::new(abs, 0.0)\n}",
      "fn abs (&self) -> Self {\n    let re: Self = self.re.clone();\n    let im: Self = self.im.clone();\n    let mut res: Self = re.clone();\n    res = res.pow(2);\n    res = res + im.clone().pow(2);\n    res = res.sqrt();\n    res\n}",
      "fn abs (&self) -> Self {\n    let re = self.re.to_f64().unwrap();\n    let im = self.im.to_f64().unwrap();\n    let result = (re.powi(2) + im.powi(2)).sqrt();\n    Complex::new(result, 0.0)\n}"
    ],
    [
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.len() == 0 {\n        panic!(\"Root vector is empty\");\n    }\n\n    let mut coef: Vec<T> = Vec::with_capacity(root.len() + 1);\n    coef.push(T::one());\n\n    for i in 0..root.len() {\n        let mut c: T = T::zero();\n        for j in 0..i {\n            c = c - root[j] * coef[i - j - 1];\n        }\n        coef.push(c);\n    }\n\n    Polynomial { coef: coef }\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.len() == 0 {\n        panic!(\"Empty vector\")\n    }\n    let mut coef: Vec<T> = vec![T::one(); root.len() + 1];\n    for i in 0..root.len() {\n        coef[i] = -root[i];\n        for j in 0..root.len() {\n            if i != j {\n                coef[i] = coef[i] + root[j] * coef[i - j - 1];\n            }\n        }\n    }\n    Polynomial::from_coef(coef)\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty()\n    {\n        panic!(\"The root is an empty vector\");\n    }\n\n    let mut coef: Vec<T> = Vec::new();\n    let mut i: usize = 0;\n    while i < root.len()\n    {\n        let mut j: usize = 0;\n        while j < root.len()\n        {\n            if i != j\n            {\n                coef.push(T::one() / (root[i] - root[j]));\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n\n    Polynomial::from_coef(coef)\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty() {\n        panic!(\"The root is an empty vector\");\n    }\n\n    let n = root.len();\n    let mut coef = vec![T::zero(); n + 1];\n    coef[0] = T::one();\n\n    for i in 0..n {\n        let mut sum = T::zero();\n        for j in 0..n {\n            if i != j {\n                sum = sum + coef[j] * (root[i] - root[j]);\n            }\n        }\n        coef[i + 1] = -sum / (i as T);\n    }\n\n    Polynomial { coef }\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.len() == 0\n    {\n        panic!(\"Root must not be empty\");\n    }\n\n    let degree = root.len() - 1;\n    let mut coef: Vec<T> = Vec::with_capacity(degree + 1);\n\n    for i in 0..degree + 1\n    {\n        let mut sum: T = T::zero();\n        for j in 0..degree + 1\n        {\n            if i == j\n            {\n                continue;\n            }\n\n            sum = sum - root[j] * coef[i - j - 1];\n        }\n\n        coef.push(sum);\n    }\n\n    Polynomial { coef }\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    let mut coef: Vec<T> = Vec::new();\n    let mut i = 0;\n    while i < root.len()\n    {\n        let mut j = 0;\n        while j < root.len()\n        {\n            if i != j\n            {\n                coef.push(-root[i] * root[j]);\n            }\n            j += 1;\n        }\n        coef.push(T::one());\n        i += 1;\n    }\n    Polynomial::from_coef(coef)\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.len() == 0 {\n        panic!(\"The root is an empty vector\");\n    }\n\n    let degree = root.len() - 1;\n    let mut coef: Vec<T> = Vec::with_capacity(degree + 1);\n    coef.push(-root[0]);\n\n    for i in 1..degree + 1 {\n        let mut sum: T = T::zero();\n        for j in 0..i {\n            sum = sum + root[j] * root[i - j - 1];\n        }\n        coef.push(-sum);\n    }\n\n    Polynomial { coef }\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.is_empty() {\n        panic!(\"Root is an empty vector\");\n    }\n    let n = root.len();\n    let mut coef: Vec<T> = Vec::with_capacity(n);\n    coef.push(T::one());\n    for i in 0..n {\n        let mut coef_i: Vec<T> = Vec::with_capacity(n);\n        coef_i.push(T::one());\n        for j in 0..n {\n            if i == j {\n                continue;\n            }\n            coef_i.push(-root[j]);\n        }\n        let coef_i: T = coef_i.iter().product();\n        coef.push(coef_i);\n    }\n    Polynomial::from_coef(coef)\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    let mut coef: Vec<T> = Vec::new();\n    let mut n = root.len() - 1;\n    for i in 0..n {\n        let mut sum = T::zero();\n        for j in 0..n {\n            if i != j {\n                sum += root[i] * root[j];\n            }\n        }\n        coef.push(sum);\n    }\n    coef.push(T::one());\n    Polynomial::from_coef(coef)\n}",
      "pub fn from_root (root: Vec<T>) -> Polynomial<T> where\nT: Field + Scalar, {\n    if root.len() == 0 {\n        panic!(\"Empty vector\")\n    }\n\n    let mut coef: Vec<T> = Vec::new();\n    let mut root_iter = root.iter();\n    let mut root_next = root_iter.next();\n    let mut root_prev = root_iter.next();\n\n    while root_next.is_some() {\n        let mut coef_i = T::zero();\n        let mut root_i = root_prev.unwrap();\n        let mut root_j = root_next.unwrap();\n\n        while root_j.is_some() {\n            coef_i -= root_i * root_j;\n            root_i = root_j;\n            root_j = root_iter.next();\n        }\n\n        coef.push(coef_i);\n        root_prev = root_next;\n        root_next = root_iter.next();\n    }\n\n    Polynomial { coef }\n}"
    ],
    [
      "pub fn eval (&self, x: T) -> T {\n    let mut res: T = T::zero();\n    for (i, coef) in self.coef.iter().enumerate()\n    {\n        res = res * x + coef;\n    }\n    res\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut result: T = T::zero();\n    for (i, c) in self.coef.iter().enumerate()\n    {\n        result += *c * x.powi(i as i32);\n    }\n    result\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut result: T = T::zero();\n    for (i, c) in self.coef.iter().enumerate()\n    {\n        result = result * x + c;\n    }\n    result\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut result: T = T::zero();\n    for (i, c) in self.coef.iter().enumerate()\n    {\n        result += c * x.powi(i as i32);\n    }\n    result\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut result: T = T::zero();\n    for (i, c) in self.coef.iter().enumerate()\n    {\n        result = result * x + c;\n    }\n    result\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut res: T = T::zero();\n    for i in 0..self.coef.len()\n    {\n        res = res * x + self.coef[i];\n    }\n    res\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut result: T = self.coef[0];\n    for i in 1..self.coef.len()\n    {\n        result = result * x + self.coef[i];\n    }\n    result\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut result: T = T::zero();\n    for (i, c) in self.coef.iter().enumerate()\n    {\n        result = result * x + c;\n    }\n    result\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut res: T = self.coef[0];\n    for i in 1..self.coef.len()\n    {\n        res = res * x + self.coef[i];\n    }\n    res\n}",
      "pub fn eval (&self, x: T) -> T {\n    let mut result: T = T::zero();\n    for (i, c) in self.coef.iter().enumerate()\n    {\n        result = result * x + c;\n    }\n    result\n}"
    ],
    [
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut coef: Vec<T> = Vec::new();\n    for i in 0..self.coef.len()\n    {\n        if i == 0\n        {\n            coef.push(self.coef[i]);\n        }\n        else\n        {\n            coef.push(self.coef[i] * (i as T));\n        }\n    }\n    Polynomial::from_coef(coef)\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let degree = self.degree();\n    let mut coef: Vec<T> = Vec::with_capacity(degree);\n    for i in 0..degree\n    {\n        coef.push(self.coef[i] * (degree - i) as T);\n    }\n    Polynomial::from_coef(coef)\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut coef: Vec<T> = Vec::new();\n    for i in 0..self.coef.len()\n    {\n        coef.push(self.coef[i] * (i as T));\n    }\n    Polynomial::from_coef(coef)\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let degree = self.degree();\n    let mut coef: Vec<T> = Vec::with_capacity(degree);\n    for i in 0..degree\n    {\n        coef.push(self.coef[i] * (degree - i) as T);\n    }\n    Polynomial::from_coef(coef)\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let degree = self.degree();\n    let mut coef: Vec<T> = Vec::with_capacity(degree);\n    for i in 0..degree\n    {\n        coef.push(self.coef[i] * (degree - i) as T);\n    }\n    Polynomial::from_coef(coef)\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let degree: usize = self.degree();\n    let mut coef: Vec<T> = Vec::new();\n    for i in 0..degree\n    {\n        coef.push(T::from(i as i32 + 1).unwrap() * self.coef[i]);\n    }\n    Polynomial::from_coef(coef)\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut coef: Vec<T> = Vec::with_capacity(self.degree());\n    for i in 0..self.degree()\n    {\n        coef.push(self.coef[i] * (self.degree() - i) as T);\n    }\n    Polynomial::from_coef(coef)\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut coef: Vec<T> = Vec::with_capacity(self.coef.len() - 1);\n    for i in 0..self.coef.len() - 1\n    {\n        coef.push(self.coef[i] * (self.coef.len() - 1 - i) as T);\n    }\n    Polynomial::from_coef(coef)\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut coef: Vec<T> = Vec::with_capacity(self.degree());\n    for i in 0..self.degree()\n    {\n        coef.push(self.coef[i] * (self.degree() - i) as T);\n    }\n    Polynomial::from_coef(coef)\n}",
      "pub fn differentiate (&self) -> Polynomial<T> {\n    let mut coef: Vec<T> = Vec::new();\n    for i in 0..self.coef.len()\n    {\n        coef.push(self.coef[i] * (i as f64 + 1));\n    }\n    Polynomial::from_coef(coef)\n}"
    ],
    [
      "pub fn integrate (&self) -> Polynomial<T> {\n    let mut coef: Vec<T> = Vec::new();\n    for i in 0..self.degree()\n    {\n        coef.push(self.coef[i] * (i as T + 1.0));\n    }\n    Polynomial::from_coef(coef)\n}",
      "pub fn integrate (&self) -> Polynomial<T> {\n    let degree: usize = self.degree();\n    let mut coef: Vec<T> = Vec::new();\n    for i in 0..degree+1\n    {\n        coef.push(self.coef[i] * (i as f64 + 1.0));\n    }\n    Polynomial::from_coef(coef)\n}",
      "pub fn integrate (&self) -> Polynomial<T> {\n    let mut coef: Vec<T> = self.coef.clone();\n    coef.insert(0, T::zero());\n    Polynomial::from_coef(coef)\n}",
      "pub fn integrate (&self) -> Polynomial<T> {\n    let mut coef: Vec<T> = Vec::new();\n    for i in 0..self.degree() + 1\n    {\n        coef.push(self.coef[i] / (i + 1) as T);\n    }\n    Polynomial::from_coef(coef)\n}",
      "pub fn integrate (&self) -> Polynomial<T> {\n    let mut coef: Vec<T> = Vec::new();\n    let mut i: usize = 0;\n    let mut sum: T = T::zero();\n\n    while i < self.degree()\n    {\n        sum += self.coef[i] * T::from(i as i32 + 1).unwrap();\n        coef.push(sum);\n        i += 1;\n    }\n\n    Polynomial::from_coef(coef)\n}",
      "pub fn integrate (&self) -> Polynomial<T> {\n    let degree = self.degree();\n    let mut coef: Vec<T> = vec![T::zero(); degree + 1];\n    coef[0] = T::one();\n    for i in 0..degree\n    {\n        coef[i + 1] = coef[i] * (i as f64 + 1.0) / (i as f64 + 2.0);\n    }\n    Polynomial::from_coef(coef)\n}",
      "pub fn integrate (&self) -> Polynomial<T> {\n    let mut coef: Vec<T> = self.coef.clone();\n    let mut coef_s: Vec<T> = vec![T::zero(); coef.len()];\n    let mut i: usize = 0;\n    let mut j: usize = 0;\n    while i < coef.len()\n    {\n        coef_s[i] = coef[i] * (i as f64 + 1) as T;\n        i += 1;\n    }\n    while j < coef_s.len()\n    {\n        coef_s[j] = coef_s[j] / (j as f64 + 1) as T;\n        j += 1;\n    }\n    Polynomial::from_coef(coef_s)\n}",
      "pub fn integrate (&self) -> Polynomial<T> {\n    let mut coef: Vec<T> = Vec::new();\n    let degree: usize = self.degree();\n    for i in 0..degree\n    {\n        coef.push(self.coef[i] * (i as T + 1));\n    }\n    Polynomial::from_coef(coef)\n}",
      "pub fn integrate (&self) -> Polynomial<T> {\n    let mut coef: Vec<T> = Vec::new();\n    for i in 0..self.degree()\n    {\n        coef.push(self.coef[i] / (i as f64 + 1.0));\n    }\n    Polynomial::from_coef(coef)\n}",
      "pub fn integrate (&self) -> Polynomial<T> {\n    let mut coef: Vec<T> = Vec::new();\n    for i in 0..self.degree()\n    {\n        coef.push(self.coef[i] * (i as f64 + 1.0));\n    }\n    Polynomial::from_coef(coef)\n}"
    ],
    [
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    if self.elem_counts.contains_key(&val) {\n        self.elem_counts.insert(val, self.elem_counts[&val] + n);\n    } else {\n        self.elem_counts.insert(val, n);\n    }\n    self.size += n;\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    self.size += n;\n    *self.elem_counts.entry(val).or_insert(0) += n;\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    self.size += n;\n    *self.elem_counts.entry(val).or_insert(0) += n;\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    if n == 0 {\n        return;\n    }\n    if self.elem_counts.contains_key(&val) {\n        self.elem_counts.insert(val, self.elem_counts[&val] + n);\n    } else {\n        self.elem_counts.insert(val, n);\n    }\n    self.size += n;\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    if n == 0 {\n        return;\n    }\n    self.size += n;\n    *self.elem_counts.entry(val).or_insert(0) += n;\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    self.size += n;\n    self.elem_counts.insert(val, n);\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    if n == 0 {\n        return;\n    }\n    self.elem_counts.insert(val, n);\n    self.size += n;\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    self.elem_counts.insert(val, n);\n    self.size += n;\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    if n == 0 {\n        return;\n    }\n    self.size += n;\n    let count = self.elem_counts.entry(val).or_insert(0);\n    *count += n;\n}",
      "pub fn insert_times (&mut self, val: K, n: usize) {\n    if n == 0 {\n        return;\n    }\n    let count = self.elem_counts.entry(val).or_insert(0);\n    *count += n;\n    self.size += n;\n}"
    ],
    [
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    let count = self.elem_counts.get_mut(val).unwrap();\n    let mut removed = 0;\n    while *count > 0 && removed < times {\n        *count -= 1;\n        removed += 1;\n        self.size -= 1;\n    }\n    if *count == 0 {\n        self.elem_counts.remove(val);\n    }\n    removed\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    if let Some(count) = self.elem_counts.get_mut(val) {\n        let remove = if *count >= times {\n            times\n        } else {\n            *count\n        };\n        *count -= remove;\n        self.size -= remove;\n        remove\n    } else {\n        0\n    }\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    let mut count = 0;\n    if let Some(n) = self.elem_counts.get_mut(val) {\n        if *n >= times {\n            *n -= times;\n            count = times;\n        } else {\n            count = *n;\n            self.elem_counts.remove(val);\n        }\n    }\n    self.size -= count;\n    count\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    if let Some(count) = self.elem_counts.get_mut(val) {\n        if *count >= times {\n            *count -= times;\n            self.size -= times;\n            return times;\n        } else {\n            let removed = *count;\n            self.elem_counts.remove(val);\n            self.size -= removed;\n            return removed;\n        }\n    }\n    0\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    if let Some(count) = self.elem_counts.get_mut(val) {\n        let removed = if times > *count {\n            *count\n        } else {\n            times\n        };\n        *count -= removed;\n        self.size -= removed;\n        removed\n    } else {\n        0\n    }\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    let mut removed = 0;\n    if let Some(count) = self.elem_counts.get_mut(val) {\n        if *count >= times {\n            *count -= times;\n            removed = times;\n        } else {\n            removed = *count;\n            self.elem_counts.remove(val);\n        }\n        self.size -= removed;\n    }\n    removed\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    if let Some(count) = self.elem_counts.get_mut(val) {\n        let removed = *count.min(times);\n        *count -= removed;\n        self.size -= removed;\n        removed\n    } else {\n        0\n    }\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    if let Some(count) = self.elem_counts.get_mut(val) {\n        let to_remove = if times >= *count {\n            *count\n        } else {\n            times\n        };\n        *count -= to_remove;\n        self.size -= to_remove;\n        to_remove\n    } else {\n        0\n    }\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    if let Some(count) = self.elem_counts.get_mut(val) {\n        if *count >= times {\n            *count -= times;\n            self.size -= times;\n            return times;\n        } else {\n            let count = *count;\n            self.remove(val);\n            return count;\n        }\n    }\n    0\n}",
      "pub fn remove_times (&mut self, val: &K, times: usize) -> usize {\n    let mut removed = 0;\n    if let Some(count) = self.elem_counts.get_mut(val) {\n        if *count >= times {\n            removed = times;\n            *count -= times;\n        } else {\n            removed = *count;\n            self.elem_counts.remove(val);\n        }\n        self.size -= removed;\n    }\n    removed\n}"
    ],
    [
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut result = HashMultiSet::new();\n    for (key, count) in self.elem_counts.into_iter() {\n        result.insert_times(key, count);\n    }\n    for (key, count) in rhs.elem_counts.into_iter() {\n        result.insert_times(key, count);\n    }\n    result\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut combined = HashMultiSet::new();\n    for (key, count) in self.elem_counts.into_iter() {\n        combined.insert_times(key, count);\n    }\n    for (key, count) in rhs.elem_counts.into_iter() {\n        combined.insert_times(key, count);\n    }\n    combined\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut result = HashMultiSet::new();\n    for (key, count) in self.elem_counts {\n        result.insert_times(key, count);\n    }\n    for (key, count) in rhs.elem_counts {\n        result.insert_times(key, count);\n    }\n    result\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut combined = HashMultiSet::new();\n    for (k, v) in self.elem_counts {\n        combined.insert_times(k, v);\n    }\n    for (k, v) in rhs.elem_counts {\n        combined.insert_times(k, v);\n    }\n    combined\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut new_map = HashMap::new();\n    for (key, val) in self.elem_counts.into_iter() {\n        new_map.insert(key, val);\n    }\n    for (key, val) in rhs.elem_counts.into_iter() {\n        *new_map.entry(key).or_insert(0) += val;\n    }\n    HashMultiSet {\n        elem_counts: new_map,\n        size: self.size + rhs.size,\n    }\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut combined = HashMultiSet::new();\n    for (key, count) in self.elem_counts.into_iter() {\n        combined.insert_times(key, count);\n    }\n    for (key, count) in rhs.elem_counts.into_iter() {\n        combined.insert_times(key, count);\n    }\n    combined\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut new_set = HashMultiSet::new();\n    for (key, count) in self.elem_counts {\n        new_set.insert_times(key, count);\n    }\n    for (key, count) in rhs.elem_counts {\n        new_set.insert_times(key, count);\n    }\n    new_set\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut result = HashMultiSet::new();\n    for (key, count) in self.elem_counts {\n        result.insert_times(key, count);\n    }\n    for (key, count) in rhs.elem_counts {\n        result.insert_times(key, count);\n    }\n    result\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut new_set = HashMultiSet::new();\n    for elem in self.distinct_elements() {\n        new_set.insert_times(elem, self.count_of(&elem) + rhs.count_of(&elem));\n    }\n    new_set\n}",
      "fn add (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut result = HashMultiSet::new();\n    for (key, count) in self.elem_counts {\n        result.insert_times(key, count);\n    }\n    for (key, count) in rhs.elem_counts {\n        result.insert_times(key, count);\n    }\n    result\n}"
    ],
    [
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut result = HashMultiSet::new();\n    for (key, count) in self.elem_counts {\n        let rhs_count = rhs.elem_counts.get(&key).cloned().unwrap_or(0);\n        let new_count = count.saturating_sub(rhs_count);\n        if new_count > 0 {\n            result.insert_times(key, new_count);\n        }\n    }\n    result\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut result = HashMultiSet::new();\n    for (key, count) in self.elem_counts.into_iter() {\n        let mut new_count = count;\n        if let Some(rhs_count) = rhs.elem_counts.get(&key) {\n            new_count = count.saturating_sub(*rhs_count);\n        }\n        if new_count > 0 {\n            result.insert_times(key, new_count);\n        }\n    }\n    result\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut result = HashMultiSet::new();\n    for (key, count) in self.elem_counts.iter() {\n        let rhs_count = rhs.elem_counts.get(key).unwrap_or(&0);\n        if count > rhs_count {\n            result.insert_times(key.clone(), count - rhs_count);\n        }\n    }\n    result\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut result = HashMultiSet::new();\n    for (k, v) in self.elem_counts {\n        if let Some(rhs_count) = rhs.elem_counts.get(&k) {\n            result.insert_times(k, v - rhs_count);\n        } else {\n            result.insert_times(k, v);\n        }\n    }\n    result\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut result = HashMultiSet::new();\n    for (key, count) in self.elem_counts.iter() {\n        let rhs_count = rhs.elem_counts.get(key).unwrap_or(&0);\n        if *count > *rhs_count {\n            result.insert_times(key, *count - *rhs_count);\n        }\n    }\n    result\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut new_multiset = HashMultiSet::new();\n    for (key, count) in self.elem_counts {\n        if count > rhs.count_of(&key) {\n            new_multiset.insert_times(key, count - rhs.count_of(&key));\n        }\n    }\n    new_multiset\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut result = HashMultiSet::new();\n    for (key, count) in self.elem_counts {\n        if count > rhs.count_of(&key) {\n            result.insert_times(key, count - rhs.count_of(&key));\n        }\n    }\n    result\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut new_set = HashMultiSet::new();\n    for (key, count) in self.elem_counts.iter() {\n        let new_count = count - rhs.elem_counts.get(key).unwrap_or(&0);\n        if new_count > 0 {\n            new_set.insert_times(key, new_count);\n        }\n    }\n    new_set\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut new_set = HashMultiSet::new();\n    for (key, count) in self.elem_counts.iter() {\n        if count > rhs.elem_counts.get(key) {\n            new_set.insert_times(key, count - rhs.elem_counts.get(key).unwrap_or(&0));\n        }\n    }\n    new_set\n}",
      "fn sub (self, rhs: HashMultiSet<T>) -> HashMultiSet<T> {\n    let mut result = HashMultiSet::new();\n    for (key, count) in self.elem_counts.iter() {\n        let rhs_count = rhs.elem_counts.get(key).unwrap_or(&0);\n        if count > rhs_count {\n            result.insert_times(key, count - rhs_count);\n        }\n    }\n    result\n}"
    ],
    [
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(s) => Cow::Borrowed(RawStr(s)),\n        Cow::Owned(s) => Cow::Owned(RawStr(s)),\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(s) => Cow::Borrowed(RawStr(s)),\n        Cow::Owned(s) => Cow::Owned(RawStr(s)),\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    Cow::from(RawStr(cow.into_owned()))\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(s) => Cow::Borrowed(RawStr(s)),\n        Cow::Owned(s) => Cow::Owned(RawStr(s)),\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(s) => Cow::Borrowed(RawStr(s)),\n        Cow::Owned(s) => Cow::Owned(RawStr(s)),\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    Cow::Owned(RawStr(cow.into_owned()))\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    Cow::from(RawStr(cow.into_owned()))\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(s) => Cow::Borrowed(RawStr(s)),\n        Cow::Owned(s) => Cow::Owned(RawStr(s)),\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    match cow {\n        Cow::Borrowed(s) => Cow::Borrowed(RawStr(s)),\n        Cow::Owned(s) => Cow::Owned(RawStr(s)),\n    }\n}",
      "pub fn from_cow_str (cow: Cow<'_, str>) -> Cow<'_, RawStr> {\n    Cow::Owned(RawStr(cow.into_owned()))\n}"
    ],
    [
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let mut s = String::new();\n    for c in self.as_str().chars() {\n        match c {\n            '&' => s.push_str(\"&amp;\"),\n            '<' => s.push_str(\"&lt;\"),\n            '>' => s.push_str(\"&gt;\"),\n            '\"' => s.push_str(\"&quot;\"),\n            '\\'' => s.push_str(\"&#x27;\"),\n            '/' => s.push_str(\"&#x2F;\"),\n            '`' => s.push_str(\"&#x60;\"),\n            _ => s.push(c),\n        }\n    }\n    s.into()\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let mut bytes = Vec::new();\n    for c in self.as_str().chars() {\n        match c {\n            '&' => bytes.extend_from_slice(b\"&amp;\"),\n            '<' => bytes.extend_from_slice(b\"&lt;\"),\n            '>' => bytes.extend_from_slice(b\"&gt;\"),\n            '\"' => bytes.extend_from_slice(b\"&quot;\"),\n            '\\'' => bytes.extend_from_slice(b\"&#x27;\"),\n            '/' => bytes.extend_from_slice(b\"&#x2F;\"),\n            '`' => bytes.extend_from_slice(b\"&#x60;\"),\n            _ => bytes.push(c as u8),\n        }\n    }\n\n    String::from_utf8(bytes).into()\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let mut escaped = String::new();\n    for c in self.as_str().chars() {\n        match c {\n            '&' => escaped.push_str(\"&amp;\"),\n            '<' => escaped.push_str(\"&lt;\"),\n            '>' => escaped.push_str(\"&gt;\"),\n            '\"' => escaped.push_str(\"&quot;\"),\n            '\\'' => escaped.push_str(\"&#x27;\"),\n            '/' => escaped.push_str(\"&#x2F;\"),\n            '`' => escaped.push_str(\"&#x60;\"),\n            _ => escaped.push(c),\n        }\n    }\n\n    escaped.into()\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let mut escaped = String::new();\n    for c in self.as_str().chars() {\n        match c {\n            '&' => escaped.push_str(\"&amp;\"),\n            '<' => escaped.push_str(\"&lt;\"),\n            '>' => escaped.push_str(\"&gt;\"),\n            '\"' => escaped.push_str(\"&quot;\"),\n            '\\'' => escaped.push_str(\"&#x27;\"),\n            '/' => escaped.push_str(\"&#x2F;\"),\n            '`' => escaped.push_str(\"&#x60;\"),\n            _ => escaped.push(c),\n        }\n    }\n    escaped.into()\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let mut out = String::with_capacity(self.len());\n    for c in self.as_str().chars() {\n        match c {\n            '<' => out.push_str(\"&lt;\"),\n            '>' => out.push_str(\"&gt;\"),\n            '\"' => out.push_str(\"&quot;\"),\n            '\\'' => out.push_str(\"&#x27;\"),\n            '`' => out.push_str(\"&#x60;\"),\n            '&' => out.push_str(\"&amp;\"),\n            '\\\\' => out.push_str(\"&#x5C;\"),\n            '/' => out.push_str(\"&#x2F;\"),\n            _ => out.push(c),\n        }\n    }\n    out.into()\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let mut result = String::new();\n    for c in self.as_str().chars() {\n        match c {\n            '&' => result.push_str(\"&amp;\"),\n            '<' => result.push_str(\"&lt;\"),\n            '>' => result.push_str(\"&gt;\"),\n            '\"' => result.push_str(\"&quot;\"),\n            '\\'' => result.push_str(\"&#x27;\"),\n            '/' => result.push_str(\"&#x2F;\"),\n            '`' => result.push_str(\"&#x60;\"),\n            _ => result.push(c),\n        }\n    }\n    result.into()\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let mut bytes = self.as_bytes().to_vec();\n    let mut i = 0;\n    while i < bytes.len() {\n        match bytes[i] {\n            b'&' => {\n                bytes.splice(i..i+1, \"&amp;\".bytes());\n                i += 4;\n            }\n            b'<' => {\n                bytes.splice(i..i+1, \"&lt;\".bytes());\n                i += 3;\n            }\n            b'>' => {\n                bytes.splice(i..i+1, \"&gt;\".bytes());\n                i += 3;\n            }\n            b'\"' => {\n                bytes.splice(i..i+1, \"&quot;\".bytes());\n                i += 5;\n            }\n            b'\\'' => {\n                bytes.splice(i..i+1, \"&#x27;\".bytes());\n                i += 5;\n            }\n            b'/' => {\n                bytes.splice(i..i+1, \"&#x2F;\".bytes());\n                i += 4;\n            }\n            b'`' => {\n                bytes.splice(i..i+1, \"&#x60;\".bytes());\n                i += 4;\n            }\n            _ => i += 1,\n        }\n    }\n\n    String::from_utf8(bytes).unwrap().into()\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let mut out = String::with_capacity(self.len());\n    for c in self.as_str().chars() {\n        match c {\n            '&' => out.push_str(\"&amp;\"),\n            '<' => out.push_str(\"&lt;\"),\n            '>' => out.push_str(\"&gt;\"),\n            '\"' => out.push_str(\"&quot;\"),\n            '\\'' => out.push_str(\"&#x27;\"),\n            '/' => out.push_str(\"&#x2F;\"),\n            '`' => out.push_str(\"&#x60;\"),\n            _ => out.push(c),\n        }\n    }\n    out.into()\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let mut bytes = self.as_bytes().to_vec();\n    let mut pos = 0;\n    while pos < bytes.len() {\n        let byte = bytes[pos];\n        match byte {\n            b'&' => {\n                bytes.splice(pos..pos+1, \"&amp;\".bytes());\n                pos += 4;\n            }\n            b'<' => {\n                bytes.splice(pos..pos+1, \"&lt;\".bytes());\n                pos += 4;\n            }\n            b'>' => {\n                bytes.splice(pos..pos+1, \"&gt;\".bytes());\n                pos += 4;\n            }\n            b'\"' => {\n                bytes.splice(pos..pos+1, \"&quot;\".bytes());\n                pos += 6;\n            }\n            b'\\'' => {\n                bytes.splice(pos..pos+1, \"&#x27;\".bytes());\n                pos += 6;\n            }\n            b'/' => {\n                bytes.splice(pos..pos+1, \"&#x2F;\".bytes());\n                pos += 6;\n            }\n            b'`' => {\n                bytes.splice(pos..pos+1, \"&#x60;\".bytes());\n                pos += 6;\n            }\n            _ => pos += 1,\n        }\n    }\n    unsafe { String::from_utf8_unchecked(bytes) }.into()\n}",
      "pub fn html_escape (&self) -> Cow<'_, str> {\n    let mut escaped = String::new();\n    for c in self.as_str().chars() {\n        match c {\n            '&' => escaped.push_str(\"&amp;\"),\n            '<' => escaped.push_str(\"&lt;\"),\n            '>' => escaped.push_str(\"&gt;\"),\n            '\"' => escaped.push_str(\"&quot;\"),\n            '\\'' => escaped.push_str(\"&#x27;\"),\n            '/' => escaped.push_str(\"&#x2F;\"),\n            '`' => escaped.push_str(\"&#x60;\"),\n            _ => escaped.push(c),\n        }\n    }\n    escaped.into()\n}"
    ],
    [
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let bytes = self.as_bytes();\n    let mut i = 0;\n    while i < bytes.len() {\n        if bytes[i] == b {\n            return (self.slice(0, i), self.slice(i + 1, self.len()));\n        }\n        i += 1;\n    }\n    (self, RawStr::new(\"\"))\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let mut iter = self.as_str().bytes();\n    let mut before = 0;\n    while let Some(c) = iter.next() {\n        if c == b {\n            break;\n        }\n        before += 1;\n    }\n    let after = self.as_str().len() - before;\n    (&self[..before], &self[before..])\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let mut i = 0;\n    while i < self.as_bytes().len() {\n        if self.as_bytes()[i] == b {\n            return (&self[..i], &self[i+1..]);\n        }\n        i += 1;\n    }\n    (self, &self[0..0])\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let bytes = self.as_bytes();\n    let mut i = 0;\n    while i < bytes.len() {\n        if bytes[i] == b {\n            break;\n        }\n        i += 1;\n    }\n    let (before, after) = bytes.split_at(i);\n    (RawStr::new(before), RawStr::new(after))\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let bytes = self.as_bytes();\n    let mut i = 0;\n    while i < bytes.len() && bytes[i] != b {\n        i += 1;\n    }\n    (self.get_unchecked(..i), self.get_unchecked(i..))\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let mut iter = self.as_str().bytes();\n    let mut before = String::new();\n    let mut after = String::new();\n    let mut found = false;\n    while let Some(byte) = iter.next() {\n        if byte == b {\n            found = true;\n            break;\n        }\n        before.push(byte as char);\n    }\n    if found {\n        after = iter.as_str().to_string();\n    }\n    (RawStr::new(&before), RawStr::new(&after))\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let bytes = self.as_bytes();\n    let mut i = 0;\n    while i < bytes.len() {\n        if bytes[i] == b {\n            return (self.slice(0, i), self.slice(i + 1, self.len()));\n        }\n        i += 1;\n    }\n    (self, RawStr::new(\"\"))\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let mut i = 0;\n    while i < self.as_bytes().len() && self.as_bytes()[i] != b {\n        i += 1;\n    }\n    let before = &self[..i];\n    let after = &self[i..];\n    (before, after)\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let mut iter = self.as_str().as_bytes().iter();\n    let mut i = 0;\n    let mut found = false;\n    while let Some(byte) = iter.next() {\n        if *byte == b {\n            found = true;\n            break;\n        }\n        i += 1;\n    }\n    if found {\n        let before = RawStr::new(&self.as_str()[..i]);\n        let after = RawStr::new(&self.as_str()[i+1..]);\n        (&before, &after)\n    } else {\n        (&self, &RawStr::new(\"\"))\n    }\n}",
      "pub fn split_at_byte (&self, b: u8) -> (&RawStr, &RawStr) {\n    let bytes = self.as_bytes();\n    let mut i = 0;\n    while i < bytes.len() {\n        if bytes[i] == b {\n            break;\n        }\n        i += 1;\n    }\n    (&self[..i], &self[i..])\n}"
    ],
    [
      "pub fn supports_payload (self) -> bool {\nmatch self {\nMethod::Get | Method::Head | Method::Connect | Method::Trace | Method::Options => false,\n_ => true,\n}\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Put | Method::Post | Method::Delete | Method::Patch => true,\n        _ => false,\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Get => false,\n        Method::Head => false,\n        Method::Connect => false,\n        Method::Trace => false,\n        Method::Options => false,\n        Method::Put => true,\n        Method::Post => true,\n        Method::Delete => true,\n        Method::Patch => true,\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Get => false,\n        Method::Head => false,\n        Method::Connect => false,\n        Method::Trace => false,\n        Method::Options => false,\n        Method::Put => true,\n        Method::Post => true,\n        Method::Delete => true,\n        Method::Patch => true,\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Get => false,\n        Method::Head => false,\n        Method::Connect => false,\n        Method::Trace => false,\n        Method::Options => false,\n        Method::Put => true,\n        Method::Post => true,\n        Method::Delete => true,\n        Method::Patch => true,\n    }\n}",
      "pub fn supports_payload (self) -> bool {\nmatch self {\nMethod::Put | Method::Post | Method::Delete | Method::Patch => true,\n_ => false,\n}\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Put | Method::Post | Method::Delete | Method::Patch => true,\n        _ => false\n    }\n}",
      "pub fn supports_payload (self) -> bool {\nmatch self {\nMethod::Put | Method::Post | Method::Delete | Method::Patch => true,\n_ => false,\n}\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Put | Method::Post | Method::Delete | Method::Patch => true,\n        _ => false,\n    }\n}",
      "pub fn supports_payload (self) -> bool {\n    match self {\n        Method::Put | Method::Post | Method::Delete | Method::Patch => true,\n        _ => false,\n    }\n}"
    ],
    [
      "pub const fn is_valid_name (name: &str) -> bool {\n    if name.is_empty() {\n        return false;\n    }\n\n    for c in name.chars() {\n        if c.is_ascii_whitespace() || c == ',' || c == ':' {\n            return false;\n        }\n    }\n\n    true\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    name.chars().all(|c| {\n        match c {\n            '!' | '#' | '$' | '%' | '&' | '\\'' | '*' | '+' | '-' | '.' | '^' | '_' | '`' | '|' | '~' |\n            '0' ... '9' | 'A' ... 'Z' | 'a' ... 'z' => true,\n            _ => false\n        }\n    })\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    !name.is_empty() && name.chars().all(|c| c.is_ascii_alphanumeric() || c == '-' || c == '_' || c == '~')\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    if name.is_empty() {\n        return false;\n    }\n    let mut iter = name.chars();\n    let first = iter.next().unwrap();\n    if !first.is_ascii_alphanumeric() {\n        return false;\n    }\n    for c in iter {\n        if !c.is_ascii_alphanumeric() && !c.is_ascii_punctuation() {\n            return false;\n        }\n    }\n    true\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    name.chars().all(|c| c.is_ascii_alphanumeric() || c == '-' || c == '_' || c == '~')\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    if name.is_empty() {\n        return false;\n    }\n\n    for c in name.chars() {\n        if c.is_ascii_alphanumeric() || c == '!' || c == '#' || c == '$' || c == '%' || c == '&' || c == '\\'' || c == '*' || c == '+' || c == '-' || c == '.' || c == '^' || c == '_' || c == '`' || c == '|' || c == '~' {\n            continue;\n        }\n\n        return false;\n    }\n\n    true\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    name.chars().all(|c| c.is_ascii_alphanumeric() || c == '-' || c == '_' || c == '~')\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    name.chars().all(|c| c.is_ascii_alphanumeric() || c == '_' || c == '-' || c == '!')\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    name.bytes().all(|b| {\n        matches!(b,\n            b'!' | b'#' | b'$' | b'%' | b'&' | b'\\'' | b'*' | b'+' | b'-' | b'.' | b'^' | b'_' | b'`' | b'|' | b'~' | b'0'..=b'9' | b'a'..=b'z' | b'A'..=b'Z'\n        )\n    })\n}",
      "pub const fn is_valid_name (name: &str) -> bool {\n    name.chars().all(|c| {\n        match c {\n            '!' | '#' | '$' | '%' | '&' | '\\'' | '*' | '+' | '-' | '.' | '^' | '_' | '`' | '|' | '~' |\n            '0' ... '9' | 'A' ... 'Z' | 'a' ... 'z' => true,\n            _ => false\n        }\n    })\n}"
    ],
    [
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    let name = name.into();\n    let entry = self.entry(name);\n    let mut vec = entry.or_insert(Vec::new());\n    vec.append(values);\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    let name = name.into();\n    let index = self.headers.get_index_of(&name);\n    if let Some(index) = index {\n        let values = mem::take(values);\n        self.headers.get_mut(index).unwrap().extend(values);\n    } else {\n        self.headers.insert(name, mem::take(values));\n    }\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    let name = name.into();\n    let mut index = self.headers.get_index_of(&name);\n    if let Some(index) = index {\n        self.headers.get_mut(index).unwrap().append(values);\n    } else {\n        index = self.headers.len();\n        self.headers.insert(name, values);\n    }\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    let name = name.into();\n    let values = mem::take(values);\n    self.headers.insert(name, values);\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    let name = name.into();\n    let mut i = 0;\n    while i < values.len() {\n        if let Some(v) = values.get(i) {\n            self.add(Header::new(name.clone(), v.clone()));\n            i += 1;\n        } else {\n            values.remove(i);\n        }\n    }\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    let name = name.into();\n    let index = self.headers.get_index_of(&name);\n    if let Some(index) = index {\n        let values = mem::replace(values, Vec::new());\n        self.headers.get_mut(index).unwrap().extend(values);\n    } else {\n        self.headers.insert(name, mem::replace(values, Vec::new()));\n    }\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    let name = name.into();\n    if let Some(headers) = self.headers.get_mut(&name) {\n        headers.append(values);\n    } else {\n        self.headers.insert(name, values.drain(..).collect());\n    }\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    let name = name.into();\n    if let Some(values) = self.headers.get_mut(&name) {\n        values.append(values);\n    } else {\n        self.headers.insert(name, values.clone());\n    }\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    let name = name.into();\n    let index = self.core.find_index(&name);\n    let index = match index {\n        Some(index) => index,\n        None => self.core.insert_full(name, Vec::new()).0,\n    };\n    self.core.get_index_mut(index).unwrap().1.append(values);\n}",
      "pub fn add_all <'n, H> (&mut self, name: H, values: &mut Vec<Cow<'h, str>>) where 'n:'h, H: Into<Cow<'n, str>> {\n    let name = name.into();\n    let mut values = mem::take(values);\n    let entry = self.entry(name);\n    if let Some(values) = entry.get_mut() {\n        values.append(&mut values);\n    } else {\n        entry.insert(values);\n    }\n}"
    ],
    [
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(authority) => Some(authority),\n        _ => None,\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(a) => Some(a),\n        _ => None,\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(authority) => Some(authority),\n        _ => None,\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(authority) => Some(authority),\n        _ => None,\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(authority) => Some(authority),\n        _ => None,\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(authority) => Some(authority),\n        _ => None,\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(authority) => Some(authority),\n        _ => None,\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(authority) => Some(authority),\n        _ => None,\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(authority) => Some(authority),\n        _ => None,\n    }\n}",
      "pub fn authority (&self) -> Option<&Authority<'a>> {\n    match self {\n        Uri::Authority(authority) => Some(authority),\n        _ => None,\n    }\n}"
    ],
    [
      "pub fn len (&self) -> usize {\n    self.segments.len()\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len()\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len()\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len()\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len()\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len() - self.pos\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len()\n}",
      "pub fn len (&self) -> usize {\n    self.segments.len()\n}"
    ],
    [
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}",
      "pub fn skip (mut self, n: usize) -> Self {\n    self.pos += n;\n    self\n}"
    ],
    [
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    if n < self.segments.len() {\n        let (k, v) = self.segments[n];\n        Some((k, v))\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    if n >= self.segments.len() {\n        return None;\n    }\n\n    let segment = &self.segments[n];\n    let (key, value) = segment.split_at_byte(b'=');\n    Some((key.as_str(), value.as_str()))\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    let mut pos = self.pos;\n    for (i, segment) in self.segments.iter().enumerate() {\n        if i == n {\n            let (key, value) = segment.split_at_byte(b'=');\n            return Some((key.as_str(), value.as_str()));\n        }\n\n        pos += segment.len() + 1;\n    }\n\n    None\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    if n >= self.segments.len() {\n        return None;\n    }\n\n    let segment = &self.segments[n];\n    let mut key = \"\";\n    let mut value = \"\";\n    let mut key_start = 0;\n    let mut value_start = 0;\n\n    for (i, b) in segment.iter().enumerate() {\n        if *b == b'=' {\n            key = &segment[key_start..i];\n            value_start = i + 1;\n        }\n    }\n\n    if value_start > 0 {\n        value = &segment[value_start..];\n    } else {\n        value = &segment[key_start..];\n    }\n\n    Some((key, value))\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    let mut segments = self.segments.iter();\n    let mut i = 0;\n    while let Some(segment) = segments.next() {\n        if i == n {\n            return Some((segment.0, segment.1));\n        }\n        i += 1;\n    }\n    None\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    if n >= self.segments.len() {\n        return None;\n    }\n\n    let segment = &self.segments[n];\n    let key = &self.source[segment.key.start..segment.key.end];\n    let value = &self.source[segment.value.start..segment.value.end];\n    Some((key, value))\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    if n >= self.segments.len() {\n        return None;\n    }\n\n    let segment = &self.segments[n];\n    let mut iter = segment.splitn(2, '=');\n    let key = iter.next().unwrap();\n    let value = iter.next().unwrap_or(\"\");\n    Some((key, value))\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    let segments = self.segments();\n    if n >= segments.len() {\n        return None;\n    }\n\n    let mut i = 0;\n    for segment in segments {\n        if i == n {\n            return Some((segment.0, segment.1));\n        }\n        i += 1;\n    }\n\n    None\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    let mut pos = self.pos;\n    let mut i = 0;\n    while i < n && pos < self.segments.len() {\n        let segment = &self.segments[pos];\n        if segment.is_empty() {\n            pos += 1;\n            continue;\n        }\n\n        let (key, value) = segment.split_at_byte(b'=');\n        if key.is_empty() {\n            pos += 1;\n            continue;\n        }\n\n        i += 1;\n        pos += 1;\n    }\n\n    if i != n {\n        return None;\n    }\n\n    let segment = &self.segments[pos];\n    let (key, value) = segment.split_at_byte(b'=');\n    Some((key.as_str(), value.as_str()))\n}",
      "pub fn get (&self, n: usize) -> Option<(&'a str, &'a str)> {\n    if n >= self.segments.len() {\n        return None;\n    }\n\n    let segment = &self.segments[n];\n    let (key, value) = segment.split_at_byte(b'=');\n    let key = key.as_str();\n    let value = value.as_str();\n\n    Some((key, value))\n}"
    ],
    [
      "pub fn is_normalized (&self) -> bool {\n    self.scheme.is_indexed() && self.authority.is_none() && self.path.is_indexed() && self.query.is_none()\n}",
      "pub fn is_normalized (&self) -> bool {\n    // TODO: implement this\n    true\n}",
      "pub fn is_normalized (&self) -> bool {\n    // TODO: implement this.\n    unimplemented!();\n}",
      "pub fn is_normalized (&self) -> bool {\n    // 1. The scheme is normalized.\n    // 2. The authority is normalized.\n    // 3. The path is normalized.\n    // 4. The query is normalized.\n    // 5. The fragment is normalized.\n    true\n}",
      "pub fn is_normalized (&self) -> bool {\n    // TODO: implement this method.\n}",
      "pub fn is_normalized (&self) -> bool {\n    self.scheme.is_indexed() && self.path.is_indexed() && self.query.is_indexed()\n}",
      "pub fn is_normalized (&self) -> bool {\n    self.scheme.is_indexed() &&\n    self.authority.as_ref().map_or(true, |a| a.is_normalized()) &&\n    self.path.is_normalized() &&\n    self.query.as_ref().map_or(true, |q| q.is_normalized())\n}",
      "pub fn is_normalized (&self) -> bool {\n    // If there is no query, then the URI is normalized.\n    if self.query.is_none() {\n        return true;\n    }\n\n    // If there is a query, then it must be normalized.\n    self.query.as_ref().unwrap().is_normalized()\n}",
      "pub fn is_normalized (&self) -> bool {\n    self.scheme.is_indexed() && self.path.is_indexed() && self.query.is_indexed()\n}",
      "pub fn is_normalized (&self) -> bool {\n    // The following code is commented out because it is not\n    // clear how to implement it.\n    //\n    // let scheme = self.scheme();\n    // let authority = self.authority();\n    // let path = self.path();\n    // let query = self.query();\n    //\n    // if scheme.is_empty() {\n    //     return false;\n    // }\n    //\n    // if authority.is_some() {\n    //     if authority.unwrap().user_info().is_some() {\n    //         return false;\n    //     }\n    //\n    //     if authority.unwrap().host().is_empty() {\n    //         return false;\n    //     }\n    // }\n    //\n    // if path.is_empty() {\n    //     return false;\n    // }\n    //\n    // if query.is_some() {\n    //     if query.unwrap().is_empty() {\n    //         return false;\n    //     }\n    // }\n    //\n    // true\n}"
    ],
    [
      "pub fn top_left (&self) -> Point {\n    Point::new(self.x(), self.y())\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.x(), self.y())\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.x(), self.y())\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.x(), self.y())\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.left(), self.top())\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.left(), self.top())\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.left(), self.top())\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.x(), self.y())\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.left(), self.top())\n}",
      "pub fn top_left (&self) -> Point {\n    Point::new(self.x(), self.y())\n}"
    ],
    [
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.y())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.x() + self.width(), self.y())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.top())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.y())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.x() + self.width() as i32, self.y())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.y())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.x() + self.width() as i32, self.y())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.x() + self.width(), self.y())\n}",
      "pub fn top_right (&self) -> Point {\n    Point::new(self.right(), self.y())\n}"
    ],
    [
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nself.left() <= x && x < self.right() && self.top() <= y && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nx >= self.left() && x < self.right() && y >= self.top() && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\n    let (x, y) = point.into();\n    self.left() <= x && x < self.right() && self.top() <= y && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nx >= self.left() && x < self.right() && y >= self.top() && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nself.left() <= x && x < self.right() && self.top() <= y && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nx >= self.x() && x < self.right() && y >= self.y() && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nself.left() <= x && x < self.right() && self.top() <= y && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nself.left() <= x && x < self.right() && self.top() <= y && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nself.left() <= x && x < self.right() && self.top() <= y && y < self.bottom()\n}",
      "pub fn contains_point <P> (&self, point: P) -> bool where\nP: Into<(i32, i32)>, {\nlet (x, y) = point.into();\nx >= self.left() && x < self.right() && y >= self.top() && y < self.bottom()\n}"
    ],
    [
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    let left = self.left();\n    let right = self.right();\n    let top = self.top();\n    let bottom = self.bottom();\n    let other_left = other.left();\n    let other_right = other.right();\n    let other_top = other.top();\n    let other_bottom = other.bottom();\n    left <= other_left && right >= other_right && top <= other_top && bottom >= other_bottom\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    self.left() <= other.left() && self.right() >= other.right() &&\n    self.top() <= other.top() && self.bottom() >= other.bottom()\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    self.left() <= other.left() && self.right() >= other.right() &&\n    self.top() <= other.top() && self.bottom() >= other.bottom()\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    let (x, y) = (self.x(), self.y());\n    let (w, h) = (self.width(), self.height());\n    let (ox, oy) = (other.x(), other.y());\n    let (ow, oh) = (other.width(), other.height());\n    x <= ox && y <= oy && x + w >= ox + ow && y + h >= oy + oh\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    self.left() <= other.left() && self.right() >= other.right() &&\n    self.top() <= other.top() && self.bottom() >= other.bottom()\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    let self_rect = self.raw();\n    let other_rect = other.raw();\n    unsafe {\n        sys::SDL_HasIntersection(self_rect, other_rect) == sys::SDL_bool::SDL_TRUE\n    }\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    let left = self.left();\n    let right = self.right();\n    let top = self.top();\n    let bottom = self.bottom();\n    let other_left = other.left();\n    let other_right = other.right();\n    let other_top = other.top();\n    let other_bottom = other.bottom();\n    left <= other_left && other_left <= right &&\n    top <= other_top && other_top <= bottom &&\n    left <= other_right && other_right <= right &&\n    top <= other_bottom && other_bottom <= bottom\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    let (x, y) = other.top_left();\n    let (w, h) = other.size();\n    self.left() <= x && self.right() >= x + w as i32 &&\n    self.top() <= y && self.bottom() >= y + h as i32\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    let self_rect = self.raw();\n    let other_rect = other.raw();\n    unsafe {\n        let ret = sys::SDL_RectEmpty(self_rect) == 0\n            && sys::SDL_RectEmpty(other_rect) == 0\n            && sys::SDL_RectEquals(self_rect, other_rect) != 0;\n        if ret {\n            sys::SDL_FreeSurface(self_rect);\n            sys::SDL_FreeSurface(other_rect);\n        }\n        ret\n    }\n}",
      "pub fn contains_rect (&self, other: Rect) -> bool {\n    let r = self.raw();\n    let o = other.raw();\n    r.x <= o.x && r.x + r.w >= o.x + o.w && r.y <= o.y && r.y + r.h >= o.y + o.h\n}"
    ],
    [
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\nlet mut curr_idx = self.tree.root;\nlet mut cmp = Ordering::Equal;\nwhile curr_idx != NodeIndex::new(0) {\nlet node = &self.tree.nodes[curr_idx];\ncmp = value.borrow().cmp(node.key.borrow());\nif cmp == Ordering::Equal {\nreturn Some(&node.value);\n}\ncurr_idx = if cmp == Ordering::Less {\nnode.lft\n} else {\nnode.rgt\n};\n}\nNone\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.get(value)\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\nlet tree = &mut self.tree;\nlet mut curr_idx = tree.root;\nlet mut cmp = Ordering::Equal;\nwhile curr_idx != NodeIndex::NULL {\nlet curr_node = &tree.nodes[curr_idx];\ncmp = value.borrow().cmp(curr_node.key.borrow());\nif cmp == Ordering::Equal {\nreturn Some(curr_node.value);\n}\ncurr_idx = if cmp == Ordering::Less {\ntree.nodes[curr_idx].left\n} else {\ntree.nodes[curr_idx].right\n};\n}\nNone\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\nlet root = self.tree.root();\nif let Some(root) = root {\nlet (node, ord) = self.tree.splay(root, value);\nif ord == Ordering::Equal {\nreturn Some(&self.tree.node_ref(node).value);\n}\n}\nNone\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\nlet mut curr_idx = self.tree.root;\nwhile let Some(node) = self.tree.node_ref(curr_idx) {\nmatch value.cmp(node.key.borrow()) {\nOrdering::Equal => return Some(node.key),\nOrdering::Less => {\nif node.lft.is_some() {\ncurr_idx = node.lft.unwrap();\n} else {\nreturn None;\n}\n}\nOrdering::Greater => {\nif node.rgt.is_some() {\ncurr_idx = node.rgt.unwrap();\n} else {\nreturn None;\n}\n}\n}\n}\nNone\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\nlet (_, idx) = self.tree.find_lower_bound(value);\nif let Some(idx) = idx {\nreturn Some(&self.tree.nodes[idx].key);\n}\nNone\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\nlet root = self.tree.root();\nif root.is_none() {\nreturn None;\n}\nlet (root, ordering) = self.tree.splay(root.unwrap(), value);\nif ordering == Ordering::Equal {\nreturn Some(&self.tree.node_ref(root).value);\n}\nNone\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\nlet root = self.tree.root;\nif root == NodeIndex::INVALID {\nreturn None;\n}\nlet (_, order) = self.tree.splay(root, value);\nif order == Ordering::Equal {\nreturn Some(&self.tree.nodes[root].value);\n}\nNone\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\nlet root = self.tree.root;\nif root == NodeIndex::end() {\nreturn None;\n}\nlet (_, ordering) = self.tree.splay(root, value);\nif ordering == Ordering::Equal {\nreturn Some(&self.tree.node_ref(root).value);\n}\nNone\n}",
      "pub fn get <Q: ?Sized> (&mut self, value: &Q) -> Option<&T> where\nT: Borrow<Q>,\nQ: Ord, {\nlet mut curr_idx = self.tree.root;\nwhile curr_idx != NodeIndex::null() {\nlet node = &self.tree.nodes[curr_idx];\nmatch value.cmp(node.key.borrow()) {\nOrdering::Equal => return Some(&node.value),\nOrdering::Less => curr_idx = node.lft,\nOrdering::Greater => curr_idx = node.rgt,\n}\n}\nNone\n}"
    ],
    [
      "pub fn smallest (&mut self) -> Option<&T> {\n    let mut node = self.tree.root();\n    while let Some(child) = self.tree.node_ref(node).left_child() {\n        node = child;\n    }\n    self.tree.node_ref(node).value()\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.get_lftmost()\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    if self.tree.len() == 0 {\n        return None;\n    }\n    let root = self.tree.root();\n    if root.is_none() {\n        return None;\n    }\n    let root = root.unwrap();\n    let root = self.tree.node_ref(root);\n    Some(&root.key)\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    let mut node = self.tree.root();\n    while let Some(child) = self.tree.node_ref(node).lft {\n        node = child;\n    }\n    self.tree.node_ref(node).val.as_ref()\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    let mut curr_idx = self.tree.root;\n    while curr_idx != NodeIndex::end() {\n        let node = &self.tree.nodes[curr_idx];\n        if node.lft == NodeIndex::end() {\n            return Some(&node.key);\n        }\n        curr_idx = node.lft;\n    }\n    None\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.root().map(|root| self.tree.node_ref(root).key)\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    if self.tree.len() == 0 {\n        return None;\n    }\n    let mut curr_idx = self.tree.root().unwrap();\n    while self.tree.node_ref(curr_idx).left_child.is_some() {\n        curr_idx = self.tree.node_ref(curr_idx).left_child.unwrap();\n    }\n    Some(&self.tree.node_ref(curr_idx).key)\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    if self.tree.len() == 0 {\n        return None;\n    }\n    let root = self.tree.root();\n    let (_, ord) = self.tree.splay_lftmost(root);\n    if ord == Ordering::Less {\n        return None;\n    }\n    Some(&self.tree.node_ref(root).key)\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(k, _)| k)\n}",
      "pub fn smallest (&mut self) -> Option<&T> {\n    let root = self.tree.root();\n    if root.is_none() {\n        return None;\n    }\n    let root = root.unwrap();\n    let root = self.tree.node_mut(root);\n    if root.left.is_none() {\n        return Some(&root.key);\n    }\n    let mut curr = root.left.unwrap();\n    loop {\n        let curr = self.tree.node_mut(curr);\n        if curr.left.is_none() {\n            return Some(&curr.key);\n        }\n        curr = curr.left.unwrap();\n    }\n}"
    ],
    [
      "pub fn smallest_immut (&self) -> Option<&T> {\n    let mut curr = self.tree.root();\n    while let Some(left) = self.tree.node_ref(curr).left() {\n        curr = left;\n    }\n    self.tree.node_ref(curr).value()\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    let root = self.tree.root();\n    if root.is_none() {\n        return None;\n    }\n    let root = root.unwrap();\n    let root = self.tree.node_ref(root);\n    if root.is_empty() {\n        return None;\n    }\n    Some(&root.key)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    let mut curr = self.tree.root;\n    while let Some(left) = self.tree.nodes[curr].left {\n        curr = left;\n    }\n    Some(&self.tree.nodes[curr].key)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.root_ref().and_then(|node| {\n        let mut curr_idx = node.left;\n        while curr_idx != 0 {\n            curr_idx = self.tree.node_ref(curr_idx).unwrap().left;\n        }\n        self.tree.node_ref(curr_idx).map(|node| &node.key)\n    })\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    let mut node = self.tree.root();\n    while let Some(child) = self.tree.node_ref(node).left_child() {\n        node = child;\n    }\n    self.tree.node_ref(node).value()\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    let root = self.tree.root();\n    if root.is_none() {\n        return None;\n    }\n    let root = root.unwrap();\n    let root = self.tree.node_ref(root);\n    if root.left.is_none() {\n        return Some(&root.key);\n    }\n    let mut curr = root.left.unwrap();\n    while self.tree.node_ref(curr).left.is_some() {\n        curr = self.tree.node_ref(curr).left.unwrap();\n    }\n    Some(&self.tree.node_ref(curr).key)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(k, _)| k)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.get_lftmost_immut().map(|(k, _)| k)\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.root_ref().and_then(|node| {\n        node.lft_most_child().map(|node| &node.key)\n    })\n}",
      "pub fn smallest_immut (&self) -> Option<&T> {\n    self.tree.root_ref().and_then(|node| node.lftmost_ref().map(|node| &node.key))\n}"
    ],
    [
      "pub fn take_largest (&mut self) -> Option<T> {\n    let mut curr_idx = self.tree.root;\n    if curr_idx == NodeIndex::end() {\n        return None;\n    }\n    let mut curr_node = self.tree.node_mut(curr_idx);\n    loop {\n        if curr_node.rgt == NodeIndex::end() {\n            break;\n        }\n        curr_idx = curr_node.rgt;\n        curr_node = self.tree.node_mut(curr_idx);\n    }\n    let ret = self.tree.take_root();\n    if ret.is_none() {\n        return None;\n    }\n    let (key, _) = ret.unwrap();\n    self.tree.splay_lftmost(curr_idx);\n    return Some(key);\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.pop_rgtmost().map(|(k, _)| k)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(k, _)| k)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    let mut curr_idx = self.tree.root();\n    if curr_idx.is_none() {\n        return None;\n    }\n    let mut curr_idx = curr_idx.unwrap();\n    let mut prev_idx = self.tree.root();\n    let mut prev_idx = prev_idx.unwrap();\n    let mut cmp = Ordering::Less;\n    while cmp == Ordering::Less {\n        let (next_idx, next_cmp) = self.tree.splay_rgtmost(curr_idx);\n        prev_idx = curr_idx;\n        curr_idx = next_idx;\n        cmp = next_cmp;\n    }\n    let node = self.tree.node_mut(curr_idx);\n    let value = node.value.take();\n    if value.is_none() {\n        return None;\n    }\n    let value = value.unwrap();\n    if prev_idx == curr_idx {\n        self.tree.root = None;\n    } else {\n        let prev_node = self.tree.node_mut(prev_idx);\n        prev_node.right = None;\n    }\n    self.tree.nodes.pop();\n    return Some(value);\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(k, _)| k)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.pop_rgtmost().map(|(k, _)| k)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.pop_rgtmost().map(|(k, _)| k)\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    let root = self.tree.root;\n    let last = self.tree.pop_last();\n    if let Some((k, v)) = last {\n        self.tree.push_root(Node::new_leaf(k, v));\n        Some(v)\n    } else {\n        None\n    }\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    let largest = self.largest();\n    match largest {\n        Some(x) => {\n            self.remove(x);\n            Some(x.clone())\n        }\n        None => None\n    }\n}",
      "pub fn take_largest (&mut self) -> Option<T> {\n    self.tree.take_rgtmost().map(|(k, _)| k)\n}"
    ],
    [
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\nlet mut iter = self.tree.iter_mut();\nlet mut curr = self.tree.root;\nwhile let Some(node) = iter.next(curr) {\nif value <= node.key.borrow() {\ncurr = node.lft;\n} else {\ncurr = node.rgt;\n}\n}\nif let Some(node) = iter.node_mut(curr) {\nif value == node.key.borrow() {\nreturn Some(node.val);\n}\n}\nNone\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.remove(value)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\n    self.tree.remove(value).map(|(k, _)| k)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\n    let mut curr_idx = self.tree.root;\n    let mut curr_node = self.tree.node_ref(curr_idx);\n    let mut parent_idx = NodeIndex::new(0);\n    let mut cmp = Ordering::Equal;\n    loop {\n        cmp = value.borrow().cmp(&curr_node.key);\n        if cmp == Ordering::Equal {\n            break;\n        }\n        parent_idx = curr_idx;\n        if cmp == Ordering::Less {\n            curr_idx = curr_node.lft;\n        } else {\n            curr_idx = curr_node.rgt;\n        }\n        if curr_idx == NodeIndex::new(0) {\n            return None;\n        }\n        curr_node = self.tree.node_ref(curr_idx);\n    }\n    let (new_root, new_root_ordering) = self.tree.splay(curr_idx, value);\n    if new_root_ordering == Ordering::Equal {\n        self.tree.root = new_root;\n        return Some(curr_node.value);\n    }\n    None\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\nlet root = self.tree.root();\nif let Some(idx) = self.tree.find_lower_bound_immut(value) {\nlet (_, ord) = self.tree.splay(root, value);\nif ord == Ordering::Equal {\nlet node = self.tree.node_mut(idx);\nself.tree.push_root(node.take());\nreturn Some(node.value);\n}\n}\nNone\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\n    let root = self.tree.root;\n    let (idx, _) = self.tree.splay(root, value);\n    if self.tree.nodes[idx].key.borrow() == value {\n        self.tree.non_empty_pop_root()\n    } else {\n        None\n    }\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\nlet mut curr_idx = self.tree.root;\nlet mut cmp = Ordering::Equal;\nlet mut lft_idx = None;\nlet mut rgt_idx = None;\n\nwhile curr_idx != NodeIndex::invalid() {\nlet curr_node = &self.tree.nodes[curr_idx];\n\ncmp = value.cmp(curr_node.key.borrow());\n\nif cmp == Ordering::Equal {\nlet mut node = self.tree.nodes[curr_idx].clone();\nself.tree.nodes[curr_idx].value = None;\n\nif node.lft_child != NodeIndex::invalid() {\nlft_idx = Some(node.lft_child);\n}\n\nif node.rgt_child != NodeIndex::invalid() {\nrgt_idx = Some(node.rgt_child);\n}\n\nreturn Some(node.value.unwrap());\n}\n\nif cmp == Ordering::Less {\ncurr_idx = curr_node.lft_child;\n} else {\ncurr_idx = curr_node.rgt_child;\n}\n}\n\nif let Some(lft_idx) = lft_idx {\nself.tree.splay_lftmost(lft_idx);\n}\n\nif let Some(rgt_idx) = rgt_idx {\nself.tree.splay_rgtmost(rgt_idx);\n}\n\nNone\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.remove(value)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.remove(value)\n}",
      "pub fn take <Q: ?Sized> (&mut self, value: &Q) -> Option<T> where\nT: Borrow<Q>,\nQ: Ord, {\nself.tree.remove(value)\n}"
    ],
    [
      "pub fn push (&mut self, item: T) {\n    self.tree.push(item);\n    self.seq += 1;\n}",
      "pub fn push (&mut self, item: T) {\n    let mut node = Node::new(Item::new(item, self.seq));\n    self.seq += 1;\n    match self.tree.root() {\n        Some(root) => {\n            let (root_idx, ordering) = self.tree.splay_by(root, |item| item.key.cmp(&node.item.key));\n            if ordering == Ordering::Equal {\n                self.tree.nodes[root_idx].item.value = node.item.value;\n                return;\n            }\n            if ordering == Ordering::Less {\n                self.tree.push_root(node);\n                return;\n            }\n            self.tree.push_root(self.tree.nodes[root_idx].lftmost().unwrap().clone());\n            self.tree.nodes[root_idx].item.value = node.item.value;\n            return;\n        },\n        None => {\n            self.tree.push_root(node);\n            return;\n        },\n    }\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.push(item);\n}",
      "pub fn push (&mut self, item: T) {\n    let mut root = self.tree.root();\n    if root.is_none() {\n        self.tree.push_root(Node::new(item));\n        return;\n    }\n    let root = root.unwrap();\n    let (root, cmp) = self.tree.splay(root, &item);\n    if cmp == Ordering::Less {\n        self.tree.push_root(Node::new(item));\n    } else {\n        self.tree.push_root(Node::new(item));\n    }\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.push(item);\n    self.seq += 1;\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.push(item);\n    self.seq += 1;\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.push(item);\n}",
      "pub fn push (&mut self, item: T) {\n    let mut new_node = Node::new(item);\n    if self.tree.root().is_none() {\n        self.tree.push_root(new_node);\n        return;\n    }\n    let mut curr_idx = self.tree.root().unwrap();\n    let mut cmp = |x: &T, y: &T| x.cmp(y);\n    let (idx, ord) = self.tree.splay_by(curr_idx, &mut cmp);\n    match ord {\n        Ordering::Less => {\n            self.tree.push_root(new_node);\n        }\n        Ordering::Equal => {\n            self.tree.insert(idx, new_node);\n        }\n        Ordering::Greater => {\n            self.tree.push_root(new_node);\n        }\n    }\n}",
      "pub fn push (&mut self, item: T) {\n    self.tree.push(item);\n}",
      "pub fn push (&mut self, item: T) {\n    let mut node = Node::new(Item::new(item));\n    let seq = self.seq;\n    self.seq += 1;\n    node.seq = seq;\n    self.tree.push_root(node);\n}"
    ],
    [
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let length = self.read_u32()?;\n    let mut bytes = vec![0; length as usize];\n    self.read_exact(&mut bytes)?;\n    Ok(bytes)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let len = self.read_u32()?;\n    let mut bytes = vec![0; len as usize];\n    self.read_exact(&mut bytes)?;\n    Ok(bytes)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let len = self.read_u32()?;\n    let mut bytes = vec![0; len as usize];\n    self.read_exact(&mut bytes)?;\n    Ok(bytes)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let len = self.read_u32()? as usize;\n    let mut bytes = vec![0; len];\n    self.read_exact(&mut bytes)?;\n    Ok(bytes)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let length = self.read_u32()?;\n    let mut bytes = vec![0; length as usize];\n    self.read_exact(&mut bytes)?;\n    Ok(bytes)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let len = self.read_u32()?;\n    let mut bytes = vec![0; len as usize];\n    self.read_exact(&mut bytes)?;\n    Ok(bytes)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let length = self.read_u32()?;\n    let mut bytes = vec![0; length as usize];\n    self.read_exact(&mut bytes)?;\n    Ok(bytes)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let len = self.read_u32()? as usize;\n    let mut bytes = vec![0; len];\n    self.read_exact(&mut bytes)?;\n    Ok(bytes)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let len = self.read_u32()?;\n    let mut bytes = vec![0; len as usize];\n    self.read_exact(&mut bytes)?;\n    Ok(bytes)\n}",
      "pub fn read_bytes (&mut self) -> Result<Vec<u8>> {\n    let len = self.read_u32()?;\n    let mut bytes = vec![0; len as usize];\n    self.read_exact(&mut bytes)?;\n    Ok(bytes)\n}"
    ],
    [
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let mut data = self.read_bytes()?;\n    if data.len() > 0 && data[0] == 0 {\n        data = data.split_off(1);\n    }\n    Ok(data)\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let length = self.read_u32()? as usize;\n    let mut bytes = self.read_bytes()?;\n    if bytes.len() > 0 && bytes[0] == 0 {\n        bytes.remove(0);\n    }\n    if bytes.len() != length {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n    Ok(bytes)\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let length = self.read_u32()? as usize;\n    let mut bytes = self.read_bytes()?;\n    if bytes.len() > length {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n    if bytes.len() == length && bytes[0] == 0 {\n        bytes = bytes[1..].to_vec();\n    }\n    Ok(bytes)\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let len = self.read_u32()? as usize;\n    let mut buf = vec![0; len];\n    self.read_exact(&mut buf)?;\n    if buf[0] == 0 {\n        buf.remove(0);\n    }\n    Ok(buf)\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let mut mpint = self.read_bytes()?;\n    if mpint.len() > 0 && mpint[0] == 0 {\n        mpint.remove(0);\n    }\n    Ok(mpint)\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let length = self.read_u32()? as usize;\n    let mut data = self.read_bytes()?;\n    if data.len() > 0 && data[0] == 0 {\n        data = data.split_off(1);\n    }\n    if data.len() != length {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n    Ok(data)\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let mut bytes = self.read_bytes()?;\n    if bytes.is_empty() {\n        return Err(Error::with_kind(ErrorKind::InvalidFormat));\n    }\n    if bytes[0] == 0 {\n        bytes.remove(0);\n    }\n    Ok(bytes)\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let mut buf = self.read_bytes()?;\n    if buf.len() > 0 && buf[0] == 0 {\n        buf.remove(0);\n    }\n    Ok(buf)\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let mut data = self.read_bytes()?;\n    if data.len() > 0 && data[0] == 0 {\n        data = data.split_off(1);\n    }\n    Ok(data)\n}",
      "pub fn read_mpint (&mut self) -> Result<Vec<u8>> {\n    let len = self.read_u32()? as usize;\n    let mut buf = vec![0; len];\n    self.read_exact(&mut buf)?;\n    if buf[0] == 0 {\n        buf.remove(0);\n    }\n    Ok(buf)\n}"
    ],
    [
      "pub fn read_string (&mut self) -> Result<String> {\n    let len = self.read_u32()? as usize;\n    let mut buf = vec![0u8; len];\n    self.read_exact(&mut buf)?;\n    String::from_utf8(buf).map_err(Error::with_kind)\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let length = self.read_u32()? as usize;\n    let mut data = vec![0; length];\n    self.read_exact(&mut data)?;\n    Ok(String::from_utf8(data)?)\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    String::from_utf8(bytes).map_err(|e| Error::with_kind(ErrorKind::Utf8Error(e)))\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    String::from_utf8(bytes).map_err(Error::with_kind)\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    let string = String::from_utf8(bytes).map_err(|err| Error::with_kind(ErrorKind::Utf8Error(err)))?;\n    Ok(string)\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    let string = String::from_utf8(bytes).map_err(|err| Error::with_kind(ErrorKind::Utf8Error(err)))?;\n    Ok(string)\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    String::from_utf8(bytes).map_err(Error::with_kind)\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let len = self.read_u32()? as usize;\n    let mut buf = vec![0; len];\n    self.read_exact(&mut buf)?;\n    String::from_utf8(buf).map_err(Error::with_kind)\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    String::from_utf8(bytes).map_err(|e| Error::with_kind(ErrorKind::Utf8Error(e)))\n}",
      "pub fn read_string (&mut self) -> Result<String> {\n    let bytes = self.read_bytes()?;\n    String::from_utf8(bytes).map_err(Error::with_kind)\n}"
    ],
    [
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    let mut buf = [0; 4];\n    self.read_exact(&mut buf)?;\n    Ok(u32::from_be_bytes(buf))\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    let mut buf = [0; 4];\n    self.read_exact(&mut buf)?;\n    Ok(u32::from_be_bytes(buf))\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    let mut bytes = [0; 4];\n    self.read_exact(&mut bytes)?;\n    Ok(u32::from_be_bytes(bytes))\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    let mut buf = [0; 4];\n    self.read_exact(&mut buf)?;\n    Ok(u32::from_be_bytes(buf))\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    let mut buf = [0u8; 4];\n    self.read_exact(&mut buf)?;\n    Ok(u32::from_be_bytes(buf))\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    let mut buf = [0; 4];\n    self.read_exact(&mut buf)?;\n    Ok(u32::from_be_bytes(buf))\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    let mut bytes = [0; 4];\n    self.read_exact(&mut bytes)?;\n    Ok(u32::from_be_bytes(bytes))\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    let mut buf = [0u8; 4];\n    self.read_exact(&mut buf)?;\n    Ok(u32::from_be_bytes(buf))\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    let mut buf = [0u8; 4];\n    self.read_exact(&mut buf)?;\n    Ok(u32::from_be_bytes(buf))\n}",
      "pub fn read_u32 (&mut self) -> Result<u32> {\n    let mut buf = [0; 4];\n    self.read_exact(&mut buf)?;\n    Ok(u32::from_be_bytes(buf))\n}"
    ],
    [
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    let mut buf = [0; 8];\n    self.read_exact(&mut buf)?;\n    Ok(u64::from_be_bytes(buf))\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    let mut buf = [0u8; 8];\n    self.read_exact(&mut buf)?;\n    Ok(u64::from_be_bytes(buf))\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    let mut buf = [0u8; 8];\n    self.read_exact(&mut buf)?;\n    Ok(u64::from_be_bytes(buf))\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    let mut buf = [0; 8];\n    self.read_exact(&mut buf)?;\n    Ok(u64::from_be_bytes(buf))\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    let mut bytes = vec![0; 8];\n    self.read_exact(&mut bytes)?;\n    Ok(u64::from_be_bytes(bytes.try_into().unwrap()))\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    let mut buf = [0u8; 8];\n    self.read_exact(&mut buf)?;\n    Ok(u64::from_be_bytes(buf))\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    let mut buf = [0; 8];\n    self.read_exact(&mut buf)?;\n    Ok(u64::from_be_bytes(buf))\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    let mut buf = [0; 8];\n    self.read_exact(&mut buf)?;\n    Ok(u64::from_be_bytes(buf))\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    let mut buf = [0; 8];\n    self.read_exact(&mut buf)?;\n    Ok(u64::from_be_bytes(buf))\n}",
      "pub fn read_u64 (&mut self) -> Result<u64> {\n    let mut buf = [0u8; 8];\n    self.read_exact(&mut buf)?;\n    Ok(u64::from_be_bytes(buf))\n}"
    ],
    [
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    self.write_mpint(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    let len = val.len();\n    self.write_mpint(&len.to_be_bytes());\n    self.write_mpint(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    self.write_mpint(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    self.write_mpint(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    self.write_mpint(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    self.write_mpint(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    self.write_mpint(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    self.write_mpint(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    self.write_mpint(val);\n}",
      "pub fn write_bytes (&mut self, val: &[u8]) {\n    self.write_mpint(val);\n}"
    ],
    [
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => &UnixStr::from_inner(&Slice::from_u8_slice(b\"\")),\n        Component::CurDir => &UnixStr::from_inner(&Slice::from_u8_slice(b\".\")),\n        Component::ParentDir => &UnixStr::from_inner(&Slice::from_u8_slice(b\"..\")),\n        Component::Normal(unix_str) => unix_str,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => UnixStr::new(\".\"),\n        Component::CurDir => UnixStr::new(\".\"),\n        Component::ParentDir => UnixStr::new(\"..\"),\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => UnixStr::from_inner(&[b'/']),\n        Component::CurDir => UnixStr::from_inner(&[b'.']),\n        Component::ParentDir => UnixStr::from_inner(&[b'.', b'.']),\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => UnixStr::from_inner(&[b'/']),\n        Component::CurDir => UnixStr::from_inner(&[b'.']),\n        Component::ParentDir => UnixStr::from_inner(&[b'.', b'.']),\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => &UnixStr::from_inner(&Slice::from_u8_slice(b\"\")),\n        Component::CurDir => &UnixStr::from_inner(&Slice::from_u8_slice(b\".\")),\n        Component::ParentDir => &UnixStr::from_inner(&Slice::from_u8_slice(b\"..\")),\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => UnixStr::from_inner(&Slice::from_u8_slice(b\"\")),\n        Component::CurDir => UnixStr::from_inner(&Slice::from_u8_slice(b\".\")),\n        Component::ParentDir => UnixStr::from_inner(&Slice::from_u8_slice(b\"..\")),\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => &UnixStr::from_inner(&Slice::from_u8_slice(b\"\")),\n        Component::CurDir => &UnixStr::from_inner(&Slice::from_u8_slice(b\".\")),\n        Component::ParentDir => &UnixStr::from_inner(&Slice::from_u8_slice(b\"..\")),\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => UnixStr::from_inner(&[b'/']),\n        Component::CurDir => UnixStr::from_inner(&[b'.']),\n        Component::ParentDir => UnixStr::from_inner(&[b'.', b'.']),\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => UnixStr::new(\".\"),\n        Component::CurDir => UnixStr::new(\".\"),\n        Component::ParentDir => UnixStr::new(\"..\"),\n        Component::Normal(s) => s,\n    }\n}",
      "pub fn as_unix_str (self) -> &'a UnixStr {\n    match self {\n        Component::RootDir => &UnixStr::new(\".\"),\n        Component::CurDir => &UnixStr::new(\".\"),\n        Component::ParentDir => &UnixStr::new(\"..\"),\n        Component::Normal(s) => s,\n    }\n}"
    ],
    [
      "pub fn as_path (&self) -> &'a Path {\n    todo!()\n}",
      "pub fn as_path (&self) -> &'a Path {\n    self.inner.as_path()\n}",
      "pub fn as_path (&self) -> &'a Path {\n    self.inner.as_path()\n}",
      "pub fn as_path (&self) -> &'a Path {\n    self.inner.as_path()\n}",
      "pub fn as_path (&self) -> &'a Path {\n    todo!()\n}",
      "pub fn as_path (&self) -> &'a Path {\n    let mut path = self.inner.as_slice();\n    let mut has_physical_root = false;\n    let mut front = State::Body;\n    let mut back = State::Body;\n    loop {\n        match self.parse_next_component_back() {\n            (0, _) => break,\n            (n, Some(Component::RootDir)) => {\n                has_physical_root = true;\n                front = State::AfterRoot;\n                back = State::Start;\n                path = &path[..n];\n            }\n            (n, Some(Component::CurDir)) => {\n                front = State::Body;\n                back = State::Start;\n                path = &path[..n];\n            }\n            (n, Some(Component::ParentDir)) => {\n                front = State::Body;\n                back = State::Body;\n                path = &path[..n];\n            }\n            (n, Some(Component::Normal(_))) => {\n                front = State::Body;\n                back = State::Body;\n                path = &path[..n];\n            }\n            (n, None) => {\n                front = State::Start;\n                back = State::Start;\n                path = &path[..n];\n            }\n        }\n    }\n    loop {\n        match self.parse_next_component() {\n            (0, _) => break,\n            (n, Some(Component::RootDir)) => {\n                has_physical_root = true;\n                front = State::AfterRoot;\n                back = State::Start;\n                path = &path[n..];\n            }\n            (n, Some(Component::CurDir)) => {\n                front = State::Body;\n                back = State::Start;\n                path = &path[n..];\n            }\n            (n, Some(Component::ParentDir)) => {\n                front = State::Body;\n                back = State::Body;\n                path = &path[n..];\n            }\n            (n, Some(Component::Normal(_))) => {\n                front = State::Body;\n                back = State::Body;\n                path = &path[n..];\n            }\n}\n}\n}",
      "pub fn as_path (&self) -> &'a Path {\n    self.inner.as_path()\n}",
      "pub fn as_path (&self) -> &'a Path {\n    let mut path = PathBuf::new();\n    for comp in self.inner.iter() {\n        path.push(comp.as_os_str());\n    }\n    path.into_path_buf()\n}",
      "pub fn as_path (&self) -> &'a Path {\n    todo!()\n}",
      "pub fn as_path (&self) -> &'a Path {\n    todo!()\n}"
    ],
    [
      "pub fn pop (&mut self) -> bool {\n    if let Some(parent) = self.parent() {\n        self.set_file_name(\"\");\n        self.set_extension(\"\");\n        self.truncate(parent.as_os_str().len());\n        true\n    } else {\n        false\n    }\n}",
      "pub fn pop (&mut self) -> bool {\n    if let Some(parent) = self.parent() {\n        self.set_file_name(\"\");\n        self.set_extension(\"\");\n        self.truncate(parent.as_os_str().len());\n        true\n    } else {\n        false\n    }\n}",
      "pub fn pop (&mut self) -> bool {\n    let mut parent = self.parent();\n    if parent.is_none() {\n        return false;\n    }\n    let parent = parent.unwrap();\n    let parent_str = parent.as_unix_str();\n    let parent_bytes = parent_str.as_bytes();\n    let parent_len = parent_bytes.len();\n    let mut self_bytes = self.as_mut_vec();\n    self_bytes.truncate(parent_len);\n    self_bytes.copy_from_slice(parent_bytes);\n    true\n}",
      "pub fn pop (&mut self) -> bool {\n    if let Some(parent) = self.parent() {\n        self.set_file_name(\"\");\n        self.set_extension(\"\");\n        self.truncate(parent.as_os_str().len());\n        true\n    } else {\n        false\n    }\n}",
      "pub fn pop (&mut self) -> bool {\n    let parent = self.parent();\n    if parent.is_none() {\n        return false;\n    }\n    let parent = parent.unwrap();\n    self.set_file_name(parent.file_name().unwrap());\n    true\n}",
      "pub fn pop (&mut self) -> bool {\n    if let Some(parent) = self.parent() {\n        self.set_file_name(\"\");\n        self.set_extension(\"\");\n        self.set_path(parent);\n        true\n    } else {\n        false\n    }\n}",
      "pub fn pop (&mut self) -> bool {\n    if let Some(parent) = self.parent() {\n        self.set_file_name(\"\");\n        self.set_extension(\"\");\n        self.set_path(parent);\n        true\n    } else {\n        false\n    }\n}",
      "pub fn pop (&mut self) -> bool {\n    if let Some(parent) = self.parent() {\n        self.set_file_name(\"\");\n        self.set_extension(\"\");\n        self.as_mut_vec().truncate(parent.as_path().as_os_str().len());\n        true\n    } else {\n        false\n    }\n}",
      "pub fn pop (&mut self) -> bool {\n    let mut s = self.as_mut_vec();\n    if s.is_empty() {\n        return false;\n    }\n    let mut pos = s.len() - 1;\n    while pos > 0 {\n        if s[pos] == b'/' {\n            break;\n        }\n        pos -= 1;\n    }\n    s.truncate(pos);\n    true\n}",
      "pub fn pop (&mut self) -> bool {\n    if let Some(parent) = self.parent() {\n        self.set_file_name(parent.file_name());\n        true\n    } else {\n        false\n    }\n}"
    ],
    [
      "pub fn parent (&self) -> Option<&Path> {\n    let mut components = self.components();\n    components.next_back();\n    components.as_path()\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    if self.is_empty() {\n        None\n    } else {\n        let mut components = self.components();\n        components.next_back();\n        Some(components.as_path())\n    }\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    let mut components = self.components();\n    components.next_back();\n    components.as_path()\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    let mut components = self.components();\n    components.next_back();\n    components.as_path()\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    if self.is_absolute() {\n        if self.components().count() == 1 {\n            return None;\n        }\n        let mut components = self.components();\n        components.next();\n        Some(Path::from_u8_slice(components.as_slice()))\n    } else {\n        if self.components().count() == 1 {\n            return None;\n        }\n        let mut components = self.components();\n        components.next();\n        Some(Path::from_u8_slice(components.as_slice()))\n    }\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    let mut components = self.components();\n    components.next_back();\n    components.as_path()\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    if self.is_absolute() {\n        Some(Path::new(\"/\"))\n    } else {\n        self.components().rev().find_map(|component| match component {\n            Component::RootDir => None,\n            Component::ParentDir => Some(Path::new(\"/\")),\n            Component::Normal(s) => Some(Path::new(s.to_string_lossy().as_ref())),\n        })\n    }\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    let mut components = self.components();\n    components.next_back();\n    components.as_path()\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    if self.is_absolute() {\n        return Some(self);\n    }\n    let mut components = self.components();\n    let mut last_component = None;\n    for component in components {\n        last_component = Some(component);\n    }\n    if let Some(last_component) = last_component {\n        if last_component.is_normal() {\n            let mut parent = Path::new(\"\");\n            for component in components {\n                if component == last_component {\n                    break;\n                }\n                parent = parent.join(component);\n            }\n            return Some(parent);\n        }\n    }\n    None\n}",
      "pub fn parent (&self) -> Option<&Path> {\n    let mut components = self.components();\n    components.next_back();\n    components.next_back();\n    components.as_path()\n}"
    ],
    [
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    let mut components = self.components();\n    components.next_back()\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    let mut iter = self.components();\n    let mut file_name = None;\n    while let Some(component) = iter.next() {\n        if component.is_normal() {\n            file_name = Some(component.as_unix_str());\n        }\n    }\n    file_name\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    let mut components = self.components();\n    components.next_back()\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    let mut components = self.components();\n    components.next_back()\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    let mut components = self.components();\n    components.next_back()\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    let mut components = self.components();\n    components.next_back()\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    let mut components = self.components();\n    components.next_back()\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    let mut components = self.components();\n    components.next_back()\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    let mut components = self.components();\n    components.next_back()\n}",
      "pub fn file_name (&self) -> Option<&UnixStr> {\n    let mut components = self.components();\n    components.next_back()\n}"
    ],
    [
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    self.v.reserve_len_exact(len);\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    if len > self.v.len() {\n        self.v.reserve_exact(len - self.v.len());\n    }\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    self.v.reserve_len_exact(len);\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    self.v.reserve_len_exact(len);\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    self.v.reserve_len_exact(len);\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    self.v.reserve_len_exact(len);\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    if len > self.v.len() {\n        self.v.reserve_exact(len - self.v.len());\n    }\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    if len > self.v.len() {\n        self.v.reserve_exact(len - self.v.len());\n    }\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    self.v.reserve_len_exact(len);\n}",
      "pub fn reserve_len_exact (&mut self, len: usize) {\n    self.v.reserve_len_exact(len);\n}"
    ],
    [
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}",
      "pub fn shrink_to_fit (&mut self) {\n    self.v.shrink_to_fit();\n}"
    ],
    [
      "pub fn append (&mut self, other: &mut Self) {\n    let other_len = other.len();\n    if other_len == 0 {\n        return;\n    }\n    let new_len = self.len() + other_len;\n    self.reserve_len_exact(new_len);\n    let mut other_iter = other.drain();\n    let mut other_entry = other_iter.next().unwrap();\n    let mut self_iter = self.iter_mut();\n    let mut self_entry = self_iter.next();\n    while let Some(other_entry) = other_entry {\n        if let Some(self_entry) = self_entry {\n            if self_entry.0 < other_entry.0 {\n                self_entry.1 = other_entry.1;\n                self_entry = self_iter.next();\n            } else {\n                self.insert(other_entry.0, other_entry.1);\n            }\n        } else {\n            self.insert(other_entry.0, other_entry.1);\n        }\n        other_entry = other_iter.next();\n    }\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    self.reserve_len_exact(other.len());\n    for (key, value) in other.drain() {\n        self.insert(key, value);\n    }\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    self.reserve_len_exact(other.len());\n    for (k, v) in other.drain() {\n        self.insert(k, v);\n    }\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    self.reserve_len(other.len());\n    for (k, v) in other.drain() {\n        self.insert(k, v);\n    }\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    let len = self.len();\n    self.reserve_len_exact(len + other.len());\n    for (key, value) in other.drain() {\n        self.insert(key, value);\n    }\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    let other_len = other.len();\n    if other_len == 0 {\n        return;\n    }\n    let self_len = self.len();\n    self.reserve_len_exact(other_len);\n    for i in 0..other_len {\n        let key = other.keys().next().unwrap();\n        let value = other.remove(key).unwrap();\n        self.insert(key, value);\n    }\n    self.shrink_to_fit();\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    let other_len = other.len();\n    self.reserve_len_exact(other_len);\n    for i in 0..other_len {\n        let key = other.keys().next().unwrap();\n        let value = other.remove(key).unwrap();\n        self.insert(key, value);\n    }\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    for (key, value) in other.iter_mut() {\n        self.insert(key, value);\n    }\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    let other_len = other.len();\n    if other_len == 0 {\n        return;\n    }\n    let new_len = self.len() + other_len;\n    self.reserve_len_exact(new_len);\n    let mut other_keys = other.keys();\n    let mut other_values = other.values_mut();\n    for i in 0..other_len {\n        let key = other_keys.next().unwrap();\n        let value = other_values.next().unwrap();\n        self.insert(key, value);\n    }\n    other.clear();\n}",
      "pub fn append (&mut self, other: &mut Self) {\n    self.reserve_len_exact(other.len());\n    for (key, value) in other.drain() {\n        self.insert(key, value);\n    }\n}"
    ],
    [
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut new = Self::with_capacity(self.capacity());\n    for (k, v) in self.iter() {\n        if k < at {\n            new.insert(k, v.clone());\n            self.remove(k);\n        }\n    }\n    new\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::with_capacity(self.capacity());\n    other.n = self.n - at;\n    for i in at..self.n {\n        other.v[i - at] = self.v[i].take();\n    }\n    self.n = at;\n    other\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::with_capacity(self.capacity());\n    let mut keys = self.keys().collect::<Vec<_>>();\n    let mut values = self.values().collect::<Vec<_>>();\n    keys.sort_unstable();\n    values.sort_unstable();\n    for i in 0..keys.len() {\n        if keys[i] < at {\n            other.insert(keys[i], values[i]);\n        } else {\n            self.insert(keys[i], values[i]);\n        }\n    }\n    other\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::with_capacity(self.capacity());\n    for (key, value) in self.iter() {\n        if key < at {\n            other.insert(key, value.clone());\n        } else {\n            self.insert(key, value.clone());\n        }\n    }\n    other\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::with_capacity(self.capacity());\n    for (k, v) in self.iter() {\n        if k < at {\n            other.insert(k, v.clone());\n            self.remove(k);\n        }\n    }\n    other\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::with_capacity(self.capacity());\n    for i in at..self.len() {\n        other.insert(i, self.remove(i).unwrap());\n    }\n    other\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut new_map = Self::with_capacity(self.capacity());\n    for (k, v) in self.iter() {\n        if k < at {\n            new_map.insert(k, v);\n        } else {\n            self.insert(k, v);\n        }\n    }\n    new_map\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::with_capacity(self.capacity());\n    let mut i = 0;\n    for (key, value) in self.iter() {\n        if i < at {\n            self.insert(key, value);\n        } else {\n            other.insert(key, value);\n        }\n        i += 1;\n    }\n    other\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::with_capacity(self.capacity());\n    for (k, v) in self.iter() {\n        if k < at {\n            other.insert(k, v);\n        } else {\n            self.insert(k, v);\n        }\n    }\n    other\n}",
      "pub fn split_off (&mut self, at: usize) -> Self {\n    let mut other = Self::with_capacity(self.capacity());\n    other.n = self.n - at;\n    other.v.extend_from_slice(&self.v[at..self.n]);\n    self.n = at;\n    other\n}"
    ],
    [
      "pub fn get (&self, key: usize) -> Option<&V> {\n    let index = self.find_index(key)?;\n    Some(&self.v[index].as_ref().unwrap())\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    if key < self.n {\n        return self.v[key].as_ref();\n    }\n    None\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    let i = self.index(key);\n    if i < self.n && self.v[i].is_some() {\n        Some(&self.v[i].as_ref().unwrap())\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    if key < self.n {\n        return self.v[key].as_ref();\n    }\n    None\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    self.v.get(key).and_then(|x| x.as_ref())\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    let index = self.find_index(key);\n    if index.is_some() {\n        Some(&self.v[index.unwrap()].as_ref().unwrap())\n    } else {\n        None\n    }\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    if key < self.n {\n        return self.v[key].as_ref();\n    }\n    None\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    self.v.get(key).and_then(|x| x.as_ref())\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    let i = self.v.binary_search_by(|x| x.as_ref().map(|x| x.0).cmp(&key));\n    match i {\n        Ok(i) => self.v[i].as_ref(),\n        Err(_) => None,\n    }\n}",
      "pub fn get (&self, key: usize) -> Option<&V> {\n    self.v.get(key).and_then(|v| v.as_ref())\n}"
    ],
    [
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    let mut i = self.n;\n    let mut j = 0;\n    let mut k = 0;\n    while j < self.n {\n        if self.v[j].is_none() {\n            k = j;\n        }\n        if self.v[j].as_ref().unwrap().0 == key {\n            i = j;\n            break;\n        }\n        j += 1;\n    }\n    if j == self.n {\n        self.n += 1;\n        if k == 0 {\n            k = j;\n        }\n        self.v[k] = Some((key, value));\n        return None;\n    }\n    let v = self.v[i].take();\n    self.v[i] = Some((key, value));\n    v.map(|x| x.1)\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    let mut index = self.n;\n    let mut parent = 0;\n    while index > 0 {\n        let child = index;\n        index = (index - 1) / 2;\n        parent = index;\n        if self.v[child].is_some() {\n            break;\n        }\n    }\n    if index == 0 {\n        self.v[0] = Some(value);\n        self.n += 1;\n        return None;\n    }\n    let mut node = self.v[child].take().unwrap();\n    while index > 0 {\n        let child = index;\n        index = (index - 1) / 2;\n        parent = index;\n        if self.v[child].is_some() {\n            break;\n        }\n    }\n    if index == 0 {\n        self.v[0] = Some(value);\n        self.n += 1;\n        return None;\n    }\n    let mut node = self.v[child].take().unwrap();\n    while index > 0 {\n        let child = index;\n        index = (index - 1) / 2;\n        parent = index;\n        if self.v[child].is_some() {\n            break;\n        }\n    }\n    if index == 0 {\n        self.v[0] = Some(value);\n        self.n += 1;\n        return None;\n    }\n    let mut node = self.v[child].take().unwrap();\n    while index > 0 {\n        let child = index;\n        index = (index - 1) / 2;\n        parent = index;\n        if self.v[child].is_some() {\n            break;\n        }\n    }\n    if index == 0 {\n        self.v[0] = Some(value);\n        self.n += 1;\n        return None;\n    }\n    let mut node = self.v[child].take().unwrap();\n    while index > 0 {\n        let child = index;\n        index = (index - 1) / 2;\n        parent = index;\n}\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    let index = self.v.len();\n    self.v.push(Some(value));\n    let mut len = self.n;\n    while len > 0 {\n        let half = len / 2;\n        let mid = index - half;\n        if self.v[mid].is_some() {\n            len = half;\n        } else {\n            self.v.swap(mid, index);\n            len = len - half - 1;\n        }\n    }\n    Some(value)\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if self.v.len() <= key {\n        self.v.resize(key + 1, None);\n    }\n    self.v[key].replace(value)\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if self.v.len() <= key {\n        self.v.resize(key + 1, None);\n    }\n    self.v[key].replace(value)\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if self.n == self.v.len() {\n        self.v.push(Some(value));\n    } else {\n        self.v[key] = Some(value);\n    }\n    self.n += 1;\n    None\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key >= self.n {\n        self.reserve_len_exact(key + 1);\n        self.n = key + 1;\n    }\n    let old = self.v[key].take();\n    self.v[key].replace(value);\n    old\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key >= self.n {\n        self.reserve_len_exact(key + 1);\n    }\n    let old_value = self.v[key].take();\n    self.v[key].replace(value);\n    old_value\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if key < self.n {\n        let mut value = Some(value);\n        if let Some(old_value) = self.v.get_mut(key) {\n            std::mem::swap(old_value, &mut value);\n        }\n        value\n    } else {\n        self.v.push(Some(value));\n        self.n = key + 1;\n        None\n    }\n}",
      "pub fn insert (&mut self, key: usize, value: V) -> Option<V> {\n    if self.n > self.v.len() {\n        self.v.resize(self.n, None);\n    }\n    let mut i = key as usize;\n    if i >= self.n {\n        self.n = i + 1;\n    }\n    if self.v[i].is_none() {\n        self.v[i] = Some(value);\n        return None;\n    }\n    let mut j = 1;\n    while j < self.n {\n        i = (i + j) % self.n;\n        if self.v[i].is_none() {\n            self.v[i] = Some(value);\n            return None;\n        }\n        j += 1;\n    }\n    Some(value)\n}"
    ],
    [
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    if key >= self.n {\n        return None;\n    }\n    let v = self.v[key].take();\n    if let Some(v) = v {\n        self.n -= 1;\n        self.v[key] = None;\n        Some(v)\n    } else {\n        None\n    }\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    if key < self.n {\n        let v = self.v[key].take();\n        if v.is_some() {\n            self.n -= 1;\n        }\n        v\n    } else {\n        None\n    }\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    if self.n > 0 {\n        let mut i = self.find(key);\n        if i < self.n && self.v[i].as_ref().map_or(false, |(k, _)| k == &key) {\n            self.n -= 1;\n            return self.v[i].take();\n        }\n    }\n    None\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    if key >= self.n {\n        return None;\n    }\n    let index = self.n - key - 1;\n    let mut v = None;\n    mem::swap(&mut v, &mut self.v[index]);\n    v\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    if key < self.n {\n        let mut i = key;\n        while i < self.n - 1 {\n            self.v[i] = self.v[i + 1].take();\n            i += 1;\n        }\n        self.n -= 1;\n        return Some(self.v[i].take().unwrap());\n    }\n    None\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    let index = self.find_index(key)?;\n    self.v[index].take()\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    let idx = self.find_idx(key)?;\n    let value = self.v[idx].take();\n    self.n -= 1;\n    if idx != self.n {\n        self.v[idx] = self.v[self.n].take();\n    }\n    Some(value.unwrap())\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    if self.n == 0 {\n        return None;\n    }\n    let mut i = self.n;\n    let mut j = 0;\n    while i > 0 {\n        if self.v[i - 1].is_some() {\n            j += 1;\n        }\n        if j == key {\n            break;\n        }\n        i -= 1;\n    }\n    if i == 0 {\n        return None;\n    }\n    let mut v = self.v[i - 1].take();\n    while i < self.n {\n        if self.v[i].is_some() {\n            self.v[i - 1] = self.v[i].take();\n            i += 1;\n        } else {\n            self.v[i - 1] = None;\n            i += 1;\n        }\n    }\n    self.n -= 1;\n    return v;\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    let index = self.v.binary_search_by(|x| x.as_ref().map(|y| y.0).cmp(&key));\n    match index {\n        Ok(index) => {\n            let value = self.v[index].take();\n            self.n -= 1;\n            value\n        }\n        Err(_) => None,\n    }\n}",
      "pub fn remove (&mut self, key: usize) -> Option<V> {\n    let idx = self.find_index(key)?;\n    self.v.remove(idx).map(|x| x.unwrap())\n}"
    ],
    [
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    let mut i = 0;\n    while i < self.n {\n        if !f(i, &mut self.v[i]) {\n            self.v[i] = self.v[self.n - 1].take();\n            self.n -= 1;\n        } else {\n            i += 1;\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    let mut i = 0;\n    while i < self.n {\n        if let Some(ref mut v) = self.v[i] {\n            if f(i, v) {\n                i += 1;\n            } else {\n                self.v[i].take();\n            }\n        } else {\n            i += 1;\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    for i in 0..self.n {\n        let k = self.v[i].as_ref().unwrap().0;\n        if !f(k, &mut self.v[i].as_mut().unwrap().1) {\n            self.remove(k);\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    let mut i = 0;\n    while i < self.n {\n        if let Some(v) = self.v.get_mut(i) {\n            if !f(i, v) {\n                self.v.swap_remove(i);\n                self.n -= 1;\n            } else {\n                i += 1;\n            }\n        } else {\n            i += 1;\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    let mut i = 0;\n    while i < self.n {\n        if let Some(v) = self.v.get_mut(i) {\n            if !f(i, v) {\n                self.remove(i);\n            } else {\n                i += 1;\n            }\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    let mut i = 0;\n    while i < self.len() {\n        if !f(i, &mut self.v[i].as_mut().unwrap()) {\n            self.remove(i);\n        } else {\n            i += 1;\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    let mut i = 0;\n    while i < self.n {\n        if !f(i, &mut self.v[i].as_mut().unwrap()) {\n            self.v[i] = None;\n        }\n        i += 1;\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    let mut i = 0;\n    while i < self.n {\n        if !f(i, &mut self.v[i]) {\n            self.remove(i);\n        } else {\n            i += 1;\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    let mut i = 0;\n    while i < self.n {\n        if !f(i, &mut self.v[i]) {\n            self.v[i] = self.v[self.n - 1].take();\n            self.n -= 1;\n        } else {\n            i += 1;\n        }\n    }\n}",
      "pub fn retain <F> (&mut self, mut f: F) where F: FnMut(usize, &mut V) -> bool {\n    let mut i = 0;\n    while i < self.n {\n        if let Some(v) = self.v.get_mut(i) {\n            if !f(i, v) {\n                self.v.swap_remove(i);\n                self.n -= 1;\n            } else {\n                i += 1;\n            }\n        }\n    }\n}"
    ],
    [
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    // Your code here\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    if self.len() == self.capacity() {\n        return Err(val);\n    }\n    self.as_mut_slice()[self.len()] = val;\n    self.set_len(self.len() + 1);\n    Ok(())\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    if self.len() < self.capacity() {\n        let mut tail = self.split_borrowed(self.len());\n        let mut tail_mut = tail.split_to_fit();\n        let tail_ptr = tail_mut.as_mut_ptr();\n        unsafe {\n            ptr::write(tail_ptr, val);\n        }\n        self.set_len(self.len() + 1);\n        Ok(())\n    } else {\n        Err(val)\n    }\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    // Your code here.\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    if self.len() < self.capacity() {\n        self.as_mut_slice()[self.len()] = val;\n        self.set_len(self.len() + 1);\n        Ok(())\n    } else {\n        Err(val)\n    }\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    if self.len() < self.capacity() {\n        self.as_mut_slice()[self.len()] = val;\n        self.set_len(self.len() + 1);\n        Ok(())\n    } else {\n        Err(val)\n    }\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    if self.len() < self.capacity() {\n        // SAFETY: The length is less than the capacity, so there is space to push an element.\n        unsafe {\n            self.as_mut_ptr().add(self.len()).write(val);\n        }\n        self.set_len(self.len() + 1);\n        Ok(())\n    } else {\n        Err(val)\n    }\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    // ...\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    // Check if there is enough space to store the element.\n    if self.len() == self.capacity() {\n        // If there is not enough space, return the element.\n        return Err(val);\n    }\n    // Get the next index to store the element.\n    let index = self.len();\n    // Store the element at the next index.\n    self.as_mut_slice()[index] = val;\n    // Increment the length of the vector.\n    self.set_len(index + 1);\n    // Return success.\n    Ok(())\n}",
      "pub fn push (&mut self, val: T) -> Result<(), T> {\n    // Your code here.\n}"
    ],
    [
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity());\n    let (uninit, len) = self.head_tail_mut();\n    let (head, tail) = uninit.split_at_mut(at);\n    *len = at;\n    FixedVec { uninit: tail, length: self.len() - at }\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    let (head, tail) = self.head_tail_mut();\n    let (head, tail) = (head.as_mut_slice(), tail.as_mut_slice());\n    let (head, tail) = (head.get_mut(..at).unwrap(), tail.get_mut(..).unwrap());\n    let (head, tail) = (head.as_mut_ptr(), tail.as_mut_ptr());\n    let head = unsafe { Uninit::from_memory(head, at) };\n    let tail = unsafe { Uninit::from_memory(tail, self.len() - at) };\n    FixedVec { uninit: tail, length: self.len() - at }\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    let mut part = self.split_at(at).unwrap();\n    // Safety: The memory is borrowed, so it is safe to split it.\n    let mut_part = unsafe { part.as_mut_slice() };\n    let part_ptr = mut_part.as_mut_ptr();\n    let part_len = mut_part.len();\n    let part_cap = mut_part.capacity();\n    // Safety: The memory is borrowed, so it is safe to split it.\n    let mut_self = unsafe { self.as_mut_slice() };\n    let self_ptr = mut_self.as_mut_ptr();\n    let self_len = mut_self.len();\n    let self_cap = mut_self.capacity();\n    // Safety: The memory is borrowed, so it is safe to split it.\n    let mut_part_ptr = unsafe { part_ptr.add(part_len) };\n    let mut_self_ptr = unsafe { self_ptr.add(self_len) };\n    // Safety: The memory is borrowed, so it is safe to split it.\n    let part_uninit = unsafe { Uninit::from_memory(ptr::NonNull::new_unchecked(mut_part_ptr), part_cap) };\n    // Safety: The memory is borrowed, so it is safe to split it.\n    let self_uninit = unsafe { Uninit::from_memory(ptr::NonNull::new_unchecked(mut_self_ptr), self_cap) };\n    FixedVec {\n        uninit: part_uninit,\n        length: part_len,\n    }\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    let mut other = self.split_to_fit();\n    other.set_len(at);\n    other\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity());\n    let mut part = FixedVec::from_unaligned(self.uninit.split_layout(Layout::array::<T>(at).unwrap()).unwrap());\n    part.length = at;\n    part\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    let (uninit, len) = self.head_tail_mut();\n    let (head, tail) = uninit.split_at(at);\n    let mut tail = FixedVec::from_unaligned(tail);\n    tail.set_len(len - at);\n    FixedVec::from_unaligned(head)\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    let mut other = FixedVec::empty();\n    other.uninit = self.uninit.split_at(at).unwrap();\n    other.length = at;\n    self.length -= at;\n    other\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    let (uninit, len) = self.head_tail_mut();\n    let (uninit, tail) = uninit.split_at(at);\n    *len = at;\n    FixedVec { uninit, length: at }\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    let (mut uninit, mut len) = self.head_tail_mut();\n    let (mut split_uninit, split_len) = uninit.split_at(at).unwrap();\n    mem::swap(&mut uninit, &mut split_uninit);\n    len.set_len(len.len() - split_len.len());\n    FixedVec {\n        uninit,\n        length: len.len(),\n    }\n}",
      "pub fn split_borrowed (&mut self, at: usize) -> FixedVec<'_, T> {\n    assert!(at <= self.capacity());\n    let (uninit, len) = self.head_tail_mut();\n    let (head, tail) = uninit.split_at(at);\n    let mut vec = FixedVec::from_unaligned(tail);\n    *len = at;\n    vec.set_len(self.len() - at);\n    FixedVec::from_unaligned(head)\n}"
    ],
    [
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.strong().get() == 0 {\n        None\n    } else {\n        Some(Rc {\n            inner: UninitView::decast(self.inner.clone()),\n        })\n    }\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    let strong = self.strong();\n    let weak = self.weak();\n    if strong.get() > 0 {\n        Some(Rc {\n            inner: UninitView::from_memory(self.inner.ptr, self.inner.len),\n        })\n    } else {\n        None\n    }\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.strong.get() > 0 {\n        Some(Rc {\n            inner: self.inner.clone(),\n        })\n    } else {\n        None\n    }\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    let inner = self.inner.as_ref();\n    let strong = inner.strong.get();\n    let weak = inner.weak.get();\n    if strong == 0 {\n        return None;\n    }\n    inner.strong.set(strong + 1);\n    Some(Rc {\n        inner: self.inner.clone(),\n    })\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.strong.get() > 0 {\n        Some(Rc {\n            inner: self.inner.clone(),\n        })\n    } else {\n        None\n    }\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    let strong = self.strong.get();\n    if strong == 0 {\n        None\n    } else {\n        self.strong.set(strong + 1);\n        Some(Rc {\n            inner: self.inner,\n        })\n    }\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    let strong = self.strong.get();\n    if strong == 0 {\n        None\n    } else {\n        Some(Rc {\n            inner: self.inner.clone(),\n        })\n    }\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    if self.strong.get() == 0 {\n        None\n    } else {\n        Some(Rc { inner: self.inner })\n    }\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    let inner = self.inner();\n    if inner.strong.get() == 0 {\n        return None;\n    }\n    let strong = inner.strong.get();\n    inner.strong.set(strong + 1);\n    Some(Rc { inner })\n}",
      "pub fn upgrade (&self) -> Option<Rc<'a, T>> {\n    let inner = self.inner();\n    let strong = inner.strong();\n    let weak = inner.weak();\n    if strong.get() == 0 {\n        return None;\n    }\n    strong.set(strong.get() + 1);\n    weak.set(weak.get() - 1);\n    Some(Rc { inner })\n}"
    ]
  ]
}